<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gemini 블로그 글 대량 생성기 (v9 - Refactored)</title>
  <!-- Tailwind CSS 로드 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Inter & Noto Sans KR 폰트 로드 -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
  <!-- Bootstrap Icons -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <style>
    body {
      font-family: 'Inter', 'Noto Sans KR', sans-serif;
      background-color: #f8f9fa;
      padding-bottom: 60px; /* 하단 푸터 공간 확보 */
    }
    /* 토스트 알림 */
    #toast {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      padding: 1rem 1.5rem;
      border-radius: 0.5rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transition: all 0.3s ease;
      opacity: 0;
      transform: translateY(20px);
      z-index: 1000;
    }
    #toast.show { opacity: 1; transform: translateY(0); }
    #toast.success { background-color: #10B981; color: white; }
    #toast.error { background-color: #EF4444; color: white; }
    #toast.info { background-color: #3B82F6; color: white; }

    /* 모달 스타일 */
    #modal-overlay { transition: opacity 0.3s ease-in-out; }
    #modal-container { transition: all 0.3s ease-in-out; }
    
    /* 아이콘 버튼 스타일 */
    .icon-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.25rem; /* 20px */
      color: #4B5563; /* text-gray-600 */
      transition: color 0.2s, transform 0.2s;
      padding: 4px;
      border-radius: 50%;
    }
    .icon-btn:hover { 
      color: #1D4ED8; /* text-blue-700 */
      transform: scale(1.1);
    }
    .icon-btn-danger:hover { 
      color: #DC2626; /* text-red-600 */
    }
    .icon-btn-purple:hover {
      color: #7E22CE; /* text-purple-700 */
    }
    .icon-btn-retry {
      color: #2563EB; /* text-blue-600 */
    }
    .icon-btn-retry:hover {
      color: #1D4ED8; /* text-blue-700 */
      transform: scale(1.1);
    }

    /* 하단 작업 푸터 */
    #job-footer-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: #1F2937; /* bg-gray-800 */
      color: white;
      padding: 0.75rem 1.5rem;
      box-shadow: 0 -4px 10px rgba(0,0,0,0.1);
      z-index: 900;
      transform: translateY(100%);
      transition: transform 0.3s ease-in-out;
    }
    #job-footer-bar.show {
      transform: translateY(0);
    }
    #processing-list .processing-item {
      background-color: #4B5563; /* bg-gray-600 */
      padding: 0.25rem 0.75rem;
      border-radius: 9999px; /* rounded-full */
      font-size: 0.875rem; /* text-sm */
      display: flex;
      align-items: center;
      margin-right: 0.5rem; /* mr-2 */
    }
    #processing-list .spinner-sm {
      width: 1rem; /* w-4 */
      height: 1rem; /* h-4 */
      border-width: 2px;
      margin-right: 0.5rem; /* mr-2 */
    }

    /* 드래그 앤 드롭 드롭존 스타일 */
    .dropzone {
      position: absolute;
      inset: 0; /* top/left/right/bottom = 0 */
      z-index: 10; /* 콘텐츠(z-20)보다 뒤에 위치 */
      border-radius: 0.5rem; /* rounded-lg */
      transition: all 0.2s ease-out;
      background-color: transparent;
    }
    .dropzone-active {
      background-color: rgba(59, 130, 246, 0.1); /* bg-blue-500/10 */
      border: 2px dashed #3B82F6; /* border-blue-500 */
    }
  </style>
</head>
<body class="text-gray-900">

  <!-- 
   *** 모달 (전체 보기) ***
  -->
  <div id="modal-overlay" class="fixed inset-0 bg-black bg-opacity-70 z-40 flex items-center justify-center p-4 hidden">
    <div id="modal-container" class="bg-white rounded-lg shadow-2xl max-w-4xl w-full m-auto transition-all transform scale-95 opacity-0" onclick="event.stopPropagation()">
      <!-- 모달 헤더 -->
      <div class="flex justify-between items-center p-4 border-b border-gray-200">
        <h3 id="modal-title" class="text-xl font-semibold text-gray-800"></h3>
        <button id="modal-close-btn" class="text-gray-400 hover:text-gray-600">
          <i class="bi bi-x-lg text-2xl"></i>
        </button>
      </div>
      <!-- 모달 본문 -->
      <div id="modal-content-wrapper" class="p-6 max-h-[70vh] overflow-y-auto">
        
        <div id="modal-image-gallery-wrapper" class="hidden mb-6">
          <h4 class="text-lg font-semibold text-gray-700 mb-2">이미지 갤러리</h4>
          <div id="modal-image-gallery" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4 p-4 bg-gray-50 rounded-md">
            </div>
        </div>
        
        <h4 class="text-lg font-semibold text-gray-700 mb-2">원본 글</h4>
        <div id="modal-content" class="p-4 bg-gray-50 rounded-md whitespace-pre-wrap text-gray-700 leading-relaxed"></div>
        
        <div id="modal-followup-wrapper" class="hidden mt-6">
          <h4 class="text-lg font-semibold text-gray-700 mb-2">후속 작업 결과</h4>
          <div id="modal-followup-content" class="p-4 bg-blue-50 rounded-md whitespace-pre-wrap text-gray-800 leading-relaxed"></div>
        </div>

      </div>
      <!-- 모달 푸터 -->
      <div class="flex justify-end p-4 bg-gray-50 border-t border-gray-200 rounded-b-lg">
        <button id="modal-close-footer-btn" class="bg-gray-200 text-gray-700 font-semibold py-2 px-4 rounded-md hover:bg-gray-300 transition">
          닫기
        </button>
      </div>
    </div>
  </div>


  <!-- 
   *** 메인 앱 컨테이너 ***
  -->
  <div id="app-container" class="max-w-7xl mx-auto p-4 sm:p-8">
    <!-- 헤더 및 탭 네비게이션 -->
    <header class="mb-6">
      <h1 class="text-3xl font-bold text-gray-800">Gemini 블로그 글 대량 생성기</h1>
      <p class="text-gray-600 mt-1">Firestore 기반 작업 큐 및 후속 작업 관리 (v9 - Refactored)</p>
      <div class="mt-4 border-b border-gray-300 flex space-x-4">
        <button id="nav-workspace" class="py-2 px-4 font-semibold border-b-2 border-blue-600 text-blue-600" onclick="window.app.ui.showView('workspace')">워크스페이스</button>
        <button id="nav-settings" class="py-2 px-4 font-semibold border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-400 transition" onclick="window.app.ui.showView('settings')">설정</button>
      </div>
      <div id="user-id-display" class="mt-2 text-xs text-gray-500"></div>
    </header>

    <!-- 1. 워크스페이스 뷰 (탭 구조) -->
    <main id="workspace-view" class="">
      <!-- 워크스페이스 탭 네비게이션 -->
      <div class="mb-4 border-b border-gray-300 flex space-x-4">
        <button id="nav-workspace-input" class="py-2 px-4 font-semibold border-b-2 border-blue-600 text-blue-600" onclick="window.app.ui.showWorkspaceView('input')">
          <i class="bi bi-pencil-square mr-1"></i> 입력
        </button>
        <button id="nav-workspace-results" class="py-2 px-4 font-semibold border-b-2 border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-400 transition" onclick="window.app.ui.showWorkspaceView('results')">
          <i class="bi bi-card-list mr-1"></i> 결과
        </button>
      </div>

      <!-- 워크스페이스 탭 패널 -->
      <div>
        <!-- 1-1. 입력 패널 -->
        <div id="workspace-input-panel" class="">
          <div class="bg-white p-6 rounded-lg shadow-lg max-w-3xl mx-auto">
            <h2 class="text-xl font-semibold mb-5 text-gray-800">입력 설정</h2>
            <div class="space-y-5">
              <!-- 1. 템플릿 선택 -->
              <div>
                <label for="template-select" class="block text-sm font-medium text-gray-700 mb-1">1. 기본 템플릿 선택</label>
                <select id="template-select" class="w-full p-2.5 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 transition"></select>
              </div>
              <!-- 2. 참고 자료 -->
              <div>
                <label for="file-input" class="block text-sm font-medium text-gray-700 mb-1">2. 참고 자료 (선택)</label>
                <input type="file" id="file-input" accept=".txt,.md,.json" class="w-full text-sm text-gray-600
                  file:mr-4 file:py-2 file:px-4
                  file:rounded-lg file:border-0
                  file:text-sm file:font-semibold
                  file:bg-blue-50 file:text-blue-700
                  hover:file:bg-blue-100 transition cursor-pointer
                "/>
              </div>
              <!-- 3. 블로그 주제 -->
              <div>
                <label for="topics-input" class="block text-sm font-medium text-gray-700 mb-1">3. 블로그 주제 (한 줄에 하나)</label>
                <textarea id="topics-input" rows="8" class="w-full p-2.5 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-300 focus:border-blue-500 transition" placeholder="예: 2025년 최고의 AI 트렌드&#10;예: Gemini API 활용법 5가지"></textarea>
              </div>
              <!-- 생성 버튼 -->
              <button id="generate-button" class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-md hover:bg-blue-700 shadow-md hover:shadow-lg transition-all duration-200 flex items-center justify-center">
                <svg id="generate-spinner" class="animate-spin -ml-1 mr-3 h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span id="generate-button-text">생성하기</span>
              </button>
            </div>
            <div id="status-message" class="mt-4 text-sm text-center text-gray-600 h-10"></div>
          </div>
        </div>

        <!-- 1-2. 출력 패널 -->
        <div id="workspace-results-panel" class="hidden">
          <div class="bg-white p-6 rounded-lg shadow-lg">
            <h2 class="text-xl font-semibold mb-5 text-gray-800">작업 결과물</h2>
            
            <!-- 필터 및 정렬 컨트롤 -->
            <div class="flex justify-end space-x-2 mb-4">
              <select id="filter-followup-status" class="p-2 border border-gray-300 rounded-md text-sm focus:ring-blue-300 focus:border-blue-500">
                <option value="all">필터: 모두</option>
                <option value="complete">필터: 후속 작업 완료</option>
                <option value="incomplete">필터: 후속 작업 대기</option>
                <option value="failed">필터: 실패</option>
              </select>
              <select id="sort-creation-date" class="p-2 border border-gray-300 rounded-md text-sm focus:ring-blue-300 focus:border-blue-500">
                <option value="newest">정렬: 최신순</option>
                <option value="oldest">정렬: 오래된순</option>
              </select>
            </div>
        
            <div id="results-container" class="space-y-4 h-[600px] overflow-y-auto pr-2">
              <p class="text-gray-500">아직 생성된 글이 없습니다.</p>
            </div>
          </div>
        </div>
      </div>
    </main>

    <!-- 2. 설정 뷰 (4열 그리드) -->
    <main id="settings-view" class="hidden">
      <div class="grid grid-cols-1 lg:grid-cols-4 gap-8">
        
        <!-- 2-1. Firebase 설정 패널 -->
        <div class="bg-white p-6 rounded-lg shadow-md lg:col-span-1">
          <h2 class="text-xl font-semibold mb-4">Firebase 설정</h2>
          <p class="text-sm text-gray-600 mb-2">Firebase 콘솔에서 '웹 앱'을 등록한 후 `firebaseConfig` 객체(JSON)를 붙여넣으세요.</p>
          <textarea id="firebase-config-input" rows="10" class="w-full p-2 font-mono text-xs border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-300 transition" placeholder="{&#10;  apiKey: &quot;...&quot;,&#10;  authDomain: &quot;...&quot;,&#10;  projectId: &quot;...&quot;,&#10;  ...&#10;}"></textarea>
          <button id="save-firebase-config-button" class="mt-2 w-full bg-red-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-red-700 shadow-sm hover:shadow-md transition">
            <i class="bi bi-save mr-1"></i> 설정 저장 (페이지 새로고침)
          </button>
        </div>

        <!-- 2-2. 인증 및 API 키 관리 패널 -->
        <div class="bg-white p-6 rounded-lg shadow-md lg:col-span-1">
          <h2 class="text-xl font-semibold mb-4">인증 및 API 키</h2>
          
          <!-- 인증 버튼 -->
          <div class="space-y-2 mb-4">
            <button id="google-login-button" class="w-full bg-white text-gray-700 font-semibold py-2 px-4 rounded-md border border-gray-300 hover:bg-gray-50 shadow-sm transition flex items-center justify-center">
              <i class="bi bi-google mr-2 text-red-500"></i> Google 계정으로 로그인
            </button>
            <button id="anonymous-login-button" class="w-full bg-gray-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-gray-700 shadow-sm transition flex items-center justify-center">
              <i class="bi bi-person-stealth mr-2"></i> 익명으로 로그인
            </button>
            <button id="logout-button" class="w-full bg-red-500 text-white font-semibold py-2 px-4 rounded-md hover:bg-red-600 shadow-sm transition hidden items-center justify-center">
              <i class="bi bi-box-arrow-right mr-2"></i> 로그아웃
            </button>
          </div>

          <hr class="my-4">
          
          <!-- API 키 관리 -->
          <h3 class="text-lg font-semibold mb-3">Gemini API 키 관리</h3>
          <div class="flex space-x-2 mb-4">
            <input type="password" id="api-key-input" placeholder="새 Gemini API 키" class="flex-grow p-2 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-300 transition">
            <button id="add-key-button" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-blue-700 shadow-sm hover:shadow-md transition">추가</button>
          </div>
          <div id="api-keys-list" class="space-y-2"></div>
        </div>

        <!-- 2-3. 기본 템플릿 관리 -->
        <div class="bg-white p-6 rounded-lg shadow-md lg:col-span-1">
          <h2 class="text-xl font-semibold mb-4">기본 템플릿 관리</h2>
          <div class="space-y-4">
            <input type="text" id="template-name" placeholder="템플릿 이름" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-300 transition">
            <textarea id="template-content" rows="8" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-300 transition" placeholder="변수: {주제}, {자료}"></textarea>
            <input type="hidden" id="template-id-hidden">
            <button id="save-template-button" class="w-full bg-green-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-green-700 shadow-sm hover:shadow-md transition">저장/새로 만들기</button>
          </div>
          <h3 class="text-lg font-semibold mt-6 mb-2">저장된 템플릿</h3>
          <div id="templates-list" class="space-y-2"></div>
        </div>
        
        <!-- 2-4. 후속 작업 템플릿 (단일) -->
        <div class="bg-white p-6 rounded-lg shadow-md lg:col-span-1">
          <h2 class="text-xl font-semibold mb-4">후속 작업 템플릿 (단일)</h2>
          <p class="text-sm text-gray-600 mb-4">여기에 저장된 템플릿이 모든 글의 후속 작업으로 자동 사용됩니다.</p>
          <div class="space-y-4">
            <input type="text" id="followup-template-name-single" placeholder="후속 작업 이름 (예: 도표 요약)" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-300 transition">
            <textarea id="followup-template-content-single" rows="8" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-blue-300 transition" placeholder="필수 변수: {글}
예: 다음 {글}을 마크다운 테이블로 요약해줘."></textarea>
            <button id="save-followup-template-single-button" class="w-full bg-purple-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-purple-700 shadow-sm hover:shadow-md transition">단일 후속 템플릿 저장</button>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- 하단 작업 푸터 -->
  <div id="job-footer-bar" class="flex items-center justify-between">
    <div class="flex items-center">
      <span class="text-sm font-medium mr-4">작업 현황</span>
      <div id="processing-list" class="flex items-center">
      </div>
    </div>
    <div id="queue-status-display" class="text-sm font-medium text-gray-300">
    </div>
  </div>

  <!-- 토스트 알림 컨테이너 -->
  <div id="toast" class=""></div>

  <!-- Firebase SDK 및 앱 초기화 -->
  <script type="module">
    // Firebase 모듈 임포트
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { 
      getAuth, 
      signInAnonymously, 
      signInWithPopup, 
      GoogleAuthProvider, 
      signOut, 
      onAuthStateChanged 
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { 
      getFirestore, doc, addDoc, setDoc, updateDoc, deleteDoc, 
      onSnapshot, collection, query, serverTimestamp, setLogLevel
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    
    /**
     * ================================================================
     * 클래스 1: UIManager - UI 상호작용 및 렌더링 전담
     * (Axiom: Separation of Concerns)
     * ================================================================
     */
    class UIManager {
      constructor() {
        this.elements = this.queryElements();
        this.currentFilter = 'all';
        this.currentSort = 'newest';
      }

      // 1. 모든 DOM 요소를 한 번에 찾아 객체로 관리
      queryElements() {
        const els = {};
        const ids = [
          'workspace-view', 'settings-view', 'nav-workspace', 'nav-settings',
          'status-message', 'generate-button', 'generate-button-text', 'generate-spinner',
          'user-id-display', 'modal-overlay', 'modal-container', 'modal-title',
          'modal-content', 'modal-followup-wrapper', 'modal-followup-content',
          'modal-close-btn', 'modal-close-footer-btn',
          'workspace-input-panel', 'workspace-results-panel', 'nav-workspace-input', 'nav-workspace-results',
          'job-footer-bar', 'processing-list', 'queue-status-display', 'toast',
          'modal-image-gallery-wrapper', 'modal-image-gallery',
          'firebase-config-input', 'save-firebase-config-button',
          'google-login-button', 'anonymous-login-button', 'logout-button',
          'api-key-input', 'add-key-button', 'api-keys-list',
          'template-select', 'file-input', 'topics-input',
          'template-name', 'template-content', 'template-id-hidden', 'save-template-button', 'templates-list',
          'followup-template-name-single', 'followup-template-content-single', 'save-followup-template-single-button',
          'filter-followup-status', 'sort-creation-date', 'results-container'
        ];
        ids.forEach(id => {
          els[id.replace(/-(\w)/g, (match, p1) => p1.toUpperCase())] = document.getElementById(id);
        });
        return els;
      }

      // 2. 이벤트 리스너 바인딩
      bindEvents(app) {
        // 전역
        window.app = app; // 전역에서 app 객체 접근 허용 (HTML onclick 등)
        
        // 뷰 전환
        // this.elements.navWorkspace.onclick = () => this.showView('workspace'); // HTML onclick으로 대체
        // this.elements.navSettings.onclick = () => this.showView('settings'); // HTML onclick으로 대체
        // this.elements.navWorkspaceInput.onclick = () => this.showWorkspaceView('input'); // HTML onclick으로 대체
        // this.elements.navWorkspaceResults.onclick = () => this.showWorkspaceView('results'); // HTML onclick으로 대체

        // 설정
        this.elements.saveFirebaseConfigButton.onclick = () => app.handleSaveConfig(this.elements.firebaseConfigInput.value);
        this.elements.googleLoginButton.onclick = () => app.firebase.handleGoogleLogin();
        this.elements.anonymousLoginButton.onclick = () => app.firebase.handleAnonymousLogin();
        this.elements.logoutButton.onclick = () => app.firebase.handleLogout();

        // API 키
        this.elements.addKeyButton.onclick = () => {
          const key = this.elements.apiKeyInput.value;
          app.firebase.addApiKey(key).then(() => {
            this.elements.apiKeyInput.value = '';
          });
        };

        // 기본 템플릿
        this.elements.saveTemplateButton.onclick = () => {
          const id = this.elements.templateIdHidden.value;
          const name = this.elements.templateName.value;
          const content = this.elements.templateContent.value;
          app.firebase.saveTemplate(id, name, content).then(() => {
            this.elements.templateIdHidden.value = '';
            this.elements.templateName.value = '';
            this.elements.templateContent.value = '';
          });
        };

        // 후속 템플릿
        this.elements.saveFollowupTemplateSingleButton.onclick = () => {
          const name = this.elements.followupTemplateNameSingle.value;
          const content = this.elements.followupTemplateContentSingle.value;
          app.firebase.saveSingleFollowUpTemplate(name, content);
        };

        // 워크스페이스
        this.elements.fileInput.onchange = (e) => app.handleFileSelect(e);
        this.elements.generateButton.onclick = () => {
          const templateId = this.elements.templateSelect.value;
          const topics = this.elements.topicsInput.value;
          app.handleGenerateClick(templateId, topics);
        };
        this.elements.topicsInput.oninput = () => {
          if (this.elements.topicsInput.value === '') {
            this.setButtonLoading(false);
          }
        };


        // 결과 뷰
        this.elements.filterFollowupStatus.onchange = (e) => {
          this.currentFilter = e.target.value;
          app.renderLocalData();
        };
        this.elements.sortCreationDate.onchange = (e) => {
          this.currentSort = e.target.value;
          app.renderLocalData();
        };

        // 모달
        this.elements.modalOverlay.onclick = () => this.closeModal();
        this.elements.modalCloseBtn.onclick = () => this.closeModal();
        this.elements.modalCloseFooterBtn.onclick = () => this.closeModal();
      }

      // 3. UI 상태 변경 메서드
      showView(viewName) {
        this.elements.workspaceView.classList.toggle('hidden', viewName !== 'workspace');
        this.elements.settingsView.classList.toggle('hidden', viewName === 'workspace');
        ['navWorkspace', 'navSettings'].forEach(navId => {
          const el = this.elements[navId];
          const isActive = (navId === 'navWorkspace' && viewName === 'workspace') || (navId === 'navSettings' && viewName !== 'workspace');
          el.classList.toggle('border-blue-600', isActive);
          el.classList.toggle('text-blue-600', isActive);
          el.classList.toggle('border-transparent', !isActive);
          el.classList.toggle('text-gray-500', !isActive);
        });
      }

      showWorkspaceView(viewName) {
        this.elements.workspaceInputPanel.classList.toggle('hidden', viewName !== 'input');
        this.elements.workspaceResultsPanel.classList.toggle('hidden', viewName === 'input');
        ['navWorkspaceInput', 'navWorkspaceResults'].forEach(navId => {
          const el = this.elements[navId];
          const isActive = (navId === 'navWorkspaceInput' && viewName === 'input') || (navId === 'navWorkspaceResults' && viewName !== 'input');
          el.classList.toggle('border-blue-600', isActive);
          el.classList.toggle('text-blue-600', isActive);
          el.classList.toggle('border-transparent', !isActive);
          el.classList.toggle('text-gray-500', !isActive);
        });
      }

      updateLoginStatus(user) {
        if (user) {
          this.elements.userIdDisplay.textContent = user.isAnonymous ? `익명 로그인됨 (ID: ${user.uid.substring(0, 6)}...)` : `로그인됨: ${user.email}`;
          this.elements.googleLoginButton.classList.add('hidden');
          this.elements.anonymousLoginButton.classList.add('hidden');
          this.elements.logoutButton.classList.remove('hidden');
          this.elements.navWorkspace.disabled = false;
          this.elements.navWorkspace.classList.remove('opacity-50', 'cursor-not-allowed');
        } else {
          this.elements.userIdDisplay.textContent = "로그아웃 상태입니다. '설정' 탭에서 로그인하세요.";
          this.elements.googleLoginButton.classList.remove('hidden');
          this.elements.anonymousLoginButton.classList.remove('hidden');
          this.elements.logoutButton.classList.add('hidden');
          this.elements.navWorkspace.disabled = true;
          this.elements.navWorkspace.classList.add('opacity-50', 'cursor-not-allowed');
          this.showView('settings');
        }
      }

      showToast(message, type = 'success') {
        const toast = this.elements.toast;
        if (!toast) return;
        toast.textContent = message;
        toast.className = type;
        toast.classList.add('show');
        setTimeout(() => { toast.classList.remove('show'); }, 3000);
      }

      setButtonLoading(isLoading, text = "생성하기") {
        this.elements.generateButtonText.textContent = text;
        this.elements.generateSpinner.classList.toggle('hidden', !isLoading);
      }

      updateStatusMessage(message) {
        this.elements.statusMessage.textContent = message;
      }
      
      setFirebaseConfigInput(config) {
        if (!config) return;
        try {
          this.elements.firebaseConfigInput.value = JSON.stringify(JSON.parse(config), null, 2);
        } catch(e) { 
          this.elements.firebaseConfigInput.value = config;
        }
      }
      
      clearTopicsInput() {
        this.elements.topicsInput.value = '';
      }

      // 4. 렌더링 메서드
      renderApiKeys(apiKeys = []) {
        const list = this.elements.apiKeysList;
        list.innerHTML = '';
        if (apiKeys.length === 0) { list.innerHTML = '<p class="text-gray-500">추가된 API 키가 없습니다.</p>'; return; }
        
        const sortedKeys = [...apiKeys].sort((a, b) => (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0));
        
        sortedKeys.forEach(key => {
          let s = { color: 'text-gray-500', text: key.status || '알 수 없음' };
          if (key.status === 'ready') { s = { color: 'text-green-500', text: '준비' }; }
          if (key.status === 'busy') { s = { color: 'text-yellow-600', text: '사용중' }; }
          if (key.status === 'cooldown') { s = { color: 'text-blue-500', text: `휴식 (1분)` }; } // 1분 휴식으로 텍스트 변경
          if (key.status === 'dead') { s = { color: 'text-red-700', text: `비활성 (실패: ${key.failureCount || 0})` }; } // 'dead' 상태 추가
          
          const buttonsHtml = (key.status === 'dead') 
            ? `<button class="icon-btn icon-btn-retry" title="키 재설정"><i class="bi bi-arrow-counterclockwise"></i></button>
               <button class="icon-btn icon-btn-danger" title="삭제"><i class="bi bi-trash"></i></button>`
            : `<button class="icon-btn icon-btn-danger" title="삭제"><i class="bi bi-trash"></i></button>`;
            
          const el = this.createDOMElement('div', 'flex items-center justify-between p-2 bg-gray-50 border border-gray-200 rounded-md', `
            <span class="font-mono text-sm"><span class="font-bold ${s.color}">[${s.text}]</span> ...${key.key.slice(-4)}</span>
            <div class="flex space-x-2">${buttonsHtml}</div>
          `);
          
          el.querySelector('button.icon-btn-danger').onclick = () => window.app.firebase.deleteApiKey(key.id);
          if (key.status === 'dead') {
            el.querySelector('button.icon-btn-retry').onclick = () => window.app.firebase.resetApiKey(key.id);
          }
          list.appendChild(el);
        });
      }

      renderTemplates(templates = []) {
        const list = this.elements.templatesList;
        const select = this.elements.templateSelect;
        list.innerHTML = ''; select.innerHTML = '';
        
        if (templates.length === 0) {
          list.innerHTML = '<p class="text-gray-500">템플릿 없음</p>';
          select.innerHTML = '<option>템플릿 없음</option>';
          return;
        }
        
        const sorted = [...templates].sort((a, b) => a.name.localeCompare(b.name));
        
        sorted.forEach(t => {
          select.innerHTML += `<option value="${t.id}">${t.name}</option>`;
          const el = this.createDOMElement('div', 'flex items-center justify-between p-2 bg-gray-50 border border-gray-200 rounded-md', `
            <span class="font-medium text-gray-700">${t.name}</span>
            <div class="space-x-2">
              <button class="icon-btn" title="수정"><i class="bi bi-pencil-square"></i></button>
              <button class="icon-btn icon-btn-danger" title="삭제"><i class="bi bi-trash"></i></button>
            </div>
          `);
          el.querySelector('button.icon-btn').onclick = () => this.loadTemplateForEdit(t);
          el.querySelector('button.icon-btn-danger').onclick = () => window.app.firebase.deleteTemplate(t.id);
          list.appendChild(el);
        });
      }
      
      loadTemplateForEdit(template) {
        this.elements.templateIdHidden.value = template.id;
        this.elements.templateName.value = template.name;
        this.elements.templateContent.value = template.content;
        this.showToast("템플릿 불러옴.", "info");
      }

      renderFollowUpTemplate(template) {
        if (template) {
          this.elements.followupTemplateNameSingle.value = template.name;
          this.elements.followupTemplateContentSingle.value = template.content;
        } else {
          this.elements.followupTemplateNameSingle.value = '';
          this.elements.followupTemplateContentSingle.value = '';
        }
      }

      renderResults(posts = [], hasFollowUpTemplate) {
        const container = this.elements.resultsContainer;
        container.innerHTML = '';
        
        // [수정] 그리드 레이아웃 및 정렬 스타일 적용
        container.className = 'h-[600px] overflow-y-auto pr-2 grid gap-4 grid-cols-[repeat(auto-fill,minmax(300px,1fr))] items-start';

        // 1. 필터링
        let filteredPosts = posts.filter(post => {
          if (this.currentFilter === 'all') return true;
          if (this.currentFilter === 'complete') return post.isFollowUpComplete === true && !post.followUpError;
          if (this.currentFilter === 'incomplete') return !post.isFollowUpComplete && !post.error;
          if (this.currentFilter === 'failed') return post.error === true || post.followUpError === true;
          return true;
        });

        // 2. 정렬
        const sortedPosts = filteredPosts.sort((a, b) => {
          const timeA = a.createdAt?.toMillis() || 0;
          const timeB = b.createdAt?.toMillis() || 0;
          return (this.currentSort === 'newest') ? timeB - timeA : timeA - timeB;
        });

        // 3. 렌더링
        if (sortedPosts.length === 0) {
          container.innerHTML = `<p class="text-gray-500">${(this.currentFilter === 'all') ? '아직 생성된 글이 없습니다.' : '일치하는 항목이 없습니다.'}</p>`;
          return;
        }
        
        sortedPosts.forEach(post => {
          const contentPreview = post.error 
            ? `<p class="text-red-600 font-medium">${post.content}</p>` 
            : `<p class="text-gray-700 whitespace-pre-wrap">${post.content.substring(0, 100)}...</p>`;
          
          // --- 버튼 로직 수정 ---
          const buttonsContainer = this.createDOMElement('div', 'flex items-center justify-end space-x-3 pt-2 border-t border-gray-100');
          
          // [신규] 이미지 갯수 뱃지 플레이스홀더 (좌측 정렬)
          buttonsContainer.innerHTML += `<span id="image-count-${post.id}" class="hidden text-sm text-gray-500 mr-auto"></span>`;
          // 1. 파일 입력 (숨김) - DOM 노드 생성 및 핸들러 연결
          // (아직 DOM에 추가하지 않음)
          const imageInputId = `image-input-${post.id}`;
          const imageInput = this.createDOMElement('input', 'hidden', '');
          imageInput.type = 'file';
          imageInput.accept = 'image/*';
          imageInput.id = imageInputId;
          imageInput.onchange = (e) => window.app.handleImageUpload(post.id, e.target.files[0]);
          
          const zipInputId = `zip-input-${post.id}`;
          const zipInput = this.createDOMElement('input', 'hidden', '');
          zipInput.type = 'file';
          zipInput.accept = '.zip';
          zipInput.id = zipInputId;
          zipInput.onchange = (e) => window.app.handleZipImageUpload(post.id, e.target.files[0]);

          // 2. 버튼 생성 (HTML 문자열)
          if (post.isFollowUpComplete) {
            buttonsContainer.innerHTML += this.createActionButton('bi-arrows-fullscreen', '', `window.app.ui.openModal('${post.id}')`, "전체 보기");
            buttonsContainer.innerHTML += this.createActionButton('bi-clipboard', '', `window.app.copyToClipboard('${post.id}', 'content')`, "원본 복사");
            if (post.followUpError) {
              buttonsContainer.innerHTML += this.createActionButton('bi-arrow-clockwise', 'icon-btn-retry', `window.app.retryFollowUpJob('${post.id}')`, "재시도");
            } else {
              buttonsContainer.innerHTML += this.createActionButton('bi-clipboard-check', 'icon-btn-purple', `window.app.copyToClipboard('${post.id}', 'followUp')`, "결과 복사");
            }
          } else if (post.error) {
            buttonsContainer.innerHTML += this.createActionButton('bi-exclamation-triangle', '', `window.app.ui.openModal('${post.id}')`, "실패 사유 보기");
            buttonsContainer.innerHTML += this.createActionButton('bi-arrow-clockwise', 'icon-btn-retry', `window.app.retryJob('${post.id}')`, "재시도");
          } else {
            buttonsContainer.innerHTML += this.createActionButton('bi-arrows-fullscreen', '', `window.app.ui.openModal('${post.id}')`, "전체 보기");
            buttonsContainer.innerHTML += this.createActionButton('bi-clipboard', '', `window.app.copyToClipboard('${post.id}', 'content')`, "원본 복사");
            if (hasFollowUpTemplate) {
              buttonsContainer.innerHTML += this.createActionButton('bi-magic', 'icon-btn-purple', `window.app.handleFollowUpClick('${post.id}')`, "후속 작업 실행");
            }
          }

          // 3. 신규 버튼 (HTML 문자열) - 파일 입력을 트리거
          buttonsContainer.insertAdjacentHTML('beforeend', this.createActionButton('bi-image', '', `document.getElementById('${imageInputId}').click()`, "개별 이미지 추가"));
          buttonsContainer.insertAdjacentHTML('beforeend', this.createActionButton('bi-file-earmark-zip', '', `document.getElementById('${zipInputId}').click()`, "ZIP 이미지 추가"));
          
          // 4. 삭제 버튼 (HTML 문자열)
          buttonsContainer.insertAdjacentHTML('beforeend', this.createActionButton('bi-trash', 'icon-btn-danger', `window.app.deletePost('${post.id}')`, "삭제"));
          
          // 5. [수정됨] 모든 HTML 문자열 조작이 끝난 후, 이벤트 리스너가 연결된 DOM 노드를 추가
          buttonsContainer.appendChild(imageInput);
          buttonsContainer.appendChild(zipInput);

          const contentWrapper = this.createDOMElement('div', 'relative z-20', `
            <h4 class="font-semibold text-gray-800">${post.topic}</h4>
            <div class="mt-2 mb-3 text-sm cursor-pointer" onclick="window.app.ui.openModal('${post.id}')">${contentPreview}</div>
          `);
          contentWrapper.appendChild(buttonsContainer); // 버튼도 래퍼에 포함

          // 2. [수정] 메인 카드(`el`)에 relative 추가 및 contentWrapper 삽입
          const el = this.createDOMElement('div', 'relative bg-white p-3 rounded-lg shadow-md hover:shadow-lg transition-shadow duration-200 border border-gray-200', '');
          el.appendChild(contentWrapper);

          // 3. [신규] 드롭존 생성 및 이벤트 바인딩
          const dropZone = this.createDOMElement('div', 'dropzone', '');
          
          const dragHandler = (e, isActive) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.toggle('dropzone-active', isActive);
          };

          dropZone.ondragover = (e) => dragHandler(e, true);
          dropZone.ondragleave = (e) => dragHandler(e, false);
          
          dropZone.ondrop = (e) => {
            dragHandler(e, false); // 비활성화
            
            const files = e.dataTransfer.files;
            if (!files || files.length === 0) return;

            this.showToast(`'${post.topic}'에 ${files.length}개 파일 드롭 감지.`, "info");

            // 모든 드롭된 파일을 순회하며 처리
            for (const file of files) {
              if (file.type === 'application/zip' || file.name.endsWith('.zip')) {
                window.app.handleZipImageUpload(post.id, file);
              } else if (file.type.startsWith('image/')) {
                window.app.handleImageUpload(post.id, file);
              } else {
                this.showToast(`지원하지 않는 파일 형식: ${file.name}`, "error");
              }
            }
          };
          
          el.appendChild(dropZone); // 드롭존을 메인 카드에 추가 (z-10)
          
          // --- 로직 수정 끝 ---
          container.appendChild(el);
          
          // [신규] 생성된 카드의 이미지 갯수를 비동기적으로 업데이트
          this.updateImageCount(post.id);
        });
      }
      
      createActionButton(icon, extraClass, onclick, title) {
        return `<button class="icon-btn ${extraClass}" onclick="${onclick}" title="${title}"><i class="bi ${icon}"></i></button>`;
      }

      openModal(postId) {
        const post = window.app.localState.generatedPosts.find(p => p.id === postId);
        if (!post) return;
        
        this.elements.modalTitle.textContent = post.topic;
        this.elements.modalContent.textContent = post.content;
        
        if (post.isFollowUpComplete && post.followUpResult) {
          this.elements.modalFollowupContent.textContent = post.followUpResult;
          this.elements.modalFollowupWrapper.classList.remove('hidden');
          this.elements.modalFollowupContent.classList.toggle('bg-red-50', post.followUpError);
          this.elements.modalFollowupContent.classList.toggle('text-red-700', post.followUpError);
          this.elements.modalFollowupContent.classList.toggle('bg-blue-50', !post.followUpError);
          this.elements.modalFollowupContent.classList.toggle('text-gray-800', !post.followUpError);
        } else {
          this.elements.modalFollowupWrapper.classList.add('hidden');
        }
        
        // --- 신규: 이미지 갤러리 로드 ---
        this.renderModalGallery(postId);
        // --- 신규 로직 끝 ---

        this.elements.modalOverlay.classList.remove('hidden');
        
        this.elements.modalOverlay.classList.remove('hidden');
        setTimeout(() => {
          this.elements.modalOverlay.classList.remove('opacity-0');
          this.elements.modalContainer.classList.remove('scale-95', 'opacity-0');
        }, 10);
      }

      closeModal() {
        this.elements.modalContainer.classList.add('scale-95', 'opacity-0');
        this.elements.modalOverlay.classList.add('opacity-0');
        setTimeout(() => { this.elements.modalOverlay.classList.add('hidden'); }, 300);
      }
      
      async renderModalGallery(postId) {
        const gallery = this.elements.modalImageGallery;
        const wrapper = this.elements.modalImageGalleryWrapper;
        gallery.innerHTML = '<p class="text-gray-500 col-span-full">이미지 로드 중...</p>';
        wrapper.classList.remove('hidden');
        
        try {
          const images = await window.app.imageDB.getImagesForPost(postId);
          if (images.length === 0) {
            gallery.innerHTML = '<p class="text-gray-500 col-span-full">업로드된 이미지가 없습니다.</p>';
            return;
          }
          
          gallery.innerHTML = ''; // 로딩 메시지 제거
          images.forEach(imgData => {
            const url = URL.createObjectURL(imgData.blob);
            
            // 1. 이미지 감싸는 래퍼 생성
            const wrapper = this.createDOMElement('div', 'relative group shadow-sm rounded-md overflow-hidden', '');
            
            // 2. 이미지 엘리먼트
            const imgEl = this.createDOMElement('img', 'w-full h-auto object-cover cursor-pointer', '');
            imgEl.src = url;
            imgEl.style.minWidth = '300px'; 
            imgEl.title = `(${imgData.type}) 클릭하여 복사`;
            imgEl.onload = () => URL.revokeObjectURL(url); 
            imgEl.onclick = () => {
              window.app.imageDB.copyImageToClipboard(imgData.blob)
                .then(() => this.showToast("이미지가 클립보드에 복사되었습니다.", "success"))
                .catch(e => this.showToast(e.message, "error"));
            };

            // 3. 삭제 버튼
            const deleteBtn = this.createDOMElement('button', 
              'absolute top-1.5 right-1.5 p-1 bg-red-600 text-white rounded-full leading-none opacity-0 group-hover:opacity-100 transition-opacity z-10 hover:bg-red-700', 
              '<i class="bi bi-trash" style="font-size: 0.75rem; vertical-align: middle;"></i>'
            );
            deleteBtn.title = "이미지 삭제";
            deleteBtn.onclick = (e) => {
              e.stopPropagation(); // 이미지 복사 이벤트 방지
              // App의 새 핸들러 호출 (imgData.id는 DB의 기본 키)
              window.app.handleDeleteImage(imgData.id, postId); 
            };
            
            wrapper.appendChild(imgEl);
            wrapper.appendChild(deleteBtn);
            gallery.appendChild(wrapper);
          });
          
        } catch (e) {
          console.error("이미지 갤러리 로드 실패:", e);
          gallery.innerHTML = '<p class="text-red-500 col-span-full">이미지 로드 중 오류가 발생했습니다.</p>';
        }
      }
      
      updateJobFooter(activelyProcessingJobs, jobQueueLength) {
        const activeJobs = Array.from(activelyProcessingJobs.values());
        
        if (activeJobs.length === 0 && jobQueueLength === 0) {
          this.elements.jobFooterBar.classList.remove('show');
          return;
        }
        
        this.elements.jobFooterBar.classList.add('show');
        const list = this.elements.processingList;
        list.innerHTML = '';
        
        let count = 0;
        for (const job of activeJobs) {
          if (count >= 3) {
            list.innerHTML += `<span class="processing-item">...외 ${activeJobs.length - count}개</span>`;
            break;
          }
          list.appendChild(this.createDOMElement('span', 'processing-item', `
            <svg class="animate-spin spinner-sm text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            ${job.topic.substring(0, 20)}...
          `));
          count++;
        }
        
        this.elements.queueStatusDisplay.textContent = (jobQueueLength > 0) ? `대기열: ${jobQueueLength}개` : `대기열 없음`;
      }

      // 5. 유틸리티
      createDOMElement(tag, className, html = '') {
        const el = document.createElement(tag);
        el.className = className;
        el.innerHTML = html;
        return el;
      }
      
      // [신규] 이미지 갯수 뱃지 업데이트 헬퍼
      async updateImageCount(postId) {
        try {
          // imageDB에서 직접 카운트 조회
          const images = await window.app.imageDB.getImagesForPost(postId);
          const badge = document.getElementById(`image-count-${postId}`);
          if (badge) {
            if (images.length > 0) {
              badge.textContent = `${images.length}개 이미지`;
              badge.classList.remove('hidden');
            } else {
              badge.textContent = '';
              badge.classList.add('hidden');
            }
          }
        } catch (e) {
          console.warn(`Image count update failed for ${postId}`, e);
        }
      }
    }

    /**
     * ================================================================
     * 클래스 2: FirebaseService - Firebase 인증 및 Firestore 전담
     * (Axiom: Single Responsibility Principle)
     * ================================================================
     */
    class FirebaseService {
      constructor(config, onAuthChangeCallback) {
        this.app = initializeApp(config);
        this.db = getFirestore(this.app);
        this.auth = getAuth(this.app);
        setLogLevel('debug');
        
        this.config = config;
        this.userId = null;
        this.collections = {};
        
        this.listeners = {}; // Firestore 리스너 구독 해제용
        
        onAuthStateChanged(this.auth, (user) => {
          this.userId = user ? user.uid : null;
          if (user) {
            this.setCollectionRefs();
          }
          onAuthChangeCallback(user);
        });
      }

      setCollectionRefs() {
        const appId = this.config?.appId || 'default-app-id';
        if (!this.userId || !appId) return;
        const userBasePath = `artifacts/${appId}/users/${this.userId}`;
        this.collections = {
          keysCol: collection(this.db, `${userBasePath}/apiKeys`),
          templatesCol: collection(this.db, `${userBasePath}/templates`),
          followUpTemplatesCol: collection(this.db, `${userBasePath}/followUpTemplates`),
          postsCol: collection(this.db, `${userBasePath}/generatedPosts`)
        };
      }
      
      // 1. 인증
      async handleGoogleLogin() {
        const provider = new GoogleAuthProvider();
        try { await signInWithPopup(this.auth, provider); } 
        catch (error) { console.error("Google 로그인 실패:", error); throw error; }
      }

      async handleAnonymousLogin() {
        try { await signInAnonymously(this.auth); } 
        catch (error) { console.error("익명 로그인 실패:", error); throw error; }
      }

      async handleLogout() {
        try { await signOut(this.auth); } 
        catch (error) { console.error("로그아웃 실패:", error); throw error; }
      }
      
      // 2. 리스너 (데이터 실시간 감지)
      listenToData(collectionName, callback) {
        const col = this.collections[collectionName];
        if (!col) return;
        
        // 기존 리스너가 있다면 구독 해제
        if (this.listeners[collectionName]) {
          this.listeners[collectionName]();
        }
        
        this.listeners[collectionName] = onSnapshot(query(col), (snapshot) => {
          const data = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
          callback(data);
        }, (e) => console.error(`${collectionName} 로드 실패:`, e));
      }
      
      stopAllListeners() {
        for (const unsub of Object.values(this.listeners)) {
          unsub();
        }
        this.listeners = {};
      }

      // 3. API 키 CRUD
      async addApiKey(key) {
        if (!key) throw new Error("API 키를 입력하세요.");
        await addDoc(this.collections.keysCol, { 
          key: key, status: 'ready', lastUsed: null, 
          createdAt: serverTimestamp(), backoffLevel: 0, failureCount: 0
        });
      }
      async deleteApiKey(id) { await deleteDoc(doc(this.db, this.collections.keysCol.path, id)); }
      async resetApiKey(id) {
        const keyDoc = doc(this.db, this.collections.keysCol.path, id);
        // 상태, 실패 카운트, 백오프 레벨, 마지막 사용 시간을 모두 초기화
        await updateDoc(keyDoc, { status: 'ready', failureCount: 0, backoffLevel: 0, lastUsed: null });
      }
      async updateApiKeyStatus(id, status, extraData = {}) {
        // 'ready' 상태로 업데이트 시, 실패 카운트와 백오프 레벨을 자동으로 초기화
        if (status === 'ready') {
          extraData = { ...extraData, failureCount: 0, backoffLevel: 0 };
        }
        
        const keyDoc = doc(this.db, this.collections.keysCol.path, id);
        const updateData = { status: status, ...extraData };
        if (['busy', 'cooldown', 'dead'].includes(status)) { // 'rate_limited' 대신 'dead' 포함
          updateData.lastUsed = serverTimestamp();
        }
        await updateDoc(keyDoc, updateData);
      }

      // 4. 템플릿 CRUD
      async saveTemplate(id, name, content) {
        if (!name || !content) throw new Error("이름과 내용을 모두 입력하세요.");
        const data = { name, content };
        if (id) { await setDoc(doc(this.db, this.collections.templatesCol.path, id), data, { merge: true }); }
        else { await addDoc(this.collections.templatesCol, data); }
      }
      async deleteTemplate(id) { await deleteDoc(doc(this.db, this.collections.templatesCol.path, id)); }

      // 5. 후속 템플릿 (단일) CRUD
      async saveSingleFollowUpTemplate(name, content, existingTemplate) {
        if (!name || !content) {
          if (existingTemplate) {
            await deleteDoc(doc(this.db, this.collections.followUpTemplatesCol.path, existingTemplate.id));
            return 'deleted';
          }
          throw new Error("이름과 내용을 모두 입력하세요.");
        }
        if (!content.includes('{글}')) throw new Error("템플릿에 {글} 변수가 포함되어야 합니다.");
        
        const data = { name, content };
        if (existingTemplate) {
          await setDoc(doc(this.db, this.collections.followUpTemplatesCol.path, existingTemplate.id), data, { merge: true });
          return 'updated';
        } else {
          await addDoc(this.collections.followUpTemplatesCol, data);
          return 'created';
        }
      }
      
      // 6. 결과물 CRUD
      async saveGeneratedPost(job, content, error = false) {
        await addDoc(this.collections.postsCol, { 
          topic: job.topic, content, error, createdAt: serverTimestamp(), 
          isFollowUpComplete: false, followUpResult: null, followUpError: false,
          hasCoverImage: false, // <-- 신규
          originalJob: { type: job.type, prompt: job.prompt }
        });
      }
      async updatePostWithFollowUp(job, resultText, isError = false) {
        const postDoc = doc(this.db, this.collections.postsCol.path, job.originalPostId);
        await updateDoc(postDoc, { 
          followUpResult: resultText, isFollowUpComplete: true, followUpError: isError,
          originalFollowUpJob: { type: job.type, prompt: job.prompt }
        });
      }
      async updatePostAfterRetry(postId) {
        const postDoc = doc(this.db, this.collections.postsCol.path, postId);
        await updateDoc(postDoc, { 
          isFollowUpComplete: false, followUpError: false, followUpResult: null 
        });
      }
      async deleteGeneratedPost(id) { await deleteDoc(doc(this.db, this.collections.postsCol.path, id)); }
    }

    /**
     * ================================================================
     * 클래스 3: JobManager - 작업 큐, API 키 상태, API 호출 전담
     * (Axiom: Algorithmic Efficiency, SOLID Architecture)
     * ================================================================
     */
    class JobManager {
      constructor(app) {
        this.app = app;
        this.jobQueue = [];
        this.apiKeys = []; // Firebase로부터 실시간 동기화됨
        this.activelyProcessingJobs = new Map();
        
        this.jobDispatcherInterval = null;
        this.totalJobsAtStart = 0;
        this.jobIdCounter = 0;
        
        this.KEY_FAILURE_COOLDOWN_MS = 60000; // 1분 (실패 시 휴식 시간)
        this.MAX_FAILURE_COUNT = 5; // 최대 연속 실패 허용 횟수
      }
      
      // 1. 작업 큐 관리
      addJobs(jobs) {
        this.jobQueue.push(...jobs);
        this.totalJobsAtStart += jobs.length;
        this.updateUIStatus();
      }
      
      addRetryJob(job, isFollowUp = false) {
        this.jobQueue.push(job); // 실패한 작업은 우선순위가 낮게 뒤로 감
        this.totalJobsAtStart++;
        this.updateUIStatus();
      }
      
      getNextJob() {
        return this.jobQueue.shift();
      }
      
      // 2. API 키 상태 관리
      updateApiKeys(keys) {
        this.apiKeys = keys;
      }
      
      getAvailableKeys() {
        // 여러 키가 준비/쿨다운 상태일 수 있으므로, 사용 가능한 모든 키를 반환
        return this.apiKeys.filter(k => k.status === 'ready');
      }

      // 3. 디스패처 (메인 루프)
      start() {
        if (this.jobDispatcherInterval) return;
        console.log("JobManager 시작됨.");
        this.jobDispatcherInterval = setInterval(() => this.dispatchJobs(), 1000);
      }
      
      stop() {
        clearInterval(this.jobDispatcherInterval);
        this.jobDispatcherInterval = null;
        console.log("JobManager 중지됨.");
      }
      
      async dispatchJobs() {
        this.updateUIStatus();
        
        if (this.jobQueue.length === 0) {
          if (this.totalJobsAtStart > 0 && this.activelyProcessingJobs.size === 0) {
            this.app.ui.updateStatusMessage("모든 작업 완료!");
            this.totalJobsAtStart = 0;
          }
          return;
        }

        const availableKeys = this.getAvailableKeys();
        if (availableKeys.length === 0) {
          return; // 사용 가능한 키 없음
        }

        // 사용 가능한 키 만큼 동시에 작업 처리
        const jobsToDispatch = Math.min(this.jobQueue.length, availableKeys.length);
        
        for (let i = 0; i < jobsToDispatch; i++) {
          const key = availableKeys[i];
          const job = this.getNextJob(); 

          // 상태 즉시 변경 (중복 할당 방지)
          key.status = 'busy'; // 로컬 상태 즉시 변경
          this.activelyProcessingJobs.set(job.jobId, job);
          this.updateUIStatus();

          this.app.ui.updateStatusMessage(`'${job.topic}' 작업 시작 (Key: ...${key.key.slice(-4)})...`);

          // executeJob은 비동기지만 await하지 않음 (병렬 실행)
          this.executeJob(job, key); 
        }
      }

      // 4. 개별 작업 실행기 (Worker)
      async executeJob(job, key) {
        let apiResponse = null;
        try {
          await this.app.firebase.updateApiKeyStatus(key.id, 'busy');
          apiResponse = await this.callGeminiAPI(job.prompt, key.key);

          if (apiResponse.success) {
            this.app.ui.showToast(`'${job.topic}' 완료 (Key: ...${key.key.slice(-4)})`, "success");
            
            if (job.type === 'initial') {
              await this.app.firebase.saveGeneratedPost(job, apiResponse.text, false);
            } else if (job.type === 'follow-up') {
              await this.app.firebase.updatePostWithFollowUp(job, apiResponse.text, false);
            }
            
            // 성공: 30초 쿨다운 제거. 즉시 '준비' 상태로 변경.
            // 'ready'로 변경 시 failureCount 등은 updateApiKeyStatus가 자동으로 리셋함.
            await this.app.firebase.updateApiKeyStatus(key.id, 'ready');

          } else {
            // 429, 4xx, 5xx 등 모든 API 오류를 handleJobFailure로 통합 처리
            await this.handleJobFailure(job, key, apiResponse.error);
          }
        } catch (error) {
          // 네트워크 오류 등 예외 처리
          console.error("큐 처리 중 예외 발생:", error);
          await this.handleJobFailure(job, key, `네트워크 오류: ${error.message}`);
          
        } finally {
          this.activelyProcessingJobs.delete(job.jobId);
          this.updateUIStatus();
        }
      }
      
      // 5. API 호출 (Fetch)
      async callGeminiAPI(prompt, apiKey) {
        //const MODEL_ID = "gemini-2.5-flash-preview-09-2025";
        const MODEL_ID = "gemini-2.5-pro";
        const API_ENDPOINT = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_ID}:generateContent?key=${apiKey}`; 
        
        const payload = {
          contents: [{ role: "user", parts: [{ "text": prompt }] }],
          // 요구사항 3: 빠른 응답을 위해 Google Search Tool 사용
          tools: [] 
        };
        
        try {
          const response = await this.fetchWithBackoff(API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (response.status === 429) {
            return { success: false, error: 'API 속도 제한 (429)', isRateLimit: true };
          }
          if (!response.ok) {
            const errBody = await response.text();
            let errMessage = `API 오류 (${response.status})`;
            try { errMessage = JSON.parse(errBody).error?.message || errBody; } 
            catch (e) { errMessage = errBody.substring(0, 100) || 'Unknown API Error'; }
            return { success: false, error: errMessage, isRateLimit: false };
          }

          const result = await response.json();
          // console.log("--- Gemini API Raw Response ---", result);
          
          if (!result.candidates || result.candidates.length === 0) {
            const blockReason = result.promptFeedback?.blockReason;
            const finishReason = result.candidates?.[0]?.finishReason;
            let error = 'API 응답에 후보 없음';
            if (blockReason) { error = `콘텐츠 생성 차단 (${blockReason})`; }
            else if (finishReason && finishReason !== 'STOP') { error = `생성 중단 (${finishReason})`; }
            return { success: false, error: error, isRateLimit: false };
          }

          const text = result.candidates[0].content?.parts?.[0]?.text;
          if (typeof text !== 'string') {
             const finishReason = result.candidates[0].finishReason;
             return { success: false, error: `API가 텍스트를 반환하지 않음 (이유: ${finishReason})`, isRateLimit: false };
          }
          
          return { success: true, text: text };
        } catch (error) { 
          return { success: false, error: `네트워크 또는 Fetch 오류: ${error.message}`, isRateLimit: false }; 
        }
      }
      
      // 6. 5xx 서버 오류 재시도
      async fetchWithBackoff(url, options, retries = 3, delay = 1000) {
        try {
          const response = await fetch(url, options);
          if (response.status === 429) { return response; }
          if (response.status >= 500 && retries > 0) {
            throw new Error(`Server error ${response.status}`);
          }
          return response;
        } catch (error) {
          if (retries > 0 && error.message.includes('Server error')) {
            this.app.ui.updateStatusMessage(`서버 오류(${error.message.split(' ')[2] || ''}), ${delay / 1000}초 후 재시도...`);
            await new Promise(resolve => setTimeout(resolve, delay));
            return this.fetchWithBackoff(url, options, retries - 1, delay * 2);
          }
          throw error;
        }
      }
      
    async handleJobFailure(job, key, errorMessage) {
        this.app.ui.showToast(`'${job.topic}' 작업 실패: ${errorMessage}`, "error");
        
        // 1. Firestore에 작업 실패 결과 저장
        try {
          if (job.type === 'initial') {
            await this.app.firebase.saveGeneratedPost(job, `작업 실패: ${errorMessage}`, true);
          } else if (job.type === 'follow-up') {
            await this.app.firebase.updatePostWithFollowUp(job, `작업 실패: ${errorMessage}`, true);
          }
        } catch (saveError) { console.error("실패 상태 저장 중 오류:", saveError); }

        // 2. 키 상태를 실패 횟수에 따라 업데이트
        const newFailureCount = (key.failureCount || 0) + 1;
        
        if (newFailureCount >= this.MAX_FAILURE_COUNT) {
          // 최대 실패 횟수 도달: 키를 'dead' 상태로 변경
          await this.app.firebase.updateApiKeyStatus(key.id, 'dead', { failureCount: newFailureCount });
          this.app.ui.showToast(`API 키 ...${key.key.slice(-4)}가 ${this.MAX_FAILURE_COUNT}회 연속 실패하여 비활성화됩니다. '설정'에서 확인하세요.`, "error");
        } else {
          // 1분 휴식
          await this.app.firebase.updateApiKeyStatus(key.id, 'cooldown', { failureCount: newFailureCount });
          setTimeout(() => this.app.firebase.updateApiKeyStatus(key.id, 'ready'), this.KEY_FAILURE_COOLDOWN_MS);
        }
      }

      // 7. UI 상태 업데이트
      updateUIStatus() {
        this.app.ui.updateJobFooter(this.activelyProcessingJobs, this.jobQueue.length);

        if (this.app.ui.elements.statusMessage) {
          const done = this.totalJobsAtStart - this.jobQueue.length - this.activelyProcessingJobs.size;
          if (this.totalJobsAtStart > 0) {
              this.app.ui.updateStatusMessage(`총 ${this.totalJobsAtStart}개 중 ${done}개 완료 (처리중: ${this.activelyProcessingJobs.size}, 대기: ${this.jobQueue.length})`);
          } else {
              this.app.ui.updateStatusMessage('');
          }
        }
      }
      
      // 8. Job ID 생성
      getNextJobId() {
        this.jobIdCounter++;
        return `job-${Date.now()}-${this.jobIdCounter}`;
      }
    }



    /**
     * ================================================================
     * 클래스 4: ImageDB - IndexedDB 이미지 스토리지
     * (Axiom: Separation of Concerns)
     * ================================================================
     */
    class ImageDB {
      constructor() {
        this.db = null;
        this.dbName = 'BlogImageStore';
        this.storeName = 'images';
      }

      async init() {
        return new Promise((resolve, reject) => {
          if (this.db) return resolve(this.db);
          
          const request = indexedDB.open(this.dbName, 1);
          
          request.onerror = (e) => reject(`IndexedDB 오류: ${e.target.errorCode}`);
          request.onsuccess = (e) => {
            this.db = e.target.result;
            resolve(this.db);
          };
          request.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains(this.storeName)) {
              const store = db.createObjectStore(this.storeName, { autoIncrement: true });
              store.createIndex('postId', 'postId', { unique: false });
            }
          };
        });
      }

      async addImage(postId, type, blob) {
        if (!this.db) await this.init();
        return new Promise((resolve, reject) => {
          const tx = this.db.transaction(this.storeName, 'readwrite');
          const store = tx.objectStore(this.storeName);
          store.add({ postId, type, blob, createdAt: new Date() });
          tx.oncomplete = () => resolve();
          tx.onerror = (e) => reject(`이미지 저장 실패: ${e.target.error}`);
        });
      }

      async getImagesForPost(postId) {
        if (!this.db) await this.init();
        return new Promise((resolve, reject) => {
          const images = [];
          const tx = this.db.transaction(this.storeName, 'readonly');
          const store = tx.objectStore(this.storeName);
          const index = store.index('postId');
          const request = index.openCursor(IDBKeyRange.only(postId)); // getAll 대신 커서 사용
          
          request.onsuccess = (e) => {
            const cursor = e.target.result;
            if (cursor) {
              // 값과 함께 기본 키(id)도 반환
              images.push({ id: cursor.primaryKey, ...cursor.value });
              cursor.continue();
            } else {
              resolve(images); // 커서 종료 시 배열 반환
            }
          };
          request.onerror = (e) => reject(`이미지 조회 실패: ${e.target.error}`);
        });
      }

      async deleteImage(imageId) { // <-- 신규 메서드
        if (!this.db) await this.init();
        return new Promise((resolve, reject) => {
          const tx = this.db.transaction(this.storeName, 'readwrite');
          const store = tx.objectStore(this.storeName);
          const request = store.delete(imageId); // 기본 키로 삭제
          
          tx.oncomplete = () => resolve();
          tx.onerror = (e) => reject(`이미지 삭제 실패: ${e.target.error}`);
        });
      }
      
      async deleteImagesForPost(postId) {
        if (!this.db) await this.init();
        return new Promise((resolve, reject) => {
          const tx = this.db.transaction(this.storeName, 'readwrite');
          const store = tx.objectStore(this.storeName);
          const index = store.index('postId');
          const request = index.openKeyCursor(postId); // 키 커서 사용
          
          request.onsuccess = (e) => {
            const cursor = e.target.result;
            if (cursor) {
              store.delete(cursor.primaryKey); // 해당 키의 레코드 삭제
              cursor.continue();
            }
          };
          
          tx.oncomplete = () => resolve();
          tx.onerror = (e) => reject(`이미지 삭제 실패: ${e.target.error}`);
        });
      }
      
      async copyImageToClipboard(blob) {
        try {
          if (!navigator.clipboard || !window.ClipboardItem) {
            throw new Error("브라우저가 클립보드 복사를 지원하지 않습니다.");
          }
          const item = new ClipboardItem({ [blob.type]: blob });
          await navigator.clipboard.write([item]);
        } catch (e) {
          console.error("클립보드 복사 실패:", e);
          throw new Error("클립보드 복사 실패. (HTTP 환경에서는 작동하지 않을 수 있습니다)");
        }
      }
    }
    
    /**
     * ================================================================
     * 클래스 5: ImageProcessor - Canvas 기반 이미지 처리
     * (Axiom: Pragmatic Implementation)
     * ================================================================
     */
    class ImageProcessor {
      async processImage(file) {
        // OffscreenCanvas가 지원되지 않는 경우를 대비해 일반 Canvas 사용
        const bmp = await createImageBitmap(file);
        const canvas = document.createElement('canvas');
        canvas.width = bmp.width;
        canvas.height = bmp.height;
        const ctx = canvas.getContext('2d');
        
        ctx.drawImage(bmp, 0, 0);
        bmp.close();
        
        // 1. 노이즈 추가 (요구사항 3)
        this.applyNoise(ctx, canvas.width, canvas.height);
        
        // 2. 1px 랜덤 노이즈 테두리 (요구사항 3)
        this.applyNoiseBorder(ctx, canvas.width, canvas.height);
        
        return new Promise(resolve => {
            canvas.toBlob(resolve, 'image/webp', 0.9);
        });
      }
      
      applyNoise(ctx, width, height, intensity = 3) {
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const noise = (Math.random() - 0.5) * intensity;
          data[i]   += noise; // R
          data[i+1] += noise; // G
          data[i+2] += noise; // B
        }
        ctx.putImageData(imageData, 0, 0);
      }
      
      applyNoiseBorder(ctx, width, height) {
        ctx.fillStyle = '#f9f9f9'; // 검은색
        
        // Top, Bottom
        for (let x = 0; x < width; x++) {
          if (Math.random() > 0.5) ctx.fillRect(x, 0, 1, 1); // Top
          if (Math.random() > 0.5) ctx.fillRect(x, height - 1, 1, 1); // Bottom
        }
        // Left, Right
        for (let y = 0; y < height; y++) {
          if (Math.random() > 0.5) ctx.fillRect(0, y, 1, 1); // Left
          if (Math.random() > 0.5) ctx.fillRect(width - 1, y, 1, 1); // Right
        }
      }
    }


    /**
     * ================================================================
     * 클래스 6: App - 메인 컨트롤러 (모든 클래스 연결) (기존 클래스 4)
     * ================================================================
     */
    class App {
      constructor() {
        this.ui = new UIManager();
        this.firebase = null; // Firebase는 설정 로드 후 초기화
        this.jobManager = new JobManager(this);
        this.imageDB = new ImageDB(); // <-- 신규
        this.imageProcessor = new ImageProcessor(); // <-- 신규
        
        // 로컬 상태 (UI 렌더링용)
        this.localState = {
          apiKeys: [],
          templates: [],
          followUpTemplates: [],
          generatedPosts: []
        };
        
        this.referenceFileContent = "";
      }
      
      // 1. 앱 초기화 (설정 로드 후)
      init(config) {
        try {
          this.firebase = new FirebaseService(config, (user) => this.onAuthStateChange(user));
          this.ui.bindEvents(this);
          this.imageDB.init().catch(e => { // <-- 신규
            console.error("ImageDB 초기화 실패", e);
            this.ui.showToast("이미지 저장소(IndexedDB) 초기화에 실패했습니다.", "error");
          });
        } catch (e) {
          console.error("Firebase 초기화 오류:", e.message);
          this.ui.showToast(`Firebase 초기화 오류: ${e.message}`, "error");
          this.ui.showView('settings');
        }
      }
      
      // 2. 인증 상태 변경 콜백
      onAuthStateChange(user) {
        this.ui.updateLoginStatus(user);
        if (user) {
          this.jobManager.start();
          this.setupDataListeners();
        } else {
          this.jobManager.stop();
          if (this.firebase) this.firebase.stopAllListeners();
        }
      }

      // 3. 데이터 리스너 설정
      setupDataListeners() {
        this.firebase.listenToData('keysCol', (data) => {
          this.localState.apiKeys = data;
          this.jobManager.updateApiKeys(data); // JobManager에 키 상태 실시간 동기화
          this.ui.renderApiKeys(data);
        });
        this.firebase.listenToData('templatesCol', (data) => {
          this.localState.templates = data;
          this.ui.renderTemplates(data);
        });
        this.firebase.listenToData('followUpTemplatesCol', (data) => {
          this.localState.followUpTemplates = data;
          this.ui.renderFollowUpTemplate(data.length > 0 ? data[0] : null);
          this.renderLocalData(); // 후속 템플릿 유무에 따라 결과창 버튼이 달라지므로
        });
        this.firebase.listenToData('postsCol', (data) => {
          this.localState.generatedPosts = data;
          this.renderLocalData();
        });
      }
      
      // 4. UI 렌더링 트리거
      renderLocalData() {
        this.ui.renderResults(this.localState.generatedPosts, this.localState.followUpTemplates.length > 0);
      }
      
      // 5. 이벤트 핸들러 (UI -> 로직)
      handleSaveConfig(configText) {
        if (!configText) {
          this.ui.showToast("설정(JSON)을 입력하세요.", "error");
          return;
        }
        try {
          let processedConfigText = configText.replace(/([\{,]\s*)(\w+)(\s*:)/g, '$1"$2"$3');
          const config = JSON.parse(processedConfigText);
          if (!config.apiKey || !config.projectId || !config.authDomain) {
            throw new Error("apiKey, projectId, authDomain은 필수입니다.");
          }
          localStorage.setItem('firebaseConfig', processedConfigText);
          this.ui.showToast("Firebase 설정이 저장되었습니다. 페이지를 새로고침합니다.", "success");
          setTimeout(() => location.reload(), 1000);
        } catch (e) {
          console.error("Firebase 설정 저장 실패:", e);
          this.ui.showToast(`잘못된 JSON 형식입니다: ${e.message}`, "error");
        }
      }
      
      handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => { 
            this.referenceFileContent = e.target.result; 
            this.ui.showToast(`파일 '${file.name}' 로드 완료.`, "success"); 
          };
          reader.readAsText(file);
        }
      }

      handleGenerateClick(templateId, topicsText) {
        const template = this.localState.templates.find(t => t.id === templateId);
        if (!template) { this.ui.showToast("유효한 기본 템플릿을 선택하세요.", "error"); return; }
        
        const topics = topicsText.split('\n').map(t => t.trim()).filter(t => t.length > 0);
        if (topics.length === 0) { this.ui.showToast("하나 이상의 주제를 입력하세요.", "error"); return; }
        if (this.localState.apiKeys.length === 0) { this.ui.showToast("설정에서 API 키를 먼저 추가하세요.", "error"); return; }

        const newJobs = topics.map(topic => ({
          jobId: this.jobManager.getNextJobId(),
          type: 'initial',
          topic: topic,
          prompt: template.content.replace('{주제}', topic).replace('{자료}', this.referenceFileContent || "참고 자료 없음")
        }));
        
        this.jobManager.addJobs(newJobs);
        this.ui.showToast(`${newJobs.length}개의 작업을 큐에 추가합니다.`, "info");
        this.ui.showWorkspaceView('results');
        this.ui.setButtonLoading(true, `(${this.jobManager.jobQueue.length}개 작업 대기 중)`);
        setTimeout(() => this.ui.setButtonLoading(false), 2000);
        this.ui.clearTopicsInput();
      }

      handleFollowUpClick(postId) {
        const post = this.localState.generatedPosts.find(p => p.id === postId);
        if (!post) return;
        
        if (this.localState.followUpTemplates.length === 0) {
          this.ui.showToast("후속 작업 템플릿이 없습니다. 설정 탭에서 템플릿을 저장하세요.", "error");
          return;
        }
        const template = this.localState.followUpTemplates[0];
        const newJob = { 
          jobId: this.jobManager.getNextJobId(),
          type: 'follow-up', 
          originalPostId: postId, 
          prompt: template.content.replace('{글}', post.content), 
          topic: `[${template.name}] ${post.topic.replace(/\[.*?\] /g, '')}` 
        };
        
        this.jobManager.addJobs([newJob]); // addJobs는 배열을 받음
        this.ui.showToast(`'${template.name}' 작업을 큐에 추가했습니다.`, "info");
      }
      
      async retryJob(postId) {
        const post = this.localState.generatedPosts.find(p => p.id === postId);
        if (!post) { this.ui.showToast("실패한 작업을 찾을 수 없습니다.", "error"); return; }
        
        const templateId = this.ui.elements.templateSelect.value;
        const template = this.localState.templates.find(t => t.id === templateId);
        if (!template) { this.ui.showToast("재시도를 위해 유효한 기본 템플릿을 선택하세요.", "error"); return; }

        const newJob = { 
          jobId: this.jobManager.getNextJobId(),
          type: 'initial', 
          topic: post.topic, 
          prompt: template.content.replace('{주제}', post.topic).replace('{자료}', this.referenceFileContent || "참고 자료 없음")
        };
        
        this.jobManager.addRetryJob(newJob);
        this.ui.showToast(`'${post.topic}' 작업을 큐에 다시 추가했습니다.`, "info");
        await this.firebase.deleteGeneratedPost(postId); // 기존 실패 내역 삭제
      }

      async retryFollowUpJob(postId) {
        const post = this.localState.generatedPosts.find(p => p.id === postId);
        if (!post || !post.content) { this.ui.showToast("원본 글을 찾을 수 없습니다.", "error"); return; }

        const template = this.localState.followUpTemplates[0];
        if (!template) { this.ui.showToast("후속 작업 템플릿이 없습니다.", "error"); return; }

        const newJob = { 
          jobId: this.jobManager.getNextJobId(),
          type: 'follow-up', 
          originalPostId: postId, 
          prompt: template.content.replace('{글}', post.content), 
          topic: `[${template.name}] ${post.topic.replace(/\[.*?\] /g, '')}` 
        };
        
        this.jobManager.addRetryJob(newJob, true);
        this.ui.showToast(`'${template.name}' 작업을 큐에 다시 추가했습니다.`, "info");
        await this.firebase.updatePostAfterRetry(postId); // 후속 작업 상태 초기화
      }

      // --- 신규 이미지 핸들러 ---
      
      async handleImageUpload(postId, file) {
        console.log(`[DEBUG] handleImageUpload A - PostID: ${postId}, 파일 수신:`, file); // <-- 디버깅 코드
        
        if (!file) return;
        this.ui.showToast("이미지 처리 중...", "info");
        try {
          const processedBlob = await this.imageProcessor.processImage(file);
          await this.imageDB.addImage(postId, 'image', processedBlob); // 'cover' -> 'image'
          
          // Firestore updateDoc 로직 제거 (요구사항 반영)
          
          this.ui.showToast("이미지가 저장되었습니다.", "success");
        } catch (e) {
          console.error("이미지 처리 실패:", e);
          this.ui.showToast(`이미지 오류: ${e.message}`, "error");
        }
      }
      
      async handleZipImageUpload(postId, file) {
        console.log(`[DEBUG] handleZipImageUpload A - PostID: ${postId}, 파일 수신:`, file); // <-- 디버깅 코드
        if (!file) return;
        if (typeof JSZip === 'undefined') {
            this.ui.showToast("JSZip 라이브러리가 로드되지 않았습니다.", "error");
            return;
        }
        this.ui.showToast(`'${file.name}' ZIP 파일 처리 중...`, "info");
        
        try {
          const jszip = new JSZip();
          const zip = await jszip.loadAsync(file);
          
          const imageFiles = [];
          zip.forEach((relativePath, zipEntry) => {
            // 이미지 파일만 필터링 (확장자 기준, 폴더 제외)
            if (!zipEntry.dir && /\.(jpe?g|png|gif|webp)$/i.test(zipEntry.name)) {
              imageFiles.push(zipEntry.async('blob'));
            }
          });
          
          if (imageFiles.length === 0) {
            this.ui.showToast("ZIP 파일에 유효한 이미지가 없습니다.", "error");
            return;
          }
          
          this.ui.showToast(`${imageFiles.length}개의 이미지 처리 시작...`, "info");

          let successCount = 0;
          await Promise.all(imageFiles.map(async (blobPromise) => {
            const blob = await blobPromise;
            const processedBlob = await this.imageProcessor.processImage(blob);
            await this.imageDB.addImage(postId, 'zip', processedBlob);
            successCount++;
          }));
          
          this.ui.showToast(`${successCount}개의 이미지가 저장되었습니다.`, "success");

        } catch (e) {
          console.error("ZIP 파일 처리 실패:", e);
          this.ui.showToast(`ZIP 파일 오류: ${e.message}`, "error");
        }
      }
      
      async handleDeleteImage(imageId, postId) { // <-- 신규 메서드
        if (!confirm("이 이미지를 영구히 삭제하시겠습니까?")) return;
        try {
          await this.imageDB.deleteImage(imageId);
          this.ui.showToast("이미지가 삭제되었습니다.", "success");
          // 모달 갤러리 즉시 새로고침
          await this.ui.renderModalGallery(postId); 
        } catch (e) {
          console.error("이미지 삭제 실패:", e);
          this.ui.showToast(`이미지 삭제 실패: ${e.message}`, "error");
        }
      }
      
      async deletePost(postId) {
        if (!confirm("이 항목을 삭제하시겠습니까? 저장된 이미지도 함께 삭제됩니다.")) {
          return;
        }
        try {
          // 1. Firestore에서 삭제
          await this.firebase.deleteGeneratedPost(postId);
          
          // 2. IndexedDB에서 관련 이미지 삭제
          await this.imageDB.deleteImagesForPost(postId);
          
          this.ui.showToast("항목이 삭제되었습니다.", "success");
        } catch (e) {
          console.error("삭제 실패:", e);
          this.ui.showToast(`삭제 실패: ${e.message}`, "error");
        }
      }
      
      copyToClipboard(postId, type) {
        const post = this.localState.generatedPosts.find(p => p.id === postId);
        if (!post) return;
        
        let textToCopy = '', toastMessage = '';
        if (type === 'content') { 
          textToCopy = post.content; toastMessage = "원본 글이 복사되었습니다."; 
        }
        else if (type === 'followUp' && post.isFollowUpComplete && !post.followUpError) { 
          textToCopy = post.followUpResult; toastMessage = "후속 작업 결과가 복사되었습니다."; 
        }
        else { this.ui.showToast("복사할 내용이 없습니다.", "error"); return; }
        
        if (navigator.clipboard && window.isSecureContext) {
          navigator.clipboard.writeText(textToCopy)
            .then(() => this.ui.showToast(toastMessage, "success"))
            .catch(err => this.ui.showToast("클립보드 복사 실패.", "error"));
        } else {
          const ta = document.createElement('textarea');
          ta.value = textToCopy; ta.style.position = 'absolute'; ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.select();
          try { document.execCommand('copy'); this.ui.showToast(toastMessage, "success"); } 
          catch (err) { this.ui.showToast("복사에 실패했습니다.", "error"); }
          document.body.removeChild(ta);
        }
      }
    }



    /**
     * ================================================================
     * === 애플리케이션 시작점 ===
     * ================================================================
     */
    
    document.addEventListener('DOMContentLoaded', () => {
      const app = new App();

      window.app = app; // 전역 스코프에 할당
      
      const configString = localStorage.getItem('firebaseConfig');
      
      if (!configString) {
        const errorMsg = "Firebase 설정이 없습니다. '설정' 탭에서 입력해주세요.";
        console.warn(errorMsg);
        app.ui.showToast(errorMsg, "info"); 
        app.ui.showView('settings'); 
        app.ui.elements.navWorkspace.disabled = true;
        app.ui.elements.navWorkspace.classList.add('opacity-50', 'cursor-not-allowed');
      } else {
        try {
          const firebaseConfig = JSON.parse(configString);
          app.ui.setFirebaseConfigInput(configString);
          app.init(firebaseConfig); // App 초기화
        } catch (e) {
          console.error("Firebase 설정 파싱 오류:", e.message);
          app.ui.showToast("저장된 Firebase 설정이 잘못되었습니다. 다시 입력해주세요.", "error");
          localStorage.removeItem('firebaseConfig');
          app.ui.showView('settings'); 
          app.ui.elements.navWorkspace.disabled = true;
          app.ui.elements.navWorkspace.classList.add('opacity-50', 'cursor-not-allowed');
        }
      }
    });

  </script>
</body>
</html>
