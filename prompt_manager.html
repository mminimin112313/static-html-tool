<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>프롬프트 관리자 프로 (최종)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" xintegrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>

    <script type="module">
        // Firebase SDK 모듈 임포트
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
        import {
            getAuth,
            GoogleAuthProvider,
            onAuthStateChanged,
            signInWithPopup,
            signOut
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
        import {
            getFirestore,
            collection,
            doc,
            getDocs, // 이 함수는 더 이상 사용되지 않음
            setDoc,
            addDoc,
            deleteDoc,
            serverTimestamp,
            getDoc,
            updateDoc,
            query,
            orderBy,
            onSnapshot // 실시간 동기화를 위해 onSnapshot을 추가로 임포트
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";

        // Firebase 프로젝트 설정
        // !!! 중요: 아래 firebaseConfig 객체에 실제 Firebase 프로젝트 설정값을 붙여넣으세요. !!!
        const firebaseConfig = {
            apiKey: "AIzaSyAzpL5nTg6v92Uj28QsBpxt1k8wYoGKXtY",
            authDomain: "prompt-76252.firebaseapp.com",
            projectId: "prompt-76252",
            storageBucket: "prompt-76252.firebasestorage.app",
            messagingSenderId: "683129810198",
            appId: "1:683129810198:web:aa39fe66cec551d41df437",
            measurementId: "G-4GCY1XH5HN"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const dbFirestore = getFirestore(app);
        let currentUser = null;
        
        // onSnapshot() 리스너를 저장할 변수
        let promptsUnsubscribe = null;
        let foldersUnsubscribe = null;
        let sequencesUnsubscribe = null;

        // =================================================================
        // IndexedDB 설정 (캐싱 및 버전 관리용)
        // =================================================================
        const INDEXEDDB_NAME = 'PromptManagerCacheDB';
        const INDEXEDDB_VERSION = 5;
        const CACHE_STORE_PROMPTS = 'cachedPrompts';
        const CACHE_STORE_FOLDERS = 'cachedFolders';
        const CACHE_STORE_VERSIONS = 'promptVersions';
        const CACHE_STORE_SEQUENCES = 'cachedSequences';
        const CACHE_STORE_USAGE_HISTORY = 'usageHistory';

        let indexedDbInstance;

        /**
         * IndexedDB 데이터베이스를 열거나 생성합니다.
         * @returns {Promise<IDBDatabase>} IndexedDB 데이터베이스 인스턴스.
         */
        function openIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(INDEXEDDB_NAME, INDEXEDDB_VERSION);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(CACHE_STORE_PROMPTS)) {
                        db.createObjectStore(CACHE_STORE_PROMPTS, { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains(CACHE_STORE_FOLDERS)) {
                        db.createObjectStore(CACHE_STORE_FOLDERS, { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains(CACHE_STORE_VERSIONS)) {
                        const versionStore = db.createObjectStore(CACHE_STORE_VERSIONS, { keyPath: 'id', autoIncrement: true });
                        versionStore.createIndex('promptId', 'promptId', { unique: false });
                        versionStore.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                    if (!db.objectStoreNames.contains(CACHE_STORE_SEQUENCES)) {
                        db.createObjectStore(CACHE_STORE_SEQUENCES, { keyPath: 'id' });
                    }
                    if (!db.objectStoreNames.contains(CACHE_STORE_USAGE_HISTORY)) {
                        const historyStore = db.createObjectStore(CACHE_STORE_USAGE_HISTORY, { keyPath: 'id', autoIncrement: true });
                        historyStore.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                };
                request.onsuccess = (event) => {
                    indexedDbInstance = event.target.result;
                    resolve(indexedDbInstance);
                };
                request.onerror = (event) => {
                    console.error("IndexedDB 열기 오류:", event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }
        /**
         * IndexedDB에서 지정된 Object Store의 모든 항목을 가져옵니다.
         * @param {string} storeName - 데이터를 가져올 Object Store의 이름.
         * @param {string} [indexName=null] - 사용할 인덱스 이름 (선택 사항).
         * @param {*} [query=null] - 인덱스 쿼리 (선택 사항).
         * @returns {Promise<Array<Object>>} 가져온 항목 배열.
         */
        async function getFromIndexedDB(storeName, indexName = null, query = null) {
            if (!indexedDbInstance) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = indexedDbInstance.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                let request;
                if (indexName && query) {
                    const index = store.index(indexName);
                    request = index.getAll(query);
                } else {
                    request = store.getAll();
                }
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }
        /**
         * IndexedDB에 항목을 추가하거나 업데이트합니다.
         * @param {string} storeName - 항목을 저장할 Object Store의 이름.
         * @param {Object} data - 저장할 데이터 객체. `keyPath`에 해당하는 속성을 포함해야 합니다.
         * @returns {Promise<any>} 추가 또는 업데이트된 항목의 키.
         */
        async function putIntoIndexedDB(storeName, data) {
            if (!indexedDbInstance) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = indexedDbInstance.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }
        /**
         * IndexedDB에서 특정 항목을 삭제합니다.
         * @param {string} storeName - 항목을 삭제할 Object Store의 이름.
         * @param {*} id - 삭제할 항목의 키.
         * @returns {Promise<void>} 삭제 완료 시 resolve.
         */
        async function deleteFromIndexedDB(storeName, id) {
            if (!indexedDbInstance) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = indexedDbInstance.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // =================================================================
        // UI 요소 참조 및 상태 관리 (UI Elements and State Management)
        // =================================================================
        const ui = {
            contentView: document.getElementById('content-view'),
            mainHeader: document.getElementById('main-header-title'),
            folderList: document.getElementById('folder-list'),
            libraryList: document.getElementById('library-list'),
            newPromptBtn: document.getElementById('new-prompt-btn'),
            newFolderBtn: document.getElementById('new-folder-btn'),
            searchInput: document.getElementById('search-input'),
            sidebarContent: document.getElementById('sidebar-content'),
            loginBtn: document.getElementById('login-btn'),
            logoutBtn: document.getElementById('logout-btn'),
            userProfile: document.getElementById('user-profile'),
            userEmail: document.getElementById('user-email'),
            userPhoto: document.getElementById('user-photo'),
            toast: document.getElementById('toast'),
            templateModal: {
                overlay: document.getElementById('template-modal-overlay'),
                title: document.getElementById('template-modal-title'),
                body: document.getElementById('template-modal-body'),
                generateBtn: document.getElementById('template-modal-generate-btn'),
                closeBtn: document.getElementById('template-modal-close-btn')
            },
            sequenceModal: {
                overlay: document.getElementById('sequence-modal-overlay'),
                title: document.getElementById('sequence-modal-title'),
                body: document.getElementById('sequence-modal-body'),
                saveBtn: document.getElementById('sequence-modal-save-btn'),
                runBtn: document.getElementById('sequence-modal-run-btn'),
                closeBtn: document.getElementById('sequence-modal-close-btn'),
                deleteBtn: document.getElementById('sequence-modal-delete-btn')
            },
            sidebar: document.getElementById('sidebar'),
            mobileMenuToggle: document.getElementById('mobile-menu-toggle'),
            sidebarCloseBtn: document.getElementById('sidebar-close-btn'),
            sequenceList: document.getElementById('sequence-list'),
            newSequenceBtn: document.getElementById('new-sequence-btn')
        };

        // 앱의 전역 상태 (현재 필터, 프롬프트/폴더 데이터)
        let state = {
            currentFilter: { type: 'all', id: null, name: '모든 항목' },
            prompts: [],
            folders: [],
            sequences: [],
            searchPending: false, // 검색 중 상태를 나타내는 플래그
            searchWorker: null, // 검색 워커 인스턴스
        };

        let fuse = null; // Fuse.js 인스턴스

        // 전역 시퀀스 실행 상태
        let activeSequencePrompts = [];
        let currentSequencePromptIndex = -1;
        let sequenceSortableInstance = null;

        // =================================================================
        // Firebase Firestore & IndexedDB 하이브리드 데이터 서비스
        // (Firebase Firestore & IndexedDB Hybrid Data Service)
        // =================================================================
        const dbService = {
            /**
             * 현재 사용자 UID 기반으로 Firestore 컬렉션 참조를 가져옵니다.
             * @param {string} collectionName - 컬렉션 이름 ('prompts', 'folders', 'sequences').
             * @returns {firebase.firestore.CollectionReference} Firestore 컬렉션 참조.
             * @throws {Error} 사용자가 로그인하지 않은 경우.
             */
            getCollectionRef: (collectionName) => {
                if (!currentUser) {
                    console.error("오류: 로그인되지 않았습니다. Firestore에 접근할 수 없습니다.");
                    throw new Error("로그인되지 않았습니다. Firestore에 접근할 수 없습니다.");
                }
                return collection(dbFirestore, 'users', currentUser.uid, collectionName);
            },
            /**
             * 현재 사용자 UID 기반으로 Firestore 문서 참조를 가져옵니다.
             * @param {string} collectionName - 컬렉션 이름.
             * @param {string} id - 문서 ID.
             * @returns {firebase.firestore.DocumentReference} Firestore 문서 참조.
             * @throws {Error} 사용자가 로그인하지 않은 경우.
             */
            getDocRef: (collectionName, id) => {
                if (!currentUser) {
                    console.error("오류: 로그인되지 않았습니다. Firestore에 접근할 수 없습니다.");
                    throw new Error("로그인되지 않았습니다. Firestore에 접근할 수 없습니다.");
                }
                return doc(dbFirestore, 'users', currentUser.uid, collectionName, id);
            },
            /**
             * onSnapshot 리스너를 설정합니다.
             * @param {string} collectionName - 컬렉션 이름 ('prompts', 'folders', 'sequences').
             * @param {function(Array<Object>)} callback - 데이터 변경 시 호출될 콜백 함수.
             * @returns {function()} 리스너를 해제하는 함수.
             */
            subscribeToCollection: (collectionName, callback) => {
                if (!currentUser) return;
                const collectionRef = dbService.getCollectionRef(collectionName);
                const q = query(collectionRef, orderBy("updatedAt", "desc"));
                
                return onSnapshot(q, async (snapshot) => {
                    const data = snapshot.docs.map(doc => {
                        const data = doc.data();
                        // Firestore Timestamp를 Date 객체로 변환하여 저장
                        if (data.createdAt && data.createdAt.toDate) data.createdAt = data.createdAt.toDate();
                        if (data.updatedAt && data.updatedAt.toDate) data.updatedAt = data.updatedAt.toDate();
                        return { id: doc.id, ...data };
                    });

                    // IndexedDB에 캐시 업데이트
                    try {
                        let cacheStoreName;
                        if (collectionName === 'prompts') cacheStoreName = CACHE_STORE_PROMPTS;
                        else if (collectionName === 'folders') cacheStoreName = CACHE_STORE_FOLDERS;
                        else if (collectionName === 'sequences') cacheStoreName = CACHE_STORE_SEQUENCES;
                        else throw new Error(`알 수 없는 컬렉션 이름: ${collectionName}`);
                        
                        const transaction = indexedDbInstance.transaction([cacheStoreName], 'readwrite');
                        const store = transaction.objectStore(cacheStoreName);
                        store.clear(); // 기존 캐시 삭제
                        for (const item of data) {
                            store.put(item); // 새 데이터 추가
                        }
                        console.log(`Firestore ${collectionName} 데이터가 실시간으로 동기화되어 IndexedDB에 캐시되었습니다.`);
                    } catch (e) {
                        console.error("IndexedDB 캐시 업데이트 오류:", e);
                    }

                    callback(data);
                }, (error) => {
                    console.error(`Firestore ${collectionName} 리스너 오류:`, error);
                    helpers.showToast(`실시간 동기화 오류: ${error.message}`);
                });
            },
            /**
             * Firestore에서 ID로 특정 문서를 가져옵니다. (주로 편집기 모드에서 사용)
             * onSnapshot 콜백에서 이미 최신 데이터가 state에 있으므로, 이 함수는 비상용으로 남겨둡니다.
             * @param {string} collectionName - 컬렉션 이름.
             * @param {string} id - 문서 ID.
             * @returns {Promise<Object|null>} 문서 객체 또는 null.
             */
            getById: async (collectionName, id) => {
                if (!currentUser) return null;
                try {
                    const docSnap = await getDoc(dbService.getDocRef(collectionName, id));
                    if (docSnap.exists()) {
                         const data = docSnap.data();
                         // Firestore Timestamp를 Date 객체로 변환
                         if (data.createdAt && data.createdAt.toDate) data.createdAt = data.createdAt.toDate();
                         if (data.updatedAt && data.updatedAt.toDate) data.updatedAt = data.updatedAt.toDate();
                         return { id: docSnap.id, ...data };
                    }
                    return null;
                } catch (error) {
                    console.error(`Firestore ${collectionName}:${id} 데이터 가져오기 오류:`, error);
                    helpers.showToast(`항목 로드 실패: ${error.message}`);
                    return null;
                }
            },
            /**
             * Firestore에 문서를 추가하거나 업데이트합니다.
             * @param {string} collectionName - 컬렉션 이름.
             * @param {Object} item - 저장할 항목 데이터. `id` 필드가 있으면 업데이트, 없으면 추가.
             * @returns {Promise<string>} 저장된 문서의 ID.
             * @throws {Error} 사용자가 로그인하지 않은 경우 또는 저장 오류 발생 시.
             */
            put: async (collectionName, item) => {
                if (!currentUser) throw new Error("로그인되지 않았습니다. 데이터를 저장할 수 없습니다.");
                const cleanItem = { ...item };
                const itemId = cleanItem.id;
                delete cleanItem.id;

                let docRef;
                try {
                    const timestampedItem = {
                        ...cleanItem,
                        updatedAt: serverTimestamp()
                    };
                    if (!itemId) {
                        timestampedItem.createdAt = serverTimestamp();
                    }

                    if (typeof itemId === 'string' && itemId.trim().length > 0 && itemId !== 'null') {
                        docRef = dbService.getDocRef(collectionName, itemId);
                        await setDoc(docRef, timestampedItem, { merge: true });
                    } else {
                        docRef = await addDoc(dbService.getCollectionRef(collectionName), timestampedItem);
                    }
                    return docRef.id;
                } catch (error) {
                    console.error(`Firestore ${collectionName} 데이터 저장 오류:`, error);
                    helpers.showToast(`데이터 저장 실패: ${error.message}`);
                    throw error;
                }
            },
            /**
             * Firestore에서 문서를 삭제합니다.
             * @param {string} collectionName - 컬렉션 이름.
             * @param {string} id - 삭제할 문서의 ID.
             * @returns {Promise<void>} 삭제 완료 시 resolve.
             * @throws {Error} 사용자가 로그인하지 않은 경우 또는 삭제 오류 발생 시.
             */
            delete: async (collectionName, id) => {
                if (!currentUser) throw new Error("로그인되지 않았습니다. 데이터를 삭제할 수 없습니다.");
                try {
                    await deleteDoc(dbService.getDocRef(collectionName, id));
                } catch (error) {
                    console.error(`Firestore ${collectionName}:${id} 데이터 삭제 오류:`, error);
                    helpers.showToast(`데이터 삭제 실패: ${error.message}`);
                    throw error;
                }
            },
            /**
             * 프롬프트 버전을 IndexedDB에만 저장합니다.
             * @param {string} promptId - 원본 프롬프트의 ID.
             * @param {string} content - 저장할 프롬프트 내용.
             * @param {string} [memo=''] - 버전 기록에 대한 메모.
             * @returns {Promise<void>} 저장 완료 시 resolve.
             */
            savePromptVersion: async (promptId, content, memo = '') => {
                if (!indexedDbInstance) await openIndexedDB();
                const versionData = {
                    promptId: promptId,
                    content: content,
                    timestamp: new Date(),
                    memo: memo
                };
                await putIntoIndexedDB(CACHE_STORE_VERSIONS, versionData);
                helpers.showToast('프롬프트 버전이 저장되었습니다.');
            },
            /**
             * 특정 프롬프트의 모든 버전 기록을 IndexedDB에서 가져옵니다.
             * @param {string} promptId - 버전 기록을 가져올 프롬프트의 ID.
             * @returns {Promise<Array<Object>>} 버전 기록 배열 (최신순).
             */
            getPromptVersions: async (promptId) => {
                if (!indexedDbInstance) await openIndexedDB();
                return new Promise((resolve, reject) => {
                    const transaction = indexedDbInstance.transaction([CACHE_STORE_VERSIONS], 'readonly');
                    const store = transaction.objectStore(CACHE_STORE_VERSIONS);
                    const index = store.index('promptId');
                    const request = index.getAll(promptId);
                    request.onsuccess = () => {
                        const sortedVersions = request.result.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
                        resolve(sortedVersions);
                    };
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            /**
             * 모든 데이터를 JSON 파일로 내보냅니다.
             */
            exportData: async () => {
                // state에 있는 최신 데이터를 사용
                const data = { prompts: state.prompts, folders: state.folders, sequences: state.sequences };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `prompt_manager_backup_${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                helpers.showToast('데이터가 내보내기되었습니다.');
            },
            /**
             * JSON 파일을 읽어 데이터를 가져옵니다.
             * @param {File} file - 가져올 JSON 파일.
             */
            importData: async (file) => {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        if (importedData.prompts && Array.isArray(importedData.prompts)) {
                            const confirmClear = await helpers.showConfirm('기존 데이터를 모두 지우고 가져오겠습니까? (취소 시 기존 데이터에 추가)');
                            if (confirmClear) {
                                for (const p of state.prompts) { await dbService.delete('prompts', p.id); }
                                for (const f of state.folders) { await dbService.delete('folders', f.id); }
                                for (const s of state.sequences) { await dbService.delete('sequences', s.id); }
                                helpers.showToast('기존 데이터가 지워졌습니다. 가져오기를 시작합니다.');
                            }

                            for (const promptData of importedData.prompts) {
                                await dbService.put('prompts', {
                                    title: promptData.title,
                                    content: promptData.content,
                                    folderId: promptData.folderId,
                                    tags: promptData.tags || [],
                                    isFavorite: promptData.isFavorite || false,
                                    isTemplate: promptData.isTemplate || false,
                                    usageCount: promptData.usageCount || 0,
                                    link: promptData.link || ''
                                });
                            }
                            if (importedData.folders && Array.isArray(importedData.folders)) {
                                for (const folderData of importedData.folders) {
                                    await dbService.put('folders', { name: folderData.name });
                                }
                            }
                            if (importedData.sequences && Array.isArray(importedData.sequences)) {
                                for (const sequenceData of importedData.sequences) {
                                    await dbService.put('sequences', {
                                        name: sequenceData.name,
                                        description: sequenceData.description || '',
                                        promptIds: sequenceData.promptIds || []
                                    });
                                }
                            }
                            helpers.showToast('데이터가 성공적으로 가져오기되었습니다!');
                        } else {
                            throw new Error("유효하지 않은 JSON 데이터 형식입니다.");
                        }
                    } catch (e) {
                        console.error("데이터 가져오기 오류:", e);
                        helpers.showToast('데이터 가져오기 실패: ' + e.message);
                    }
                };
                reader.readAsText(file);
            }
        };

        // =================================================================
        // UI 렌더링 함수들 (UI Rendering Functions)
        // =================================================================
        const render = {
            /**
             * 폴더 목록을 렌더링합니다.
             */
            folders: () => {
                ui.folderList.innerHTML = state.folders.map(f => `
                    <li class="nav-item" data-filter-type="folder" data-folder-id="${f.id}">
                        <a><i class="nav-icon fa-regular fa-folder"></i> ${f.name}</a>
                    </li>
                `).join('') + `<li class="nav-item" data-filter-type="uncategorized"><a><i class="nav-icon fa-solid fa-inbox"></i> 미분류</a></li>`;
            },
            /**
             * 시퀀스 목록을 렌더링합니다.
             */
            sequences: () => {
                ui.sequenceList.innerHTML = state.sequences
                    .map(s => `<li class="nav-item" data-filter-type="sequence" data-seq-id="${s.id}">
                                <a><i class="nav-icon fa-solid fa-layer-group"></i> ${s.name}</a>
                            </li>`).join('');
            },
            /**
             * 프롬프트 목록을 렌더링합니다. 필터링 및 검색 기능을 포함합니다.
             */
            prompts: () => {
                ui.mainHeader.textContent = state.currentFilter.name;
                
                let filtered = state.prompts;

                // 현재 필터 타입에 따른 데이터 필터링
                const { type, id } = state.currentFilter;
                if (type === 'folder') filtered = state.prompts.filter(p => p.folderId === id);
                else if (type === 'uncategorized') filtered = state.prompts.filter(p => !p.folderId);
                else if (type === 'favorites') filtered = state.prompts.filter(p => p.isFavorite);
                else if (type === 'templates') filtered = state.prompts.filter(p => p.isTemplate);
                else if (type === 'prompts') filtered = state.prompts.filter(p => !p.isTemplate);

                // 검색어 필터링 (Fuse.js 사용)
                const searchTerm = ui.searchInput.value.toLowerCase();
                if(searchTerm) {
                    if (!fuse) { // Fuse 인덱스가 없으면 빌드
                        buildSearchIndex(state.prompts);
                    }
                    if (searchTerm.startsWith('is:template')) {
                        filtered = filtered.filter(p => p.isTemplate);
                    } else if (searchTerm.startsWith('is:prompt')) {
                        filtered = filtered.filter(p => !p.isTemplate);
                    } else if (searchTerm.startsWith('#')) {
                        const tag = searchTerm.slice(1);
                        filtered = filtered.filter(p => p.tags?.some(t => t.toLowerCase().includes(tag)));
                    } else {
                        // 일반 검색어는 Fuse.js 사용
                        filtered = fuse.search(searchTerm).map(r => r.item);
                    }
                }
                
                // 필터링된 항목이 없을 경우 메시지 표시
                if (filtered.length === 0) {
                    ui.contentView.innerHTML = `<div class="content-placeholder">항목을 찾을 수 없습니다.</div>`;
                    return;
                }
                
                // 프롬프트 목록 HTML 생성 및 렌더링
                ui.contentView.innerHTML = filtered.map(p => {
                    const icon = p.isTemplate ? 'fa-puzzle-piece' : 'fa-file-lines';
                    const tagsHTML = (p.tags || []).map(tag => `<span class="prompt-tag">#${tag}</span>`).join('');
                    const date = p.updatedAt ? p.updatedAt.toLocaleString() : 'N/A';
                    
                    let buttonsHtml = '';
                    if (p.isTemplate) {
                        buttonsHtml += `<button class="use-btn"><i class="fa-solid fa-wand-magic-sparkles"></i> 사용</button>`;
                    } else if (p.link) {
                        buttonsHtml += `<a href="${p.link}" target="_blank" class="visit-link-btn" title="링크 방문"><i class="fa-solid fa-external-link-alt"></i> 방문</a>`;
                    } else {
                        buttonsHtml += `<button class="copy-btn"><i class="fa-regular fa-copy"></i> 복사</button>`;
                    }
                    if (p.isTemplate && p.link) {
                        buttonsHtml += `<a href="${p.link}" target="_blank" class="visit-link-btn" title="링크 방문" style="margin-left: 8px;"><i class="fa-solid fa-external-link-alt"></i> 방문</a>`;
                    }

                    return `
                    <div class="prompt-list-item" data-prompt-id="${p.id}">
                        <i class="prompt-list-icon fa-solid ${icon}" style="color: ${p.isTemplate ? 'var(--accent-blue)' : 'var(--text-secondary)'}"></i>
                        <i class="prompt-list-icon fa-solid fa-star fav-icon ${p.isFavorite ? 'active' : ''}" style="color: ${p.isFavorite ? 'var(--accent-yellow)' : 'var(--text-secondary)'}"></i>
                        <div style="flex-grow:1;">
                            <div class="prompt-title">${p.title}</div>
                            <div class="prompt-subtitle">업데이트: ${date}</div>
                            ${tagsHTML ? `<div class="prompt-tags">${tagsHTML}</div>` : ''}
                        </div>
                        <div class="prompt-actions">
                            ${buttonsHtml}
                            <button class="edit-btn"><i class="fa-regular fa-edit"></i> 편집</button>
                        </div>
                    </div>`;
                }).join('');
            },
            /**
             * 프롬프트 편집기 화면을 렌더링합니다.
             * @param {string|null} id - 편집할 프롬프트의 ID (새 항목인 경우 null).
             */
            promptEditor: async (id) => {
                const isNew = id === null;
                let p = { title: '', content: '', folderId: null, tags: [], isFavorite: false, isTemplate: false, usageCount: 0, link: '' };
                if (!isNew) {
                    const fetchedPrompt = state.prompts.find(prompt => prompt.id === id);
                    if (fetchedPrompt) {
                        p = fetchedPrompt;
                    } else {
                        helpers.showToast('항목을 찾을 수 없습니다!');
                        render.prompts();
                        return;
                    }
                }
                
                const folderOpts = state.folders.map(f => `<option value="${f.id}" ${f.id === p.folderId ? 'selected' : ''}>${f.name}</option>`).join('');
                
                ui.mainHeader.textContent = isNew ? '새 항목' : `편집: ${p.title}`;
                ui.contentView.innerHTML = `
                    <div class="editor-header">
                        <h2>${isNew ? '새 항목 생성' : '항목 편집'}</h2>
                        <div class="editor-actions">
                            ${!isNew ? `<button class="delete-btn" data-id="${id}"><i class="fa-regular fa-trash-can"></i> 삭제</button>` : ''}
                            <button class="save-btn" id="save-prompt-btn" ${isNew ? '' : `data-id="${id}"`}><i class="fa-regular fa-save"></i> 저장</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>제목</label>
                        <input id="title-input" value="${p.title || ''}">
                    </div>
                    <div class="form-group">
                        <label>내용 ${p.isTemplate ? '(플레이스홀더에 {{변수}} 사용)' : ''}</label>
                        <textarea id="content-input">${p.content || ''}</textarea>
                        <div class="file-upload-section">
                            <input type="file" id="large-text-file" accept=".txt,.html,.htm,.md,.json,.csv,.xml,.yaml,.yml,.js,.css,text/*" style="display:none;">
                            <button id="load-text-btn" class="button-like"><i class="fa-solid fa-file-arrow-up"></i> 파일에서 불러오기</button>
                            <span id="loaded-file-name" style="margin-left: 10px; font-size: 0.85rem; color: var(--text-secondary);"></span>
                        </div>
                        <p id="content-size-warning" style="color: var(--accent-yellow); font-size: 0.85rem; margin-top: 5px; display: none;">
                            경고: 내용이 너무 길어 저장에 실패할 수 있습니다. (Firestore 문서 제한 1MB)
                        </p>
                    </div>
                    <div class="form-group">
                        <label>링크 (URL)</label>
                        <input id="link-input" type="url" value="${p.link || ''}" placeholder="예: https://example.com">
                    </div>
                    <div style="display:flex; gap: 24px;">
                        <div class="form-group" style="flex:1;">
                            <label>폴더</label>
                            <select id="folder-select">
                                <option value="">미분류</option>${folderOpts}
                            </select>
                        </div>
                        <div class="form-group" style="flex:1;">
                            <label>태그 (쉼표로 구분)</label>
                            <input id="tags-input" value="${(p.tags || []).join(', ')}">
                        </div>
                    </div>
                    <div class="is-template-toggle">
                        <input type="checkbox" id="is-template-checkbox" ${p.isTemplate ? 'checked' : ''}>
                        <label for="is-template-checkbox">✨ 재사용 가능한 템플릿으로 만들기</label>
                    </div>
                    ${!isNew ? `
                    <button id="view-versions-btn" class="button-like" style="margin-top: 20px;"><i class="fa-solid fa-history"></i> 버전 기록 보기</button>
                    <div id="versions-history" style="margin-top: 20px; border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; display:none;">
                        <h3>버전 기록</h3>
                        <ul id="versions-list" style="list-style: none; padding: 0;"></ul>
                    </div>
                    ` : ''}
                `;
                if (p.folderId) document.getElementById('folder-select').value = p.folderId;
                if (isNew) {
                    const saveBtnElement = document.getElementById('save-prompt-btn');
                    if (saveBtnElement) {
                        saveBtnElement.removeAttribute('data-id');
                    }
                }
                const largeTextFile = document.getElementById('large-text-file');
                const loadTextBtn = document.getElementById('load-text-btn');
                const loadedFileNameSpan = document.getElementById('loaded-file-name');
                const contentInput = document.getElementById('content-input');
                const contentSizeWarning = document.getElementById('content-size-warning');
                loadTextBtn.onclick = () => {
                    largeTextFile.click();
                };
                const handleFileLoad = async (file, targetTextarea, fileNameSpan = null) => {
                    if (!file) {
                        if (fileNameSpan) fileNameSpan.textContent = '';
                        return;
                    }
                    const MAX_FILE_SIZE_MB = 5;
                    if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                        helpers.showToast(`파일 용량이 너무 큽니다. (${MAX_FILE_SIZE_MB}MB 이하로 업로드해주세요.)`);
                        if (fileNameSpan) fileNameSpan.textContent = '';
                        return false;
                    }
                    if (fileNameSpan) fileNameSpan.textContent = file.name;
                    try {
                        let raw = await file.text();
                        let processedText = raw;
                        if (file.name.match(/\.(html?|htm)$/i)) {
                            processedText = raw.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                            helpers.showToast('HTML 파일이 이스케이프되어 불러와졌습니다.');
                        } else if (file.name.match(/\.(json|yaml|yml)$/i)) {
                            helpers.showToast('파일 내용이 불러와졌습니다.');
                        } else {
                            helpers.showToast('파일 내용이 불러와졌습니다.');
                        }
                        targetTextarea.value = processedText;
                        if (targetTextarea.id === 'content-input') {
                            checkContentSizeWarning();
                        }
                        return true;
                    } catch (error) {
                        console.error("파일 읽기 오류:", error);
                        helpers.showToast('파일을 읽는 중 오류가 발생했습니다.');
                        return false;
                    }
                };
                largeTextFile.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        await handleFileLoad(file, contentInput, loadedFileNameSpan);
                    }
                    e.target.value = '';
                };
                contentInput.addEventListener('dragover', e => {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                });
                contentInput.addEventListener('drop', async e => {
                    e.preventDefault();
                    const file = e.dataTransfer.files[0];
                    if (file) {
                        await handleFileLoad(file, contentInput, loadedFileNameSpan);
                    }
                });
                const checkContentSizeWarning = () => {
                    const contentByteLength = new TextEncoder().encode(contentInput.value).length;
                    const FIREBASE_DOC_LIMIT_BYTES = 1000 * 1024;
                    const WARNING_THRESHOLD_BYTES = 900 * 1024;
                    if (contentByteLength > WARNING_THRESHOLD_BYTES) {
                        contentSizeWarning.style.display = 'block';
                    } else {
                        contentSizeWarning.style.display = 'none';
                    }
                };
                contentInput.addEventListener('input', checkContentSizeWarning);
                checkContentSizeWarning();
                const viewVersionsBtn = document.getElementById('view-versions-btn');
                const versionsHistoryDiv = document.getElementById('versions-history');
                const versionsList = document.getElementById('versions-list');
                if (viewVersionsBtn) {
                    viewVersionsBtn.addEventListener('click', async () => {
                        if (versionsHistoryDiv.style.display === 'none') {
                            versionsHistoryDiv.style.display = 'block';
                            const versions = await dbService.getPromptVersions(id);
                            if (versions.length === 0) {
                                versionsList.innerHTML = '<li>저장된 버전이 없습니다.</li>';
                            } else {
                                versionsList.innerHTML = versions.map(v => `
                                    <li style="padding: 8px 0; border-bottom: 1px dashed var(--border-color);">
                                        <strong>${v.timestamp.toLocaleString()}</strong>: ${v.memo || '메모 없음'}
                                        <button data-version-id="${v.id}" class="restore-version-btn button-like" style="margin-left: 10px;">복원</button>
                                        <button data-version-id="${v.id}" class="delete-version-btn button-like" style="margin-left: 5px; color: var(--accent-pink); border-color: var(--accent-pink);">삭제</button>
                                    </li>
                                `).join('');
                            }
                        } else {
                            versionsHistoryDiv.style.display = 'none';
                        }
                    });
                    versionsList.addEventListener('click', async (e) => {
                        const versionId = parseInt(e.target.dataset.versionId, 10);
                        if (e.target.classList.contains('restore-version-btn')) {
                            const confirmed = await helpers.showConfirm('이 버전으로 프롬프트를 복원하시겠습니까? 현재 내용은 덮어씌워집니다.');
                            if (confirmed) {
                                const versions = await dbService.getPromptVersions(id);
                                const versionToRestore = versions.find(v => v.id === versionId);
                                if (versionToRestore) {
                                    document.getElementById('content-input').value = versionToRestore.content;
                                    helpers.showToast('버전이 복원되었습니다. 저장을 눌러 적용하세요.');
                                    checkContentSizeWarning();
                                }
                            }
                        } else if (e.target.classList.contains('delete-version-btn')) {
                            const confirmed = await helpers.showConfirm('이 버전을 삭제하시겠습니까?');
                            if (confirmed) {
                                await deleteFromIndexedDB(CACHE_STORE_VERSIONS, versionId);
                                helpers.showToast('버전이 삭제되었습니다.');
                                viewVersionsBtn.click();
                                viewVersionsBtn.click();
                            }
                        }
                    });
                }
            },
            /**
             * 템플릿 사용 모달을 렌더링하고 사용자 입력을 처리합니다.
             * @param {string} id - 사용할 템플릿 프롬프트의 ID.
             * @param {Function} [onCompleteCallback=null] - 템플릿 처리 완료 후 호출될 콜백 함수 (주로 시퀀스 실행 시 사용).
             * @returns {Promise<{inputs: NodeListOf<HTMLTextAreaElement>, preview: HTMLElement, updatePreview: Function}>} 모달 요소 및 프리뷰 업데이트 함수.
             */
            templateModal: async (id, onCompleteCallback = null) => {
                const p = state.prompts.find(prompt => prompt.id === id);
                if (!p) {
                    helpers.showToast('템플릿을 찾을 수 없습니다!');
                    if (onCompleteCallback) onCompleteCallback(true);
                    return Promise.reject(new Error('Template not found'));
                }
                const placeholders = [...p.content.matchAll(/{{([^\n}]+?)}}/g)].map(match => match[1].trim());
                const uniquePlaceholders = [...new Set(placeholders)];
                
                ui.templateModal.title.textContent = `템플릿 사용: ${p.title}`;
                ui.templateModal.body.innerHTML = uniquePlaceholders.map(ph => `
                    <div class="form-group">
                        <label for="ph-${ph}">${ph.replace(/_/g, ' ')}</label>
                        <div class="template-input-with-file"> <textarea id="ph-${ph}" data-placeholder="${ph}" rows="1"></textarea> <input type="file" id="file-ph-${ph}" accept=".txt,.html,.htm,.md,.json,.csv,.xml,.yaml,.yml,.js,.css,text/*" style="display:none;">
                            <button class="button-like file-upload-icon-btn" data-target-ph="${ph}" title="파일에서 불러오기">
                                <i class="fa-solid fa-file-arrow-up"></i>
                            </button>
                        </div>
                    </div>`).join('') + `<div class="form-group"><label>미리보기</label><div class="modal-preview" id="template-preview">${p.content}</div></div>`;
                ui.templateModal.overlay.classList.add('show');
                
                return new Promise(resolve => {
                    setTimeout(() => {
                        const inputs = ui.templateModal.body.querySelectorAll('textarea[data-placeholder]');
                        const preview = document.getElementById('template-preview');
                        
                        const updatePreview = () => {
                            let content = p.content;
                            inputs.forEach(input => {
                                const ph = `{{${input.dataset.placeholder}}}`;
                                const value = input.value;
                                content = content.replaceAll(ph, value || ph);
                            });
                            preview.textContent = content;
                        };
                        inputs.forEach(input => input.addEventListener('input', updatePreview));
                        updatePreview();
                        
                        const handleModalFileLoad = async (file, targetTextarea) => {
                            if (!file) return;
                            const MAX_FILE_SIZE_MB = 5;
                            if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                                helpers.showToast(`파일 용량이 너무 큽니다. (${MAX_FILE_SIZE_MB}MB 이하로 업로드해주세요.)`);
                                return false;
                            }
                            try {
                                let raw = await file.text();
                                let processedText = raw;
                                if (file.name.match(/\.(html?|htm)$/i)) {
                                    processedText = raw.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                                    helpers.showToast('HTML 파일이 이스케이프되어 불러와졌습니다.');
                                } else if (file.name.match(/\.(json|yaml|yml)$/i)) {
                                    helpers.showToast('파일 내용이 불러와졌습니다.');
                                } else {
                                    helpers.showToast('파일 내용이 불러와졌습니다.');
                                }
                                targetTextarea.value = processedText;
                                updatePreview();
                                return true;
                            } catch (error) {
                                console.error("파일 읽기 오류:", error);
                                helpers.showToast('파일을 읽는 중 오류가 발생했습니다.');
                                return false;
                            }
                        };
                        const fileInputButtons = ui.templateModal.body.querySelectorAll('.file-upload-icon-btn');
                        fileInputButtons.forEach(button => {
                            button.addEventListener('click', () => {
                                const targetPh = button.dataset.targetPh;
                                const fileInput = document.getElementById(`file-ph-${targetPh}`);
                                fileInput.click();
                            });
                        });
                        inputs.forEach(textarea => {
                            const ph = textarea.dataset.placeholder;
                            const fileInput = document.getElementById(`file-ph-${ph}`);
                            fileInput.addEventListener('change', async (e) => {
                                const file = e.target.files[0];
                                if (file) {
                                    await handleModalFileLoad(file, textarea);
                                }
                                e.target.value = '';
                            });
                            textarea.addEventListener('dragover', e => {
                                e.preventDefault();
                                e.dataTransfer.dropEffect = 'copy';
                            });
                            textarea.addEventListener('drop', async e => {
                                e.preventDefault();
                                const file = e.dataTransfer.files[0];
                                if (file) {
                                    await handleModalFileLoad(file, textarea);
                                }
                            });
                        });
                        ui.templateModal.generateBtn.onclick = async () => {
                            const textToCopy = preview.textContent;
                            const variablesUsed = {};
                            inputs.forEach(input => {
                                variablesUsed[input.dataset.placeholder] = input.value;
                            });
                            try {
                                const textarea = document.createElement('textarea');
                                textarea.value = textToCopy;
                                document.body.appendChild(textarea);
                                textarea.select();
                                document.execCommand('copy');
                                document.body.removeChild(textarea);

                                helpers.showToast('템플릿이 생성되어 클립보드에 복사되었습니다!');
                                
                                if (p.id) {
                                    const currentUsageCount = p.usageCount || 0;
                                    await dbService.put('prompts', { id: p.id, usageCount: currentUsageCount + 1 });
                                    helpers.logUsage('template_generate', p.id, p.title, textToCopy, variablesUsed);
                                }
                                if (onCompleteCallback) {
                                    onCompleteCallback();
                                }
                            } catch (err) {
                                console.error('텍스트 복사 실패: ', err);
                                helpers.showToast('복사 실패. 다시 시도해 주세요.');
                                if (onCompleteCallback) onCompleteCallback(true);
                            }
                        };
                        ui.templateModal.closeBtn.onclick = () => {
                            ui.templateModal.overlay.classList.remove('show');
                            if (onCompleteCallback) onCompleteCallback(true);
                        };
                        resolve({ inputs, preview, updatePreview });
                    }, 50);
                });
            },
            /**
             * 시퀀스 편집기 모달을 렌더링합니다.
             * @param {string|null} id - 편집할 시퀀스의 ID (새 항목인 경우 null).
             */
            sequenceEditor: async (id) => {
                const isNew = id === null;
                let s = { name: '', description: '', promptIds: [] };
                if (!isNew) {
                    const fetchedSequence = state.sequences.find(seq => seq.id === id);
                    if (fetchedSequence) {
                        s = fetchedSequence;
                    } else {
                        helpers.showToast('시퀀스를 찾을 수 없습니다!');
                        render.sequences();
                        return;
                    }
                }

                const allPrompts = state.prompts;

                ui.sequenceModal.title.textContent = isNew ? '새 시퀀스 생성' : `시퀀스 편집: ${s.name}`;
                ui.sequenceModal.body.innerHTML = `
                    <div class="form-group">
                        <label for="sequence-name-input">시퀀스 이름</label>
                        <input type="text" id="sequence-name-input" value="${s.name || ''}">
                    </div>
                    <div class="form-group">
                        <label for="sequence-description-input">설명</label>
                        <textarea id="sequence-description-input">${s.description || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label for="sequence-prompts-select">시퀀스에 포함할 프롬프트 선택 (Ctrl/Cmd 클릭으로 다중 선택)</label>
                        <select id="sequence-prompts-select" multiple size="10">
                            ${allPrompts.map(p => `<option value="${p.id}">${p.title}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label>시퀀스 순서 조정 (선택된 프롬프트를 드래그하여 순서를 변경하세요.)</label>
                        <div id="sequence-sortable-list" class="sequence-sortable-list">
                            </div>
                    </div>
                `;
                ui.sequenceModal.overlay.classList.add('show');
                ui.sequenceModal.saveBtn.dataset.id = isNew ? '' : id;
                ui.sequenceModal.runBtn.dataset.id = isNew ? '' : id;
                ui.sequenceModal.deleteBtn.dataset.id = isNew ? '' : id;
                ui.sequenceModal.deleteBtn.style.display = isNew ? 'none' : 'inline-block';
                const sequencePromptsSelect = document.getElementById('sequence-prompts-select');
                const sequenceSortableList = document.getElementById('sequence-sortable-list');
                if (sequenceSortableInstance) {
                    sequenceSortableInstance.destroy();
                }
                sequenceSortableInstance = Sortable.create(sequenceSortableList, {
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    handle: '.drag-handle'
                });
                s.promptIds.forEach(promptId => {
                    const prompt = allPrompts.find(p => p.id === promptId);
                    if (prompt) {
                        const item = document.createElement('div');
                        item.classList.add('sequence-sortable-item');
                        item.dataset.promptId = prompt.id;
                        item.innerHTML = `
                            <i class="fa-solid fa-grip-vertical drag-handle"></i>
                            <span>${prompt.title}</span>
                            <button class="remove-from-sequence-btn button-like"><i class="fa-solid fa-times"></i></button>
                        `;
                        sequenceSortableList.appendChild(item);
                        const option = sequencePromptsSelect.querySelector(`option[value="${prompt.id}"]`);
                        if (option) {
                            option.selected = true;
                        }
                    }
                });
                sequencePromptsSelect.addEventListener('change', () => {
                    const currentSortableIds = Array.from(sequenceSortableList.children).map(item => item.dataset.promptId);
                    const selectedIds = Array.from(sequencePromptsSelect.selectedOptions).map(opt => opt.value);
                    selectedIds.forEach(id => {
                        if (!currentSortableIds.includes(id)) {
                            const prompt = allPrompts.find(p => p.id === id);
                            if (prompt) {
                                const item = document.createElement('div');
                                item.classList.add('sequence-sortable-item');
                                item.dataset.promptId = prompt.id;
                                item.innerHTML = `
                                    <i class="fa-solid fa-grip-vertical drag-handle"></i>
                                    <span>${prompt.title}</span>
                                    <button class="remove-from-sequence-btn button-like"><i class="fa-solid fa-times"></i></button>
                                `;
                                sequenceSortableList.appendChild(item);
                            }
                        }
                    });
                    currentSortableIds.forEach(id => {
                        if (!selectedIds.includes(id)) {
                            const itemToRemove = sequenceSortableList.querySelector(`[data-prompt-id="${id}"]`);
                            if (itemToRemove) {
                                itemToRemove.remove();
                            }
                        }
                    });
                });
                sequenceSortableList.addEventListener('click', (e) => {
                    if (e.target.closest('.remove-from-sequence-btn')) {
                        const item = e.target.closest('.sequence-sortable-item');
                        const promptIdToRemove = item.dataset.promptId;
                        item.remove();
                        const optionToDeselect = sequencePromptsSelect.querySelector(`option[value="${promptIdToRemove}"]`);
                        if (optionToDeselect) {
                            optionToDeselect.selected = false;
                        }
                    }
                });
            },
            /**
             * 사용 기록 페이지를 렌더링합니다.
             */
            usageHistory: async () => {
                ui.mainHeader.textContent = '사용 기록';
                const history = await getFromIndexedDB(CACHE_STORE_USAGE_HISTORY);
                history.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());

                if (history.length === 0) {
                    ui.contentView.innerHTML = `<div class="content-placeholder">사용 기록이 없습니다.</div>`;
                    return;
                }

                ui.contentView.innerHTML = `
                    <div class="usage-history-list">
                        ${history.map(record => `
                            <div class="usage-history-item" data-record-id="${record.id}" data-record-type="${record.type}">
                                <div class="usage-history-header">
                                    <span class="usage-history-type">${record.type === 'prompt_copy' ? '프롬프트 복사' : record.type === 'template_generate' ? '템플릿 생성' : '시퀀스 실행'}</span>
                                    <span class="usage-history-time">${record.timestamp.toLocaleString()}</span>
                                </div>
                                <div class="usage-history-details">
                                    <strong>${record.itemName}</strong>
                                    ${record.contentSnippet ? `<p class="usage-history-snippet">${record.contentSnippet.trim()}...</p>` : ''}
                                </div>
                                <div class="usage-history-actions">
                                    <button class="reuse-history-btn button-like">
                                        <i class="fa-solid fa-redo"></i> 재사용
                                    </button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
        };

        // =================================================================
        // 이벤트 핸들러 (Event Handlers)
        // =================================================================
        const handlers = {
            /**
             * 사이드바 메뉴 항목 클릭 이벤트 처리.
             * @param {Event} e - 클릭 이벤트 객체.
             */
            sidebar: (e) => {
                const target = e.target.closest('.nav-item');
                if (!target) return;
                document.querySelectorAll('.sidebar-nav .nav-item.active').forEach(el => el.classList.remove('active'));
                target.classList.add('active');
                
                const { filterType, folderId, seqId } = target.dataset;
                if (filterType === 'folder') {
                    const id = folderId;
                    state.currentFilter = { type: 'folder', id, name: state.folders.find(f => f.id === id)?.name || '알 수 없는 폴더' };
                    render.prompts();
                } else if (filterType === 'sequence') {
                    const id = seqId;
                    state.currentFilter = { type: 'sequence', id, name: state.sequences.find(s => s.id === id)?.name || '알 수 없는 시퀀스' };
                    render.sequenceEditor(id);
                } else if (filterType === 'history') {
                    state.currentFilter = { type: 'history', id: null, name: '사용 기록' };
                    render.usageHistory();
                } else {
                    state.currentFilter = { type: filterType, id: null, name: target.textContent.trim() };
                    render.prompts();
                }
                if (window.innerWidth <= 768) {
                    ui.sidebar.classList.remove('open');
                    document.body.classList.remove('no-scroll');
                }
            },
            /**
             * 메인 콘텐츠 영역 클릭 이벤트 처리 (프롬프트 목록 항목, 버튼 등).
             * @param {Event} e - 클릭 이벤트 객체.
             */
            content: async (e) => {
                const promptItem = e.target.closest('.prompt-list-item');
                const historyItem = e.target.closest('.usage-history-item');
                
                if (promptItem) {
                    const promptId = promptItem.dataset.promptId;
                    const p = state.prompts.find(p => p.id === promptId);
                    if (!p) {
                        helpers.showToast('항목을 찾을 수 없습니다.');
                        return;
                    }
                    
                    if (e.target.closest('.edit-btn')) {
                        render.promptEditor(promptId);
                    } else if (e.target.closest('.use-btn')) {
                        render.templateModal(promptId);
                    } else if (e.target.closest('.copy-btn')) {
                        try {
                            const textarea = document.createElement('textarea');
                            textarea.value = p.content;
                            document.body.appendChild(textarea);
                            textarea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textarea);
                            helpers.showToast('클립보드에 복사되었습니다!');
                            helpers.logUsage('prompt_copy', p.id, p.title, p.content);
                        } catch (err) {
                            console.error('텍스트 복사 실패: ', err);
                            helpers.showToast('복사 실패. 다시 시도해 주세요.');
                        }
                    } else if (e.target.closest('.visit-link-btn')) {
                        e.preventDefault();
                        if (p.link) {
                            window.open(p.link, '_blank');
                            helpers.showToast('링크를 새 탭에서 엽니다.');
                        }
                    }
                    else if (e.target.closest('.fav-icon')) {
                        await dbService.put('prompts', { id: promptId, isFavorite: !p.isFavorite });
                        helpers.showToast(!p.isFavorite ? '즐겨찾기에 추가되었습니다.' : '즐겨찾기에서 제거되었습니다.');
                    } else if (promptItem) {
                        if (p.link) {
                            window.open(p.link, '_blank');
                            helpers.showToast('링크를 새 탭에서 엽니다.');
                        } else {
                            render.promptEditor(promptId);
                        }
                    }
                } else if (historyItem) {
                    if (e.target.closest('.reuse-history-btn')) {
                        const recordId = parseInt(historyItem.dataset.recordId, 10);
                        const historyRecord = await getFromIndexedDB(CACHE_STORE_USAGE_HISTORY, null, recordId);
                        const record = historyRecord[0];

                        if (!record) {
                            helpers.showToast('사용 기록을 찾을 수 없습니다.');
                            return;
                        }

                        if (record.type === 'prompt_copy') {
                            try {
                                const textarea = document.createElement('textarea');
                                textarea.value = record.content;
                                document.body.appendChild(textarea);
                                textarea.select();
                                document.execCommand('copy');
                                document.body.removeChild(textarea);
                                helpers.showToast('프롬프트가 클립보드에 복사되었습니다!');
                            } catch (err) {
                                console.error('텍스트 복사 실패: ', err);
                                helpers.showToast('복사 실패. 다시 시도해 주세요.');
                            }
                        } else if (record.type === 'template_generate') {
                            const originalTemplate = state.prompts.find(p => p.id === record.itemId);
                            if (!originalTemplate) {
                                helpers.showToast('원본 템플릿을 찾을 수 없습니다. (삭제되었을 수 있습니다.)');
                                return;
                            }
                            
                            const { inputs, preview, updatePreview } = await render.templateModal(originalTemplate.id);

                            if (record.variablesUsed) {
                                for (const placeholder in record.variablesUsed) {
                                    const value = record.variablesUsed[placeholder];
                                    const inputElement = ui.templateModal.body.querySelector(`textarea[data-placeholder="${placeholder}"]`);
                                    if (inputElement) {
                                        inputElement.value = value;
                                    }
                                }
                                updatePreview();
                            }
                            helpers.showToast('템플릿이 미리 채워져 모달에 로드되었습니다!');
                        }
                    }
                }
            },
            /**
             * 편집기 화면 내 버튼 클릭 이벤트 처리 (저장, 삭제).
             * @param {Event} e - 클릭 이벤트 객체.
             */
            editor: async (e) => {
                const saveBtn = e.target.closest('.save-btn');
                const deleteBtn = e.target.closest('.delete-btn');
                if (saveBtn) {
                    const idFromDataset = saveBtn.dataset.id;
                    const id = (typeof idFromDataset === 'string' && idFromDataset.trim().length > 0 && idFromDataset !== 'null') ? idFromDataset : null;
                    
                    const tags = document.getElementById('tags-input').value.split(',').map(t => t.trim()).filter(Boolean);
                    const currentContent = document.getElementById('content-input').value;
                    const link = document.getElementById('link-input').value.trim();
                    
                    const contentByteLength = new TextEncoder().encode(currentContent).length;
                    const FIREBASE_DOC_LIMIT_BYTES = 1000 * 1024;
                    if (contentByteLength > FIREBASE_DOC_LIMIT_BYTES) {
                        helpers.showToast('오류: 내용이 너무 길어 저장할 수 없습니다. (Firestore 문서 제한 1MB 초과)');
                        return;
                    }
                    
                    let data = {
                        title: document.getElementById('title-input').value,
                        content: currentContent,
                        folderId: document.getElementById('folder-select').value || null,
                        tags: tags,
                        isTemplate: document.getElementById('is-template-checkbox').checked,
                        link: link
                    };
                    
                    if (id) {
                        const existingPrompt = state.prompts.find(p => p.id === id);
                        if (existingPrompt) {
                            data.isFavorite = existingPrompt.isFavorite !== undefined ? existingPrompt.isFavorite : false;
                            data.usageCount = existingPrompt.usageCount !== undefined ? existingPrompt.usageCount : 0;
                        }
                    } else {
                        data.isFavorite = false;
                        data.usageCount = 0;
                    }

                    try {
                        const savedId = await dbService.put('prompts', { id: id, ...data });
                        helpers.showToast(id ? '항목이 업데이트되었습니다!' : '항목이 저장되었습니다!');

                        if (savedId) {
                            const memo = prompt('이 버전에 대한 메모를 남겨주세요 (선택 사항):');
                            await dbService.savePromptVersion(savedId, currentContent, memo || '');
                        }
                    } catch (error) {
                        console.error("항목 저장 오류:", error);
                        helpers.showToast('항목 저장 오류: ' + error.message);
                    }
                }

                if (deleteBtn) {
                    const id = deleteBtn.dataset.id;
                    const confirmed = await helpers.showConfirm('이 항목을 영구적으로 삭제하시겠습니까?');
                    if (confirmed) {
                        try {
                            await dbService.delete('prompts', id);
                            helpers.showToast('항목이 삭제되었습니다.');
                        } catch (error) {
                            console.error("항목 삭제 오류:", error);
                            helpers.showToast('항목 삭제 오류: ' + error.message);
                        }
                    }
                }
            }
        };

        // =================================================================
        // 헬퍼 함수 (Helper Functions)
        // =================================================================
        const helpers = {
            /**
             * 사용자에게 짧은 토스트 알림 메시지를 표시합니다.
             * @param {string} msg - 표시할 메시지.
             */
            showToast: (msg) => {
                ui.toast.textContent = msg;
                ui.toast.classList.add('show');
                setTimeout(() => ui.toast.classList.remove('show'), 3000);
            },
            /**
             * 시퀀스 실행을 중단하고 상태를 초기화합니다.
             */
            resetSequenceExecution: () => {
                activeSequencePrompts = [];
                currentSequencePromptIndex = -1;
                ui.templateModal.overlay.classList.remove('show');
                helpers.showToast('시퀀스 실행이 종료되었습니다.');
            },
            /**
             * 사용자에게 사용자 정의 확인 대화 상자를 표시합니다.
             * @param {string} message - 확인 메시지.
             * @returns {Promise<boolean>} 사용자가 '확인'을 클릭하면 true, '취소'를 클릭하면 false.
             */
            showConfirm: (message) => {
                return new Promise(resolve => {
                    const modalOverlay = document.createElement('div');
                    modalOverlay.classList.add('modal-overlay', 'show');
                    modalOverlay.innerHTML = `
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3>확인</h3>
                                <button class="close-btn">&times;</button>
                            </div>
                            <div class="modal-body">
                                <p>${message}</p>
                            </div>
                            <div class="modal-footer">
                                <button id="confirm-cancel-btn" class="button-like">취소</button>
                                <button id="confirm-ok-btn" class="generate-btn">확인</button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modalOverlay);
                    const closeAndResolve = (result) => {
                        modalOverlay.classList.remove('show');
                        modalOverlay.addEventListener('transitionend', () => modalOverlay.remove(), { once: true });
                        resolve(result);
                    };
                    modalOverlay.querySelector('.close-btn').onclick = () => closeAndResolve(false);
                    modalOverlay.querySelector('#confirm-cancel-btn').onclick = () => closeAndResolve(false);
                    modalOverlay.querySelector('#confirm-ok-btn').onclick = () => closeAndResolve(true);
                    modalOverlay.onclick = (e) => {
                        if (e.target === modalOverlay) {
                            closeAndResolve(false);
                        }
                    };
                });
            },
            /**
             * 사용 기록을 IndexedDB에 저장하고 최신 20개 기록만 유지합니다.
             * @param {'prompt_copy'|'template_generate'|'sequence_run'} type - 사용 기록의 타입.
             * @param {string} itemId - 관련된 프롬프트 또는 시퀀스의 ID.
             * @param {string} itemName - 관련된 프롬프트 또는 시퀀스의 이름.
             * @param {string} [content=''] - 프롬프트 내용 또는 생성된 내용 (스니펫용).
             * @param {Object} [variablesUsed=null] - 템플릿 사용 시 채워진 변수들.
             * @returns {Promise<void>}
             */
            logUsage: async (type, itemId, itemName, content = '', variablesUsed = null) => {
                if (!indexedDbInstance) await openIndexedDB();
                const record = {
                    type,
                    itemId,
                    itemName,
                    timestamp: new Date(),
                    content: content,
                    contentSnippet: content.substring(0, 100),
                    variablesUsed: variablesUsed
                };
                await putIntoIndexedDB(CACHE_STORE_USAGE_HISTORY, record);
                const allRecords = await getFromIndexedDB(CACHE_STORE_USAGE_HISTORY);
                if (allRecords.length > 20) {
                    const sortedRecords = allRecords.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
                    for (let i = 20; i < sortedRecords.length; i++) {
                        await deleteFromIndexedDB(CACHE_STORE_USAGE_HISTORY, sortedRecords[i].id);
                    }
                }
            }
        };

        // =================================================================
        // Fuse.js 검색 인덱스 빌드
        // =================================================================
        /**
         * Fuse.js 검색 인덱스를 빌드합니다.
         * @param {Array<Object>} data - 인덱싱할 데이터 배열.
         */
        function buildSearchIndex(data) {
            fuse = new Fuse(data, {
                keys: ['title', 'content', 'tags'],
                includeScore: true,
                threshold: 0.3
            });
            console.log("Fuse.js 검색 인덱스 빌드 완료.");
        }

        // =================================================================
        // 시퀀스 실행 로직
        // =================================================================
        /**
         * 시퀀스의 다음 프롬프트를 실행합니다.
         * @param {boolean} [forceStop=false] - 시퀀스 실행을 강제로 중단할지 여부.
         */
        async function executeNextPromptInSequence(forceStop = false) {
            if (forceStop || currentSequencePromptIndex >= activeSequencePrompts.length) {
                helpers.resetSequenceExecution();
                return;
            }

            const currentPrompt = activeSequencePrompts[currentSequencePromptIndex];

            if (currentPrompt.isTemplate) {
                render.templateModal(currentPrompt.id, (isErrorOrCanceled) => {
                    if (isErrorOrCanceled) {
                        helpers.resetSequenceExecution();
                    } else {
                        currentSequencePromptIndex++;
                        executeNextPromptInSequence();
                    }
                });
            } else {
                try {
                    const textarea = document.createElement('textarea');
                    textarea.value = currentPrompt.content;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    helpers.showToast(`'${currentPrompt.title}' 프롬프트가 클립보드에 복사되었습니다!`);
                    helpers.logUsage('prompt_copy', currentPrompt.id, currentPrompt.title, currentPrompt.content);
                } catch (err) {
                    console.error('텍스트 복사 실패: ', err);
                    helpers.showToast(`'${currentPrompt.title}' 복사 실패. 시퀀스를 중단합니다.`);
                    helpers.resetSequenceExecution();
                    return;
                }

                currentSequencePromptIndex++;
                setTimeout(() => {
                    executeNextPromptInSequence();
                }, 1000);
            }
        }

        /**
         * 시퀀스 실행을 시작합니다.
         * @param {string} sequenceId - 실행할 시퀀스의 ID.
         */
        async function startSequenceExecution(sequenceId) {
            const sequence = state.sequences.find(seq => seq.id === sequenceId);
            if (!sequence || !sequence.promptIds || sequence.promptIds.length === 0) {
                helpers.showToast('실행할 프롬프트가 없는 시퀀스입니다.');
                return;
            }

            activeSequencePrompts = [];
            for (const promptId of sequence.promptIds) {
                const prompt = state.prompts.find(p => p.id === promptId);
                if (prompt) {
                    activeSequencePrompts.push(prompt);
                } else {
                    helpers.showToast(`시퀀스에 포함된 프롬프트 (ID: ${promptId})를 찾을 수 없습니다. 시퀀스 실행을 중단합니다.`);
                    helpers.resetSequenceExecution();
                    return;
                }
            }

            currentSequencePromptIndex = 0;
            ui.sequenceModal.overlay.classList.remove('show');
            helpers.showToast(`'${sequence.name}' 시퀀스를 시작합니다.`);
            helpers.logUsage('sequence_run', sequenceId, sequence.name);
            executeNextPromptInSequence();
        }

        /**
         * onSnapshot() 리스너를 설정하고, 데이터 변경 시 상태를 업데이트합니다.
         */
        function setupRealtimeListeners() {
            // 기존 리스너가 있다면 해제
            if (promptsUnsubscribe) promptsUnsubscribe();
            if (foldersUnsubscribe) foldersUnsubscribe();
            if (sequencesUnsubscribe) sequencesUnsubscribe();
            
            // 새 리스너 설정
            promptsUnsubscribe = dbService.subscribeToCollection('prompts', (newPrompts) => {
                state.prompts = newPrompts;
                render.prompts();
                buildSearchIndex(newPrompts); // 데이터가 변경될 때마다 검색 인덱스 갱신
            });
            foldersUnsubscribe = dbService.subscribeToCollection('folders', (newFolders) => {
                state.folders = newFolders;
                render.folders();
            });
            sequencesUnsubscribe = dbService.subscribeToCollection('sequences', (newSequences) => {
                state.sequences = newSequences;
                render.sequences();
            });
        }
        
        /**
         * onSnapshot() 리스너를 모두 해제합니다.
         */
        function tearDownRealtimeListeners() {
            if (promptsUnsubscribe) promptsUnsubscribe();
            if (foldersUnsubscribe) foldersUnsubscribe();
            if (sequencesUnsubscribe) sequencesUnsubscribe();
            promptsUnsubscribe = null;
            foldersUnsubscribe = null;
            sequencesUnsubscribe = null;
        }


        // =================================================================
        // 앱 초기화 및 인증 로직 (App Initialization and Authentication Logic)
        // =================================================================
        /**
         * 앱의 초기 로직을 실행합니다.
         */
        async function initializeApp() {
            // IndexedDB 초기화는 로그인 여부와 관계없이 실행
            await openIndexedDB();

            // UI 이벤트 리스너를 등록합니다 (인증 상태와 관계없이 동작).
            setupEventListeners();
        }

        /**
         * UI 요소에 대한 이벤트 리스너를 설정합니다.
         */
        function setupEventListeners() {
            ui.newPromptBtn.addEventListener('click', () => render.promptEditor(null));
            ui.newFolderBtn.addEventListener('click', async () => {
                const name = prompt('새 폴더 이름을 입력하세요:');
                if (name?.trim()) {
                    try {
                        await dbService.put('folders', { name: name.trim() });
                        helpers.showToast('폴더가 생성되었습니다!');
                    } catch (error) {
                        console.error("폴더 생성 오류:", error);
                        helpers.showToast('폴더 생성 오류: ' + error.message);
                    }
                }
            });
            ui.newSequenceBtn.addEventListener('click', () => render.sequenceEditor(null));
            ui.libraryList.addEventListener('click', handlers.sidebar);
            ui.folderList.addEventListener('click', handlers.sidebar);
            ui.sequenceList.addEventListener('click', handlers.sidebar);
            ui.contentView.addEventListener('click', handlers.content);
            ui.contentView.addEventListener('click', handlers.editor);
            ui.searchInput.addEventListener('input', () => render.prompts());
            ui.templateModal.closeBtn.addEventListener('click', () => {
                ui.templateModal.overlay.classList.remove('show');
            });
            ui.templateModal.overlay.addEventListener('click', e => {
                if (e.target === ui.templateModal.overlay) {
                    ui.templateModal.overlay.classList.remove('show');
                }
            });
            ui.sequenceModal.closeBtn.addEventListener('click', () => ui.sequenceModal.overlay.classList.remove('show'));
            ui.sequenceModal.overlay.addEventListener('click', e => {
                if (e.target === ui.sequenceModal.overlay) {
                    ui.sequenceModal.overlay.classList.remove('show');
                }
            });
            ui.sequenceModal.saveBtn.addEventListener('click', async () => {
                const id = ui.sequenceModal.saveBtn.dataset.id || null;
                const name = document.getElementById('sequence-name-input').value;
                const description = document.getElementById('sequence-description-input').value;
                const sequenceSortableList = document.getElementById('sequence-sortable-list');
                const promptIds = Array.from(sequenceSortableList.children).map(item => item.dataset.promptId);
                if (!name.trim()) {
                    helpers.showToast('시퀀스 이름을 입력해주세요.');
                    return;
                }
                const data = {
                    name: name.trim(),
                    description: description.trim(),
                    promptIds: promptIds,
                };
                try {
                    await dbService.put('sequences', { id: id, ...data });
                    helpers.showToast(id ? '시퀀스가 업데이트되었습니다!' : '시퀀스가 저장되었습니다!');
                    ui.sequenceModal.overlay.classList.remove('show');
                } catch (error) {
                    console.error("시퀀스 저장 오류:", error);
                    helpers.showToast('시퀀스 저장 오류: ' + error.message);
                }
            });
            ui.sequenceModal.deleteBtn.addEventListener('click', async () => {
                const id = ui.sequenceModal.deleteBtn.dataset.id;
                const confirmed = await helpers.showConfirm('이 시퀀스를 영구적으로 삭제하시겠습니까?');
                if (confirmed) {
                    try {
                        await dbService.delete('sequences', id);
                        helpers.showToast('시퀀스가 삭제되었습니다.');
                        ui.sequenceModal.overlay.classList.remove('show');
                    } catch (error) {
                        console.error("시퀀스 삭제 오류:", error);
                        helpers.showToast('시퀀스 삭제 오류: ' + error.message);
                    }
                }
            });
            ui.sequenceModal.runBtn.addEventListener('click', async () => {
                const id = ui.sequenceModal.runBtn.dataset.id;
                startSequenceExecution(id);
            });
            ui.mobileMenuToggle.addEventListener('click', () => {
                ui.sidebar.classList.toggle('open');
                document.body.classList.toggle('no-scroll');
            });
            ui.sidebarCloseBtn.addEventListener('click', () => {
                ui.sidebar.classList.remove('open');
                document.body.classList.remove('no-scroll');
            });
            document.addEventListener('click', (e) => {
                if (ui.sidebar.classList.contains('open') && !ui.sidebar.contains(e.target) && !ui.mobileMenuToggle.contains(e.target)) {
                    ui.sidebar.classList.remove('open');
                    document.body.classList.remove('no-scroll');
                }
            });
            
            // 데이터 내보내기/가져오기 버튼 추가 (설정 섹션이 없으므로 임시로 추가)
            const dataMgmtSection = document.createElement('div');
            dataMgmtSection.style = "padding: 16px; border-top: 1px solid var(--border-color); margin-top: 20px;";
            dataMgmtSection.innerHTML = `
                <h3 class="nav-section-title" style="padding: 0;">데이터 관리</h3>
                <button id="export-data-btn" class="button-like" style="width:100%; padding: 8px; margin-top: 10px; background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">데이터 내보내기</button>
                <input type="file" id="import-data-input" accept=".json" style="display: none;">
                <button id="import-data-btn" class="button-like" style="width:100%; padding: 8px; margin-top: 10px; background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">데이터 가져오기</button>
            `;
            ui.sidebarContent.appendChild(dataMgmtSection);
            document.getElementById('export-data-btn').addEventListener('click', dbService.exportData);
            document.getElementById('import-data-btn').addEventListener('click', () => {
                document.getElementById('import-data-input').click();
            });
            document.getElementById('import-data-input').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    dbService.importData(e.target.files[0]);
                }
            });
            document.addEventListener('keydown', (e) => {
                if (e.key === 'n' && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
                    e.preventDefault();
                    ui.newPromptBtn.click();
                }
                if (e.key === 'f' && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) {
                    e.preventDefault();
                    document.body.classList.toggle('fullscreen-editor-mode');
                    document.body.classList.toggle('no-scroll');
                    const editorArea = document.querySelector('.main-content .content-view');
                    if (editorArea) {
                        editorArea.classList.toggle('fullscreen-editor');
                        if (editorArea.classList.contains('fullscreen-editor')) {
                            helpers.showToast('풀스크린 편집 모드');
                        } else {
                            helpers.showToast('풀스크린 편집 모드 종료');
                        }
                    }
                }
            });
        }
        
        // Firebase 인증 상태 변화 감지 옵저버
        onAuthStateChanged(auth, async user => {
            if (user) {
                currentUser = user;
                ui.loginBtn.style.display = 'none';
                ui.userProfile.style.display = 'flex';
                ui.userEmail.textContent = user.displayName || user.email;
                ui.userPhoto.src = user.photoURL || `https://via.placeholder.com/32`;
                ui.sidebarContent.style.display = 'flex';
                ui.contentView.innerHTML = '<div class="content-placeholder">데이터를 불러오는 중...</div>';
                ui.mainHeader.textContent = "모든 항목";
                
                // 로그인 시 실시간 리스너 설정
                setupRealtimeListeners();
            } else {
                currentUser = null;
                // 로그아웃 시 모든 리스너 해제
                tearDownRealtimeListeners();
                
                ui.loginBtn.style.display = 'block';
                ui.userProfile.style.display = 'none';
                ui.sidebarContent.style.display = 'none';
                ui.contentView.innerHTML = '<div class="content-placeholder">프롬프트를 관리하려면 로그인해주세요.</div>';
                ui.mainHeader.textContent = "환영합니다";
            }
        });
        
        // 로그인 버튼 이벤트 리스너
        ui.loginBtn.addEventListener('click', () => {
            const provider = new GoogleAuthProvider();
            signInWithPopup(auth, provider).catch(error => {
                console.error("로그인 실패:", error);
                helpers.showToast("로그인에 실패했습니다. 자세한 내용은 콘솔을 확인해주세요.");
            });
        });
        
        // 로그아웃 버튼 이벤트 리스너
        ui.logoutBtn.addEventListener('click', () => {
            signOut(auth);
        });

        // 앱 초기화 함수 호출
        initializeApp();

    </script>
    <style>        
        /* 기본 스타일 및 변수 정의 */
        :root{--bg-primary:#131314;--bg-secondary:#1e1f20;--bg-tertiary:#2d2e30;--bg-hover:#3c4043;--text-primary:#e2e2e3;--text-secondary:#bdc1c6;--accent-blue:#8ab4f8;--accent-yellow:#fdd663;--accent-pink:#f28b82;--border-color:#3c4043;--sidebar-width:280px;--header-height:64px}        
        *{margin:0;padding:0;box-sizing:border-box}        
        body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;background-color:var(--bg-primary);color:var(--text-primary);display:flex;height:100vh;} /* overflow:hidden 제거 */
        button{font-family:inherit; cursor: pointer;}        
        
        /* body에 스크롤 막는 클래스 추가 */
        body.no-scroll {
            overflow: hidden;
        }

        /* 인증 섹션 스타일 */
        #auth-section{padding:16px;border-bottom:1px solid var(--border-color); display:flex; flex-direction:column; align-items:center; gap: 10px;}        
        #login-btn{width:100%;padding:10px;background-color:var(--accent-blue);color:var(--bg-primary);border:none;border-radius:6px;font-weight:500}        
        #user-profile{display:none;align-items:center;gap:10px; width:100%;}        
        #user-profile img{width:32px;height:32px;border-radius:50%}        
        #user-profile p{font-size:.9rem;flex-grow:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}        
        #logout-btn{background:none;border:1px solid var(--border-color);color:var(--text-secondary);padding:6px 10px;border-radius:6px; flex-shrink: 0;}        
        
        /* 사이드바 스타일 */
        .sidebar{width:var(--sidebar-width);background-color:var(--bg-secondary);display:flex;flex-direction:column;flex-shrink:0;height:100%}.sidebar-content{flex-grow:1;overflow-y:auto; min-height:0;} /* min-height:0 추가 */
        .new-prompt-btn{display:flex;align-items:center;gap:12px;background-color:var(--bg-primary);color:var(--text-primary);border:1px solid var(--border-color);border-radius:24px;padding:10px 16px;font-size:.9rem;cursor:pointer;margin:8px 16px;white-space:nowrap}.new-prompt-btn:hover{background-color:#282a2c}.nav-section-title{font-size:.9rem;color:var(--text-secondary);padding:16px 16px 8px;font-weight:500}.nav-list{list-style:none}.nav-item a{display:flex;align-items:center;gap:16px;padding:10px 16px;color:var(--text-primary);text-decoration:none;border-radius:4px;font-size:.9rem;white-space:nowrap;cursor:pointer}.nav-item a:hover{background-color:var(--bg-tertiary)}.nav-item.active a{background-color:var(--accent-blue);color:var(--bg-primary)}.nav-icon{width:24px;text-align:center;font-size:1rem}.new-folder-btn{width:calc(100% - 32px);margin:10px 16px;padding:10px;background:none;border:1px dashed var(--border-color);color:var(--text-secondary);border-radius:4px}.new-folder-btn:hover{background-color:var(--bg-tertiary)}        
        
        /* 메인 콘텐츠 스타일 */
        .main-content{flex-grow:1;display:flex;flex-direction:column; min-height:0;} /* min-height:0 추가 */
        /* Adjusted main-header for top search bar */
        .main-header{
            display: flex;
            flex-direction: column; /* Stack items vertically */
            align-items: flex-start; /* Align items to the start */
            padding: 16px 24px 0; /* Padding top and sides, no padding bottom */
            height: auto; /* Height adapts to content */
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            gap: 10px; /* Space between title/toggle and search bar */
        }
        .main-header-top-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding-bottom: 16px; /* Padding below the title/toggle row */
        }
        .main-header h1{font-size:1.4rem;font-weight:500; margin: 0;} /* Reset margin */
        .search-wrapper{
            position:relative;
            width: 100%; /* Make search bar full width within header */
            margin-bottom: 16px; /* Space below search bar */
        }        
        .search-input{background-color:var(--bg-secondary);border:1px solid var(--border-color);border-radius:8px;color:var(--text-primary);padding:8px 16px 8px 36px;font-size:1rem; width: 100%;}
        .search-wrapper .fa-magnifying-glass{position:absolute;left:12px;top:11px;color:var(--text-secondary)}        
        
        /* 콘텐츠 뷰 및 목록 항목 스타일 */
        .content-view{
            flex:1 1 auto; /* flex-grow:1; 대신 flex:1 1 auto; 사용 */
            overflow-y:auto;
            padding:24px;
            min-height:0; /* min-height:0 추가 */
            -webkit-overflow-scrolling:touch; /* iOS 부드러운 스크롤 */
        }
        .content-placeholder{padding:50px 20px;text-align:center;color:var(--text-secondary)}
        /* 프롬프트 목록을 더 얇게 만들기 (패딩 조정) */
        .prompt-list-item{display:flex;align-items:center;padding:10px 16px;border-bottom:1px solid var(--border-color);cursor:pointer;gap:16px}
        .prompt-list-item:hover{background-color:var(--bg-secondary)}.prompt-list-icon{font-size:1.1rem;color:var(--text-secondary);width:20px}.prompt-title{font-weight:500}.prompt-subtitle{font-size:.8rem;color:var(--text-secondary);margin-top:4px}.prompt-tags{display:flex;gap:6px;margin-top:8px}.prompt-tag{background-color:var(--bg-tertiary);color:var(--text-secondary);font-size:.75rem;padding:2px 6px;border-radius:4px}.prompt-actions{margin-left:auto;display:flex;gap:8px}.prompt-actions button, .prompt-actions a.visit-link-btn{background-color:var(--bg-tertiary);border:1px solid var(--border-color);color:var(--text-primary);padding:8px 12px;border-radius:6px; text-decoration: none; display: flex; align-items: center; justify-content: center; gap: 6px;} /* Added a.visit-link-btn */
        .prompt-actions button:hover, .prompt-actions a.visit-link-btn:hover{background-color:var(--bg-hover)}        
        
        /* 편집기 스타일 */
        .editor-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:24px}.editor-actions button{background-color:var(--bg-tertiary);border:1px solid var(--border-color);color:var(--text-primary);padding:10px 16px;border-radius:6px;margin-left:8px}.editor-actions button.save-btn{background-color:var(--accent-blue);color:var(--bg-primary);border:none}.editor-actions button.delete-btn{color:var(--accent-pink);border-color:var(--accent-pink)}        
        .form-group{margin-bottom:24px}.form-group label{display:block;font-size:.9rem;color:var(--text-secondary);margin-bottom:8px}.form-group input,.form-group textarea,.form-group select{width:100%;background-color:var(--bg-secondary);border:1px solid var(--border-color);border-radius:8px;color:var(--text-primary);padding:12px;font-size:1rem;font-family:inherit}.form-group textarea{height:300px;resize:vertical}        
        .is-template-toggle{display:flex;align-items:center;gap:10px;margin-top:16px;font-size:.9rem}        
        
        /* 모달 스타일 */
        .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:1000;opacity:0;visibility:hidden;transition:opacity .3s,visibility .3s}.modal-overlay.show{opacity:1;visibility:visible}.modal-content{background-color:var(--bg-secondary);padding:24px;border-radius:8px;width:90%;max-width:600px;box-shadow:0 5px 15px rgba(0,0,0,0.3)}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}.modal-header h3{color:var(--accent-blue)}.modal-header .close-btn{background:none;border:none;color:var(--text-secondary);font-size:1.5rem;cursor:pointer}.modal-body{max-height:60vh;overflow-y:auto}.modal-body .form-group label{font-weight:500;color:var(--accent-blue);}.modal-preview{background-color:var(--bg-primary);padding:12px;border-radius:4px;margin-top:16px;white-space:pre-wrap;font-family:monospace;max-height:150px;overflow-y:auto}.modal-footer{display:flex;justify-content:flex-end;gap:10px;margin-top:24px}.modal-footer button{padding:10px 16px;border-radius:6px;cursor:pointer;border:none}.modal-footer .generate-btn{background-color:var(--accent-blue);color:var(--bg-primary)}        
        
        /* 토스트 알림 스타일 */
        .toast{position:fixed;bottom:20px;right:20px;background-color:var(--bg-tertiary);color:var(--text-primary);padding:12px 20px;border-radius:6px;border-left:4px solid var(--accent-blue);opacity:0;visibility:hidden;transition:opacity .3s,visibility .3s,transform .3s;transform:translateY(20px);z-index:2000}.toast.show{opacity:1;visibility:visible;transform:translateY(0)}    
        
        /* 풀스크린 편집 모드 (24번) */
        body.fullscreen-editor-mode {
            overflow: hidden; /* 스크롤바 숨김 */
        }
        .main-content .content-view.fullscreen-editor {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            background-color: var(--bg-primary);
            z-index: 999; /* 다른 요소 위에 표시 */
            overflow-y: auto;
        }
        /* 풀스크린 시 사이드바 숨김 (모바일에서는 햄버거 메뉴로 제어) */
        body.fullscreen-editor-mode .sidebar { 
            display: none; 
        }
        /* 풀스크린 시 검색창 숨김 (모바일에서는 다시 표시될 수 있음) */
        body.fullscreen-editor-mode .main-header .search-wrapper {
            display: none; 
        }

        /* 반응형 디자인 개선 (26번) */
        /* 모바일 햄버거 메뉴 버튼은 데스크탑에서 숨김 */
        #mobile-menu-toggle {
            display: none; 
        }

        @media (max-width: 768px) {
            /* 모바일에서 햄버거 메뉴 버튼 표시 */
            #mobile-menu-toggle {
                display: block; 
                background: none;
                border: none;
                color: var(--text-secondary);
                font-size: 1.5rem;
                cursor: pointer;
                padding: 8px;
            }
            #mobile-menu-toggle:hover {
                background-color: var(--bg-tertiary);
                border-radius: 50%;
            }

            .sidebar {
                position: fixed;
                top: 0;
                left: -100%; /* 기본적으로 숨김 */
                height: 100%;
                width: 250px; /* 모바일 사이드바 너비 */
                z-index: 1000;
                transition: left 0.3s ease-in-out;
            }
            .sidebar.open {
                left: 0; /* 열릴 때 표시 */
            }

            /* 사이드바 닫기 버튼 (모바일에서만 표시) */
            #sidebar-close-btn {
                display: block;
                background: none;
                border: none;
                color: var(--text-secondary);
                font-size: 1.8rem;
                cursor: pointer;
                padding: 8px;
                position: absolute;
                top: 10px;
                right: 10px;
                z-index: 1001;
            }
            #sidebar-close-btn:hover {
                background-color: var(--bg-tertiary);
                border-radius: 50%;
            }
            
            .main-content {
                width: 100%;
            }
            .main-header {
                padding: 16px; /* 모바일 헤더 패딩 조정 */
                flex-direction: column; /* 스택 유지 */
                align-items: flex-start;
                gap: 15px;
            }
            .main-header-top-row {
                padding-bottom: 0; /* 모바일에서는 추가 패딩 없음 */
            }
            .main-header h1 {
                font-size: 1.2rem;
                flex-grow: 1; /* 제목이 남은 공간 차지 */
            }
            .main-header .search-wrapper {
                width: 100%; /* 검색창 너비 조정 */
                margin-bottom: 0; /* 모바일에서는 검색창 아래 여백 없음 */
            }
            .search-input {
                width: 100%;
            }
            .prompt-list-item {
                flex-wrap: wrap; /* 작은 화면에서 항목 줄바꿈 */
            }
            .prompt-actions {
                width: 100%; /* 버튼이 아래로 내려오도록 */
                justify-content: flex-end; /* 오른쪽 정렬 */
                margin-top: 10px;
            }
            .editor-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }
            .editor-actions {
                width: 100%;
                justify-content: flex-end;
            }

            /* 풀스크린 모드에서 사이드바 숨김 (모바일) */
            body.fullscreen-editor-mode .sidebar { 
                display: none; 
            }
            /* 풀스크린 모드에서 모바일 검색창도 숨김 */
            body.fullscreen-editor-mode .main-header .search-wrapper {
                display: none;
            }
        }
        /* 버튼 공통 스타일 (버전 기록 버튼 등) */
        .button-like {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.9rem;
            white-space: nowrap; /* 버튼 텍스트 줄바꿈 방지 */
        }
        .button-like:hover {
            background-color: var(--bg-hover);
        }
        /* 시퀀스 모달을 위한 추가 스타일 */
        .modal-sequence-content {
            background-color: var(--bg-secondary);
            padding: 24px;
            border-radius: 8px;
            width: 90%;
            max-width: 700px; /* 템플릿 모달보다 약간 넓게 */
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-sequence-footer {
            display: flex;
            justify-content: space-between; /* 저장/실행 버튼과 삭제 버튼 분리 */
            gap: 10px;
            margin-top: 24px;
        }
        .modal-sequence-footer .left-actions {
            display: flex;
            gap: 10px;
        }
        .modal-sequence-footer .delete-btn {
            background: none;
            color: var(--accent-pink);
            border: 1px solid var(--accent-pink);
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
        }

        /* 파일 업로드 섹션 스타일 (메인 편집기) */
        .file-upload-section {
            display: flex;
            align-items: center;
            margin-top: 10px;
            gap: 10px;
        }
        .file-upload-section .button-like {
            padding: 8px 12px;
            font-size: 0.85rem;
        }

        /* Sortable.js를 위한 시퀀스 프롬프트 목록 스타일 */
        .sequence-sortable-list {
            min-height: 100px; /* 드래그 앤 드롭 영역 확보 */
            border: 1px dashed var(--border-color);
            border-radius: 8px;
            padding: 10px;
            background-color: var(--bg-primary);
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            max-height: 250px;
            min-height: 0; /* min-height:0 추가 */
        }
        .sequence-sortable-item {
            display: flex;
            align-items: center;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.95rem;
            cursor: grab; /* 드래그 가능함을 나타냄 */
            gap: 10px;
        }
        .sequence-sortable-item:active {
            cursor: grabbing;
        }
        .sequence-sortable-item .drag-handle {
            cursor: grab;
            color: var(--text-secondary);
            font-size: 1.1rem;
            margin-right: 5px;
        }
        .sequence-sortable-item span {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .sequence-sortable-item .remove-from-sequence-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1rem;
            padding: 4px;
            border-radius: 4px;
            cursor: pointer;
            line-height: 1; /* 아이콘 정렬 */
        }
        .sequence-sortable-item .remove-from-sequence-btn:hover {
            background-color: var(--bg-hover);
            color: var(--accent-pink);
        }
        /* Sortable.js 고스트 클래스 */
        .sortable-ghost {
            opacity: 0.4;
            background-color: var(--accent-blue);
            border: 1px dashed var(--accent-blue);
        }

        /* New style for template input with file button in modal */
        .template-input-with-file {
            display: flex;
            align-items: center;
            gap: 8px; /* Space between textarea and button */
        }

        .template-input-with-file textarea {
            flex-grow: 1; /* Allow textarea to take available space */
            min-width: 0; /* Prevent flex item from overflowing */
            height: auto; /* Allow textarea to adjust height based on rows */
            resize: vertical; /* Allow vertical resize */
        }

        .file-upload-icon-btn {
            padding: 8px 10px; /* Adjust padding for icon-only button */
            font-size: 1rem; /* Adjust icon size */
            width: auto; /* Allow button to size based on content */
            flex-shrink: 0; /* Prevent button from shrinking */
        }

        /* 데이터 새로고침 버튼 스타일 */
        #refresh-data-btn {
            margin-top: 10px;
            width: 100%;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px;
            border-radius: 4px;
        }
        #refresh-data-btn:hover {
            background-color: var(--bg-hover);
        }

        /* 사용 기록 목록 스타일 */
        .usage-history-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .usage-history-item {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .usage-history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0; /* Padding moved to gap */
        }
        .usage-history-type {
            font-weight: bold;
            color: var(--accent-blue);
        }
        .usage-history-details strong {
            color: var(--text-primary);
            font-size: 1rem;
        }
        .usage-history-snippet {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
            white-space: pre-wrap;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis; /* For multiline text overflow */
            margin-top: 4px;
        }
        .usage-history-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 8px;
        }
        .usage-history-actions .reuse-history-btn {
            padding: 6px 10px;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <aside class="sidebar" id="sidebar">
        <div id="auth-section">
            <button id="login-btn"><i class="fa-brands fa-google"></i> Google 계정으로 로그인</button>
            <div id="user-profile">
                <img id="user-photo" src="" alt="사용자 사진">
                <p id="user-email"></p>
                <button id="logout-btn" title="로그아웃"><i class="fa-solid fa-arrow-right-from-bracket"></i></button>
            </div>
        </div>
        <div class="sidebar-content" id="sidebar-content" style="display:none;">
            <button class="new-prompt-btn" id="new-prompt-btn"><i class="fa-solid fa-plus"></i> 새 항목</button>
            <nav class="sidebar-nav">
                <h3 class="nav-section-title">라이브러리</h3>
                <ul class="nav-list" id="library-list">
                    <li class="nav-item active" data-filter-type="all"><a><i class="nav-icon fa-solid fa-book-bookmark"></i> 모든 항목</a></li>
                    <li class="nav-item" data-filter-type="favorites"><a><i class="nav-icon fa-solid fa-star"></i> 즐겨찾기</a></li>
                    <li class="nav-item" data-filter-type="templates"><a><i class="nav-icon fa-solid fa-puzzle-piece"></i> 템플릿만</a></li>
                    <li class="nav-item" data-filter-type="prompts"><a><i class="nav-icon fa-solid fa-file-lines"></i> 프롬프트만</a></li>
                    <li class="nav-item" data-filter-type="history"><a><i class="nav-icon fa-solid fa-history"></i> 사용 기록</a></li> <!-- 사용 기록 메뉴 추가 -->
                </ul>
                <h3 class="nav-section-title">폴더</h3>
                <ul class="nav-list" id="folder-list"></ul>
                <button class="new-folder-btn" id="new-folder-btn"><i class="fa-solid fa-folder-plus"></i> 새 폴더</button>
                
                <h3 class="nav-section-title">시퀀스</h3>
                <ul class="nav-list" id="sequence-list"></ul>
                <button id="new-sequence-btn" class="new-folder-btn">
                    <i class="fa-solid fa-layer-group"></i> 새 시퀀스
                </button>
            </nav>
        </div>
        <button id="sidebar-close-btn" style="display: none;"><i class="fa-solid fa-times"></i></button>
    </aside>

    <main class="main-content">
        <header class="main-header">
            <div class="main-header-top-row">
                <button id="mobile-menu-toggle"><i class="fa-solid fa-bars"></i></button>
                <h1 id="main-header-title">환영합니다</h1>
            </div>
            <div class="search-wrapper">
                <i class="fa-solid fa-magnifying-glass"></i>
                <input type="text" class="search-input" id="search-input" placeholder="검색...">
            </div>
        </header>
        <div class="content-view" id="content-view">
            <div class="content-placeholder">프롬프트를 관리하려면 로그인해주세요.</div>
        </div>
    </main>

    <div class="modal-overlay" id="template-modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="template-modal-title">템플릿 사용</h3>
                <button class="close-btn" id="template-modal-close-btn">&times;</button>
            </div>
            <div class="modal-body" id="template-modal-body">
                </div>
            <div class="modal-footer">
                <button id="template-modal-generate-btn" class="generate-btn"><i class="fa-solid fa-wand-magic-sparkles"></i> 생성 및 복사</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="sequence-modal-overlay">
        <div class="modal-sequence-content">
            <div class="modal-header">
                <h3 id="sequence-modal-title">새 시퀀스 생성</h3>
                <button class="close-btn" id="sequence-modal-close-btn">&times;</button>
            </div>
            <div class="modal-body" id="sequence-modal-body">
                </div>
            <div class="modal-sequence-footer">
                <div class="left-actions">
                    <button id="sequence-modal-save-btn" class="generate-btn"><i class="fa-regular fa-save"></i> 저장</button>
                    <button id="sequence-modal-run-btn" class="button-like"><i class="fa-solid fa-play"></i> 실행</button>
                </div>
                <button id="sequence-modal-delete-btn" class="delete-btn" style="display: none;"><i class="fa-regular fa-trash-can"></i> 삭제</button>
            </div>
        </div>
    </div>
        
    <div class="toast" id="toast"></div>

</body>
</html>
