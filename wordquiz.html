<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Vocabulary Hub</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* ==========================================================================
           1. Design System & Base Styles
           ========================================================================== */
        :root {
            --background-light: #f8fafc; /* slate-50 */
            --background-dark: #0f172a;  /* slate-900 */
            --card-light: #ffffff;
            --card-dark: #1e293b; /* slate-800 */
            --text-light-primary: #0f172a; /* slate-900 */
            --text-light-secondary: #64748b; /* slate-500 */
            --text-dark-primary: #f8fafc; /* slate-50 */
            --text-dark-secondary: #94a3b8; /* slate-400 */
            
            --primary-accent: #3b82f6; /* blue-500 */
            --primary-accent-hover: #2563eb; /* blue-600 */
            
            --secondary-accent: #10b981; /* emerald-500 */
            --secondary-accent-hover: #059669; /* emerald-600 */
            --danger-accent: #ef4444; /* red-500 */
            --danger-accent-hover: #dc2626; /* red-600 */
            --border-light: #e2e8f0; /* slate-200 */
            --border-dark: #334155; /* slate-700 */
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        html.dark { color-scheme: dark; }
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: var(--background-light);
            color: var(--text-light-primary);
            transition: background-color 0.3s, color 0.3s;
        }
        .dark body {
            background-color: var(--background-dark);
            color: var(--text-dark-primary);
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--border-light); }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        .dark ::-webkit-scrollbar-track { background: var(--border-dark); }
        .dark ::-webkit-scrollbar-thumb { background: #475569; }
        .dark ::-webkit-scrollbar-thumb:hover { background: #64748b; }
        
        /* Animations */
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .animate-spin { animation: spin 1s linear infinite; }
        .fade-in { animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }

        .fade-in-up { animation: fadeInUp 0.5s ease-in-out forwards; opacity:0; }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        
        /* Card Flip Animation */
        .perspective { perspective: 1000px; }
        .flip-card-inner { transition: transform 0.7s; transform-style: preserve-3d; }
        .flip-card.flipped .flip-card-inner { transform: rotateY(180deg); }
        .flip-card-front, .flip-card-back { backface-visibility: hidden; -webkit-backface-visibility: hidden; }
        .flip-card-back { transform: rotateY(180deg); }

        /* Highlighted Text (q tag) */
        q {
            font-weight: 600;
            color: var(--primary-accent);
        }

        /* General Accessibility & UX improvements */
        button, input, select, textarea {
            outline-offset: 2px;
        }
        button:focus-visible, input:focus-visible, select:focus-visible, textarea:focus-visible {
            outline: 2px solid var(--primary-accent);
        }

        /* Smooth timer bar transition */
        #quiz-timer-bar {
            transition: width 1s linear;
        }

        .heatmap-day { transition: background-color 0.3s; }
    </style>
</head>
<body class="bg-slate-50 dark:bg-slate-900 text-slate-900 dark:text-slate-50">
    <div id="app" class="h-screen w-screen flex flex-col"></div>

    <script type="module">
        // =================================================================================
        // 1. CONFIGURATION & CONSTANTS
        // =================================================================================
        const DB_CONFIG = {
            NAME: 'AI_Vocabulary_Hub_DB', VERSION: 3,
            STORES: { USER_PROFILE: 'userProfile', CATEGORIES: 'categories', DECKS: 'decks', CARDS: 'cards', SETTINGS: 'settings', QUIZ_SESSIONS: 'quizSessions', ACTIVITY_LOG: 'activityLog' }
        };
        const XP_PER_CORRECT = 10;
        const LEVEL_THRESHOLDS = [0, 100, 250, 500, 1000, 2000, 4000, 8000, 16000, 32000];
        const SRS_INTERVALS = [14400, 28800, 86400, 259200, 604800, 1209600, 2592000, 7776000]; // in seconds
        const ACHIEVEMENTS = {
            FIRST_DECK: { id: 'FIRST_DECK', title: '첫 걸음', description: '첫 단어장을 만들었습니다!' },
            FIRST_QUIZ: { id: 'FIRST_QUIZ', title: '학습 시작', description: '첫 퀴즈를 완료했습니다!' },
            TEN_CARDS: { id: 'TEN_CARDS', title: '열정의 시작', description: '누적 10개 단어 생성!' },
            PERFECT_QUIZ: { id: 'PERFECT_QUIZ', title: '완벽주의자', description: '퀴즈에서 만점을 받았습니다!' },
            MASTERED_CARD: { id: 'MASTERED_CARD', title: '단어의 지배자', description: '첫 단어를 마스터했습니다!' },
            STREAK_7: { id: 'STREAK_7', title: '불타는 일주일', description: '7일 연속으로 학습했습니다!' },
            NIGHT_OWL: { id: 'NIGHT_OWL', title: '올빼미 학습자', description: '밤 12시에서 4시 사이에 학습했습니다.' },
        };
        const QUIZ_TYPE = { MEANING: 'meaning', CLOZE: 'cloze', LISTENING: 'listening' };
        const LANGUAGES = ['English', 'Korean', 'Japanese', 'Chinese', 'Spanish', 'French', 'German', 'Russian'];
        const QUIZ_TIME_LIMIT = 15; // in seconds
        const DEFAULT_QUIZ_QUESTION_COUNT = 20;
        const DEFAULT_PROMPT_TEMPLATE = `<?xml version="1.0" encoding="UTF-8"?>
<request>
  <task>
    For each {{sourceLang}} word provided, create one or more vocabulary learning cards.
    If a word has multiple common meanings, create a separate card for each meaning.
    Each card must contain:
    1. A practical {{sourceLang}} example sentence. The target word in this sentence MUST be wrapped in <q> tags.
    2. A natural {{targetLang}} translation of the sentence. The corresponding {{targetLang}} translation of the target word MUST also be wrapped in <q> tags.
  </task>
  <wordList>
    {{wordList}}
  </wordList>
  <outputFormat>
    Respond ONLY with a valid JSON array of objects inside a <json_response> tag. Each object represents one card and must have "word", "sentence", and "translation" keys.
  </outputFormat>
</request>`;


        // =================================================================================
        // 2. DATABASE MODULE (IndexedDB)
        // =================================================================================
        const DB = (() => {
            let db = null;
            const init = () => new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_CONFIG.NAME, DB_CONFIG.VERSION);
                request.onupgradeneeded = (e) => {
                    db = e.target.result;
                    Object.values(DB_CONFIG.STORES).forEach(storeName => {
                        if (!db.objectStoreNames.contains(storeName)) {
                            const keyPath = storeName === 'activityLog' ? 'date' : 'id';
                            const autoIncrement = !['userProfile', 'settings', 'quizSessions', 'activityLog'].includes(storeName);
                            const store = db.createObjectStore(storeName, { keyPath, autoIncrement });
                            
                            if (storeName === 'cards') store.createIndex('deckId', 'deckId');
                            if (storeName === 'decks') store.createIndex('categoryId', 'categoryId');
                        }
                    });
                };
                request.onsuccess = e => { db = e.target.result; resolve(db); };
                request.onerror = e => reject(e.target.error);
            });
            const getStore = (name, mode = 'readonly') => db.transaction(name, mode).objectStore(name);
            const promisify = request => new Promise((resolve, reject) => {
                request.onsuccess = e => resolve(e.target.result);
                request.onerror = e => reject(e.target.error);
            });
            return {
                init, add: (name, data) => promisify(getStore(name, 'readwrite').add(data)), get: (name, key) => promisify(getStore(name).get(key)),
                getAll: (name) => promisify(getStore(name).getAll()), getAllByIndex: (name, index, query) => promisify(getStore(name).index(index).getAll(query)),
                update: (name, data) => promisify(getStore(name, 'readwrite').put(data)), delete: (name, key) => promisify(getStore(name, 'readwrite').delete(key)),
            };
        })();

        // =================================================================================
        // 3. STATE MANAGER
        // =================================================================================
        const state = {
            _data: {
                isLoading: true, currentView: 'dashboard', currentDeckId: null, isAddingWords: false,
                categories: [], decks: [], cards: [], userProfile: { id: 'main', level: 1, xp: 0, achievements: [] },
                reviewCardCount: 0, apiKey: null, toast: {}, modal: {}, promptTemplate: DEFAULT_PROMPT_TEMPLATE,
                quizQuestionCount: DEFAULT_QUIZ_QUESTION_COUNT,
                savedQuizSession: null,
                searchQuery: '', sortCriteria: 'priority-desc', themeColor: 'blue', // Default sort
                activityLog: {},
                bulkEditState: { enabled: false, selectedCards: new Set() },
                quizState: { 
                    active: false, type: null, cards: [], currentIndex: 0, score: 0, 
                    incorrectCards: [], isAnswered: false, timeLeft: QUIZ_TIME_LIMIT, quizHistory: [] 
                },
                learnState: { active: false, cards: [], currentIndex: 0 }
            },
            listeners: [], get data() { return this._data; }, setState(newState) {
                if (newState.quizState) { newState.quizState = { ...this._data.quizState, ...newState.quizState }; }
                if (newState.bulkEditState) { newState.bulkEditState = { ...this._data.bulkEditState, ...newState.bulkEditState }; }
                if (newState.learnState) { newState.learnState = { ...this._data.learnState, ...newState.learnState }; }
                Object.assign(this._data, newState); 
                this.notify(); 
            },
            subscribe(listener) { this.listeners.push(listener); }, notify() { this.listeners.forEach(listener => listener(this._data)); }
        };
        
        // =================================================================================
        // 4. QUIZ TIMER & LOGIC HELPERS
        // =================================================================================
        let quizTimerId = null; 

        const stopQuestionTimer = () => {
            if (quizTimerId) {
                clearInterval(quizTimerId);
                quizTimerId = null;
            }
        };

        const processAnswer = async (isCorrect, userAnswer = '', isTimeUp = false) => {
            stopQuestionTimer();
            const { quizState } = state.data;
            const currentCard = quizState.cards[quizState.currentIndex];
            
            const newHistory = [...quizState.quizHistory, { card: currentCard, userAnswer, isCorrect }];
            
            state.setState({ quizState: { isAnswered: true, quizHistory: newHistory }});
            
            const feedbackArea = document.getElementById('feedback-area');
            const inputElement = document.getElementById('answer-input') || document.getElementById('cloze-answer-input');

            await api.updateCardReview(currentCard, isCorrect);
            if (isCorrect) api.logActivity();
            
            const correctText = quizState.type === QUIZ_TYPE.MEANING || quizState.type === QUIZ_TYPE.LISTENING 
                ? extractQTagContent(currentCard.translation) 
                : extractQTagContent(currentCard.sentence);

            if (isTimeUp) {
                feedbackArea.innerHTML = `<span class="text-yellow-500 font-bold">시간 초과!</span> 정답: <q>${correctText}</q>`;
                state.setState({ quizState: { incorrectCards: [...state.data.quizState.incorrectCards, currentCard] } });
            } else if (isCorrect) {
                feedbackArea.innerHTML = `<span class="text-emerald-500">정답! ${I('check-circle', 'inline-block w-6 h-6')}</span>`;
                if(inputElement) inputElement.classList.add('border-emerald-500');
                state.setState({ quizState: { score: state.data.quizState.score + 1 } });
            } else {
                feedbackArea.innerHTML = `<span class="text-red-500">오답!</span> 정답: <q>${correctText}</q>`;
                if(inputElement) inputElement.classList.add('border-red-500');
                state.setState({ quizState: { incorrectCards: [...state.data.quizState.incorrectCards, currentCard] } });
            }

            setTimeout(() => {
                const currentQuizState = state.data.quizState;
                if (currentQuizState.currentIndex + 1 < currentQuizState.cards.length) {
                    state.setState({ quizState: { currentIndex: currentQuizState.currentIndex + 1, isAnswered: false, timeLeft: QUIZ_TIME_LIMIT } });
                    startQuestionTimer();
                } else {
                    api.endQuiz();
                }
            }, 1200);
        };

        const startQuestionTimer = () => {
            stopQuestionTimer(); 
            state.setState({ quizState: { timeLeft: QUIZ_TIME_LIMIT } });
            
            const timerBar = document.getElementById('quiz-timer-bar');
            if(timerBar) {
                timerBar.style.transition = 'none';
                timerBar.style.width = '100%';
                setTimeout(() => {
                    timerBar.style.transition = `width ${QUIZ_TIME_LIMIT}s linear`;
                    timerBar.style.width = '0%';
                }, 100);
            }

            quizTimerId = setInterval(() => {
                const currentQuizState = state.data.quizState;
                if (currentQuizState.timeLeft > 0) {
                    state.setState({ quizState: { timeLeft: currentQuizState.timeLeft - 1 } });
                } else {
                    stopQuestionTimer();
                    const inputElement = document.getElementById('answer-input') || document.getElementById('cloze-answer-input');
                    processAnswer(false, inputElement?.value || '', true); 
                }
            }, 1000);
        };

        // =================================================================================
        // 5. SERVICES & UTILITIES
        // =================================================================================
        
        /**
         * A dedicated service for handling Text-to-Speech (TTS) functionality.
         * It loads available voices from the browser and intelligently selects the best voice
         * for the requested language to improve pronunciation accuracy.
         */
        const TTSService = (() => {
            let voices = [];

            const loadVoices = () => {
                voices = speechSynthesis.getVoices();
            };

            // Load voices initially and set up a listener for when the voice list changes.
            loadVoices();
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = loadVoices;
            }

            /**
             * Speaks the given text in the specified language.
             * @param {string} text - The text to be spoken.
             * @param {string} langCode - The language code (e.g., 'en-US', 'fr-FR').
             */
            const speak = (text, langCode) => {
                if (!text || !langCode) return;
                
                speechSynthesis.cancel(); // Cancel any ongoing speech

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = langCode;

                // Find a specific voice for the given language for better pronunciation.
                // 1. Try for an exact match (e.g., 'fr-FR')
                let voice = voices.find(v => v.lang === langCode);
                
                // 2. If no exact match, try for a partial match (e.g., 'fr')
                if (!voice) {
                    const langBase = langCode.split('-')[0];
                    voice = voices.find(v => v.lang.startsWith(langBase));
                }
                
                // 3. If a suitable voice is found, use it. If not, inform the user.
                if (voice) {
                    utterance.voice = voice;
                    speechSynthesis.speak(utterance);
                } else {
                    const langName = mapCodeToLang(langCode);
                    showToast(`${langName} 음성을 찾을 수 없습니다. OS 또는 브라우저에 해당 언어 팩 설치가 필요할 수 있습니다.`, 'warning', 5000);
                    console.warn(`TTS voice not found for language: ${langCode}.`);
                }
            };

            return {
                speak
            };
        })();

        const Services = {
            checkAndGrantAchievement: (achievementId) => {
                const { userProfile } = state.data;
                if (!userProfile.achievements.includes(achievementId)) {
                    const achievement = ACHIEVEMENTS[achievementId];
                    const updatedProfile = { ...userProfile, achievements: [...userProfile.achievements, achievementId] };
                    api.updateUserProfile(updatedProfile);
                    showToast(`${achievement.title} 업적 달성!`, 'success');
                }
            },
            updateSrsData: (card, isCorrect) => {
                let { srsLevel = 0, streak = 0 } = card;
                const maxSrsLevel = SRS_INTERVALS.length - 1;

                if (isCorrect) {
                    srsLevel = Math.min(srsLevel + 1, maxSrsLevel);
                    streak++;
                    if (srsLevel === maxSrsLevel) {
                        Services.checkAndGrantAchievement('MASTERED_CARD');
                    }
                } else {
                    srsLevel = card.srsLevel === maxSrsLevel ? 0 : Math.max(0, srsLevel - 2);
                    streak = 0;
                }
                const interval = SRS_INTERVALS[srsLevel] * 1000;
                const nextReviewAt = new Date(Date.now() + interval);

                return { ...card, srsLevel, streak, nextReviewAt, lastReviewedAt: new Date(), lastAnswerCorrect: isCorrect };
            },
            buildXMLPrompt: (words, sourceLang, targetLang) => {
                const { promptTemplate } = state.data;
                if (!promptTemplate) return '';
                const wordListXML = words.map(word => `<word>${word}</word>`).join('\n    ');
                
                let finalPrompt = promptTemplate.replace('{{wordList}}', wordListXML);
                finalPrompt = finalPrompt.replace(/{{sourceLang}}/g, sourceLang);
                finalPrompt = finalPrompt.replace(/{{targetLang}}/g, targetLang);
                return finalPrompt;
            },
            calculateWeight: (card) => {
                if (!card.lastReviewedAt) return Infinity; 
                
                const maxSrsLevel = SRS_INTERVALS.length - 1;
                
                if ((card.srsLevel || 0) === maxSrsLevel && Math.random() > 0.1) {
                    return -1;
                }

                const srsFactor = (maxSrsLevel - (card.srsLevel || 0)) * 5;
                const streakFactor = 15 / ((card.streak || 0) + 1);
                const recencyFactor = Math.min(20, (Date.now() - new Date(card.lastReviewedAt).getTime()) / (1000 * 60 * 60 * 24));
                const correctnessFactor = card.lastAnswerCorrect === false ? 30 : 0;
                
                return srsFactor + streakFactor + recencyFactor + correctnessFactor;
            },
            /**
             * Sorts an array of cards based on a given criteria string.
             * @param {Array} cards - The array of card objects to sort.
             * @param {string} sortCriteria - The sorting criteria (e.g., 'priority-desc', 'word-asc').
             * @returns {Array} The sorted array of cards.
             */
            sortCards(cards, sortCriteria) {
                const [sortKey, sortOrder] = sortCriteria.split('-');
                const sorted = [...cards]; // Create a new array to avoid mutating the original

                sorted.sort((a, b) => {
                    if (sortKey === 'priority') {
                        // Priority is always descending
                        return Services.calculateWeight(b) - Services.calculateWeight(a);
                    }

                    let valA = a[sortKey];
                    let valB = b[sortKey];

                    // Handle cases where property might not exist
                    if (valA === undefined || valA === null) valA = sortKey === 'word' ? '' : 0;
                    if (valB === undefined || valB === null) valB = sortKey === 'word' ? '' : 0;

                    if (sortKey === 'word') {
                        valA = String(valA).toLowerCase();
                        valB = String(valB).toLowerCase();
                    }

                    if (valA < valB) return sortOrder === 'asc' ? -1 : 1;
                    if (valA > valB) return sortOrder === 'asc' ? 1 : -1;
                    return 0;
                });
                return sorted;
            }
        };

        const api = {
            async loadInitialData() {
                state.setState({ isLoading: true });
                try {
                    const [dbCategories, dbDecks, settings, profile, allCards, savedSession, activityLog] = await Promise.all([
                        DB.getAll(DB_CONFIG.STORES.CATEGORIES), DB.getAll(DB_CONFIG.STORES.DECKS),
                        DB.get(DB_CONFIG.STORES.SETTINGS, 'appSettings'), DB.get(DB_CONFIG.STORES.USER_PROFILE, 'main'),
                        DB.getAll(DB_CONFIG.STORES.CARDS), DB.get(DB_CONFIG.STORES.QUIZ_SESSIONS, 'current'),
                        DB.getAll(DB_CONFIG.STORES.ACTIVITY_LOG)
                    ]);
                    const now = new Date();
                    const reviewCardCount = allCards.filter(c => c.nextReviewAt && new Date(c.nextReviewAt) <= now).length;
                    
                    const categories = dbCategories.map(c => ({
                        ...c,
                        sourceLang: c.sourceLang || 'English',
                        targetLang: c.targetLang || 'Korean'
                    }));

                    const decksWithLangAndStats = await Promise.all(dbDecks.map(async (deck) => {
                        const parentCategory = categories.find(c => c.id === deck.categoryId);
                        const cardsInDeck = allCards.filter(c => c.deckId === deck.id);
                        const learnedCards = cardsInDeck.filter(c => (c.srsLevel || 0) > 0).length;
                        const mastery = cardsInDeck.length > 0 ? (learnedCards / cardsInDeck.length) * 100 : 0;
                        return {
                           ...deck,
                            sourceLang: parentCategory?.sourceLang,
                            targetLang: parentCategory?.targetLang,
                            cardCount: cardsInDeck.length,
                            mastery: Math.round(mastery)
                        }
                    }));
                    
                    const activityMap = activityLog.reduce((acc, log) => {
                        acc[log.date] = log.count;
                        return acc;
                    }, {});

                    state.setState({
                        categories, decks: decksWithLangAndStats, reviewCardCount, allCards,
                        apiKey: settings?.apiKey || null,
                        promptTemplate: settings?.promptTemplate || DEFAULT_PROMPT_TEMPLATE,
                        quizQuestionCount: settings?.quizQuestionCount || DEFAULT_QUIZ_QUESTION_COUNT,
                        themeColor: settings?.themeColor || 'blue',
                        userProfile: profile || { id: 'main', level: 1, xp: 0, achievements: [] },
                        savedQuizSession: savedSession,
                        activityLog: activityMap,
                    });
                    
                    if (categories.length === 0 && decksWithLangAndStats.length === 0) {
                       showModal(OnboardingModalContent());
                    }
                } catch (e) { console.error('Failed to load data:', e); showToast('데이터 로딩 실패.', 'error'); }
                finally { state.setState({ isLoading: false }); }
            },
            async saveSettings(key, template, questionCount, theme) {
                const count = parseInt(questionCount, 10) || DEFAULT_QUIZ_QUESTION_COUNT;
                await DB.update(DB_CONFIG.STORES.SETTINGS, { id: 'appSettings', apiKey: key, promptTemplate: template, quizQuestionCount: count, themeColor: theme });
                state.setState({ apiKey: key, promptTemplate: template, quizQuestionCount: count, themeColor: theme });
                applyTheme(theme);
                showToast('설정이 저장되었습니다.', 'success');
            },
            async logActivity() {
                const today = new Date().toISOString().split('T')[0];
                const todayLog = await DB.get(DB_CONFIG.STORES.ACTIVITY_LOG, today);
                const count = (todayLog?.count || 0) + 1;
                await DB.update(DB_CONFIG.STORES.ACTIVITY_LOG, { date: today, count });
                state.setState({ activityLog: { ...state.data.activityLog, [today]: count }});

                const lastLog = new Date(state.data.userProfile.lastLogin || 0);
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                
                let newStreak = state.data.userProfile.streak || 0;
                if (lastLog.toDateString() !== new Date().toDateString()) {
                    if (lastLog.toDateString() === yesterday.toDateString()) {
                        newStreak++;
                    } else {
                        newStreak = 1;
                    }
                }
                
                if (newStreak >= 7) Services.checkAndGrantAchievement('STREAK_7');

                const currentHour = new Date().getHours();
                if(currentHour >= 0 && currentHour < 4) Services.checkAndGrantAchievement('NIGHT_OWL');

                api.updateUserProfile({...state.data.userProfile, streak: newStreak, lastLogin: new Date().toISOString() });
            },
            async bulkDeleteCards(cardIds) {
                for (const id of cardIds) {
                    await DB.delete(DB_CONFIG.STORES.CARDS, id);
                }
                await api.loadDeckDetailData(state.data.currentDeckId);
                state.setState({ bulkEditState: { enabled: false, selectedCards: new Set() }});
                showToast(`${cardIds.size}개의 카드를 삭제했습니다.`, 'success');
            },
            async bulkMoveCards(cardIds, targetDeckId) {
                for (const id of cardIds) {
                    const card = await DB.get(DB_CONFIG.STORES.CARDS, id);
                    if(card) {
                        await DB.update(DB_CONFIG.STORES.CARDS, {...card, deckId: targetDeckId});
                    }
                }
                await api.loadDeckDetailData(state.data.currentDeckId);
                state.setState({ bulkEditState: { enabled: false, selectedCards: new Set() }});
                showToast(`${cardIds.size}개의 카드를 이동했습니다.`, 'success');
            },
            async mergeDecks(deckIds, newDeckName) {
                if (!newDeckName || !newDeckName.trim()) return showToast('새 단어장 이름을 입력하세요.', 'warning');
                const firstDeck = state.data.decks.find(d => d.id === deckIds[0]);
                if (!firstDeck) return;
                
                const newDeckId = await DB.add(DB_CONFIG.STORES.DECKS, {
                    categoryId: firstDeck.categoryId,
                    name: newDeckName,
                    createdAt: new Date()
                });

                for (const deckId of deckIds) {
                    const cardsToMove = await DB.getAllByIndex(DB_CONFIG.STORES.CARDS, 'deckId', deckId);
                    for (const card of cardsToMove) {
                        await DB.update(DB_CONFIG.STORES.CARDS, {...card, deckId: newDeckId });
                    }
                }
                await api.loadInitialData();
                showToast('단어장이 병합되었습니다.', 'success');
            },
            async exportDeck(deckId, format) {
                const cards = await DB.getAllByIndex(DB_CONFIG.STORES.CARDS, 'deckId', deckId);
                const deck = state.data.decks.find(d => d.id === deckId);
                let data, mimeType, extension;

                if (format === 'json') {
                    data = JSON.stringify(cards.map(({word, sentence, translation}) => ({word, sentence, translation})), null, 2);
                    mimeType = 'application/json';
                    extension = 'json';
                } else { // csv
                    const headers = 'word,sentence,translation';
                    const rows = cards.map(c => `"${c.word}","${c.sentence}","${c.translation}"`).join('\n');
                    data = `${headers}\n${rows}`;
                    mimeType = 'text/csv;charset=utf-8;';
                    extension = 'csv';
                }

                const blob = new Blob([data], { type: mimeType });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `${deck.name}.${extension}`;
                link.click();
                URL.revokeObjectURL(link.href);
            },
            async importCards(deckId, data, format) {
                let cardsToImport = [];
                try {
                    if (format === 'json') {
                        cardsToImport = JSON.parse(data);
                    } else { // csv
                        const rows = data.split('\n');
                        const headers = rows.shift().split(',').map(h => h.trim());
                        const wordIndex = headers.indexOf('word');
                        const sentenceIndex = headers.indexOf('sentence');
                        const translationIndex = headers.indexOf('translation');

                        if (wordIndex === -1 || sentenceIndex === -1 || translationIndex === -1) {
                            throw new Error('Invalid CSV headers');
                        }

                        cardsToImport = rows.map(row => {
                            const values = row.split('","').map(v => v.replace(/"/g, ''));
                            return {
                                word: values[wordIndex],
                                sentence: values[sentenceIndex],
                                translation: values[translationIndex]
                            };
                        });
                    }
                } catch(e) {
                    showToast('파일 형식이 잘못되었습니다.', 'error');
                    return;
                }
                
                await api.addCardsFromText(deckId, JSON.stringify(cardsToImport));
                closeModal();
            },
            async updateUserProfile(profile) {
                await DB.update(DB_CONFIG.STORES.USER_PROFILE, profile);
                state.setState({ userProfile: profile });
            },
            async addCategory(name, sourceLang, targetLang) {
                if (!name || !name.trim()) return showToast('카테고리 이름을 입력하세요.', 'warning');
                await DB.add(DB_CONFIG.STORES.CATEGORIES, { name, sourceLang, targetLang, createdAt: new Date() });
                await api.loadInitialData();
            },
            async updateCategory(id, name, sourceLang, targetLang) {
                if (!name || !name.trim()) return showToast('카테고리 이름을 입력하세요.', 'warning');
                const cat = await DB.get(DB_CONFIG.STORES.CATEGORIES, id);
                await DB.update(DB_CONFIG.STORES.CATEGORIES, { ...cat, name, sourceLang, targetLang });
                await api.loadInitialData();
            },
            async deleteCategory(id) {
                const decksToDelete = await DB.getAllByIndex(DB_CONFIG.STORES.DECKS, 'categoryId', id);
                for (const deck of decksToDelete) {
                    await api.deleteDeck(deck.id, true);
                }
                await DB.delete(DB_CONFIG.STORES.CATEGORIES, id);
                await api.loadInitialData();
            },
            async addDeck(categoryId, name) {
                if (!name || !name.trim()) return showToast('단어장 이름을 입력하세요.', 'warning');
                await DB.add(DB_CONFIG.STORES.DECKS, { categoryId, name, createdAt: new Date() });
                Services.checkAndGrantAchievement('FIRST_DECK');
                await api.loadInitialData();
            },
            async updateDeck(id, name) {
                if (!name || !name.trim()) return showToast('단어장 이름을 입력하세요.', 'warning');
                const deck = await DB.get(DB_CONFIG.STORES.DECKS, id);
                await DB.update(DB_CONFIG.STORES.DECKS, { ...deck, name });
                await api.loadInitialData();
            },
            async deleteDeck(id, fromCategoryDelete = false) {
                 const cardsToDelete = await DB.getAllByIndex(DB_CONFIG.STORES.CARDS, 'deckId', id);
                 for (const card of cardsToDelete) {
                     await DB.delete(DB_CONFIG.STORES.CARDS, card.id);
                 }
                 await DB.delete(DB_CONFIG.STORES.DECKS, id);
                 if (!fromCategoryDelete) await api.loadInitialData();
            },
            async loadDeckDetailData(deckId) {
                state.setState({ isLoading: true, currentDeckId: deckId, isAddingWords: false });
                const cards = await DB.getAllByIndex(DB_CONFIG.STORES.CARDS, 'deckId', deckId);
                state.setState({ cards, isLoading: false, isAddingWords: cards.length === 0 });
            },
            async addCardsFromText(deckId, jsonText) {
                 try {
                     const parsedCards = JSON.parse(jsonText);
                     if (!Array.isArray(parsedCards)) throw new Error("JSON is not an array.");
                     let createdCount = 0;
                     for (const card of parsedCards) {
                         if (card.word && card.sentence && card.translation) {
                             await DB.add(DB_CONFIG.STORES.CARDS, { deckId, ...card, srsLevel: 0, nextReviewAt: new Date(), streak: 0, lastAnswerCorrect: null, createdAt: new Date() });
                             createdCount++;
                         }
                     }
                     if (createdCount > 0) {
                         const allCardsInDb = await DB.getAll(DB_CONFIG.STORES.CARDS);
                         if(allCardsInDb.length >= 10) Services.checkAndGrantAchievement('TEN_CARDS');
                         await api.loadDeckDetailData(deckId);
                         showToast(`${createdCount}개의 카드가 생성되었습니다.`, 'success');
                     } else {
                         throw new Error("No valid cards found in JSON.");
                     }
                     return true;
                 } catch (e) { console.error("Manual add Error:", e); showToast('유효하지 않은 JSON 형식입니다. 다시 시도하세요.', 'error'); return false; }
            },
            async addCardsFromAI(deckId, wordsText) {
                if (!state.data.apiKey) return showModal(SettingsModalContent(true));
                const words = wordsText.split('\n').map(w => w.trim()).filter(Boolean);
                if (!words.length || words.length > 100) return showToast(words.length ? '최대 100개까지 가능합니다.' : '단어를 입력하세요.', 'warning');
                
                const currentDeck = state.data.decks.find(d => d.id === deckId);
                if (!currentDeck) return showToast('단어장을 찾을 수 없습니다.', 'error');
                const { sourceLang, targetLang } = currentDeck;

                state.setState({ isLoading: true });
                showToast('AI가 학습 카드를 생성 중입니다...', 'info');
                try {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${state.data.apiKey}`;
                    const prompt = Services.buildXMLPrompt(words, sourceLang, targetLang);
                    const payload = { contents: [{ parts: [{ text: prompt }] }] };
                    const res = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if (!res.ok) throw new Error(`API Error: ${res.statusText}`);
                    const result = await res.json();
                    const responseText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    const jsonMatch = responseText.match(/<json_response>([\s\S]*?)<\/json_response>/);
                    if (!jsonMatch || !jsonMatch[1]) throw new Error("JSON response not found in AI output.");
                    await api.addCardsFromText(deckId, jsonMatch[1].trim());
                } catch (e) { console.error("AI Error:", e); showToast('AI 카드 생성 실패. API 키를 확인하거나 나중에 다시 시도하세요.', 'error'); }
                finally { state.setState({ isLoading: false }); }
            },
            async updateCard(cardId, newWord, newSentence, newTranslation) {
                const card = await DB.get(DB_CONFIG.STORES.CARDS, cardId);
                await DB.update(DB_CONFIG.STORES.CARDS, { ...card, word: newWord, sentence: newSentence, translation: newTranslation });
                await api.loadDeckDetailData(card.deckId);
                showToast('카드가 수정되었습니다.', 'success');
            },
            async deleteCard(cardId) {
                const card = await DB.get(DB_CONFIG.STORES.CARDS, cardId);
                await DB.delete(DB_CONFIG.STORES.CARDS, cardId);
                await api.loadDeckDetailData(card.deckId);
            },
            async updateCardReview(card, isCorrect) {
                const updatedCard = Services.updateSrsData(card, isCorrect);
                await DB.update(DB_CONFIG.STORES.CARDS, updatedCard);
            },
            async startSmartReviewSession() {
                const allCards = await DB.getAll(DB_CONFIG.STORES.CARDS);
                const now = new Date();
                const reviewCards = allCards.filter(c => c.nextReviewAt && new Date(c.nextReviewAt) <= now);
                if (reviewCards.length === 0) return showToast('복습할 카드가 없습니다!', 'info');
                api.startQuizSession(reviewCards, QUIZ_TYPE.MEANING);
            },
            startLearnSession(cards) {
                if (cards.length === 0) return showToast('학습할 카드가 없습니다.', 'warning');
                state.setState({ currentView: 'learn', learnState: { active: true, cards, currentIndex: 0 } });
            },
            startQuizSession(allCards, type) {
                if (allCards.length < 1) return showToast('퀴즈를 진행할 카드가 없습니다.', 'warning');

                const weightedCards = allCards.map(card => ({ card, weight: Services.calculateWeight(card) }))
                                              .filter(item => item.weight > 0)
                                              .sort((a, b) => b.weight - a.weight);
                
                const questionCount = Math.min(weightedCards.length, state.data.quizQuestionCount);
                if(questionCount === 0) return showToast('지금은 퀴즈를 진행할 단어가 없습니다.', 'info');
                
                const selectedCards = weightedCards.slice(0, questionCount).map(item => item.card);

                const shuffled = [...selectedCards].sort(() => Math.random() - 0.5);
                state.setState({ 
                    currentView: 'quiz', 
                    quizState: { 
                        active: true, type, cards: shuffled, currentIndex: 0, score: 0, 
                        incorrectCards: [], isAnswered: false, timeLeft: QUIZ_TIME_LIMIT, quizHistory: []
                    } 
                });
                startQuestionTimer();
            },
            async resumeQuizSession() {
                const savedSession = await DB.get(DB_CONFIG.STORES.QUIZ_SESSIONS, 'current');
                if (savedSession) {
                    state.setState({
                        currentView: 'quiz',
                        quizState: savedSession.quizState,
                    });
                    startQuestionTimer();
                } else {
                    showToast('저장된 퀴즈가 없습니다.', 'info');
                }
            },
            async saveQuizSession() {
                const { quizState } = state.data;
                await DB.update(DB_CONFIG.STORES.QUIZ_SESSIONS, { id: 'current', quizState });
                showToast('퀴즈 진행 상황이 저장되었습니다.', 'success');
                api.loadInitialData().then(() => state.setState({ currentView: 'dashboard'}));
            },
            async deleteQuizSession() {
                await DB.delete(DB_CONFIG.STORES.QUIZ_SESSIONS, 'current');
                state.setState({ savedQuizSession: null });
            },
            endQuiz() {
                stopQuestionTimer();
                const { quizState, userProfile } = state.data;
                if(quizState.score === quizState.cards.length && quizState.cards.length > 0) {
                    Services.checkAndGrantAchievement('PERFECT_QUIZ');
                }
                const newXp = userProfile.xp + quizState.score * XP_PER_CORRECT;
                let newLevel = userProfile.level;
                while (LEVEL_THRESHOLDS[newLevel] && newXp >= LEVEL_THRESHOLDS[newLevel]) {
                    newLevel++;
                }
                
                api.updateUserProfile({ ...userProfile, xp: newXp, level: newLevel });
                Services.checkAndGrantAchievement('FIRST_QUIZ');
                api.deleteQuizSession();
                state.setState({ currentView: 'quizReview' });
            },
            async markCardAsKnown(cardId) {
                const card = await DB.get(DB_CONFIG.STORES.CARDS, cardId);
                if (card) {
                    const maxSrsLevel = SRS_INTERVALS.length - 1;
                    const updatedCard = { ...card, srsLevel: maxSrsLevel, nextReviewAt: new Date(Date.now() + SRS_INTERVALS[maxSrsLevel] * 1000) };
                    await DB.update(DB_CONFIG.STORES.CARDS, updatedCard);
                    return card; // Return original card for context (e.g., getting the name for a toast)
                }
                return null;
            }
        };

        // =================================================================================
        // 6. UI COMPONENTS & HELPERS
        // =================================================================================
        const mapLangToCode = (lang) => {
            const langMap = {
                'English': 'en-US', 'Korean': 'ko-KR', 'Japanese': 'ja-JP', 'Chinese': 'zh-CN',
                'Spanish': 'es-ES', 'French': 'fr-FR', 'German': 'de-DE', 'Russian': 'ru-RU'
            };
            return langMap[lang] || 'en-US';
        };
        const mapCodeToLang = (code) => {
            const codeMap = {
                'en-US': 'English', 'ko-KR': 'Korean', 'ja-JP': 'Japanese', 'zh-CN': 'Chinese',
                'es-ES': 'Spanish', 'fr-FR': 'French', 'de-DE': 'German', 'ru-RU': 'Russian'
            };
            const baseCode = code.split('-')[0];
            for (const key in codeMap) {
                if (key.startsWith(baseCode)) {
                    return codeMap[key];
                }
            }
            return code; // Fallback to the code itself if no match is found
        };
        const I = (name, classes = "w-4 h-4") => `<i data-lucide="${name}" class="${classes}"></i>`;
        const showToast = (message, type = 'info', duration = 3000) => { state.setState({ toast: { message, type, visible: true } }); setTimeout(() => state.setState({ toast: { ...state.data.toast, visible: false } }), duration); };
        const showModal = (content) => { state.setState({ modal: { visible: true, content } }); };
        const closeModal = () => { state.setState({ modal: { visible: false, content: '' } }); };
        const ToastComponent = ({ message, type, visible }) => visible ? `<div class="fixed top-5 right-5 z-[100] ${ {info:'bg-blue-500', success:'bg-emerald-500', warning:'bg-yellow-500', error:'bg-red-500'}[type] } text-white py-2 px-4 rounded-lg shadow-lg fade-in">${message}</div>` : '';
        const ModalComponent = ({ visible, content }) => visible ? `<div id="modal-backdrop" class="fixed inset-0 bg-black/60 flex items-center justify-center z-50 fade-in"><div id="modal-content" class="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-2xl m-4">${content}</div></div>` : '';
        const SettingsModalContent = (fromError = false) => `
            <h3 class="text-xl font-bold mb-6">설정</h3>
            ${fromError ? `<p class="text-red-400 text-sm mb-4">AI 또는 TTS 기능을 사용하려면 Google AI Studio에서 발급받은 API 키가 필요합니다.</p>` : ''}
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-1">테마 색상</label>
                    <div class="flex gap-2">
                        ${['blue', 'green', 'purple', 'red'].map(color => `
                            <button data-color="${color}" class="theme-color-btn h-8 w-8 rounded-full bg-${color}-500 ${state.data.themeColor === color ? 'ring-2 ring-offset-2 dark:ring-offset-slate-800 ring-blue-500' : ''}"></button>
                        `).join('')}
                    </div>
                </div>
                <div>
                    <label for="api-key-input" class="block text-sm font-medium mb-1">Google AI API Key</label>
                    <input id="api-key-input" type="password" value="${state.data.apiKey || ''}" class="w-full border p-2 rounded bg-slate-100 dark:bg-slate-700 dark:border-slate-600" placeholder="API 키를 여기에 붙여넣으세요">
                    <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-xs text-blue-500 hover:underline">여기서 API 키를 발급받으세요.</a>
                </div>
                 <div>
                    <label for="quiz-question-count-input" class="block text-sm font-medium mb-1">퀴즈 문제 수</label>
                    <input id="quiz-question-count-input" type="number" value="${state.data.quizQuestionCount}" class="w-full border p-2 rounded bg-slate-100 dark:bg-slate-700 dark:border-slate-600">
                </div>
                <div>
                    <label for="prompt-template-input" class="block text-sm font-medium mb-1">AI 프롬프트 템플릿</label>
                    <textarea id="prompt-template-input" class="w-full h-48 p-2 text-xs font-mono bg-slate-100 dark:bg-slate-900 rounded border dark:border-slate-600">${state.data.promptTemplate}</textarea>
                    <p class="text-xs text-slate-500 mt-1">사용 가능한 변수: <code class="bg-slate-200 dark:bg-slate-700 rounded px-1">{{sourceLang}}</code>, <code class="bg-slate-200 dark:bg-slate-700 rounded px-1">{{targetLang}}</code>, <code class="bg-slate-200 dark:bg-slate-700 rounded px-1">{{wordList}}</code></p>
                </div>
            </div>
            <div class="flex justify-end gap-2 mt-6">
                <button id="modal-cancel" class="bg-slate-300 dark:bg-slate-600 hover:bg-slate-400 font-bold py-2 px-4 rounded">취소</button>
                <button id="modal-confirm-save-settings" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">저장</button>
            </div>`;
        const OnboardingModalContent = () => `
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2">${I('party-popper', 'w-6 h-6 text-yellow-400')} AI Vocabulary Hub에 오신 것을 환영합니다!</h3>
            <p class="mb-2 text-slate-600 dark:text-slate-300">이 앱은 당신만의 단어장을 만들고, AI와 함께 효율적으로 단어를 암기할 수 있도록 돕습니다.</p>
            <p class="font-semibold mb-4">시작하는 방법:</p>
            <ol class="list-decimal list-inside space-y-2 mb-4">
                <li><span class="font-bold">'새 카테고리'</span>를 눌러 'TOEIC'이나 '비즈니스 영어' 같은 주제를 만드세요.</li>
                <li>카테고리 안에서 <span class="font-bold">'단어장 추가'</span> 버튼으로 세부 단어장을 만드세요.</li>
                <li>단어장에 들어가 단어를 입력하고 <span class="font-bold">'AI로 자동 생성'</span>을 눌러보세요! (설정에서 API 키 입력 필요)</li>
            </ol>
            <div class="flex justify-end gap-2 mt-4">
                <button id="modal-cancel" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">시작하기</button>
            </div>`;
        const extractQTagContent = (str) => {
            if (!str) return '';
            const match = str.match(/<q>(.*?)<\/q>/);
            return match ? match[1].trim() : '';
        }
        const renderClozeSentence = (sentence, isDisabled) => sentence.replace(/<q>.*?<\/q>/, `<input id="cloze-answer-input" type="text" class="inline-block w-32 text-center text-lg border-b-2 p-1 bg-transparent border-slate-400 focus:outline-none focus:border-blue-500 transition-colors" autocomplete="off" autofocus ${isDisabled ? 'disabled' : ''}>`);
        const SpecialCharacterPanel = (lang) => {
            const charMap = {
                'French': ['é', 'è', 'ê', 'ë', 'ç', 'à', 'â', 'î', 'ô', 'û', 'ù', 'œ'],
                'German': ['ä', 'ö', 'ü', 'ß'],
                'Spanish': ['á', 'é', 'í', 'ó', 'ú', 'ñ', 'ü', '¡', '¿'],
            };
            const chars = charMap[lang];
            if (!chars) return '';

            return `
                <div class="mt-4 flex flex-wrap justify-center gap-2">
                    ${chars.map(char => `<button type="button" class="special-char-btn bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 font-mono text-lg rounded-md w-10 h-10" data-char="${char}">${char}</button>`).join('')}
                </div>
            `;
        };
        
        // =================================================================================
        // 7. VIEWS
        // =================================================================================
        const MainHeader = ({ profile, searchQuery }) => `
            <header class="bg-white dark:bg-slate-800 shadow-lg p-4 flex justify-between items-center border-b border-slate-200 dark:border-slate-700 sticky top-0 z-10">
                <div class="flex items-center gap-2">
                    <div class="bg-blue-100 dark:bg-blue-900/50 p-2 rounded-lg">
                        ${I('brain-circuit', 'w-8 h-8 text-blue-500')}
                    </div>
                    <h1 class="text-2xl font-bold cursor-pointer" id="home-btn">AI Vocabulary Hub</h1>
                </div>
                <div class="flex items-center gap-2 w-1/3">
                     <div class="relative w-full">
                         <input id="search-input" type="text" placeholder="단어장, 카드 검색..." value="${searchQuery}" class="w-full pl-10 pr-4 py-2 rounded-full bg-slate-100 dark:bg-slate-700 border border-transparent focus:bg-white focus:border-blue-500 dark:focus:bg-slate-800 transition">
                         <div class="absolute left-3 top-1/2 -translate-y-1/2 text-slate-400">${I('search', 'w-5 h-5')}</div>
                     </div>
                </div>
                <div class="flex items-center gap-4">
                    <div class="text-sm text-right">
                        <span class="font-bold text-lg">Lv. ${profile.level}</span>
                        <div class="w-32 bg-slate-200 dark:bg-slate-700 rounded-full h-2.5 mt-1" title="${profile.xp} XP">
                            <div class="bg-blue-500 h-2.5 rounded-full transition-all duration-500" style="width: ${Math.min(100, (profile.xp - (LEVEL_THRESHOLDS[profile.level - 1] || 0)) / ((LEVEL_THRESHOLDS[profile.level] || Infinity) - (LEVEL_THRESHOLDS[profile.level - 1] || 0)) * 100)}%"></div>
                        </div>
                    </div>
                    <button id="profile-btn" class="p-2 hover:bg-slate-200 dark:hover:bg-slate-700 rounded-full transition-colors" title="내 정보">${I('user')}</button>
                    <button id="settings-btn" class="p-2 hover:bg-slate-200 dark:hover:bg-slate-700 rounded-full transition-colors" title="설정">${I('settings')}</button>
                </div>
            </header>`;
            
        const DashboardView = ({ categories, decks, userProfile, reviewCardCount, savedQuizSession, searchQuery }) => {
            const lowerQuery = searchQuery.toLowerCase();
            const filteredDecks = searchQuery ? decks.filter(d => d.name.toLowerCase().includes(lowerQuery)) : decks;
            const filteredCategories = searchQuery ? categories.filter(c => c.name.toLowerCase().includes(lowerQuery) || filteredDecks.some(d => d.categoryId === c.id)) : categories;

            return `
            ${MainHeader({ profile: userProfile, searchQuery })}
            <main class="flex-1 p-6 overflow-y-auto">
                <div class="max-w-7xl mx-auto">
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                        <button id="start-smart-review-btn" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-5 px-5 rounded-lg flex items-center justify-center gap-3 text-lg transition-all hover:scale-105 shadow-md hover:shadow-lg relative lg:col-span-1">
                            ${I('sparkles')} 스마트 복습 시작 
                            <span class="absolute -top-2 -right-2 bg-red-500 text-white text-xs font-bold rounded-full h-6 w-6 flex items-center justify-center">${reviewCardCount}</span>
                        </button>
                        ${savedQuizSession ? `
                        <button id="resume-quiz-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-5 px-5 rounded-lg flex items-center justify-center gap-3 text-lg transition-all hover:scale-105 shadow-md hover:shadow-lg relative lg:col-span-1">
                            ${I('play-circle')} 퀴즈 이어하기
                        </button>
                        ` : ''}
                        <button id="add-category-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-5 px-5 rounded-lg flex items-center justify-center gap-3 text-lg transition-all hover:scale-105 shadow-md hover:shadow-lg ${savedQuizSession ? 'lg:col-start-3' : ''} lg:col-span-1">
                            ${I('plus-circle')} 새 카테고리
                        </button>
                    </div>
                    <div id="category-list" class="space-y-8">
                        ${filteredCategories.map((category, index) => `
                            <div class="bg-white dark:bg-slate-800 rounded-lg shadow-md p-5 group fade-in-up" style="animation-delay: ${index * 100}ms">
                                <div class="flex justify-between items-center mb-4">
                                    <div class="flex items-center gap-3">
                                        <h2 class="text-2xl font-bold">${category.name}</h2>
                                        <span class="text-xs font-semibold bg-slate-200 dark:bg-slate-700 px-2 py-1 rounded-full">${category.sourceLang} → ${category.targetLang}</span>
                                    </div>
                                    <div class="flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                                        <button class="edit-category-btn p-1.5 text-slate-500 hover:text-slate-800 dark:hover:text-slate-200" data-id="${category.id}" data-name="${category.name}" data-sl="${category.sourceLang}" data-tl="${category.targetLang}">${I('file-pen-line', 'w-5 h-5')}</button>
                                        <button class="delete-category-btn p-1.5 text-slate-500 hover:text-red-500" data-id="${category.id}" data-name="${category.name}">${I('trash-2', 'w-5 h-5')}</button>
                                        <button class="add-deck-btn bg-blue-500 hover:bg-blue-600 text-white text-sm py-1.5 px-4 rounded-full flex items-center gap-1.5 transition-colors" data-category-id="${category.id}">${I('plus','w-4 h-4')} 단어장 추가</button>
                                    </div>
                                </div>
                                <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                                    ${filteredDecks.filter(d => d.categoryId === category.id).map(deck => `
                                        <div class="deck-item bg-slate-50 dark:bg-slate-700/50 rounded-lg p-4 group/deck relative cursor-pointer hover:shadow-lg hover:-translate-y-1 transition-all duration-300" data-deck-id="${deck.id}">
                                            <div class="flex justify-between items-start">
                                                <h3 class="font-semibold text-lg pr-10">${deck.name}</h3>
                                                <div class="absolute top-2 right-2 flex gap-1 opacity-0 group-hover/deck:opacity-100 transition-opacity">
                                                    <button class="edit-deck-btn p-1 text-slate-500 hover:text-slate-800 dark:hover:text-slate-200" data-id="${deck.id}" data-name="${deck.name}" title="수정">${I('file-pen-line','w-3.5 h-3.5')}</button>
                                                    <button class="delete-deck-btn p-1 text-slate-500 hover:text-red-500" data-id="${deck.id}" data-name="${deck.name}" title="삭제">${I('trash-2','w-3.5 h-3.5')}</button>
                                                </div>
                                            </div>
                                            <p class="text-xs text-slate-500 dark:text-slate-400 mt-2">${deck.cardCount} cards</p>
                                            <div class="w-full bg-slate-200 dark:bg-slate-600 rounded-full h-2 mt-2">
                                                <div class="bg-emerald-500 h-2 rounded-full" style="width: ${deck.mastery}%" title="숙련도 ${deck.mastery}%"></div>
                                            </div>
                                        </div>`).join('')}
                                </div>
                            </div>`).join('') || `<div class="text-center py-20 text-slate-500"><p class="text-lg">${searchQuery ? '검색 결과가 없습니다.' : '카테고리가 없습니다.'}</p></div>`}
                    </div>
                </div>
            </main>`;
        };

        const DeckDetailView = ({ deck, cards, isAddingWords, sortCriteria, bulkEditState, searchQuery }) => {
            if (!deck) return `<div class="flex items-center justify-center h-full"><p>단어장을 찾을 수 없습니다.</p></div>`;

            // Use the centralized sorting service
            const sortedCards = Services.sortCards(cards, sortCriteria);
            
            const lowerQuery = searchQuery.toLowerCase();
            const filteredCards = searchQuery 
                ? sortedCards.filter(c => 
                    c.word.toLowerCase().includes(lowerQuery) || 
                    c.sentence.toLowerCase().includes(lowerQuery) || 
                    c.translation.toLowerCase().includes(lowerQuery)) 
                : sortedCards;
                
            const AddWordsPanel = () => `
                <div class="bg-white dark:bg-slate-800 rounded-lg shadow-md p-5 flex flex-col h-full">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold">단어 추가 (${deck.sourceLang})</h2>
                        ${cards.length > 0 ? `<button id="back-to-learn-panel-btn" class="text-sm bg-slate-200 dark:bg-slate-700 py-1 px-3 rounded-full flex items-center gap-1">${I('arrow-left', 'w-3 h-3')} 학습으로</button>` : ''}
                    </div>
                    <textarea id="word-input-area" class="flex-1 w-full p-3 border rounded bg-slate-100 dark:bg-slate-700 border-slate-300 dark:border-slate-600 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none transition" placeholder="학습할 단어를 한 줄에 하나씩 입력하세요..."></textarea>
                    <div class="grid grid-cols-2 gap-4 mt-4">
                        <button id="generate-ai-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors shadow hover:shadow-md">${I('wand-sparkles')} AI로 자동 생성</button>
                        <button id="manual-generate-btn" class="w-full bg-slate-500 hover:bg-slate-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors shadow hover:shadow-md">${I('edit-3')} 수동 생성 가이드</button>
                    </div>
                </div>`;
            
            const LearnPanel = () => `
                <div class="bg-white dark:bg-slate-800 rounded-lg shadow-md p-5 flex flex-col h-full justify-between">
                    <div>
                        <h2 class="text-2xl font-bold mb-3">학습 준비 완료</h2>
                        <p class="text-slate-600 dark:text-slate-300">이 단어장에 ${cards.length}개의 학습 카드가 있습니다. 바로 학습을 시작하거나 단어를 더 추가할 수 있습니다.</p>
                    </div>
                    <div class="space-y-4 mt-6">
                          <button id="start-learning-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 text-lg transition-transform hover:scale-105">${I('book-open')} 학습 모드</button>
                          <button id="start-quiz-meaning-btn" class="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 text-lg transition-transform hover:scale-105">${I('swords')} 뜻 맞추기 퀴즈</button>
                          <button id="start-quiz-listening-btn" class="w-full bg-sky-500 hover:bg-sky-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 text-lg transition-transform hover:scale-105">${I('headphones')} 듣기 퀴즈</button>
                          <button id="start-quiz-cloze-btn" class="w-full bg-purple-500 hover:bg-purple-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 text-lg transition-transform hover:scale-105">${I('pencil-ruler')} 빈칸 채우기 퀴즈</button>
                    </div>
                    <button id="toggle-add-words-btn" class="w-full mt-8 bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 text-sm py-2 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors">${I('plus', 'w-4 h-4')} 단어 더 추가하기</button>
                </div>`;

            return `
            <header class="bg-white dark:bg-slate-800 shadow-lg p-4 flex justify-between items-center border-b border-slate-200 dark:border-slate-700">
                <div class="flex items-center gap-3">
                    <button id="back-to-dashboard-btn" class="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors">${I('arrow-left')}</button>
                    <div>
                        <h1 class="text-2xl font-bold">${deck.name}</h1>
                        <p class="text-sm text-slate-500">${deck.sourceLang} → ${deck.targetLang}</p>
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <button id="deck-import-btn" class="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700" title="가져오기">${I('import')}</button>
                    <button id="deck-export-btn" class="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700" title="내보내기">${I('export')}</button>
                </div>
            </header>
            <main class="flex-1 grid grid-cols-1 lg:grid-cols-2 gap-6 p-6 overflow-hidden">
                <div class="lg:h-full">
                    ${isAddingWords ? AddWordsPanel() : LearnPanel()}
                </div>
                <div class="bg-white dark:bg-slate-800 rounded-lg shadow-md p-5 flex flex-col min-h-0">
                    <div class="flex justify-between items-center mb-3 flex-shrink-0">
                        <h2 class="text-xl font-semibold">학습 세트 (${filteredCards.length}개)</h2>
                        <div class="flex items-center gap-2">
                            <select id="sort-criteria-select" class="text-sm rounded border-slate-300 dark:bg-slate-700 dark:border-slate-600 focus:ring-blue-500 focus:border-blue-500">
                                <option value="priority-desc" ${sortCriteria === 'priority-desc' ? 'selected' : ''}>우선순위순</option>
                                <option value="createdAt-desc" ${sortCriteria === 'createdAt-desc' ? 'selected' : ''}>최신순</option>
                                <option value="createdAt-asc" ${sortCriteria === 'createdAt-asc' ? 'selected' : ''}>오래된순</option>
                                <option value="word-asc" ${sortCriteria === 'word-asc' ? 'selected' : ''}>알파벳순</option>
                            </select>
                            <button id="bulk-edit-toggle-btn" class="p-2 rounded hover:bg-slate-200 dark:hover:bg-slate-700">${I(bulkEditState.enabled ? 'x' : 'edit', 'w-4 h-4')}</button>
                        </div>
                    </div>
                    ${bulkEditState.enabled ? `
                    <div class="flex-shrink-0 mb-2 p-2 bg-blue-100 dark:bg-blue-900/50 rounded-md flex justify-between items-center">
                        <span>${bulkEditState.selectedCards.size}개 선택됨</span>
                        <div>
                           <button id="bulk-move-btn" class="p-2 rounded hover:bg-slate-200 dark:hover:bg-slate-700" title="이동">${I('move-right', 'w-4 h-4')}</button>
                           <button id="bulk-delete-btn" class="p-2 rounded hover:bg-slate-200 dark:hover:bg-slate-700" title="삭제">${I('trash-2', 'w-4 h-4')}</button>
                        </div>
                    </div>` : ''}
                    <div class="flex-1 overflow-y-auto space-y-2 pr-2 overscroll-contain">${filteredCards.map(c => `
                        <div class="border border-slate-200 dark:border-slate-700 rounded-lg p-3 group/card relative flex items-center gap-3 transition-colors hover:bg-slate-50 dark:hover:bg-slate-700/50">
                            ${bulkEditState.enabled ? `<input type="checkbox" data-card-id="${c.id}" class="bulk-edit-checkbox accent-blue-500" ${bulkEditState.selectedCards.has(c.id) ? 'checked' : ''}>` : ''}
                            <div class="flex-1">
                                <div class="flex items-center justify-between">
                                    <p class="font-bold text-slate-800 dark:text-slate-100">${c.word}</p>
                                    ${(c.srsLevel || 0) >= 7 ? `<span title="마스터한 단어">${I('award', 'w-4 h-4 text-yellow-500')}</span>` : ''}
                                </div>
                                <p class="text-sm text-slate-600 dark:text-slate-300 mt-1">${c.sentence.replace(/<q>/g, '<q>').replace(/<\/q>/g, '</q>')}</p>
                                <p class="text-sm text-blue-600 dark:text-blue-400 mt-1">${c.translation.replace(/<q>/g, '<q>').replace(/<\/q>/g, '</q>')}</p>
                            </div>
                            <div class="absolute top-2 right-2 flex gap-1 opacity-0 group-hover/card:opacity-100 transition-opacity">
                                <button class="know-this-card-btn p-1 text-slate-500 hover:text-emerald-500" data-id="${c.id}" title="아는 단어 (학습에서 제외)">${I('eye-off','w-3.5 h-3.5')}</button>
                                <button class="edit-card-btn p-1 text-slate-500 hover:text-blue-500" data-id="${c.id}" title="수정">${I('file-pen-line','w-3.5 h-3.5')}</button>
                                <button class="delete-card-btn p-1 text-slate-500 hover:text-red-500" data-id="${c.id}" title="삭제">${I('trash-2','w-3.5 h-3.5')}</button>
                            </div>
                        </div>`).join('') || `<div class="text-center py-10 text-slate-500"><p>${searchQuery ? '검색 결과가 없습니다.' : '추가된 단어가 없습니다.'}</p></div>`}
                    </div>
                </div>
            </main>`;
        }
        const LearnView = ({ learnState }) => {
            if (!learnState.cards || learnState.cards.length === 0) {
                 return `
                    <header class="bg-white dark:bg-slate-800 shadow-lg p-4 flex justify-between items-center border-b border-slate-200 dark:border-slate-700">
                        <div class="flex items-center gap-3">
                            <button id="back-to-deck-btn" class="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700">${I('arrow-left')}</button>
                            <h1 class="text-2xl font-bold">학습 완료</h1>
                        </div>
                    </header>
                    <main class="flex-1 flex flex-col items-center justify-center p-6">
                        <div class="text-center">
                            <h2 class="text-2xl font-bold">모든 카드를 학습했습니다!</h2>
                            <button id="back-to-deck-btn" class="mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded">단어장으로 돌아가기</button>
                        </div>
                    </main>
                `;
            }
            const card = learnState.cards[learnState.currentIndex];
            const currentDeck = state.data.decks.find(d => d.id === card.deckId);
            const sourceLangCode = mapLangToCode(currentDeck?.sourceLang);
            return `
            <header class="bg-white dark:bg-slate-800 shadow-lg p-4 flex justify-between items-center border-b border-slate-200 dark:border-slate-700">
                <div class="flex items-center gap-3">
                    <button id="back-to-deck-btn" class="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700">${I('arrow-left')}</button>
                    <h1 class="text-2xl font-bold">학습 모드</h1>
                </div>
                 <div class="flex items-center gap-4">
                    <button id="learn-know-this-card-btn" data-id="${card.id}" class="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors" title="아는 단어 (학습에서 제외)">${I('eye-off')}</button>
                    <div class="font-semibold text-lg">${learnState.currentIndex + 1} / ${learnState.cards.length}</div>
                </div>
            </header>
            <main class="flex-1 flex flex-col items-center justify-center p-6">
                <div class="w-full max-w-2xl perspective">
                    <div id="flashcard" class="flip-card w-full h-80 relative cursor-pointer" data-tts-text="${card.word}" data-tts-lang="${sourceLangCode}">
                        <div class="flip-card-inner absolute w-full h-full">
                            <div class="flip-card-front absolute w-full h-full bg-white dark:bg-slate-800 rounded-lg shadow-xl flex flex-col items-center justify-center p-6 text-center border border-slate-200 dark:border-slate-700">
                                <p class="text-5xl font-extrabold tracking-tight">${card.word}</p>
                                <button id="tts-btn" data-tts-text="${card.word}" data-tts-lang="${sourceLangCode}" class="mt-4 p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors">${I('volume-2')}</button>
                            </div>
                            <div class="flip-card-back absolute w-full h-full bg-white dark:bg-slate-800 rounded-lg shadow-xl flex flex-col items-center justify-center p-6 text-center space-y-4 border border-slate-200 dark:border-slate-700">
                                <p class="text-xl">${card.sentence.replace(/<q>/g, '<q>').replace(/<\/q>/g, '</q>')}</p>
                                <p class="text-xl font-semibold text-blue-500">${card.translation.replace(/<q>/g, '<q>').replace(/<\/q>/g, '</q>')}</p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex items-center justify-between w-full max-w-2xl mt-8">
                    <button id="prev-card-btn" class="p-4 rounded-full bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors disabled:opacity-50" ${learnState.currentIndex === 0 ? 'disabled' : ''}>${I('arrow-left')}</button>
                    <span class="text-sm text-slate-500">카드를 클릭하거나 스페이스바를 누르세요</span>
                    <button id="next-card-btn" class="p-4 rounded-full bg-slate-200 dark:bg-slate-700 hover:bg-slate-300 dark:hover:bg-slate-600 transition-colors disabled:opacity-50" ${learnState.currentIndex === learnState.cards.length - 1 ? 'disabled' : ''}>${I('arrow-right')}</button>
                </div>
            </main>`;
        };
        const QuizView = ({ quizState }) => {
            const card = quizState.cards[quizState.currentIndex];
            const currentDeck = state.data.decks.find(d => d.id === card.deckId);
            const sourceLangCode = mapLangToCode(currentDeck?.sourceLang);

            const QuestionArea = () => {
                if(quizState.type === QUIZ_TYPE.LISTENING) {
                    if (!quizState.isAnswered) {
                        setTimeout(() => document.getElementById('tts-btn')?.click(), 200);
                    }
                    return `
                        <p class="text-slate-500 text-lg">들리는 단어의 뜻을 입력하세요.</p>
                        <button id="tts-btn" data-tts-text="${card.word}" data-tts-lang="${sourceLangCode}" class="my-8 p-4 bg-blue-500 text-white rounded-full hover:bg-blue-600">${I('volume-2', 'w-12 h-12')}</button>
                    `;
                }
                if (quizState.type === QUIZ_TYPE.MEANING) {
                    return `<p class="text-slate-500 text-lg">다음 단어의 뜻은?</p>
                            <div class="flex items-center justify-center gap-4 my-8">
                                <h2 class="text-6xl font-extrabold text-blue-500">${card.word}</h2>
                                <button id="tts-btn" data-tts-text="${card.word}" data-tts-lang="${sourceLangCode}" class="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700">${I('volume-2')}</button>
                            </div>
                    `;
                }
                if (quizState.type === QUIZ_TYPE.CLOZE) {
                    return `<p class="text-slate-500 text-lg">빈칸에 알맞은 단어는?</p><h2 class="text-3xl font-bold my-6 text-center leading-relaxed">${renderClozeSentence(card.sentence, quizState.isAnswered)}</h2><p class="text-lg text-slate-500 dark:text-slate-400 mt-4">${card.translation}</p>`;
                }
                return '';
            };

            const timePercentage = (quizState.timeLeft / QUIZ_TIME_LIMIT) * 100;
            const timeColor = timePercentage > 50 ? 'bg-emerald-500' : timePercentage > 25 ? 'bg-yellow-500' : 'bg-red-500';

            return `
            <header class="bg-white dark:bg-slate-800 shadow-lg p-4 sticky top-0 z-10">
                <div class="flex items-center justify-between gap-4">
                    <button id="exit-quiz-btn" class="p-2 rounded-full hover:bg-slate-200 dark:hover:bg-slate-700">${I('x')}</button>
                    <div class="font-bold text-lg w-16 text-center">${quizState.currentIndex + 1} / ${quizState.cards.length}</div>
                    <div class="w-full bg-slate-200 dark:bg-slate-700 rounded-full h-4 overflow-hidden">
                        <div id="quiz-timer-bar" class="${timeColor} h-4" style="width: 100%"></div>
                    </div>
                    <div id="quiz-timer-text" class="font-bold text-lg w-12 text-right">${quizState.timeLeft}s</div>
                </div>
            </header>
            <main class="flex-1 flex flex-col items-center justify-center p-6 text-center">
                ${QuestionArea()}
                <form id="quiz-form" class="w-full max-w-md">
                    ${quizState.type !== QUIZ_TYPE.CLOZE ? `<input id="answer-input" type="text" class="w-full text-center text-xl border-b-2 p-2 bg-transparent border-slate-400 focus:outline-none focus:border-blue-500 transition-colors" autocomplete="off" autofocus ${quizState.isAnswered ? 'disabled' : ''}>` : ''}
                    ${SpecialCharacterPanel(currentDeck.sourceLang)}
                    <div id="feedback-area" class="h-10 mt-4 text-lg font-semibold"></div>
                    <button type="submit" class="mt-4 bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-12 rounded-lg text-lg transition-colors shadow hover:shadow-md disabled:bg-slate-400 dark:disabled:bg-slate-600 disabled:cursor-not-allowed" ${quizState.isAnswered ? 'disabled' : ''}>제출</button>
                </form>
            </main>`;
        };
        const QuizReviewView = ({ quizState, userProfile }) => `
            <header class="bg-white dark:bg-slate-800 shadow-lg p-4 flex justify-between items-center border-b border-slate-200 dark:border-slate-700">
                <h1 class="text-2xl font-bold">퀴즈 결과 및 리뷰</h1>
            </header>
            <main class="flex-1 p-6 overflow-y-auto">
                <div class="max-w-4xl mx-auto">
                    <div class="bg-white dark:bg-slate-800 rounded-lg shadow-md p-6 mb-6 text-center">
                        <h2 class="text-2xl font-bold">최종 점수</h2>
                        <p class="text-6xl font-extrabold my-4">${quizState.score} / ${quizState.cards.length}</p>
                        <p class="text-yellow-400 font-semibold text-xl flex items-center justify-center gap-2">${I('award', 'inline-block w-6 h-6')} +${quizState.score * XP_PER_CORRECT} XP</p>
                    </div>
                    <div class="bg-white dark:bg-slate-800 rounded-lg shadow-md p-6">
                        <h3 class="text-xl font-bold mb-4">상세 리뷰</h3>
                        <div class="space-y-3">
                        ${quizState.quizHistory.map(item => `
                            <div class="p-3 rounded-lg ${item.isCorrect ? 'bg-emerald-50 dark:bg-emerald-900/50' : 'bg-red-50 dark:bg-red-900/50'}">
                                <div class="flex items-center gap-3">
                                    ${item.isCorrect ? I('check-circle', 'w-5 h-5 text-emerald-500') : I('x-circle', 'w-5 h-5 text-red-500')}
                                    <p class="font-bold text-lg">${item.card.word}</p>
                                </div>
                                <div class="pl-8 mt-1 text-sm space-y-1">
                                    <p><span class="font-semibold">제출한 답:</span> ${item.userAnswer || '<span class="text-slate-500">미입력</span>'}</p>
                                    <p><span class="font-semibold">정답:</span> ${extractQTagContent(item.card.translation)}</p>
                                </div>
                            </div>
                        `).join('')}
                        </div>
                    </div>
                     <div class="flex justify-center gap-4 mt-8">
                         <button id="back-to-dashboard-btn" class="bg-slate-500 hover:bg-slate-600 text-white font-bold py-3 px-6 rounded-lg transition-colors">완료</button>
                         ${quizState.incorrectCards.length > 0 ? `<button id="retry-incorrect-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-lg transition-colors">틀린 문제 다시 풀기</button>` : ''}
                    </div>
                </div>
            </main>`;

        const ProfileView = ({ userProfile, allCards, activityLog }) => {
            const totalCards = allCards.length;
            const learnedCards = allCards.filter(c => (c.srsLevel || 0) > 0).length;
            const masteredCards = allCards.filter(c => (c.srsLevel || 0) >= 7).length;

            const today = new Date();
            const oneYearAgo = new Date();
            oneYearAgo.setFullYear(today.getFullYear() - 1);

            const dates = [];
            let currentDate = oneYearAgo;
            while (currentDate <= today) {
                dates.push(new Date(currentDate));
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            const firstDay = dates[0].getDay();

            return `
            ${MainHeader({profile: userProfile, searchQuery: state.data.searchQuery})}
            <main class="flex-1 p-6 overflow-y-auto">
                <div class="max-w-4xl mx-auto">
                    <h1 class="text-3xl font-bold mb-6">내 정보</h1>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-6 mb-8">
                        <div class="bg-white dark:bg-slate-800 p-4 rounded-lg shadow-md text-center">
                            <h3 class="text-sm font-semibold text-slate-500">연속 학습</h3>
                            <p class="text-3xl font-bold">${userProfile.streak || 0}일</p>
                        </div>
                        <div class="bg-white dark:bg-slate-800 p-4 rounded-lg shadow-md text-center">
                            <h3 class="text-sm font-semibold text-slate-500">총 단어</h3>
                            <p class="text-3xl font-bold">${totalCards}</p>
                        </div>
                        <div class="bg-white dark:bg-slate-800 p-4 rounded-lg shadow-md text-center">
                            <h3 class="text-sm font-semibold text-slate-500">학습한 단어</h3>
                            <p class="text-3xl font-bold">${learnedCards}</p>
                        </div>
                        <div class="bg-white dark:bg-slate-800 p-4 rounded-lg shadow-md text-center">
                            <h3 class="text-sm font-semibold text-slate-500">마스터한 단어</h3>
                            <p class="text-3xl font-bold">${masteredCards}</p>
                        </div>
                    </div>
                     <div class="bg-white dark:bg-slate-800 rounded-lg shadow-md p-6 mb-8">
                         <h3 class="text-xl font-bold mb-4">학습 활동</h3>
                         <div class="grid grid-flow-col grid-rows-7 gap-1">
                             ${Array(firstDay).fill(0).map(() => '<div></div>').join('')}
                             ${dates.map(date => {
                                 const dateString = date.toISOString().split('T')[0];
                                 const count = activityLog[dateString] || 0;
                                 let colorClass = 'bg-slate-200 dark:bg-slate-700';
                                 if (count > 0) colorClass = 'bg-emerald-200 dark:bg-emerald-800';
                                 if (count > 5) colorClass = 'bg-emerald-400 dark:bg-emerald-600';
                                 if (count > 10) colorClass = 'bg-emerald-600 dark:bg-emerald-400';
                                 return `<div class="w-4 h-4 rounded-sm ${colorClass} heatmap-day" title="${dateString}: ${count}개 정답"></div>`
                             }).join('')}
                         </div>
                     </div>
                     <div class="bg-white dark:bg-slate-800 rounded-lg shadow-md p-6">
                         <h3 class="text-xl font-bold mb-4">획득한 업적</h3>
                         <div class="space-y-4">
                             ${Object.values(ACHIEVEMENTS).map(ach => `
                                 <div class="flex items-center gap-4 ${userProfile.achievements.includes(ach.id) ? '' : 'opacity-40'}">
                                     <div class="p-2 bg-yellow-400 rounded-full text-white">${I('award', 'w-6 h-6')}</div>
                                     <div>
                                         <p class="font-bold">${ach.title}</p>
                                         <p class="text-sm text-slate-500">${ach.description}</p>
                                     </div>
                                 </div>
                             `).join('')}
                         </div>
                     </div>
                </div>
            </main>
            `;
        };

        // =================================================================================
        // 8. APP & ROUTER
        // =================================================================================
        const App = (appState) => {
            const { isLoading, currentView, toast, modal } = appState;
            if (isLoading && !modal.visible) return `<div class="h-screen w-screen flex items-center justify-center text-slate-500"><svg class="animate-spin -ml-1 mr-3 h-8 w-8" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span class="ml-3 text-lg">로딩 중...</span></div>`;
            
            let viewContent = '';
            switch(currentView) {
                case 'dashboard': viewContent = DashboardView(appState); break;
                case 'deckDetail':
                    const deck = appState.decks.find(d => d.id === appState.currentDeckId);
                    viewContent = DeckDetailView({ ...appState, deck });
                    break;
                case 'learn': viewContent = LearnView(appState); break;
                case 'quiz': viewContent = QuizView(appState); break;
                case 'quizReview': viewContent = QuizReviewView(appState); break;
                case 'profile': viewContent = ProfileView(appState); break;
                default: viewContent = `<p>Not Found</p>`;
            }
            return `${viewContent}${ToastComponent(toast)}${ModalComponent(modal)}`;
        };
        
        let prevState = null;

        function render(appState) {
            // Simple diffing logic to prevent focus loss on timer update
            if (
                prevState &&
                prevState.currentView === 'quiz' &&
                appState.currentView === 'quiz' &&
                prevState.quizState.currentIndex === appState.quizState.currentIndex &&
                !appState.quizState.isAnswered &&
                prevState.quizState.timeLeft !== appState.quizState.timeLeft
            ) {
                const timerText = document.getElementById('quiz-timer-text');

                if (timerText) {
                    timerText.textContent = `${appState.quizState.timeLeft}s`;
                    
                    prevState = JSON.parse(JSON.stringify(appState));
                    return; 
                }
            }

            document.getElementById('app').innerHTML = App(appState);
            lucide.createIcons();
            prevState = JSON.parse(JSON.stringify(appState));
        }

        // =================================================================================
        // 9. EVENT HANDLERS
        // =================================================================================
        function handleGlobalClicks(event) {
            const target = event.target.closest('button, .deck-item, #home-btn, #flashcard');
            if (!target) return;
            const id = target.id;
            const classList = target.classList;

            if(target.tagName === 'BUTTON' && target.closest('.deck-item')) { event.stopPropagation(); }

            if (id === 'home-btn' || id === 'back-to-dashboard-btn') return api.loadInitialData().then(() => state.setState({ currentView: 'dashboard' }));
            if (id === 'back-to-deck-btn') return state.setState({ currentView: 'deckDetail', isAddingWords: false });
            if (id === 'back-to-learn-panel-btn') return state.setState({ isAddingWords: false });
            if (id === 'start-smart-review-btn') return api.startSmartReviewSession();
            if (id === 'resume-quiz-btn') return api.resumeQuizSession();
            if (id === 'profile-btn') return state.setState({ currentView: 'profile' });

            if (classList.contains('deck-item')) {
                const deckId = parseInt(target.dataset.deckId);
                state.setState({ currentView: 'deckDetail', currentDeckId: deckId, cards: [], searchQuery: '' });
                api.loadDeckDetailData(deckId);
                return;
            }

            if (id === 'exit-quiz-btn') {
                return showModal(`
                    <h3 class="text-lg font-bold mb-4">퀴즈 중단</h3>
                    <p>퀴즈를 중단하시겠습니까? 진행 상황은 자동으로 저장됩니다.</p>
                    <div class="flex justify-end gap-2 mt-6">
                        <button id="modal-cancel" class="bg-slate-300 dark:bg-slate-600 py-2 px-4 rounded">계속하기</button>
                        <button id="modal-confirm-exit-quiz" class="bg-red-500 text-white py-2 px-4 rounded">나가기</button>
                    </div>`);
            }
            if (id === 'modal-confirm-exit-quiz') {
                stopQuestionTimer();
                api.saveQuizSession();
                closeModal();
            }
            
            const langOptions = (selected) => LANGUAGES.map(l => `<option value="${l}" ${l === selected ? 'selected' : ''}>${l}</option>`).join('');

            const CategoryModalContent = (title, category = {}) => `
                <h3 class="text-lg font-bold mb-4">${title}</h3>
                <div class="space-y-4">
                    <div>
                        <label for="category-name-input">카테고리 이름</label>
                        <input id="category-name-input" value="${category.name || ''}" class="w-full p-2 rounded bg-slate-100 dark:bg-slate-700 dark:border-slate-600 border mt-1" placeholder="카테고리 이름">
                    </div>
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="source-lang-select">학습할 언어 (Source)</label>
                            <select id="source-lang-select" class="w-full p-2 rounded bg-slate-100 dark:bg-slate-700 dark:border-slate-600 border mt-1">${langOptions(category.sourceLang || 'English')}</select>
                        </div>
                        <div>
                            <label for="target-lang-select">의미 언어 (Target)</label>
                            <select id="target-lang-select" class="w-full p-2 rounded bg-slate-100 dark:bg-slate-700 dark:border-slate-600 border mt-1">${langOptions(category.targetLang || 'Korean')}</select>
                        </div>
                    </div>
                </div>
                <div class="flex justify-end gap-2 mt-6">
                    <button id="modal-cancel" class="bg-slate-400 text-white py-2 px-4 rounded">취소</button>
                    <button id="${category.id ? 'modal-confirm-edit-category' : 'modal-confirm-add-category'}" data-id="${category.id}" class="bg-blue-500 text-white py-2 px-4 rounded">저장</button>
                </div>
            `;
            if (id === 'add-category-btn') return showModal(CategoryModalContent('새 카테고리'));
            if (classList.contains('edit-category-btn')) return showModal(CategoryModalContent('카테고리 수정', { id: target.dataset.id, name: target.dataset.name, sourceLang: target.dataset.sl, targetLang: target.dataset.tl }));

            if (id === 'settings-btn') return showModal(SettingsModalContent());
            
            const DeleteConfirmModalContent = (type, id, name) => `
                <h3 class="text-lg font-bold mb-4">${type} 삭제</h3>
                <p>정말로 '${name}' ${type}을(를) 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.</p>
                <p class="text-sm my-4">삭제를 확인하려면 아래에 <span class="font-bold text-red-500">${name}</span> 을(를) 입력하세요.</p>
                <input id="delete-confirm-input" class="w-full p-2 rounded bg-slate-100 dark:bg-slate-700 border dark:border-slate-600">
                <div class="flex justify-end gap-2 mt-4">
                    <button id="modal-cancel">취소</button>
                    <button id="modal-confirm-delete" data-type="${type}" data-id="${id}" data-name="${name}" class="bg-red-500 text-white py-2 px-4 rounded opacity-50 cursor-not-allowed" disabled>삭제</button>
                </div>
            `;
            if (classList.contains('delete-category-btn')) return showModal(DeleteConfirmModalContent('카테고리', target.dataset.id, target.dataset.name));
            if (classList.contains('delete-deck-btn')) return showModal(DeleteConfirmModalContent('단어장', target.dataset.id, target.dataset.name));

            if (id === 'modal-confirm-delete') {
                const { type, id: itemId } = target.dataset;
                if (type === '카테고리') api.deleteCategory(parseInt(itemId));
                if (type === '단어장') api.deleteDeck(parseInt(itemId));
                closeModal();
            }

            if (classList.contains('add-deck-btn')) return showModal(`<h3 class="text-lg font-bold mb-4">새 단어장</h3><input id="modal-input" class="w-full p-2 rounded bg-slate-100 dark:bg-slate-700 dark:border-slate-600" placeholder="단어장 이름"><div class="flex justify-end gap-2 mt-4"><button id="modal-cancel">취소</button><button id="modal-confirm-add-deck" data-category-id="${target.dataset.categoryId}" class="bg-blue-500 text-white py-2 px-4 rounded">생성</button></div>`);
            if (classList.contains('edit-deck-btn')) return showModal(`<h3 class="text-lg font-bold mb-4">단어장 수정</h3><input id="modal-input" value="${target.dataset.name}" class="w-full p-2 rounded"><div class="flex justify-end gap-2 mt-4"><button id="modal-cancel">취소</button><button id="modal-confirm-edit-deck" data-id="${target.dataset.id}" class="bg-blue-500 text-white py-2 px-4 rounded">수정</button></div>`);
            
            if (classList.contains('edit-card-btn')) {
                const cardId = parseInt(target.dataset.id);
                const card = state.data.cards.find(c => c.id === cardId);
                return showModal(`
                    <h3 class="text-lg font-bold mb-4">카드 수정</h3>
                    <div class="space-y-3">
                        <div><label class="text-sm">단어</label><input id="edit-card-word" value="${card.word}" class="w-full p-2 mt-1 rounded bg-slate-100 dark:bg-slate-700"></div>
                        <div><label class="text-sm">예문</label><textarea id="edit-card-sentence" class="w-full p-2 mt-1 rounded bg-slate-100 dark:bg-slate-700">${card.sentence}</textarea></div>
                        <div><label class="text-sm">번역</label><textarea id="edit-card-translation" class="w-full p-2 mt-1 rounded bg-slate-100 dark:bg-slate-700">${card.translation}</textarea></div>
                    </div>
                     <div class="flex justify-end gap-2 mt-4">
                         <button id="modal-cancel">취소</button>
                         <button id="modal-confirm-edit-card" data-id="${cardId}" class="bg-blue-500 text-white py-2 px-4 rounded">수정</button>
                     </div>
                `);
            }
            if (id === 'modal-confirm-edit-card') {
                const cardId = parseInt(target.dataset.id);
                const word = document.getElementById('edit-card-word').value;
                const sentence = document.getElementById('edit-card-sentence').value;
                const translation = document.getElementById('edit-card-translation').value;
                api.updateCard(cardId, word, sentence, translation);
                closeModal();
            }

            if (classList.contains('delete-card-btn')) {
                const cardId = parseInt(target.dataset.id);
                return showModal(`<p>이 카드를 삭제하시겠습니까?</p><div class="flex justify-end gap-2 mt-4"><button id="modal-cancel">취소</button><button id="modal-confirm-delete-card" data-id="${cardId}" class="bg-red-500 text-white py-2 px-4 rounded">삭제</button></div>`);
            }
            
            if (id === 'modal-cancel') return closeModal();
            if (id === 'modal-confirm-save-settings') { 
                const key = document.getElementById('api-key-input').value;
                const template = document.getElementById('prompt-template-input').value;
                const count = document.getElementById('quiz-question-count-input').value;
                const theme = state.data.themeColor;
                api.saveSettings(key, template, count, theme); 
                closeModal(); 
            }
            
            if (id === 'modal-confirm-add-category' || id === 'modal-confirm-edit-category') {
                const name = document.getElementById('category-name-input').value;
                const sourceLang = document.getElementById('source-lang-select').value;
                const targetLang = document.getElementById('target-lang-select').value;
                if (id === 'modal-confirm-add-category') {
                    api.addCategory(name, sourceLang, targetLang);
                } else {
                    api.updateCategory(parseInt(target.dataset.id), name, sourceLang, targetLang);
                }
                closeModal();
            }
            
            if (id === 'modal-confirm-add-deck') { api.addDeck(parseInt(target.dataset.categoryId), document.getElementById('modal-input').value); closeModal(); }
            if (id === 'modal-confirm-edit-deck') { api.updateDeck(parseInt(target.dataset.id), document.getElementById('modal-input').value); closeModal(); }

            if (id === 'modal-confirm-delete-card') { api.deleteCard(parseInt(target.dataset.id)); closeModal(); }

            if (classList.contains('theme-color-btn')) {
                const color = target.dataset.color;
                state.setState({ themeColor: color });
                applyTheme(color);
            }
             if (id === 'generate-ai-btn') { api.addCardsFromAI(state.data.currentDeckId, document.getElementById('word-input-area').value); document.getElementById('word-input-area').value = ''; }
            if (id === 'manual-generate-btn') {
                const words = document.getElementById('word-input-area').value.split('\n').map(w=>w.trim()).filter(Boolean);
                const currentDeck = state.data.decks.find(d => d.id === state.data.currentDeckId);
                const promptText = Services.buildXMLPrompt(words.length > 0 ? words : ['sample word'], currentDeck.sourceLang, currentDeck.targetLang);
                return showModal(`
                    <h3 class="text-lg font-bold mb-4">수동 생성 가이드</h3>
                    <p class="text-sm mb-2">1. 아래 프롬프트를 복사하여 ChatGPT 등 외부 AI 서비스에 붙여넣으세요.</p>
                    <textarea id="prompt-output" readonly class="w-full h-32 p-2 text-xs bg-slate-100 dark:bg-slate-700 rounded">${promptText}</textarea>
                    <button id="copy-prompt-btn" class="w-full mt-2 bg-blue-500 text-white py-2 rounded flex items-center justify-center gap-2">${I('copy')} 프롬프트 복사</button>
                    <p class="text-sm mt-4 mb-2">2. AI가 생성한 <span class="font-bold text-red-500">&lt;json_response&gt;</span> 태그 안의 <span class="font-bold text-red-500">[ ... ]</span> JSON 배열만 복사하여 아래에 붙여넣고 '적용' 버튼을 누르세요.</p>
                    <textarea id="manual-input-area" class="w-full h-24 p-2 border rounded bg-slate-100 dark:bg-slate-700" placeholder="[ { ... } ] 형식의 JSON 결과를 여기에 붙여넣으세요..."></textarea>
                    <div class="flex justify-end gap-2 mt-4">
                        <button id="modal-cancel" class="bg-slate-500 text-white py-2 px-4 rounded">닫기</button>
                        <button id="modal-confirm-manual-add" class="bg-emerald-500 text-white py-2 px-4 rounded">적용</button>
                    </div>`);
            }
            if (id === 'copy-prompt-btn') {
                document.getElementById('prompt-output').select();
                document.execCommand('copy');
                showToast('프롬프트가 복사되었습니다.', 'success');
            }
            if (id === 'modal-confirm-manual-add') {
                const jsonText = document.getElementById('manual-input-area').value;
                if(jsonText) {
                    api.addCardsFromText(state.data.currentDeckId, jsonText).then(success => {
                        if (success) closeModal();
                    });
                } else { showToast('JSON 결과를 입력하세요.', 'warning'); }
            }
            if (id === 'toggle-add-words-btn') return state.setState({ isAddingWords: true });
            if (id === 'start-learning-btn') return api.startLearnSession(state.data.cards);
            if (id === 'start-quiz-meaning-btn') return api.startQuizSession(state.data.cards, QUIZ_TYPE.MEANING);
            if (id === 'start-quiz-cloze-btn') return api.startQuizSession(state.data.cards, QUIZ_TYPE.CLOZE);
            if (id === 'start-quiz-listening-btn') return api.startQuizSession(state.data.cards, QUIZ_TYPE.LISTENING);
            if (id === 'retry-incorrect-btn') {
                const { quizState } = state.data;
                api.startQuizSession(quizState.incorrectCards, quizState.type);
            }
            
            if (id === 'flashcard') document.getElementById('flashcard').classList.toggle('flipped');
            if (id === 'prev-card-btn') {
                 document.getElementById('flashcard').classList.remove('flipped');
                 setTimeout(() => state.setState({ learnState: { ...state.data.learnState, currentIndex: Math.max(0, state.data.learnState.currentIndex - 1) } }), 200);
            }
            if (id === 'next-card-btn') {
                document.getElementById('flashcard').classList.remove('flipped');
                setTimeout(() => state.setState({ learnState: { ...state.data.learnState, currentIndex: Math.min(state.data.learnState.cards.length - 1, state.data.learnState.currentIndex + 1) } }), 200);
            }
            if (id === 'tts-btn') {
                const button = event.target.closest('#tts-btn');
                if (!button) return;

                const textToSpeak = button.dataset.ttsText;
                const langCode = button.dataset.ttsLang;
                
                TTSService.speak(textToSpeak, langCode);
            }
            
            if (classList.contains('know-this-card-btn')) {
                const cardId = parseInt(target.dataset.id);
                api.markCardAsKnown(cardId).then(card => {
                    if (card) {
                        showToast(`'${card.word}'을(를) 아는 단어로 표시했습니다.`, 'success');
                        api.loadDeckDetailData(card.deckId);
                    }
                });
            }

            if (id === 'learn-know-this-card-btn') {
                const cardId = parseInt(target.dataset.id);
                api.markCardAsKnown(cardId).then(card => {
                    if (card) {
                        showToast(`'${card.word}'을(를) 아는 단어로 표시했습니다.`, 'success');
                        
                        // Remove the card from the current learn session and advance.
                        const { learnState } = state.data;
                        const newCards = learnState.cards.filter(c => c.id !== cardId);

                        // Unflip the card for the next one
                        const flashcard = document.getElementById('flashcard');
                        if (flashcard) flashcard.classList.remove('flipped');

                        setTimeout(() => {
                           if (newCards.length === 0) {
                                // If it was the last card, go back to the deck detail view.
                                api.loadDeckDetailData(card.deckId).then(() => {
                                    state.setState({ currentView: 'deckDetail' });
                                });
                            } else {
                                // If we removed the last card in the list, clamp index to the new last card.
                                const newIndex = Math.min(learnState.currentIndex, newCards.length - 1);
                                state.setState({
                                    learnState: {
                                        ...learnState,
                                        cards: newCards,
                                        currentIndex: newIndex
                                    }
                                });
                            }
                        }, 200); // Delay to allow flip animation to reset
                    }
                });
            }
        }
        
        async function handleGlobalSubmit(event) {
            event.preventDefault();
            if (event.target.id !== 'quiz-form' || state.data.quizState.isAnswered) return;
            
            const { quizState } = state.data;
            const currentCard = quizState.cards[quizState.currentIndex];
            let userAnswer = '', isCorrect;
            
            const inputElement = document.getElementById('answer-input') || document.getElementById('cloze-answer-input');
            if(inputElement) {
                userAnswer = inputElement.value.trim();
            }

            if (quizState.type === QUIZ_TYPE.MEANING || quizState.type === QUIZ_TYPE.LISTENING) {
                const correctAnswer = extractQTagContent(currentCard.translation);
                isCorrect = userAnswer.length > 0 && correctAnswer.toLowerCase().includes(userAnswer.toLowerCase());
            } else if (quizState.type === QUIZ_TYPE.CLOZE) {
                const correctAnswer = extractQTagContent(currentCard.sentence);
                isCorrect = userAnswer.toLowerCase() === correctAnswer.toLowerCase();
            }
            
            processAnswer(isCorrect, userAnswer);
        }

        function handleGlobalInput(event) {
            const target = event.target;
            if (target.id === 'delete-confirm-input') {
                const modalContent = target.closest('#modal-content');
                const confirmButton = modalContent.querySelector('#modal-confirm-delete');
                const expectedName = confirmButton.dataset.name;
                if (target.value === expectedName) {
                    confirmButton.disabled = false;
                    confirmButton.classList.remove('opacity-50', 'cursor-not-allowed');
                } else {
                    confirmButton.disabled = true;
                    confirmButton.classList.add('opacity-50', 'cursor-not-allowed');
                }
            }
            if (target.id === 'search-input') {
                state.setState({ searchQuery: target.value });
            }
        }

        /**
         * Handles all 'change' events across the app using event delegation.
         * @param {Event} event - The change event object.
         */
        function handleGlobalChange(event) {
            const target = event.target;
            if (target.id === 'sort-criteria-select') {
                state.setState({ sortCriteria: target.value });
            }
        }

        function handleGlobalKeydown(event) {
            const { currentView } = state.data;
            if (event.key === 'Escape' && state.data.modal.visible) closeModal();
            if ((event.ctrlKey || event.metaKey) && event.key === 'f') {
                event.preventDefault();
                document.getElementById('search-input')?.focus();
            }

            if (currentView === 'learn') {
                if (event.key === 'ArrowLeft') document.getElementById('prev-card-btn')?.click();
                if (event.key === 'ArrowRight') document.getElementById('next-card-btn')?.click();
                if (event.key === ' ') {
                    event.preventDefault();
                    document.getElementById('flashcard')?.click();
                }
            }
        }
        
        const applyTheme = (color) => {
            const root = document.documentElement;
            const colors = {
                blue: { accent: '#3b82f6', hover: '#2563eb' },
                green: { accent: '#10b981', hover: '#059669' },
                purple: { accent: '#8b5cf6', hover: '#7c3aed' },
                red: { accent: '#ef4444', hover: '#dc2626' },
            };
            root.style.setProperty('--primary-accent', colors[color].accent);
            root.style.setProperty('--primary-accent-hover', colors[color].hover);
        }

        // =================================================================================
        // 10. INITIALIZATION
        // =================================================================================
        async function main() {
            state.subscribe(render);
            await DB.init();
            await api.loadInitialData();
            applyTheme(state.data.themeColor);

            document.getElementById('app').addEventListener('click', handleGlobalClicks);
            document.getElementById('app').addEventListener('submit', handleGlobalSubmit);
            document.getElementById('app').addEventListener('input', handleGlobalInput);
            document.getElementById('app').addEventListener('change', handleGlobalChange); // Add new event listener
            document.addEventListener('keydown', handleGlobalKeydown);
            
            const applyColorScheme = (isDark) => document.documentElement.classList.toggle('dark', isDark);
            const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
            applyColorScheme(mediaQuery.matches);
            mediaQuery.addEventListener('change', e => applyColorScheme(e.matches));
        }
        main();
    </script>
</body>
</html>


