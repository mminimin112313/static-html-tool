<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini File Store 관리자</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- [NEW] Bootstrap Icons CDN 추가 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <!-- [NEW] Google Fonts (Inter, Noto Sans KR) (원칙 2: 일관성/가독성) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- [NEW] Tailwind Config for Font Family (원칙 2: 일관성/가독성) -->
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'Noto Sans KR', ...tailwind.defaultTheme.fontFamily.sans],
            },
          },
        },
      }
    </script>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <style>
      body {
        background-color: #030712; /* bg-gray-950 */
        /* 폰트 계열은 Tailwind Config로 적용됨 */
      }
      .drag-over {
        border-style: dashed !important;
        border-color: #3b82f6 !important; /* blue-500 */
        background-color: #111827 !important; /* gray-900 */
      }
      .prose p { margin-top: 0.5em; margin-bottom: 0.5em; }
      .prose ul, .prose ol { list-style-position: inside; padding-left: 1.5em; margin: 0.5em 0; }
      .prose li { margin: 0.25em 0; }
      .prose pre { background-color: #030712; padding: 0.75rem; border-radius: 0.375rem; overflow-x: auto; margin: 1em 0; font-family: monospace; }
      .prose code:not(pre code) { background-color: #1f2937; padding: 0.2em 0.4em; border-radius: 0.25rem; font-family: monospace; }
      .prose a { color: #60a5fa; text-decoration: underline; }
      .prose-invert { color: #d1d5db; }
      .prose-invert a { color: #93c5fd; }
      .prose-invert strong { color: #ffffff; }
      div.prose.prose-invert table {
        width: 100%;
        border-collapse: collapse;
        margin: 1em 0;
      }
      div.prose.prose-invert th {
        background-color: #374151; /* bg-gray-700 */
        border: 1px solid #4b5563; /* border-gray-600 */
        padding: 0.75em 1em;
        font-weight: 600;
        color: #ffffff !important; 
        text-align: left;
      }
      div.prose.prose-invert td {
        border: 1px solid #4b5563; /* border-gray-600 */
        padding: 0.75em 1em;
        color: #d1d5db !important; 
      }
      div.prose.prose-invert tr:nth-child(even) {
          background-color: #1f2937; /* bg-gray-800 */
      }
        
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .animate-fade-in {
        animation: fadeIn 0.3s ease-out;
      }
      .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 20px; 
            height: 20px;
            border-radius: 50%;
            border-left-color: #3b82f6; /* blue-500 */
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
      /* [NEW] Custom Scrollbar */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #111827; /* gray-900 */
      }
      ::-webkit-scrollbar-thumb {
        background: #374151; /* gray-700 */
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #4b5563; /* gray-600 */
      }
    </style>
</head>
<body>
    <noscript>이 앱을 실행하려면 JavaScript가 필요합니다.</noscript>
    <div id="root"></div>

    <script type="text/babel">
(function() { // IIFE

const { useState, useEffect, useRef, useMemo, useCallback } = React;

/* --- 아이콘 컴포넌트 (Bootstrap Icons) --- */
// (원칙 2: 일관성 - 모든 아이콘을 단일 세트로 통일)
function IconFolder() { return ( <i className="bi bi-folder text-xl"></i> ); }
function IconChat() { return ( <i className="bi bi-chat-dots text-xl"></i> ); }
function IconTrash() { return ( <i className="bi bi-trash text-xl"></i> ); }
function IconFile() { return ( <i className="bi bi-file-earmark-text text-xl"></i> ); }
function IconCloudUpload() { return ( <i className="bi bi-cloud-arrow-up text-xl"></i> ); }
function IconPlus() { return ( <i className="bi bi-plus-lg text-xl"></i> ); }
function IconSpinner() { return ( <div className="spinner !w-5 !h-5" role="status"></div> ); } 
function IconArrowLeft() { return ( <i className="bi bi-arrow-left text-xl"></i> ); }
function IconSearch() { return ( <i className="bi bi-search text-xl"></i> ); }
function IconCopy() { return ( <i className="bi bi-clipboard text-base"></i> ); }
function IconCheck() { return ( <i className="bi bi-check-lg text-base"></i> ); }
function IconUser() { return ( <i className="bi bi-person text-xl"></i> ); }
function IconGemini() { return ( <i className="bi bi-gem text-xl"></i> ); }
function IconEdit() { return ( <i className="bi bi-pencil text-base"></i> ); }
function IconCheckSmall() { return ( <i className="bi bi-check-lg text-base"></i> ); }
function IconXSmall() { return ( <i className="bi bi-x-lg text-base"></i> ); }
function IconUploadQueue() { return ( <i className="bi bi-cloud-arrow-up text-xl"></i> ); }
function IconExternalLink() { return ( <i className="bi bi-box-arrow-up-right text-xs"></i> ); }
function IconSettings() { return ( <i className="bi bi-gear text-xl"></i> ); }
function IconXCircle() { return ( <i className="bi bi-x-circle text-xl"></i> ); }
function IconFileQueue() { return ( <i className="bi bi-file-earmark text-xl"></i> ); }
function IconDownload() { return ( <i className="bi bi-download text-xl"></i> ); }


/* --- API 및 유틸리티 --- */

const API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/';
const UPLOAD_BASE_URL = 'https://generativelanguage.googleapis.com/upload/v1beta/';

const DB_NAME = 'GeminiFileStoreDB';
const CHAT_STORE = 'chats';

// IndexedDB 헬퍼 (변경 없음)
function openDB() { return new Promise((resolve, reject) => { const request = indexedDB.open(DB_NAME, 1); request.onupgradeneeded = (event) => { const db = event.target.result; if (!db.objectStoreNames.contains(CHAT_STORE)) { db.createObjectStore(CHAT_STORE, { keyPath: 'id' }); } }; request.onsuccess = (event) => { resolve(event.target.result); }; request.onerror = (event) => { reject('IndexedDB error: ' + event.target.errorCode); }; }); }
function dbRequest(storeName, mode, operation) { return new Promise(async (resolve, reject) => { try { const db = await openDB(); const tx = db.transaction(storeName, mode); const store = tx.objectStore(storeName); operation(store, resolve, reject); tx.oncomplete = () => { if (mode !== 'readonly') { resolve(); } }; tx.onerror = (event) => { reject(event.target.error); }; } catch (error) { reject(error); } }); }
function getChatsFromDB() { return dbRequest(CHAT_STORE, 'readonly', (store, resolve) => { const request = store.getAll(); request.onsuccess = () => resolve(request.result); }); }
function saveChatToDB(chat) { return dbRequest(CHAT_STORE, 'readwrite', (store) => { store.put(chat); }); }
function deleteChatFromDB(chatId) { return dbRequest(CHAT_STORE, 'readwrite', (store) => { store.delete(chatId); }); }
function clearChatsFromDB() { return dbRequest(CHAT_STORE, 'readwrite', (store) => { store.clear(); }); }

// 일반 API 요청 (File API 용) (변경 없음)
async function apiRequest(endpoint, options = {}, apiKey) {
  let url = `${API_BASE_URL}${endpoint}`;
  
  if (options.params) {
    const query = new URLSearchParams(options.params).toString();
    if (query) {
      url += `?${query}`;
    }
  }

  const headers = {
    'Content-Type': 'application/json',
    'x-goog-api-key': apiKey,
    ...options.headers,
  };
  
  const method = options.method || 'GET';
  console.log(`[File API] Requesting: ${method} ${url}`); // [LOG]

  try {
    const response = await fetch(url, { ...options, method, headers, params: undefined }); 
    if (!response.ok) {
      const errorData = await response.json();
      console.error('API Error Response:', errorData);
      throw new Error(`API Error: ${errorData.error?.message || response.statusText}`);
    }
    const text = await response.text();
    const jsonData = text ? JSON.parse(text) : {};
    console.log(`[File API] Success: ${method} ${endpoint}`, jsonData); // [LOG]
    return jsonData;
  } catch (error) {
    console.error(`API Request Failed: ${error.message}`);
    throw error;
  }
}

// Gemini API 호출 (generateContent 용) (변경 없음)
async function apiGeminiFilter(prompt, apiKey, modelName, retries = 3, delay = 1000) { 
  console.log('%c[Gemini API] 호출 시작...', 'color: blue; font-weight: bold;'); // [LOG]
  console.log(`[Gemini API] Model: ${modelName}`); // [LOG]
  console.log('[Gemini API] Prompt:', prompt); // [LOG]
  
  const apiUrl = `${API_BASE_URL}models/${modelName}:generateContent?key=${apiKey}`;

  const payload = {
    contents: [{ parts: [{ text: prompt }] }],
  };

  for (let i = 0; i < retries; i++) {
      try {
          console.log(`[Gemini API] ${i + 1}번째 시도...`); // [LOG]
          const response = await fetch(apiUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
          });

          if (!response.ok) {
              const errorData = await response.json();
              console.error('[Gemini API] 응답 오류:', errorData); // [LOG]
              throw new Error(errorData.error?.message || `HTTP ${response.status} 오류`);
          }

          const result = await response.json();
          console.log('[Gemini API] 응답 성공:', result); // [LOG]

          if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
              const extractedText = result.candidates[0].content.parts[0].text;
              console.log('[Gemini API] 추출된 텍스트:', extractedText); // [LOG]
              return extractedText;
          } else {
              let errorMsg = 'Gemini API로부터 유효한 응답을 받지 못했습니다.';
              if (result.candidates && result.candidates[0].finishReason) {
                  errorMsg += ` (이유: ${result.candidates[0].finishReason})`;
              }
              console.warn('[Gemini API] 콘텐츠 없음:', errorMsg, result); // [LOG]
              throw new Error(errorMsg);
          }
      } catch (error) {
          console.warn(`[Gemini API] ${i + 1}번째 시도 실패:`, error); // [LOG]
          if (i === retries - 1) {
              throw error; // 재시도 모두 실패 시 에러 throw
          }
          await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
      }
  }
}

// 파일 업로드 요청 (변경 없음)
async function apiUploadRequest(endpoint, file, metadata, apiKey, onProgress) {
  const params = new URLSearchParams();
  if (metadata.displayName) {
    params.append('displayName', metadata.displayName);
  }
  const url = `${UPLOAD_BASE_URL}${endpoint}?${params.toString()}`;

  const formData = new FormData();
  formData.append('file', file);
  
  console.log(`[File Upload] Requesting: POST ${url}`); // [LOG]

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'x-goog-api-key': apiKey,
      },
      body: formData,
    });

    const responseText = await response.text();
    if (!response.ok) {
        console.error('Upload API Error Response Text:', responseText);
        throw new Error(`Upload API Error: ${responseText}`);
    }
    try {
        const jsonData = JSON.parse(responseText);
        console.log(`[File Upload] Success:`, jsonData); // [LOG]
        return jsonData;
    } catch (parseError) {
        console.error('API Upload JSON Parse Error:', parseError, 'Response Text:', responseText);
        throw new Error(`업로드 API가 JSON이 아닌 응답을 반환했습니다: ${responseText.substring(0, 100)}...`);
    }
  } catch (error) {
    console.error('API Upload Error:', error);
    throw error;
  }
}

// 파일 크기 포맷터 (변경 없음)
function formatBytes(bytes, decimals = 2) { if (!bytes || bytes === 0) return 'N/A'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`; }

// 클립보드 훅 (변경 없음)
function useClipboard(timeout = 1500) { 
  const [copied, setCopied] = useState(false); 
  const copy = useCallback((text) => { 
    try { 
      const el = document.createElement('textarea'); 
      el.value = text; 
      document.body.appendChild(el); 
      el.select(); 
      const success = document.execCommand('copy'); 
      document.body.removeChild(el); 
      if (success) { 
        setCopied(true); 
        setTimeout(() => setCopied(false), timeout); 
      } else { 
        throw new Error('Copy command failed'); 
      } 
    } catch (e) { 
      console.error('Failed to copy to clipboard:', e); 
      Swal.fire({ 
        title: '오류', 
        text: '클립보드 복사에 실패했습니다.', 
        icon: 'error', 
        background: '#1f2937', 
        color: '#d1d5db' 
      }); 
    } 
  }, [timeout]); 
  return [copied, copy]; 
}

// 자동 높이 조절 훅 (변경 없음)
function useAutosizeTextarea(textareaRef, value) {
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = '0px'; 
      const scrollHeight = textareaRef.current.scrollHeight;
      textareaRef.current.style.height = `${scrollHeight}px`; 
    }
  }, [textareaRef, value]);
}


/* --- 하위 컴포넌트 --- */

// 설정 모달 (변경 없음)
function SettingsModal({ isOpen, onClose, apiKey, setApiKey, systemInstruction, setSystemInstruction, selectedModel, setSelectedModel }) {
  const [localApiKey, setLocalApiKey] = useState(apiKey);
  const [localInstruction, setLocalInstruction] = useState(systemInstruction);
  const [localModel, setLocalModel] = useState(selectedModel); 

  useEffect(() => { setLocalApiKey(apiKey); }, [apiKey]);
  useEffect(() => { setLocalInstruction(systemInstruction); }, [systemInstruction]);
  useEffect(() => { setLocalModel(selectedModel); }, [selectedModel]); 

  if (!isOpen) return null;

  const handleSave = () => {
    setApiKey(localApiKey);
    setSystemInstruction(localInstruction);
    setSelectedModel(localModel); 
    localStorage.setItem('gemini-api-key', localApiKey);
    localStorage.setItem('gemini-system-instruction', localInstruction);
    localStorage.setItem('gemini-selected-model', localModel); 
    onClose();
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-75">
      <div className="bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl p-6 border border-gray-700 animate-fade-in">
        <h2 className="text-2xl font-bold text-white mb-6">설정</h2>
        
        <div className="mb-6">
          <label htmlFor="apiKey" className="block text-sm font-medium text-gray-300 mb-2">
            Gemini API 키
          </label>
          <input
            type="password"
            id="apiKey"
            value={localApiKey}
            onChange={(e) => setLocalApiKey(e.target.value)}
            className="w-full px-4 py-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="gme-..."
          />
        </div>

        <div className="mb-6">
          <label htmlFor="modelSelect" className="block text-sm font-medium text-gray-300 mb-2">
            Gemini 모델 선택 (채팅 및 필터링)
          </label>
          <select
            id="modelSelect"
            value={localModel}
            onChange={(e) => setLocalModel(e.target.value)}
            className="w-full px-4 py-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="gemini-2.5-pro">Gemini 2.5 Pro (최고 성능)</option>
            <option value="gemini-2.5-flash">Gemini 2.5 Flash (균형 - Stable)</option>
            <option value="gemini-flash-latest">Gemini Flash (최신 별칭)</option>
            <option value="gemini-2.5-flash-preview-09-2025">Gemini 2.5 Flash Preview (9월)</option>
          </select>
          <p className="text-xs text-gray-500 mt-2">
            'File Search' (파일 검색) 기능이 지원되는 모델만 표시됩니다.
          </p>
        </div>

        <div className="mb-8">
          <label htmlFor="systemInstruction" className="block text-sm font-medium text-gray-300 mb-2">
            시스템 프롬프트 (System Instruction)
          </label>
          <textarea
            id="systemInstruction"
            rows="8"
            value={localInstruction}
            onChange={(e) => setLocalInstruction(e.target.value)}
            className="w-full px-4 py-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="모델이 항상 따르도록 할 지침을 입력하세요..."
          />
        </div>
        
        <div className="flex justify-end space-x-4">
          <button
            onClick={onClose}
            className="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-6 rounded-lg transition"
          >
            취소
          </button>
          <button
            onClick={handleSave}
            className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition"
          >
            저장
          </button>
        </div>
      </div>
    </div>
  );
}

// 헤더 (원칙 3: 힉의 법칙 - 로그아웃 버튼을 시각적으로 구분)
function Header({ apiKey, onLogout, pendingOperations, removeOperation, onOpenSettings }) {
  const [showOps, setShowOps] = useState(false);
  const opCount = Object.keys(pendingOperations).length;

  const getStatusColor = (status) => {
    if (status === 'succeeded') return 'text-green-400';
    if (status === 'failed') return 'text-red-400';
    return 'text-blue-400';
  };

  return (
    <header className="flex-shrink-0 bg-gray-900 border-b border-gray-700 flex items-center justify-between p-4">
      <div className="flex items-center space-x-2">
        <IconGemini />
        <h1 className="text-xl font-bold text-white">File Store Manager</h1>
      </div>
      <div className="flex items-center space-x-4">
        <div className="relative">
          <button 
            onClick={() => setShowOps(!showOps)}
            className="relative p-2 rounded-full text-gray-400 hover:text-white hover:bg-gray-700"
          >
            <IconUploadQueue />
            {opCount > 0 && (
              <span className="absolute top-0 right-0 block h-5 w-5 rounded-full text-xs flex items-center justify-center bg-blue-600 text-white ring-2 ring-gray-900">
                {opCount}
              </span>
            )}
          </button>
          
          {showOps && opCount > 0 && (
            <div className="absolute right-0 mt-2 w-80 bg-gray-800 border border-gray-700 rounded-lg shadow-xl z-50">
              <div className="p-4 border-b border-gray-700"><h3 className="font-semibold text-white">진행중인 작업</h3></div>
              <ul className="max-h-64 overflow-y-auto">
                {Object.values(pendingOperations).map(op => (
                  <li key={op.id} className="p-4 border-b border-gray-700 last:border-b-0">
                    <div className="flex items-center justify-between">
                      <span className="text-sm text-gray-300 w-3/4 truncate">{op.description}</span>
                      {['processing', 'indexing'].includes(op.status) && <IconSpinner />}
                      {op.status === 'succeeded' && <i className="bi bi-check-lg text-green-400 text-xl"></i>}
                      {op.status === 'failed' && <i className="bi bi-x-lg text-red-400 text-xl"></i>}
                    </div>
                    <p className={`text-xs mt-1 ${getStatusColor(op.status)}`}>
                      {op.status === 'failed' ? op.error : op.status}
                    </p>
                    {(op.status === 'succeeded' || op.status === 'failed') && (
                      <button onClick={() => removeOperation(op.id)} className="text-xs text-gray-500 hover:text-red-400 mt-1"> 닫기 </button>
                    )}
                  </li>
                ))}
              </ul>
      
      </div>
          )}
        </div>

        <div className="text-sm text-gray-500">
          API Key: ...{apiKey.slice(-4)}
        </div>
        
        <button
          onClick={onOpenSettings}
          className="p-2 rounded-full text-gray-400 hover:text-white hover:bg-gray-700"
          title="설정"
        >
          <IconSettings />
        </button>

        <button
          onClick={onLogout}
          className="bg-gray-700 hover:bg-red-600 text-white text-sm font-semibold py-2 px-4 rounded-lg transition"
        >
          로그아웃
        </button>
      </div>
    </header>
  );
}

// 채팅 사이드바 (변경 없음)
function ChatSidebar({ chats, selectedChat, onSelectChat, onCreateNewChat, onDeleteChat, onUpdateChat, onNavigateBack, currentStoreName }) {
  const [editingChatId, setEditingChatId] = useState(null);
  const [newTitle, setNewTitle] = useState('');

  const handleStartEdit = (chat) => { setEditingChatId(chat.id); setNewTitle(chat.title); };
  const handleSaveEdit = (chat) => { if (newTitle.trim()) { onUpdateChat({ ...chat, title: newTitle.trim() }); } setEditingChatId(null); };

  const filteredChats = chats.filter(c => c.storeName === selectedChat.storeName);

  return (
    <div className="w-72 flex-shrink-0 bg-gray-900 border-r border-gray-700 flex flex-col">
      <div className="p-4 border-b border-gray-700">
        <button onClick={onNavigateBack} className="flex items-center space-x-2 text-sm text-gray-400 hover:text-white mb-3">
          <IconArrowLeft /> <span>모든 프로젝트 (스토어)</span>
        </button>
        <h2 className="text-lg font-semibold text-white truncate" title={currentStoreName}> {currentStoreName || "채팅"} </h2>
      </div>
      <div className="p-4">
        <button onClick={onCreateNewChat} className="w-full flex items-center justify-center space-x-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition">
          <IconPlus /> <span>새 채팅 시작</span>
        </button>
      </div>
      <nav className="flex-1 overflow-y-auto px-2 py-2 space-y-1">
        {filteredChats.length > 0 ? (
          filteredChats.map(chat => (
            <div key={chat.id} className={`group flex items-center justify-between p-3 rounded-lg cursor-pointer ${selectedChat?.id === chat.id ? 'bg-blue-800 text-white' : 'text-gray-300 hover:bg-gray-800'}`}>
              {editingChatId === chat.id ? (
                <input
                  type="text" value={newTitle} onChange={(e) => setNewTitle(e.target.value)}
                  onBlur={() => handleSaveEdit(chat)} onKeyDown={(e) => e.key === 'Enter' && handleSaveEdit(chat)}
                  className="flex-1 bg-gray-700 text-white p-1 rounded outline-none" autoFocus
                />
              ) : (
                <span className="flex-1 truncate" onClick={() => onSelectChat(chat)}> {chat.title} </span>
              )}
              <div className="flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
                {editingChatId === chat.id ? (
                  <button onClick={() => handleSaveEdit(chat)} className="p-1 hover:text-white"><IconCheckSmall /></button>
                ) : (
                  <button onClick={() => handleStartEdit(chat)} className="p-1 hover:text-white"><IconEdit /></button>
                )}
                <button onClick={() => onDeleteChat(chat.id)} className="p-1 hover:text-red-400"><IconTrash /></button>
              </div>
            </div>
          ))
        ) : ( <p className="text-sm text-gray-500 text-center p-4">이 스토어의 채팅 기록이 없습니다.</p> )}
      </nav>
    </div>
  );
}

// [MODIFIED] 스토어 목록 (원칙 1, 3, 4, 5 적용)
function FileSearchStoreList({ stores, onCreateStore, onDeleteStore, onSelectStoreForDocs, onSelectStoreForChat, deletingStoreName }) {
  const [newStoreName, setNewStoreName] = useState('');
  const handleSubmit = (e) => { e.preventDefault(); if (newStoreName.trim()) { onCreateStore(newStoreName.trim()); setNewStoreName(''); } };

  return (
    <div className="animate-fade-in">
      {/* (원칙 1: 게슈탈트 - '새 프로젝트' 작업을 명확한 카드로 그룹화) */}
      <div className="mb-8 p-6 bg-gray-900 rounded-lg shadow-lg border border-gray-700">
        <form onSubmit={handleSubmit} className="flex space-x-4">
          <input
            type="text" value={newStoreName} onChange={(e) => setNewStoreName(e.target.value)}
            className="flex-1 px-4 py-3 bg-gray-800 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="새 프로젝트 (스토어) 이름"
          />
          <button type="submit" className="flex items-center justify-center space-x-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition">
            <IconPlus /> <span>생성</span>
          </button>
        </form>
      </div>
      <h2 className="text-2xl font-bold text-white mb-6">프로젝트 대시보드 ({stores.length})</h2>
      {stores.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {/* (원칙 5: 밀러의 법칙 - 각 카드를 정보 청크로 제공) */}
          {stores.map(store => (
            <div key={store.name} className="bg-gray-900 border border-gray-700 rounded-lg shadow-xl p-6 flex flex-col justify-between transition hover:shadow-blue-500/20 hover:-translate-y-1">
              <div> {/* 정보 그룹 Wrapper */}
                <h3 className="text-xl font-bold text-white mb-2 truncate" title={store.displayName}>{store.displayName}</h3>
                <p className="text-sm text-gray-500 truncate mb-4" title={store.name}>{store.name}</p>
                <div className="flex space-x-4 text-sm text-gray-400 mb-6">
                  <span className="flex items-center space-x-1"><i className="bi bi-file-earmark-text"></i> <span>{store.activeDocumentsCount || 0} Docs</span></span>
                  <span className="flex items-center space-x-1"><i className="bi bi-hdd-stack"></i> <span>{formatBytes(store.sizeBytes)}</span></span>
                </div>
              </div>
              
              {/* [MODIFIED] 게슈탈트(구분) 원칙 적용: 정보와 작업을 시각적으로 분리 (원칙 1) */}
              <div className="border-t border-gray-700 mt-4 pt-4 flex items-center space-x-2">
                {/* (원칙 3, 4: 힉의 법칙/피츠의 법칙 - 주요 작업 버튼을 명확하게) */}
                <button onClick={() => onSelectStoreForDocs(store)} className="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition text-sm flex items-center justify-center space-x-2">
                  <IconFolder /> <span>문서 관리</span>
                </button>
                <button onClick={() => onSelectStoreForChat(store)} className="flex-1 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition text-sm flex items-center justify-center space-x-2">
                  <IconChat /> <span>채팅 시작</span>
                </button>
                {/* (원칙 3: 힉의 법칙 - 파괴적 작업을 시각적으로 구분) */}
                <button 
                  onClick={() => onDeleteStore(store.name)} 
                  className="bg-gray-700 hover:bg-red-600 text-white p-2 rounded-lg transition disabled:opacity-50" 
                  title="스토어 삭제"
                  disabled={deletingStoreName === store.name}
                >
                  {deletingStoreName === store.name ? <IconSpinner /> : <IconTrash />}
                </button>
              </div>
            </div>
          ))}
        </div>
      ) : ( <p className="text-gray-400">생성된 스토어가 없습니다. 새 프로젝트(스토어)를 생성해주세요.</p> )}
    </div>
  );
}


// 문서 목록 (원칙 1: 게슈탈트 - 업로드와 목록을 명확히 구분)
function DocumentList({ store, documents, onDeleteDocument, onUploadFiles, onSelectDocument, onBack, isLoading, onSelectStoreForSearch }) {
  const [uploadQueue, setUploadQueue] = useState([]); 
  const [isDragging, setIsDragging] = useState(false);
  const fileInputRef = useRef(null);

  const handleFilesChange = (files) => {
    if (files && files.length > 0) {
      const newFiles = Array.from(files);
      const uniqueNewFiles = newFiles.filter(nf => !uploadQueue.some(qf => qf.name === nf.name && qf.size === nf.size));
      setUploadQueue(prev => [...prev, ...uniqueNewFiles]);
    }
  };
  
  const handleFileChange = (e) => {
    handleFilesChange(e.target.files);
    if (fileInputRef.current) {
        fileInputRef.current.value = '';
    }
  };
  
  const removeFromQueue = (fileName) => {
    setUploadQueue(prev => prev.filter(f => f.name !== fileName));
  };

  const handleUploadAll = () => {
    if (uploadQueue.length === 0) return;

    Swal.fire({
      title: `${uploadQueue.length}개 파일 업로드`,
      text: '선택한 모든 파일을 업로드하시겠습니까?',
      icon: 'info',
      showCancelButton: true,
      confirmButtonText: '업로드 시작',
      cancelButtonText: '취소',
      background: '#1f2937',
      color: '#d1d5db'
    }).then((result) => {
      if (result.isConfirmed) {
        onUploadFiles(store.name, uploadQueue);
        setUploadQueue([]);
      }
    });
  };

  const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(true); };
  const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); };
  const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFilesChange(e.dataTransfer.files); };


  return (
    <div 
      className={`animate-fade-in ${isDragging ? 'drag-over' : ''}`}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <button onClick={onBack} className="flex items-center space-x-2 text-sm text-blue-400 hover:text-blue-300 mb-6">
        <IconArrowLeft />
        <span>프로젝트 대시보드로 돌아가기</span>
      </button>
      
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-2xl font-bold text-white">
          문서 관리: <span className="text-blue-400">{store.displayName}</span>
        </h2>
        <button 
          onClick={() => onSelectStoreForSearch(store)} 
          className="flex items-center space-x-2 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition text-sm"
          disabled={documents.length === 0 || isLoading}
        >
          <IconSearch /> <span>스토어 전체 검색</span>
        </button>
      </div>
      
      {/* (원칙 1: 게슈탈트 - '업로드' 작업을 명확한 카드로 그룹화) */}
      <div className={`mb-8 p-6 bg-gray-900 rounded-lg shadow-lg border border-gray-700 transition-all ${isDragging ? 'border-blue-500 border-dashed' : 'border-gray-700'}`}>
        <h3 className="text-xl font-semibold text-white mb-4">새 문서 업로드</h3>
        
        <div className="flex justify-center items-center p-8 border-2 border-dashed border-gray-600 rounded-lg text-center">
          <input
            type="file"
            ref={fileInputRef}
            onChange={handleFileChange}
            multiple 
            className="hidden"
            id="file-upload"
          />
          <label htmlFor="file-upload" className="cursor-pointer">
            <i className="bi bi-cloud-arrow-up mx-auto h-12 w-12 text-gray-500" style={{ fontSize: '2.5rem' }}></i>
            <p className="mt-2 text-blue-400 font-semibold">파일 선택</p>
            <p className="text-sm text-gray-400">또는 파일을 드래그 앤 드롭하세요</p>
            <p className="text-xs text-gray-500">(여러 파일 선택 가능)</p>
          </label>
        </div>

        {uploadQueue.length > 0 && (
          <div className="mt-6">
            <h4 className="font-semibold text-white mb-3">업로드 대기열 ({uploadQueue.length})</h4>
            <ul className="max-h-48 overflow-y-auto space-y-2 bg-gray-800 p-3 rounded-lg border border-gray-700">
              {uploadQueue.map(file => (
                <li key={file.name} className="flex items-center justify-between text-sm text-gray-300 bg-gray-700 p-2 rounded">
                  <span className="flex items-center space-x-2 truncate">
                    <IconFileQueue className="flex-shrink-0" />
                    <span className="truncate" title={file.name}>{file.name}</span>
                  </span>
                  <div className="flex items-center space-x-2">
                    <span className="text-xs text-gray-400">{formatBytes(file.size)}</span>
                    <button 
                      onClick={() => removeFromQueue(file.name)} 
                      className="text-red-400 hover:text-red-300"
                      title="큐에서 제거"
                    >
                      <IconXCircle />
                    </button>
                  </div>
                </li>
              ))}
            </ul>
            <button 
              onClick={handleUploadAll} 
              className="w-full mt-4 flex items-center justify-center space-x-2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition"
            >
              <IconCloudUpload /> <span>모두 업로드 ({uploadQueue.length}개)</span>
            </button>
          </div>
        )}
      </div>

      {/* (원칙 1: 게슈탈트 - '문서 목록'을 별도 카드로 그룹화) */}
      <div className="bg-gray-900 rounded-lg shadow-lg border border-gray-700 overflow-hidden">
        <table className="min-w-full divide-y divide-gray-700">
          <thead className="bg-gray-800">
            <tr>
              <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">표시 이름</th>
              <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">상태</th>
              <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">크기</th>
              <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">MIME 유형</th>
              <th scope="col" className="px-6 py-3 text-right text-xs font-medium text-gray-300 uppercase tracking-wider">작업</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-700">
            {isLoading && !documents.length ? (
              <tr><td colSpan="5" className="text-center py-8 text-gray-400"><div className="flex justify-center"><IconSpinner /></div></td></tr>
            ) : (
              documents.map(doc => (
                <tr key={doc.name} className="hover:bg-gray-800">
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{doc.displayName}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm">
                    <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${ doc.state === 'ACTIVE' ? 'bg-green-900 text-green-300' : doc.state === 'PENDING' ? 'bg-yellow-900 text-yellow-300' : 'bg-red-900 text-red-300' }`}>
                      {doc.state}
                    </span>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatBytes(doc.sizeBytes)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{doc.mimeType}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium space-x-2">
                    <button onClick={() => onSelectDocument(doc)} disabled={doc.state !== 'ACTIVE'} className="text-blue-400 hover:text-blue-300 disabled:opacity-50" title="시맨틱 검색"> <IconSearch /> </button>
                    <button onClick={() => onDeleteDocument(doc.name)} className="text-red-400 hover:text-red-300" title="문서 삭제"> <IconTrash /> </button>
                  </td>
                </tr>
    
          ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}

// 문서 시맨틱 검색 (변경 없음)
function DocumentSearch({ document, apiKey, onBack }) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [copied, copy] = useClipboard();

  const handleSearch = async (e) => {
    e.preventDefault();
    if (!query.trim()) return;
    setIsLoading(true); setError(null); setResults([]);
    try {
      const endpoint = `${document.name}:query`;
      const data = await apiRequest(endpoint, {
        method: 'POST',
        body: JSON.stringify({ query: query, resultsCount: 10 }),
      }, apiKey);
      setResults(data.relevantChunks || []);
    } catch (err) { setError(err.message); } finally { setIsLoading(false); }
  };

  const copyAllResults = () => { const allText = results.map((chunk, i) => (`[검색 결과 ${i + 1} (청크 ID: ${chunk.chunk.name})]\n${chunk.chunk.text}\n\n`)).join('--------------------\n'); copy(allText); };

  return (
    <div className="animate-fade-in">
      <button onClick={onBack} className="flex items-center space-x-2 text-sm text-blue-400 hover:text-blue-300 mb-6">
        <IconArrowLeft /> <span>문서 목록으로 돌아가기</span>
      </button>
      <h2 className="text-2xl font-bold text-white mb-2"> 시맨틱 검색: <span className="text-blue-400">{document.displayName}</span> </h2>
      <p className="text-sm text-gray-500 mb-6">{document.name}</p>
      <form onSubmit={handleSearch} className="mb-8 flex space-x-4">
        <input
          type="text" value={query} onChange={(e) => setQuery(e.target.value)}
          className="flex-1 px-4 py-3 bg-gray-800 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="문서 내용 검색..." disabled={isLoading}
        />
        <button type="submit" className="flex items-center justify-center space-x-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition disabled:opacity-50" disabled={isLoading || !query.trim()}>
          {isLoading ? <IconSpinner /> : <IconSearch />} <span>검색</span>
        </button>
      </form>
      {error && ( <div className="mb-4 bg-red-800 border border-red-600 text-red-200 px-4 py-3 rounded-lg"> {error} </div> )}
      <div>
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-xl font-semibold text-white">검색 결과 ({results.length})</h3>
          {results.length > 0 && (
            <button onClick={copyAllResults} className="flex items-center space-x-2 text-sm bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition">
              {copied ? <IconCheck /> : <IconCopy />} <span>{copied ? '복사 완료!' : '전체 복사'}</span>
            </button>
          )}
        </div>
        {isLoading && results.length === 0 && <p className="text-gray-400">검색 중...</p>}
        {!isLoading && results.length === 0 && query && ( <p className="text-gray-400">검색 결과가 없습니다.</p> )}
        <div className="space-y-4">
          {results.map((chunk, index) => (
            <div key={index} className="bg-gray-900 border border-gray-700 rounded-lg p-4">
              <p className="text-sm text-blue-400 mb-2 font-mono" title={chunk.chunk.name}> 청크 ID: ...{chunk.chunk.name.split('/').pop()} </p>
              <p className="text-gray-300 whitespace-pre-wrap">{chunk.chunk.text}</p>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}


// 스토어 전체 검색 (변경 없음)
function StoreSearch({ store, documents, apiKey, onBack, selectedModel }) { 
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]); 
  const [isLoading, setIsLoading] = useState(false);
  const [geminiStatus, setGeminiStatus] = useState(''); 
  const [searchStatus, setSearchStatus] = useState(''); 
  const [error, setError] = useState(null);
  const [downloadReady, setDownloadReady] = useState(false);

  const handleSearch = async (e) => {
    e.preventDefault();
    if (!query.trim()) return;

    console.log(`[StoreSearch] 검색 시작. 쿼리: "${query}"`);
    setIsLoading(true);
    setError(null);
    setResults([]);
    setGeminiStatus('Gemini가 관련 문서를 필터링 중...');
    setSearchStatus('');
    setDownloadReady(false);

    try {
      const docNames = documents.map(d => d.displayName || d.name.split('/').pop());
      const prompt = `사용자 쿼리: "${query}"\n\n문서 목록: [${docNames.join(', ')}]\n\n위 쿼리와 가장 관련성이 높아 보이는 문서의 '표시 이름(displayName)'을 쉼표(,)로 구분된 목록으로 반환해 줘. 다른 설명은 필요 없고, 관련 문서가 없으면 "없음"이라고만 응답해 줘.\n\n관련 문서 목록:`;
      
      const geminiResponse = await apiGeminiFilter(prompt, apiKey, selectedModel);

      if (!geminiResponse || geminiResponse.trim().toLowerCase() === '없음') {
        setGeminiStatus('Gemini가 관련 문서를 찾지 못했습니다.');
        setIsLoading(false);
        return;
      }

      const relevantDocNames = geminiResponse.split(',').map(name => name.trim()).filter(name => name.length > 0);
      console.log('[StoreSearch] Gemini 추천 문서:', relevantDocNames);

      const docsToSearch = documents.filter(doc => {
          const docName = doc.displayName || doc.name.split('/').pop();
          return relevantDocNames.some(geminiName => docName.includes(geminiName));
      });
      
      console.log(`[StoreSearch] ${docsToSearch.length}개의 일치하는 문서를 찾았습니다.`, docsToSearch.map(d => d.displayName));

      if (docsToSearch.length === 0) {
        setGeminiStatus(`Gemini가 "${geminiResponse}" 문서를 찾았으나, 실제 문서 목록과 일치하는 항목이 없습니다.`);
        setIsLoading(false);
        return;
      }

      setGeminiStatus(`Gemini가 선택한 관련 문서: ${docsToSearch.map(d => d.displayName).join(', ')}`);

      let allRelevantChunks = [];
      let resultsFound = false;
      setSearchStatus(`총 ${docsToSearch.length}개 문서에서 병렬 검색을 시작합니다...`);

      const searchPromises = docsToSearch.map(doc =>
        apiRequest(
          `${doc.name}:query`,
          {
            method: 'POST',
            body: JSON.stringify({ query: query, resultsCount: 100 })
          },
          apiKey
        )
      );

      const promiseResults = await Promise.allSettled(searchPromises);
      let newResultsBatch = []; 

      promiseResults.forEach((result, index) => {
        const doc = docsToSearch[index]; 
        const docDisplayName = doc.displayName || doc.name.split('/').pop();

        if (result.status === 'fulfilled') {
          const resultData = result.value;
          if (resultData && resultData.relevantChunks && resultData.relevantChunks.length > 0) {
            resultsFound = true;
            const chunksWithDoc = resultData.relevantChunks.map(chunk => ({
              ...chunk,
        
       documentName: docDisplayName
            }));
            
            allRelevantChunks.push(...chunksWithDoc);
            newResultsBatch.push(...chunksWithDoc); 
          }
        } else {
          const docError = result.reason;
          console.warn(`'${docDisplayName}' 문서 검색 실패:`, docError);
          newResultsBatch.push({ isError: true, documentName: docDisplayName, error: docError.message });
        }
      });
      
      setResults(newResultsBatch);
      setSearchStatus(resultsFound ? `총 ${allRelevantChunks.length}개의 결과를 찾았습니다.` : '관련된 검색 결과를 찾을 수 없습니다.');
      if (resultsFound) {
        setDownloadReady(true);
      }

    } catch (err) {
      console.error('[StoreSearch] 검색 오류:', err);
      setError(err.message);
      setGeminiStatus('');
      setSearchStatus('');
    } finally {
      setIsLoading(false);
    }
  };

  const downloadResults = () => {
    if (results.length === 0 || !downloadReady) return;
    
    const validResults = results.filter(r => !r.isError);
    if (validResults.length === 0) {
        Swal.fire({ title: '오류', text: '다운로드할 유효한 검색 결과가 없습니다.', icon: 'error', background: '#1f2937', color: '#d1d5db' });
        return;
    }

    const data = JSON.stringify(validResults, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `search_results_${store.displayName.replace(/[^a-z0-9]/gi, '_')}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <div className="animate-fade-in">
      <button onClick={onBack} className="flex items-center space-x-2 text-sm text-blue-400 hover:text-blue-300 mb-6">
        <IconArrowLeft /> <span>문서 목록으로 돌아가기</span>
      </button>
      <h2 className="text-2xl font-bold text-white mb-2">
        스토어 전체 검색: <span className="text-blue-400">{store.displayName}</span>
      </h2>
      <p className="text-sm text-gray-500 mb-6">총 {documents.length}개 문서를 대상으로 Gemini가 필터링 후 검색합니다.</p>
      
      <form onSubmit={handleSearch} className="mb-6 flex space-x-4">
        <input
          type="text" value={query} onChange={(e) => setQuery(e.target.value)}
          className="flex-1 px-4 py-3 bg-gray-800 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="스토어 전체에서 검색할 쿼리 입력..." disabled={isLoading}
        />
        <button type="submit" className="flex items-center justify-center space-x-2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition disabled:opacity-50" disabled={isLoading || !query.trim()}>
          {isLoading ? <IconSpinner /> : <IconSearch />} <span>검색</span>
        </button>
      </form>

      {/* 상태 및 결과 표시 */}
      <div className="bg-gray-900 border border-gray-700 rounded-lg shadow-lg p-6 min-h-[400px]">
        <div className="flex justify-between items-center mb-4 border-b border-gray-700 pb-3">
          <h3 className="text-xl font-semibold text-white">검색 결과</h3>
          <button 
            onClick={downloadResults} 
            className="flex items-center space-x-2 bg-indigo-600 text-white px-4 py-2 rounded-lg font-medium text-sm hover:bg-indigo-700 transition shadow-sm disabled:opacity-50 disabled:cursor-not-allowed"
            disabled={!downloadReady || isLoading}
          >
            <IconDownload />
            <span>결과 다운로드 (JSON)</span>
          </button>
        </div>

        {error && ( <div className="my-4 bg-red-800 border border-red-600 text-red-200 px-4 py-3 rounded-lg"> <strong>오류:</strong> {error} </div> )}

        {geminiStatus && (
          <div className="text-sm text-gray-300 mb-4 p-3 bg-blue-900 border border-blue-700 rounded-lg">
            <strong>Gemini 필터:</strong> {geminiStatus}
          </div>
        )}
        
        {isLoading && (
          <div className="flex items-center space-x-3 text-gray-400">
            <IconSpinner />
            <span>{searchStatus || '대기 중...'}</span>
          </div>
        )}

        {!isLoading && results.length === 0 && searchStatus && (
           <p className="text-gray-400">{searchStatus}</p>
        )}

        <div className="space-y-4 mt-4">
          {results.map((item, index) => {
            if (item.isError) {
              return (
                <div key={index} className="border border-red-700 p-4 rounded-lg bg-red-900 bg-opacity-30">
                  <p className="text-sm font-medium text-red-400 mb-2">
                    <strong>출처:</strong> {item.documentName} (검색 실패)
                  </p>
                  <p className="text-red-300 text-xs">{item.error}</p>
                </div>
              )
            }
            
            const chunk = item.chunk || {};
            const chunkText = chunk.text || `(텍스트를 찾을 수 없음. JSON: ${JSON.stringify(chunk)})`;
            const chunkName = chunk.name || '알 수 없는 청크';

            return (
              <div key={index} className="border border-gray-700 p-4 rounded-lg bg-gray-800 transition hover:shadow-md animate-fade-in">
                <p className="text-sm font-medium text-blue-400 mb-2">
                  
                  <strong>출처:</strong> {item.documentName}
                </p>
                <p className="text-gray-300 whitespace-pre-wrap text-sm">{chunkText}</p>
  
            <p className="text-xs text-gray-500 mt-3 font-mono">
                  <strong>Chunk ID:</strong> {chunkName.split('/').pop()}
                </p>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}


// 채팅 인터페이스 (원칙 1: 게슈탈트 - 메시지 목록과 입력창의 명확한 구분)
function ChatInterface({ chat, apiKey, systemInstruction, onUpdateChat, selectedModel }) { 
  const [messages, setMessages] = useState(chat.messages || []);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const messagesEndRef = useRef(null);
  const [copied, copy] = useClipboard();
  
  const textareaRef = useRef(null);
  useAutosizeTextarea(textareaRef, input); 

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages, isLoading]); // [FIX] isLoading 변경 시에도 스크롤

  const generateChatResponse = async (userMessage) => {
    setIsLoading(true);
    setError(null);
    console.log('[Chat] 응답 생성 시작...'); // [LOG]
    
    const model = selectedModel || 'gemini-2.5-flash'; 
    const endpoint = `models/${model}:generateContent`;

    const instructionText = systemInstruction || `모든 문장 하나하나는 정확한 출처를 명시해야 합니다. 정보를 찾을 때에는 법원 실무제요를 잘 뒤져보고, 그밖의 도서와 법률을 잘 뒤져봐. 정확한 정보출처 표기해서(책의 경우, 목차 어디에 있다, 법의 경우 조문, 판례의 경우 판례번호) 상세히 설명해`;
    
    const systemInstructionPayload = {
        parts: [ { text: instructionText } ]
    };

    const generationConfig = {
        thinkingConfig: { thinkingBudget: -1 },
        imageConfig: { imageSize: '1K' },
    };

    const contents = [
        ...messages.map(m => ({
            role: m.role,
            parts: [{ text: m.text }]
        })),
        {
            role: 'user',
            parts: [{ text: userMessage }]
        }
    ];

    const tools = [
        {
            fileSearch: {
                fileSearchStoreNames: [chat.storeName]
            }
        }
    ];

    const payload = {
        systemInstruction: systemInstructionPayload,
        generationConfig,
        contents,
        tools
    };
    
    console.log('[Chat] API Payload:', payload); // [LOG]

    try {
      const data = await apiRequest(endpoint, {
        method: 'POST',
        body: JSON.stringify(payload),
      }, apiKey);
      
      console.log('[Chat] API Response:', data); // [LOG]

      const modelResponse = data.candidates[0].content.parts[0].text;
      const groundingMetadata = data.candidates[0].groundingMetadata;

      return {
        text: modelResponse,
        groundingMetadata: groundingMetadata
      };

    } catch (err) {
      console.error('[Chat] API Error:', err); // [LOG]
      setError(err.message);
      setIsLoading(false);
      return null;
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!input.trim() || isLoading) return;

    const userMessage = { role: 'user', text: input.trim() };
    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setInput('');
    
    let updatedChat = { ...chat, messages: newMessages };
    if (chat.title === "새 채팅") {
      updatedChat.title = input.trim().substring(0, 30);
    }
    
    const modelResponse = await generateChatResponse(input.trim());
    setIsLoading(false);

    if (modelResponse) {
      const botMessage = {
        role: 'model',
        text: modelResponse.text,
        groundingMetadata: modelResponse.groundingMetadata
      };
      const finalMessages = [...newMessages, botMessage];
      setMessages(finalMessages);
      onUpdateChat({ ...updatedChat, messages: finalMessages });
      console.log('[Chat] 채팅 업데이트됨 (응답 포함).'); // [LOG]
    } else {
      onUpdateChat(updatedChat); // 에러가 났어도 유저 메시지는 저장
      console.log('[Chat] 채팅 업데이트됨 (유저 메시지만).'); // [LOG]
    }
  };
  
  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && e.shiftKey) {
        e.preventDefault();
        handleSubmit(e);
    }
  };


  // 마크다운 파싱 및 복사 버튼 래퍼
  const ChatMessageContent = ({ message }) => {
    const [justCopied, setJustCopied] = useState(false);

    const handleCopy = () => {
      copy(message.text);
      setJustCopied(true);
      setTimeout(() => setJustCopied(false), 1500);
    };

    const renderedHtml = useMemo(() => {
        if (!window.marked) return message.text.replace(/\n/g, '<br>'); 
        return window.marked.parse(message.text, {
            gfm: true, 
            breaks: true,
            sanitize: false 
        });
    }, [message.text]);

    return (
      <div className={`relative group w-full max-w-full ${message.role === 'user' ? 'bg-gray-800' : 'bg-gray-900'}`}>
        <div className="max-w-4xl mx-auto px-6 py-6 flex space-x-4">
          <div className="flex-shrink-0 w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center">
            {message.role === 'user' ? <IconUser /> : <IconGemini />}
          </div>
          <div className="flex-1 overflow-hidden">
            <div
              className="prose prose-invert max-w-none"
              dangerouslySetInnerHTML={{ __html: renderedHtml }}
            />

            {message.groundingMetadata?.groundingAttributions?.length > 0 && (
              <div className="mt-4 border-t border-gray-700 pt-3">
                <h4 className="text-sm font-semibold text-gray-400 mb-2">참조 (인용)</h4>
                <div className="flex flex-wrap gap-2">
                  {message.groundingMetadata.groundingAttributions.map((attr, idx) => (
                    <a 
                      key={idx}
                      href={attr.web?.uri} 
                      target="_blank" rel="noopener noreferrer"
                      className="flex items-center space-x-1 text-xs bg-blue-900 text-blue-300 px-2 py-1 rounded-full hover:bg-blue-800"
                      title={`출처: ${attr.file?.displayName || '알 수 없음'}`}
                    >
                      <span>{attr.file?.displayName ? attr.file.displayName.substring(0, 20) : '출처'}...</span>
                      <IconExternalLink />
                    </a>
                  ))}
                </div>
              </div>
            )}
            
            {message.role === 'model' && (
              <button onClick={handleCopy} className="absolute top-2 right-2 p-1.5 rounded-lg bg-gray-800 text-gray-400 opacity-0 group-hover:opacity-100 transition hover:bg-gray-700 hover:text-white" title="응답 복사">
                {justCopied ? <IconCheck /> : <IconCopy />}
              </button>
            )}
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="flex flex-col h-full animate-fade-in">
      {/* (원칙 1: 게슈탈트 - 메시지 목록 영역) */}
      <div className="flex-1 overflow-y-auto">
        {messages.length === 0 && !isLoading && (
          <div className="flex h-full items-center justify-center">
            <p className="text-gray-500">무엇이든 물어보세요. 이 스토어의 문서를 참조하여 답변합니다.</p>
          </div>
        )}
        
        {messages.length > 0 && (
            <div> {/* Wrapper for messages */}
                {messages.map((msg, index) => (
                  <ChatMessageContent key={index} message={msg} />
                ))}
            </div>
        )}

        {/* Loading and Error moved inside the scrollable area */}
        {isLoading && (
          <div className="w-full max-w-full bg-gray-900">
            <div className="max-w-4xl mx-auto px-6 py-6 flex space-x-4">
              <div className="flex-shrink-0 w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center"><IconGemini /></div>
              <div className="flex-1 overflow-hidden flex items-center">
                <IconSpinner /> <span className="ml-2 text-gray-400">생각 중...</span>
              </div>
            </div>
          </div>
        )}
        {error && (
          <div className="w-full max-w-full bg-red-900 text-red-200">
            <div className="max-w-4xl mx-auto px-6 py-4"> <strong>오류:</strong> {error} </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* (원칙 1: 게슈탈트 - 입력창 영역) */}
      <div className="flex-shrink-0 p-4 bg-gray-950">
        <form onSubmit={handleSubmit} className="max-w-4xl mx-auto flex items-end space-x-4">
          <textarea
            ref={textareaRef}
            rows="1" 
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={handleKeyDown} 
            className="flex-1 px-4 py-3 bg-gray-800 text-white rounded-lg border border-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none overflow-y-auto"
      
          style={{ maxHeight: '200px' }} 
            placeholder={isLoading ? "답변 생성 중..." : `${chat.storeDisplayName}에 질문하기... (Enter로 줄바꿈, Shift+Enter로 전송)`}
            disabled={isLoading}
          />
          {/* (원칙 4: 피츠의 법칙 - 전송 버튼 크기 확보) */}
          <button
            type="submit"
            className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition disabled:opacity-50 self-end"
            disabled={isLoading || !input.trim()}
          >
            전송
          </button>
        </form>
      </div>
    </div>
  );
}


/* --- 메인 앱 컴포넌트 --- */
function App() {
  const [apiKey, setApiKey] = useState(localStorage.getItem('gemini-api-key') || '');
  const [systemInstruction, setSystemInstruction] = useState(localStorage.getItem('gemini-system-instruction') || '반드시 모든 답변에는 출처를 특정하여 기술하세요.');
  const [selectedModel, setSelectedModel] = useState(localStorage.getItem('gemini-selected-model') || 'gemini-2.5-flash');

  const [apiKeyValid, setApiKeyValid] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [globalError, setGlobalError] = useState(null);
  
  const [currentView, setCurrentView] = useState('STORES'); // 'STORES', 'DOCS', 'DOC_SEARCH', 'CHAT', 'STORE_SEARCH'
  const [selectedStore, setSelectedStore] = useState(null);
  const [selectedDoc, setSelectedDoc] = useState(null);
  const [selectedChat, setSelectedChat] = useState(null);

  const [stores, setStores] = useState([]);
  const [documents, setDocuments] = useState([]);
  const [chats, setChats] = useState([]);
  
  const [pendingOperations, setPendingOperations] = useState({});
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  
  const [deletingStoreName, setDeletingStoreName] = useState(null);

  // (데이터 CRUD 및 헬퍼 함수들은 변경 없음)
  const addOperation = (id, description) => { 
    console.log('[Operation] Add:', id, description); // [LOG]
    setPendingOperations(prev => ({ ...prev, [id]: { id, description, status: 'processing' } })); 
  };
  const updateOperation = (id, status, error = null) => { 
    console.log('[Operation] Update:', id, status, error); // [LOG]
    setPendingOperations(prev => ({ ...prev, [id]: { ...prev[id], status, error } })); 
  };
  const removeOperation = (id) => { 
    console.log('[Operation] Remove:', id); // [LOG]
    setPendingOperations(prev => { const newState = { ...prev }; delete newState[id]; return newState; }); 
  };

  const validateApiKey = useCallback(async (key) => {
    console.log('[Auth] API 키 유효성 검사 중...'); // [LOG]
    if (!key) { 
      console.log('[Auth] API 키 없음.'); // [LOG]
      setApiKeyValid(false); setIsLoading(false); return; 
    }
    setIsLoading(true); setGlobalError(null);
    try {
      await apiRequest('fileSearchStores', { method: 'GET' }, key);
      console.log('[Auth] API 키 유효성 검사 성공.'); // [LOG]
      setApiKeyValid(true);
      localStorage.setItem('gemini-api-key', key);
    } catch (error) {
      console.error('[Auth] API 키 유효성 검사 실패:', error); // [LOG]
      setApiKeyValid(false);
      setGlobalError('API 키가 유효하지 않거나, 네트워크 오류가 발생했습니다.');
      localStorage.removeItem('gemini-api-key');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    validateApiKey(apiKey);
  }, [apiKey, validateApiKey]);

  useEffect(() => {
    if (apiKeyValid) { 
      console.log('[Data] API 키 유효, 스토어 및 채팅 로드.'); // [LOG]
      listStores(); 
      loadChats(); 
    } 
    else { 
      console.log('[Data] API 키 유효하지 않음, 데이터 초기화.'); // [LOG]
      setStores([]); 
      setChats([]); 
    }
  }, [apiKeyValid]);

  const listStores = useCallback(async () => {
    if (!apiKeyValid) return;
    console.log('[Data] 스토어 목록 로드 중...'); // [LOG]
    setIsLoading(true);
    try {
      const data = await apiRequest('fileSearchStores', { method: 'GET' }, apiKey);
      setStores(data.fileSearchStores || []);
      console.log(`[Data] 스토어 ${data.fileSearchStores?.length || 0}개 로드 완료.`); // [LOG]
    } catch (error) { 
      console.error('[Data] 스토어 목록 로드 실패:', error); // [LOG]
      setGlobalError(error.message); 
    } finally { setIsLoading(false); }
  }, [apiKey, apiKeyValid]);

  const createStore = async (displayName) => {
    console.log(`[Data] 스토어 생성 중: ${displayName}`); // [LOG]
    try {
      const newStore = await apiRequest('fileSearchStores', { method: 'POST', body: JSON.stringify({ displayName }), }, apiKey);
      console.log(`[Data] 스토어 생성 성공:`, newStore); // [LOG]
      setStores([newStore, ...stores]);
    } catch (error) { 
      console.error(`[Data] 스토어 생성 실패:`, error); // [LOG]
      setGlobalError(`스토어 생성 실패: ${error.message}`); 
    }
  };

  const deleteStore = async (storeName) => {
    console.log(`[Data] 스토어 삭제 요청: ${storeName}`); // [LOG]
    const result = await Swal.fire({
      title: '정말 삭제하시겠습니까?',
      text: "이 스토어와 관련된 모든 문서 및 채팅 기록(로컬)이 영구적으로 삭제됩니다.",
      icon: 'warning',
      showCancelButton: true,
      confirmButtonText: '삭제',
      cancelButtonText: '취소',
      confirmButtonColor: '#e53e3e',
      background: '#1f2937', 
      color: '#d1d5db'
    });

    if (!result.isConfirmed) {
      console.log('[Data] 스토어 삭제 취소됨.'); // [LOG]
      return;
    }
    
    setDeletingStoreName(storeName); 
    setGlobalError(null); 

    console.log(`[Data] 로컬 채팅 삭제 중...`); // [LOG]
    const chatsToDelete = chats.filter(c => c.storeName === storeName);
    for (const chat of chatsToDelete) { await deleteChatFromDB(chat.id); }
    setChats(prev => prev.filter(c => c.storeName !== storeName));
    
    try {
      console.log(`[Data] API 스토어 삭제 중 (force=true): ${storeName}`); // [LOG]
      await apiRequest(storeName, { method: 'DELETE', params: { force: true } }, apiKey);
      setStores(stores.filter(s => s.name !== storeName));
      console.log(`[Data] 스토어 삭제 완료: ${storeName}`); // [LOG]
    } catch (error) { 
      console.error(`[Data] 스토어 삭제 실패:`, error); // [LOG]
      setGlobalError(`스토어 삭제 실패: ${error.message}`); 
    } finally {
      setDeletingStoreName(null); 
    }
  };

  const listDocuments = useCallback(async (storeName) => {
    if (!apiKeyValid) return;
    setIsLoading(true);
    setDocuments([]); 
    let allDocuments = [];
    let nextPageToken = null;
    try {
      do {
        const params = { pageSize: 20 };
        if (nextPageToken) {
          params.pageToken = nextPageToken;
        }
        const data = await apiRequest(`${storeName}/documents`, { 
            method: 'GET',
            params: params
        }, apiKey);
        allDocuments = [...allDocuments, ...(data.documents || [])];
        nextPageToken = data.nextPageToken;
      } while (nextPageToken);
      setDocuments(allDocuments);
    } catch (error) {
      setGlobalError(error.message);
    } finally {
      setIsLoading(false);
    }
  }, [apiKey, apiKeyValid]);

  const uploadFiles = async (storeName, files) => {
    console.log(`[Data] ${files.length}개 파일 업로드 시작...`); // [LOG]
    for (const file of files) {
      const opId = `upload-${crypto.randomUUID()}`;
      addOperation(opId, `${file.name} 업로드 중...`);
      const metadata = { displayName: file.name };
      try {
        const operation = await apiUploadRequest(
          `${storeName}:uploadToFileSearchStore`, file, metadata, apiKey
        );
        console.log(`[Data] ${file.name} 업로드 성공, 인덱싱 시작... Op: ${operation.name}`); // [LOG]
        updateOperation(opId, 'indexing', '파일 인덱싱 중...');
        pollOperation(operation.name, opId);
      } catch (error) {
        console.error(`[Data] ${file.name} 업로드 실패:`, error); // [LOG]
        updateOperation(opId, 'failed', error.message);
      }
    }
  };

  const deleteDocument = async (docName) => {
    console.log(`[Data] 문서 삭제 요청: ${docName}`); // [LOG]
    try {
      await apiRequest(docName, { method: 'DELETE', params: { force: true } }, apiKey);
      setDocuments(documents.filter(d => d.name !== docName));
      console.log(`[Data] 문서 삭제 성공: ${docName}`); // [LOG]
    } catch (error) { 
      console.error(`[Data] 문서 삭제 실패:`, error); // [LOG]
      setGlobalError(`문서 삭제 실패: ${error.message}`); 
    }
  };

  const pollOperation = useCallback(async (opName, uiOpId) => {
    try {
      console.log(`[Poll] ${uiOpId} 상태 확인 중...`); // [LOG]
      const operation = await apiRequest(opName, { method: 'GET' }, apiKey);
      if (operation.done) {
        if (operation.error) { 
          console.error(`[Poll] ${uiOpId} 작업 실패:`, operation.error); // [LOG]
          throw new Error(operation.error.message); 
        }
        console.log(`[Poll] ${uiOpId} 작업 성공.`); // [LOG]
        updateOperation(uiOpId, 'succeeded', '완료');
        if (currentView === 'STORES') listStores();
        if (currentView === 'DOCS' && selectedStore) listDocuments(selectedStore.name);
        setTimeout(() => removeOperation(uiOpId), 3000);
      } else {
        console.log(`[Poll] ${uiOpId} 아직 진행 중...`); // [LOG]
        setTimeout(() => pollOperation(opName, uiOpId), 3000);
      }
    } catch (error) { 
      console.error(`[Poll] ${uiOpId} 폴링 오류:`, error); // [LOG]
      updateOperation(uiOpId, 'failed', error.message); 
    }
  }, [apiKey, currentView, selectedStore, listStores, listDocuments]);

  const loadChats = async () => { 
    console.log('[Data] 로컬 채팅 기록 로드 중...'); // [LOG]
    const dbChats = await getChatsFromDB(); 
    setChats(dbChats); 
    console.log(`[Data] 로컬 채팅 ${dbChats.length}개 로드 완료.`); // [LOG]
  };
  const createNewChat = (store) => { 
    console.log(`[Data] 새 채팅 생성 (스토어: ${store.displayName})`); // [LOG]
    const newChat = { id: crypto.randomUUID(), storeName: store.name, storeDisplayName: store.displayName, title: "새 채팅", messages: [], createdAt: new Date().toISOString(), }; 
    setChats([newChat, ...chats]); 
    setSelectedChat(newChat); 
    saveChatToDB(newChat); 
    setCurrentView('CHAT'); 
  };
  const updateChat = (chat) => { 
    console.log(`[Data] 채팅 업데이트: ${chat.title}`); // [LOG]
    setSelectedChat(chat); 
    saveChatToDB(chat); 
    setChats(prev => prev.map(c => c.id === chat.id ? chat : c)); 
  };
  const deleteChat = (chatId) => { 
    console.log(`[Data] 채팅 삭제: ${chatId}`); // [LOG]
    deleteChatFromDB(chatId); 
    setChats(prev => prev.filter(c => c.id !== chatId)); 
    if (selectedChat?.id === chatId) { 
      setSelectedChat(null); 
      setCurrentView('STORES'); 
    } 
  };

  /* --- UI 렌더링 로직 --- */
  const handleApiKeySubmit = (e) => {
    e.preventDefault();
    const key = e.target.elements.apiKey.value;
    console.log('[Auth] 새 API 키 제출됨.'); // [LOG]
    setApiKey(key);
    validateApiKey(key);
  };

  const selectStoreForDocs = (store) => { 
    console.log(`[View] 문서 관리로 전환: ${store.displayName}`); // [LOG]
    setSelectedStore(store); 
    listDocuments(store.name); 
    setCurrentView('DOCS'); 
  };
  const selectStoreForChat = (store) => { 
    console.log(`[View] 채팅으로 전환: ${store.displayName}`); // [LOG]
    setSelectedStore(store); 
    const existingChat = chats.find(c => c.storeName === store.name); 
    if (existingChat) { 
      setSelectedChat(existingChat); 
      setCurrentView('CHAT'); 
    } else { 
      createNewChat(store); 
    } 
  };
  const selectDocForSearch = (doc) => { 
    console.log(`[View] 단일 문서 검색으로 전환: ${doc.displayName}`); // [LOG]
    setSelectedDoc(doc); 
    setCurrentView('DOC_SEARCH'); 
  };
  const selectStoreForSearch = (store) => {
    console.log(`[View] 스토어 전체 검색으로 전환: ${store.displayName}`); // [LOG]
    setSelectedStore(store);
    setCurrentView('STORE_SEARCH');
  };
  const navigateTo = (view) => { 
    console.log(`[View] 뷰 전환: ${view}`); // [LOG]
    setCurrentView(view); 
    if (view === 'STORES') { 
      setSelectedStore(null); 
      setSelectedDoc(null); 
      setSelectedChat(null); 
      listStores(); 
    } 
  };
  const selectChat = (chat) => { 
    console.log(`[View] 기존 채팅 선택: ${chat.title}`); // [LOG]
    setSelectedChat(chat); 
    setCurrentView('CHAT'); 
  };
  
  if (isLoading && !apiKeyValid && !apiKey) {
      return <div className="flex h-screen w-full items-center justify-center bg-gray-950 text-white"><IconSpinner /> 로딩 중...</div>; 
  }

  if (!apiKey) {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-gray-900 text-white">
        <div className="w-full max-w-md p-8 bg-gray-800 rounded-lg shadow-xl">
          <h1 className="text-3xl font-bold text-center text-blue-400 mb-6">Gemini File Store 관리자</h1>
          <p className="text-center text-gray-300 mb-8">시작하려면 Gemini API 키를 입력하세요.</p>
          <form onSubmit={handleApiKeySubmit}>
            <input
              type="password" name="apiKey"
              className="w-full px-4 py-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Gemini API Key"
            />
            <button type="submit" className="w-full mt-6 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition">
              API 키 저장 및 시작
            </button>
            {globalError && <p className="mt-4 text-center text-red-400">{globalError}</p>}
          </form>
        </div>
      </div>
    );
  }

  if (!apiKeyValid) {
     return (
        <div className="flex h-screen w-full items-center justify-center bg-gray-900 text-white">
            <div className="w-full max-w-md p-8 bg-gray-800 rounded-lg shadow-xl">
                <h1 className="text-3xl font-bold text-center text-red-400 mb-6">오류</h1>
                <p className="text-center text-gray-300 mb-8">{globalError || "API 키가 유효하지 않습니다."}</p>
                <button 
                    onClick={() => setIsSettingsOpen(true)} 
                    className="w-full mt-6 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition"
                >
                    설정에서 API 키 수정
                </button>
                <SettingsModal
                    isOpen={true} 
                    onClose={() => setIsSettingsOpen(false)} 
                    apiKey={apiKey}
                    setApiKey={setApiKey} 
                    systemInstruction={systemInstruction}
                    setSystemInstruction={setSystemInstruction}
                    selectedModel={selectedModel} 
                    setSelectedModel={setSelectedModel} 
                />
            </div>
    
    </div>
     );
  }

  return (
    <div className="flex h-screen bg-gray-950 text-gray-200">
      <SettingsModal
        isOpen={isSettingsOpen}
        onClose={() => setIsSettingsOpen(false)}
        apiKey={apiKey}
        setApiKey={setApiKey} 
        systemInstruction={systemInstruction}
        setSystemInstruction={setSystemInstruction}
        selectedModel={selectedModel} 
        setSelectedModel={setSelectedModel} 
      />

      {/* (원칙 1: 게슈탈트 - 채팅 뷰에서 사이드바(전경)와 메인(배경)을 구분) */}
      {currentView === 'CHAT' && (
        <ChatSidebar 
          chats={chats} 
          selectedChat={selectedChat}
          onSelectChat={selectChat}
          onCreateNewChat={() => createNewChat(selectedStore)}
          onDeleteChat={deleteChat}
          onUpdateChat={updateChat}
          onNavigateBack={() => navigateTo('STORES')}
          currentStoreName={selectedStore?.displayName}
        />
      )}

      <div className="flex-1 flex flex-col overflow-hidden">
        <Header 
          apiKey={apiKey} 
          onLogout={() => {
            console.log('[Auth] 로그아웃.'); // [LOG]
            setApiKey('');
            setApiKeyValid(false);
            localStorage.removeItem('gemini-api-key');
            localStorage.removeItem('gemini-selected-model'); 
            setGlobalError(null);
          }}
          pendingOperations={pendingOperations}
          removeOperation={removeOperation}
          onOpenSettings={() => setIsSettingsOpen(true)}
        />
        {/* [MODIFIED] main 태그의 className 수정 (채팅 뷰 스크롤 문제 해결) */}
        <main className={`flex-1 ${currentView !== 'CHAT' ? 'overflow-y-auto p-4 md:p-8' : 'overflow-hidden'}`}>
          {globalError && (
            <div className="m-4 md:m-8 bg-red-800 border border-red-600 text-red-200 px-4 py-3 rounded-lg relative" role="alert">
              <span className="block sm:inline">{globalError}</span>
              <button className="absolute top-0 bottom-0 right-0 px-4 py-3" onClick={() => setGlobalError(null)}>
                  <IconXSmall />
              </button>
            </div>
          )}

          <div className={currentView !== 'CHAT' ? 'max-w-7xl mx-auto' : 'h-full'}>
            {currentView === 'STORES' && (
              <FileSearchStoreList 
                stores={stores}
                deletingStoreName={deletingStoreName}
                onCreateStore={createStore}
                onDeleteStore={deleteStore}
                onSelectStoreForDocs={selectStoreForDocs}
                onSelectStoreForChat={selectStoreForChat}
              />
            )}
            
            {currentView === 'DOCS' && selectedStore && (
              <DocumentList
                store={selectedStore}
                documents={documents}
                onDeleteDocument={deleteDocument}
                onUploadFiles={uploadFiles} 
                onSelectDocument={selectDocForSearch}
                onBack={() => navigateTo('STORES')}
                isLoading={isLoading}
                onSelectStoreForSearch={selectStoreForSearch} 
              />
            )}

            {currentView === 'DOC_SEARCH' && selectedDoc && (
              <DocumentSearch
                document={selectedDoc}
                apiKey={apiKey}
                onBack={() => setCurrentView('DOCS')}
              />
            )}
            
            {currentView === 'STORE_SEARCH' && selectedStore && (
              <StoreSearch
                store={selectedStore}
                documents={documents}
                apiKey={apiKey}
                onBack={() => setCurrentView('DOCS')}
                selectedModel={selectedModel} 
              />
            )}

      </div>

          {currentView === 'CHAT' && selectedChat && (
            <ChatInterface
              key={selectedChat.id}
              chat={selectedChat}
              apiKey={apiKey}
              systemInstruction={systemInstruction}
              onUpdateChat={updateChat}
              selectedModel={selectedModel} 
            />
          )}
        </main>
      </div>
    </div>
  );
}


// React 앱 마운트
const container = document.getElementById('root');
if (!window._geminiAppRoot) {
  // ReactDOM 18+의 createRoot를 우선적으로 시도
  const EffectiveReactDOM = ReactDOM.default || ReactDOM; 
  if (EffectiveReactDOM && typeof EffectiveReactDOM.createRoot === 'function') {
    window._geminiAppRoot = EffectiveReactDOM.createRoot(container);
  // 일부 환경(예: CodePen)에서는 ReactDOMClient가 노출될 수 있음
  } else if (typeof ReactDOMClient !== 'undefined') {
    window._geminiAppRoot = ReactDOMClient.createRoot(container);
  } else {
    console.error('Could not find ReactDOM.createRoot or ReactDOMClient.createRoot.');
  }
}
if (window._geminiAppRoot) {
  window._geminiAppRoot.render(<App />);
} else {
  console.error('Failed to create React root.');
}

})(); // IIFE 종료
    </script>
</body>
</html>
