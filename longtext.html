<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 번역 보조 도구</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- JSZip 라이브러리 추가 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Firebase SDK 추가 -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase 전역 변수 설정 (Canvas 환경에서 제공)
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        let app, db, auth, userId;

        window.firebaseInitPromise = (async () => {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                userId = auth.currentUser?.uid || crypto.randomUUID(); // Fallback for anonymous or if uid is somehow null
                console.log("Firebase initialized. User ID:", userId);
                document.getElementById('user-id-display').textContent = userId;

                window.firebase = { app, db, auth, userId, appId };
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                document.getElementById('user-id-display').textContent = "Initialization Failed";
                // Fallback to anonymous if custom token fails
                try {
                    auth = getAuth(app); // Ensure auth is initialized even if app failed previously
                    await signInAnonymously(auth);
                    userId = auth.currentUser?.uid || crypto.randomUUID();
                    console.log("Firebase initialized with anonymous auth. User ID:", userId);
                    document.getElementById('user-id-display').textContent = userId;
                    window.firebase = { app, db, auth, userId, appId };
                } catch (anonError) {
                    console.error("Anonymous sign-in failed:", anonError);
                    document.getElementById('user-id-display').textContent = "Auth Failed";
                    window.firebase = null; // Mark firebase as failed
                }
            }
        })();
    </script>
    <style>
        body { font-family: 'Inter', 'Noto Sans KR', sans-serif; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        .outline-item { cursor: pointer; transition: all 0.2s ease-in-out; }
        .outline-item:hover { background-color: #f0f4ff; }
        .outline-item.active { background-color: #e0e7ff; font-weight: 600; border-left: 4px solid #4f46e5; padding-left: 12px !important; }
        .outline-item.completed { background-color: #ecfdf5; border-left: 4px solid #10b981; } /* Green for completed */
        #sidebar { transition: transform 0.3s ease-in-out; }
        .modal { transition: opacity 0.3s ease; }
        .modal-content { transition: transform 0.3s ease; }

        /* Project Modal specific styles */
        .project-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: #f8f8f8;
            border-radius: 8px;
            margin-bottom: 8px;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }
        .project-item:hover {
            background-color: #f0f4ff;
        }
        .project-item.active-project {
            background-color: #e0e7ff;
            font-weight: 600;
            border: 1px solid #4f46e5;
        }
        .project-item button {
            background-color: #ef4444;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .project-item button:hover {
            opacity: 1;
        }

        /* Adjust textarea padding for copy button */
        #modal-prompt-textarea {
            padding-left: 80px; /* Make space for the button on the left */
        }

        /* Custom styles for the new edit button */
        .chapter-edit-button {
            background: none;
            border: none;
            color: #4f46e5; /* Indigo-600 */
            font-weight: 600;
            padding: 0.5rem 0.75rem; /* px-3 py-2 */
            border-radius: 0.5rem; /* rounded-lg */
            transition: all 0.2s ease-in-out;
            display: flex;
            align-items: center;
            gap: 0.25rem; /* space-x-1 */
        }
        .chapter-edit-button:hover {
            background-color: #e0e7ff; /* Indigo-100 */
            color: #3730a3; /* Indigo-800 */
        }
        .chapter-edit-button:active {
            transform: scale(0.98);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 1.2em;
            color: #4f46e5;
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="spinner"></div>
        <p>데이터 로드 중...</p>
    </div>

    <div class="relative min-h-screen md:flex">
        <!-- Mobile Header -->
        <div class="md:hidden flex justify-between items-center p-4 bg-white border-b border-gray-200 sticky top-0 z-20">
            <!-- Hamburger button moved to the left -->
            <button id="menu-open-btn" class="text-gray-600 hover:text-gray-900 mr-2"><i class="fas fa-bars fa-lg"></i></button>
            <h1 class="text-lg font-bold text-gray-900 flex-grow text-center">AI 번역 보조 도구</h1>
        </div>

        <!-- Sidebar -->
        <aside id="sidebar" class="bg-white w-80 max-w-[85vw] fixed inset-y-0 left-0 z-40 transform -translate-x-full md:relative md:translate-x-0 md:w-1/3 lg:w-1/4 flex flex-col md:h-screen md:sticky md:top-0">
            <div class="p-4 flex justify-between items-center border-b border-gray-200">
                <h1 class="text-xl font-bold text-gray-900">번역 설정</h1>
                <div>
                    <button id="project-manage-btn" class="text-gray-500 hover:text-indigo-600 transition-colors duration-200 mr-2" title="프로젝트 관리"><i class="fas fa-folder fa-lg"></i></button>
                    <button id="settings-btn" class="text-gray-500 hover:text-indigo-600 transition-colors duration-200 mr-2" title="프롬프트 템플릿 설정"><i class="fas fa-cog fa-lg"></i></button>
                    <button id="menu-close-btn" class="md:hidden text-gray-500 hover:text-gray-800"><i class="fas fa-times fa-lg"></i></button>
                </div>
            </div>
            <div class="p-4 border-b border-gray-200">
                <p class="text-sm text-gray-600">현재 프로젝트: <span id="current-project-display" class="font-semibold text-indigo-700">선택되지 않음</span></p>
                <p class="text-xs text-gray-500 mt-1">사용자 ID: <span id="user-id-display" class="font-mono text-gray-700 break-all">로딩 중...</span></p>
            </div>
            <div class="flex-grow overflow-y-auto">
                <div class="p-4">
                    <label for="zip-file-input-btn" class="text-sm font-semibold mb-2 block">ZIP 파일 업로드:</label>
                    <input type="file" id="zip-file-input" accept=".zip" class="hidden">
                    <button id="zip-file-input-btn" class="w-full bg-blue-600 text-white py-2 rounded-lg font-semibold hover:bg-blue-700 transition shadow-sm">
                        <i class="fas fa-upload mr-2"></i> ZIP 파일 업로드
                    </button>
                    <p id="zip-status-message" class="mt-2 text-sm text-gray-600"></p>
                    <p class="text-xs text-gray-500 mt-1">ZIP 파일 내의 .txt 파일들이 목차로 변환됩니다.</p>
                </div>
                <div class="p-4">
                    <label for="json-input" class="text-sm font-semibold mb-2 block">또는 목차 JSON 직접 붙여넣기:</label>
                    <textarea id="json-input" class="w-full h-40 p-3 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-indigo-500" placeholder="여기에 JSON 목차를 붙여넣으세요..."></textarea>
                    <button id="render-btn" class="mt-3 w-full bg-indigo-600 text-white py-2 rounded-lg font-semibold hover:bg-indigo-700 transition shadow-sm">목차 생성</button>
                </div>
                <hr class="my-2">
                <div class="p-4">
                    <h2 class="text-lg font-semibold mb-2">전체 구조</h2>
                    <div id="outline-container" class="pr-2"><p class="text-gray-400 text-sm">목차를 생성하면 여기에 표시됩니다.</p></div>
                </div>
            </div>
            <div class="p-4 border-t border-gray-200">
                <button id="export-btn" class="w-full bg-green-600 text-white py-2 rounded-lg font-semibold hover:bg-green-700 disabled:bg-gray-400" disabled><i class="fas fa-download mr-2"></i> 전체 번역 다운로드</button>
            </div>
        </aside>

        <!-- Main Content Area -->
        <main class="flex-1 p-4 md:p-6 lg:p-8">
            <div id="main-content-area" class="h-full">
                <div id="welcome-screen" class="flex flex-col items-center justify-center h-full text-center text-gray-500">
                    <i class="fas fa-language text-6xl text-gray-300 mb-4"></i>
                    <h2 class="text-2xl font-bold text-gray-700">번역 작업을 시작하세요</h2>
                    <p class="mt-2">왼쪽 사이드바에서 ZIP 파일을 업로드하거나 목차를 생성해주세요.</p>
                </div>
                <div id="chapter-container" class="hidden">
                    <!-- Chapters will be rendered here -->
                </div>
            </div>
        </main>
    </div>
    
    <!-- Sidebar Overlay for Mobile -->
    <div id="sidebar-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-30 hidden md:hidden"></div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="modal fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50 hidden opacity-0">
        <div class="modal-content bg-white rounded-2xl shadow-2xl w-full max-w-3xl flex flex-col transform scale-95">
            <div class="p-5 border-b border-gray-200 flex justify-between items-center">
                <h3 class="text-2xl font-bold text-gray-900">프롬프트 템플릿 설정</h3>
                <button class="close-modal-btn text-gray-400 hover:text-gray-800"><i class="fas fa-times fa-2x"></i></button>
            </div>
            <div class="p-6 flex-grow overflow-y-auto">
                <textarea id="prompt-template-input" class="w-full h-80 p-4 border border-gray-300 rounded-lg text-sm font-mono focus:ring-2 focus:ring-indigo-500"></textarea>
                <div class="mt-4 p-4 bg-gray-100 rounded-lg">
                    <h4 class="font-semibold text-gray-700 mb-2">사용 가능한 변수:</h4>
                    <div class="grid grid-cols-2 md:grid-cols-3 gap-x-4 gap-y-2 text-sm text-gray-600">
                        <p><code>&lt;&lt;책제목&gt;&gt;</code></p>
                        <p><code>&lt;&lt;파트&gt;&gt;</code></p>
                        <p><code>&lt;&lt;파트설명&gt;&gt;</code></p>
                        <p><code>&lt;&lt;챕터&gt;&gt;</code></p>
                        <p><code>&lt;&lt;챕터설명&gt;&gt;</code></p>
                        <p><code>&lt;&lt;전체목차&gt;&gt;</code></p>
                        <p><code>&lt;&lt;현재파트목차&gt;&gt;</code></p>
                        <p><code>&lt;&lt;원본텍스트&gt;&gt;</code></p> <!-- New variable for source text -->
                        <p><code>&lt;&lt;자료&gt;&gt;</code></p>
                    </div>
                </div>
            </div>
            <div class="p-5 border-t border-gray-200 flex justify-between items-center">
                <button id="reset-template-btn" class="text-sm text-gray-500 hover:text-red-600">기본값으로 초기화</button>
                <div>
                    <span id="template-save-status" class="text-sm mr-4"></span>
                    <button id="save-template-btn" class="bg-indigo-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-indigo-700">저장</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Project Management Modal -->
    <div id="project-modal" class="modal fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50 hidden opacity-0">
        <div class="modal-content bg-white rounded-2xl shadow-2xl w-full max-w-xl flex flex-col transform scale-95">
            <div class="p-5 border-b border-gray-200 flex justify-between items-center">
                <h3 class="text-2xl font-bold text-gray-900">프로젝트 관리</h3>
                <button class="close-modal-btn text-gray-400 hover:text-gray-800"><i class="fas fa-times fa-2x"></i></button>
            </div>
            <div class="p-6 flex-grow overflow-y-auto">
                <div class="mb-6">
                    <h4 class="text-lg font-semibold mb-3 text-gray-700">새 프로젝트 생성</h4>
                    <div class="flex gap-2">
                        <input type="text" id="new-project-name" class="flex-grow p-3 border border-gray-300 rounded-lg text-base focus:ring-2 focus:ring-indigo-500" placeholder="새 프로젝트 이름 (예: AI 번역 프로젝트)">
                        <button id="create-project-btn" class="bg-blue-600 text-white px-5 py-2 rounded-lg font-semibold hover:bg-blue-700 transition shadow-sm">생성</button>
                    </div>
                    <p id="new-project-status" class="mt-2 text-sm text-red-500"></p>
                </div>

                <div class="mb-6"> <!-- New section for materials -->
                    <h4 class="text-lg font-semibold mb-3 text-gray-700">프로젝트 자료 (모든 챕터 프롬프트에 포함)</h4>
                    <textarea id="project-materials-input" class="w-full h-32 p-3 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-indigo-500" placeholder="이 프로젝트의 모든 챕터 생성 시 참조될 자료를 입력하세요. (예: 번역 지침, 용어집 등)"></textarea>
                    <button id="save-project-materials-btn" class="mt-3 w-full bg-indigo-600 text-white py-2 rounded-lg font-semibold hover:bg-indigo-700 transition shadow-sm">자료 저장</button>
                    <p id="project-materials-status" class="mt-2 text-sm text-gray-600"></p>
                </div>

                <div>
                    <h4 class="text-lg font-semibold mb-3 text-gray-700">내 프로젝트</h4>
                    <div id="project-list" class="space-y-2">
                        <p class="text-gray-400 text-sm">저장된 프로젝트가 없습니다.</p>
                    </div>
                </div>
            </div>
            <div class="p-5 border-t border-gray-200 flex justify-end">
                <button class="close-modal-btn bg-gray-200 text-gray-800 px-6 py-2 rounded-lg font-semibold hover:bg-gray-300">닫기</button>
            </div>
        </div>
    </div>

    <!-- Chapter Editor Modal (New) -->
    <div id="chapter-editor-modal" class="modal fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50 hidden opacity-0">
        <div class="modal-content bg-white rounded-2xl shadow-2xl w-full max-w-4xl h-[90vh] flex flex-col transform scale-95">
            <div class="p-5 border-b border-gray-200 flex justify-between items-center">
                <h3 id="chapter-editor-modal-title" class="text-2xl font-bold text-gray-900">챕터 편집: </h3>
                <button class="close-modal-btn text-gray-400 hover:text-gray-800"><i class="fas fa-times fa-2x"></i></button>
            </div>
            <div class="p-6 flex-grow overflow-y-auto flex flex-col gap-6">
                <div>
                    <h4 class="text-base font-semibold mb-2 text-gray-700"><i class="fas fa-file-alt mr-2 text-blue-500"></i>원본 텍스트</h4>
                    <textarea id="modal-source-textarea" readonly class="w-full h-48 p-3 border bg-gray-50 border-gray-300 rounded-lg text-sm resize-none"></textarea>
                </div>
                <div>
                    <h4 class="text-base font-semibold mb-2 text-gray-700"><i class="fas fa-magic-sparkles mr-2 text-indigo-500"></i>자동 생성 프롬프트</h4>
                    <div class="relative">
                        <!-- Copy button positioned to the left -->
                        <button id="modal-copy-prompt-btn" class="absolute top-3 left-3 bg-indigo-500 text-white px-4 py-2 rounded-lg text-sm font-semibold hover:bg-indigo-600 transition shadow-sm z-10"><i class="fas fa-copy mr-1"></i> 복사</button>
                        <textarea id="modal-prompt-textarea" readonly class="w-full h-48 p-3 border bg-white border-gray-300 rounded-lg text-sm resize-none"></textarea>
                    </div>
                    <p id="copy-status-message" class="text-sm mt-1 text-gray-600"></p>
                </div>
                <div>
                    <h4 class="text-base font-semibold mb-2 text-gray-700"><i class="fas fa-pencil-alt mr-2 text-green-500"></i>번역 결과 입력</h4>
                    <textarea id="modal-result-textarea" class="w-full h-60 p-3 border border-gray-300 rounded-lg text-base focus:ring-2 focus:ring-indigo-500 resize-y" placeholder="LLM 생성 번역 글을 여기에 붙여넣으세요..."></textarea>
                </div>
            </div>
            <div class="p-5 border-t border-gray-200 flex justify-end items-center">
                <span id="modal-save-status" class="text-sm mr-4"></span>
                <button id="modal-save-btn" class="bg-indigo-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-indigo-700 transition shadow-sm"><i class="fas fa-save mr-2"></i> 저장</button>
            </div>
        </div>
    </div>

    <!-- Generic Message Modal -->
    <div id="message-modal" class="modal fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50 hidden opacity-0">
        <div class="modal-content bg-white rounded-2xl shadow-2xl w-full max-w-sm flex flex-col transform scale-95">
            <div class="p-5 border-b border-gray-200 flex justify-between items-center">
                <h3 id="message-modal-title" class="text-xl font-bold text-gray-900">알림</h3>
                <button class="close-modal-btn text-gray-400 hover:text-gray-800"><i class="fas fa-times fa-2x"></i></button>
            </div>
            <div class="p-6">
                <p id="message-modal-content" class="text-gray-700"></p>
            </div>
            <div class="p-5 border-t border-gray-200 flex justify-end">
                <button class="close-modal-btn bg-indigo-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-indigo-700">확인</button>
            </div>
        </div>
    </div>

    <!-- Generic Confirmation Modal -->
    <div id="confirmation-modal" class="modal fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50 hidden opacity-0">
        <div class="modal-content bg-white rounded-2xl shadow-2xl w-full max-w-sm flex flex-col transform scale-95">
            <div class="p-5 border-b border-gray-200 flex justify-between items-center">
                <h3 id="confirmation-modal-title" class="text-xl font-bold text-gray-900">확인</h3>
                <button class="close-modal-btn text-gray-400 hover:text-gray-800"><i class="fas fa-times fa-2x"></i></button>
            </div>
            <div class="p-6">
                <p id="confirmation-modal-content" class="text-gray-700"></p>
            </div>
            <div class="p-5 border-t border-gray-200 flex justify-end gap-3">
                <button id="confirm-cancel-btn" class="bg-gray-200 text-gray-800 px-6 py-2 rounded-lg font-semibold hover:bg-gray-300">취소</button>
                <button id="confirm-ok-btn" class="bg-red-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-red-700">확인</button>
            </div>
        </div>
    </div>


    <script type="module">
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // 전역 Firebase 객체가 초기화될 때까지 기다립니다.
        let db, userId, appId;
        const waitForFirebase = async () => {
            if (window.firebase && window.firebase.db && window.firebase.userId && window.firebase.appId) {
                db = window.firebase.db;
                userId = window.firebase.userId;
                appId = window.firebase.appId;
                return true;
            }
            // Firebase 초기화가 비동기적으로 이루어지므로, 프로미스가 해결될 때까지 기다립니다.
            if (window.firebaseInitPromise) {
                await window.firebaseInitPromise;
                if (window.firebase && window.firebase.db && window.firebase.userId && window.firebase.appId) {
                    db = window.firebase.db;
                    userId = window.firebase.userId;
                    appId = window.firebase.appId;
                    return true;
                }
            }
            console.error("Firebase is not initialized after waiting.");
            return false;
        };

        const APP_ID = 'ai-translation-tool-v1'; // Changed app ID for translation version
        const PROMPT_TEMPLATE_KEY = `${APP_ID}-prompt-template`; // This will still use localStorage for simplicity
        // PROJECTS_KEY and CURRENT_PROJECT_KEY are no longer directly used for localStorage, but for conceptual mapping

        // Updated DEFAULT_PROMPT_TEMPLATE for translation
        const DEFAULT_PROMPT_TEMPLATE = `
<?xml version="1.0" encoding="UTF-8"?>
<metaPrompt>
  <purpose>
    essentialContext에 제공된 특정 문서를 입력받아, 원문의 톤앤매너를 완벽하게 유지하면서도 가장 유려하고 자연스러운 한국어로 한 문장도 빠짐없이 번역한다.
    최종 결과물은 즉시 출판 가능하도록 가독성, 읽기 쉬우면서, 학문적 엄밀성을 보전하고, 의미 전달의 정확성, 어법 준수성을 최고 수준으로 충족해야 한다.
  </purpose>

  <promptDesignFramework>

    <objectiveDefinition id="1" title="목표 정의: 과업의 제1원칙">
      <finalDeliverable id="1.1" description="프롬프트를 통해 얻고자 하는 최종 결과물">
        이 문서의 콘텐츠는 사용자가 제공한 원문을 한국어로 완벽하게 번역하고, 전문가 수준으로 다듬어 즉시 출판하여 베스트셀러가 될 수 있는 상태의 글이다.
      </finalDeliverable>
      <coreTask id="1.2" description="LLM이 수행해야 할 핵심적인 동사">
        번역(Translate), 교정(Refine), 그리고 형식화(Format). 단순히 단어를 옮기는 것을 넘어, 전문 편집자로서 원문의 의미와 뉘앙스를 살리면서 한국어 독자에게 최적화된 콘텐츠로 재구성하고, 지정된 XML 형식에 맞춰 구조화해야 한다.
      </coreTask>
      <successCriteria id="1.3" description="결과물이 '성공'이라고 판단할 객관적인 기준">
        - 결과물은 문법적으로 완벽한(well-formed) 한국어
        - 학문적 엄밀성 및 정확성
        - 결과물이 읽기 쉬움
        - 일문 일의주의에 따라 문장을 작성
        - 번역문은 원문의 핵심 의미, 세부 뉘앙스, 그리고 저자의 의도를 100% 보존한다.
        - 한국어 문장은 문법적으로 완벽하며, 원문의 어조와 스타일을 유지하면서도 자연스럽고 유려하다.
        - 제목, 요약, 소제목, 문단 나누기 등 내용의 논리적 흐름을 반영하여 가독성을 극대화한다.
        - '[여기에 입력]'과 같은 플레이스홀더 텍스트가 최종 결과물에 남아있지 않다.
      </successCriteria>
    </objectiveDefinition>

    <personaAssignment id="2" title="역할 부여: 최적의 인지 모델 설계">
      <expertPersona id="2.1" description="과업을 가장 잘 수행할 전문가의 상세한 묘사">
        당신은 '마스터 번역가 겸 콘텐츠 전략가'입니다. 20년 경력의 국제회의 통역사이자 여러 권의 베스트셀러 기술 서적을 번역한 경험이 있습니다. 당신은 단순히 언어를 변환하는 것을 넘어, 문화적 맥락과 미묘한 뉘앙스까지 포착하여 독자의 마음을 움직이는 글을 만들어내는 전문가입니다. 또한, 디지털 콘텐츠의 가독성과 검색엔진최적화(SEO)에 대한 깊은 이해를 바탕으로, 번역된 콘텐츠가 온라인 환경에서 최고의 성과를 낼 수 있도록 구조화하는 능력을 갖추고 있습니다.
      </expertPersona>
      <audience id="2.2" description="결과물을 소비할 대상과 그들의 지식 수준">
        제공될 원문의 내용, 어휘, 스타일을 분석하여 잠재 독자층(예: 기술 전문가, 일반 대중, 특정 분야의 학생 등)을 추론하고, 그들의 지식 수준과 관심사에 맞춰 가장 이해하기 쉬운 어휘와 문장 구조를 선택해야 한다.
      </audience>
      <toneAndStyle id="2.3" description="결과물의 어조와 스타일 및 정신적 도구">
        - **톤앤매너 복제:** 원문의 톤(예: 학술적, 유머러스함, 진지함, 대중적)을 정확히 분석하고, 그 느낌을 한국어의 표현으로 완벽하게 재현해야 한다. 직역으로 어색해지는 관용구나 문화적 표현은 한국 독자가 즉시 이해할 수 있는 자연스러운 표현으로 의역한다.
        - **정신적 도구 (Mental Model):** '독자의 입장에서 생각하기'. 문장을 완성하기 전에, 잠재 독자의 관점에서 그 문장을 소리 내어 읽어본다고 상상하라. '이 문장은 명확한가? 매력적인가? 이전 내용과 자연스럽게 연결되는가?'를 끊임없이 자문하며 결과물을 다듬어라.
      </toneAndStyle>
    </personaAssignment>

    <contextAndFormat id="3" title="맥락 제공 및 형식 지정">
      <essentialContext id="3.1" description="과업 수행에 필요한 모든 배경 정보, 데이터, 이전 대화 내용">
        <![CDATA[
          <!-- 여기에 번역할 원문을 입력하십시오. -->
          <<원본텍스트>>
        ]]>
      </essentialContext>
      <outputFormat id="3.2" description="결과물이 출력되어야 할 정확한 형식 또는 템플릿">
        <![CDATA[
          입력에 따라서 적절한 형식으로.
        ]]>
      </outputFormat>
    </contextAndFormat>

    <reasoningDesign id="4" title="추론 과정 설계: 생각의 경로 구축">
      <reasoningFramework id="4.1" description="과업 복잡성에 따른 추론 방식 선택">
        <option type="ProblemDecomposition" description="복잡한 프로젝트 수행 시 사용">
          <instruction>아래의 최종 목표를 달성하기 위해, 다음의 하위 작업들을 명시된 순서대로 반드시 수행하라. 각 단계의 결과는 다음 단계의 입력으로 사용된다.</instruction>
          <subTasks>
            <task id="1">**1단계: 원문 심층 분석 (Analyze):** 제공된 원문을 최소 3회 이상 정독하여 핵심 메시지, 논리 구조, 저자의 어조와 문체, 그리고 숨은 의도를 완벽하게 파악한다.</task>
            <task id="2">**2단계: 초벌 번역 및 뉘앙스 포착 (Translate & Capture):** 원문의 의미를 정확하게 전달하는 데 초점을 맞춰 초벌 번역을 수행한다. 특히 기술 용어, 관용 표현, 문화적 배경이 담긴 뉘앙스를 놓치지 않도록 주의한다.</task>
            <task id="3">**3단계: 윤문 및 유려함 확보 (Refine & Polish):** 초벌 번역 결과물을 한국어 독자의 시각에서 어색함이 없도록 다듬는다. 딱딱한 번역투 문장을 자연스러운 한국어 문장으로 재구성하고, 더 적절한 어휘를 선택하여 글 전체의 유려함을 극대화한다.</task>
            <task id="4">**4단계: 콘텐츠 구조화 및 형식화 (Structure & Format):** 완성된 번역문을 지정된 XML 형식에 맞춰 재구성한다. 독자의 흥미를 유발할 제목과 핵심을 꿰뚫는 요약을 작성한다. 가독성을 높이기 위해 본문을 논리적인 문단과 소제목으로 나누고, 핵심 키워드를 추출하여 태그를 생성한다.</task>
          </subTasks>
        </option>
      </reasoningFramework>
      <fewShotExamples id="4.2" description="1~3개의 고품질 입/출력 예시로 결과물 패턴 학습">
        <example id="1">
          <input><![CDATA[
            Title: The Unseen Power of Micro-interactions

            Micro-interactions are the small, often unnoticed animations and design elements that make a user interface feel alive. Think of the "like" button animation on Twitter, or the subtle bounce when you pull to refresh a feed. While seemingly minor, these details are critical. They provide feedback, guide users, and add a touch of personality to a digital product, transforming a functional tool into an enjoyable experience. Good micro-interactions are almost invisible, doing their job without shouting for attention.
          ]]></input>
          <output><![CDATA[
            <!-- 번역된 내용 -->
          ]]></output>
        </example>
      </fewShotExamples>
    </constraints>

    <constraints id="5" title="제약 조건 설정: 탐색 공간 제어">
      <mustInclude id="5.1" description="결과물에 반드시 포함되어야 할 키워드, 개념, 데이터 포인트">
        - 최종 결과물은 번역문이어야 한다.
        - 원문에 포함된 모든 정보는 번역문에 반드시 포함되어야 한다.
      </mustInclude>
      <mustAvoid id="5.2" description="반드시 피해야 할 주제, 표현, 단어, 편향, 가정">
        - 단어 대 단어 식의 기계적인 직역.
        - 원문의 정보를 누락하거나, 원문에 없는 내용을 임의로 추가하는 행위.
        - 한국어 독자가 읽기에 어색하거나 부자연스러운 번역투 문장.
        - 최종 결과물에 '여기를 채우세요'와 같은 미완성된 플레이스홀더를 남기는 것.
      </mustAvoid>
      <selfCorrectionCommand id="5.3" description="생성될 프롬프트 마지막에 포함될 최종 검증 명령">
        <![CDATA[
          모든 지시사항을 완수한 후, 최종 답변을 제출하기 전에 잠시 멈추고 스스로 '레드팀'의 역할을 수행하라. 내가 제시한 모든 요구사항(역할, 형식, 내용, 제약 조건 등)이 100% 충족되었는지, 논리적 비약이나 모순은 없는지, 더 나은 대안은 없는지 최소 세 번 이상 교차 검증하고, 그 결과를 반영하여 최종적으로 완벽하고 군더더기 없는 결과물만 출력하라.
        ]]>
      </selfCorrectionCommand>
    </constraints>

  </promptDesignFramework>
</metaPrompt>
`;

        // --- Application State Management ---
        const appState = {
            currentProjectName: null,
            currentJsonData: null,
            promptTemplate: DEFAULT_PROMPT_TEMPLATE,
            projects: {}, // Stores project metadata: { projectName: { createdAt, jsonContent, materials } }
            chapterContents: {} // Stores actual chapter text: { `${projectName}-${path}`: { source: string, translated: string } }
        };

        // LOCAL_STORAGE_KEYS will now primarily be for prompt template, not main data
        const LOCAL_STORAGE_KEYS = {
            PROMPT_TEMPLATE: `${APP_ID}-prompt-template`,
            // PROJECTS and CURRENT_PROJECT will be managed by Firestore
        };

        // --- Firestore Operations ---

        /**
         * Firestore에서 프로젝트 메타데이터를 가져옵니다.
         * @param {string} projectName - 가져올 프로젝트 이름
         * @returns {Promise<object|null>} 프로젝트 데이터 또는 null
         */
        const getProjectFromFirestore = async (projectName) => {
            if (!db || !userId || !appId) {
                console.error("Firestore not initialized.");
                return null;
            }
            const projectDocRef = doc(db, `artifacts/${appId}/public/data/projects`, projectName);
            const projectDocSnap = await getDoc(projectDocRef);
            if (projectDocSnap.exists()) {
                return projectDocSnap.data();
            }
            return null;
        };

        /**
         * Firestore에 프로젝트 메타데이터를 저장하거나 업데이트합니다.
         * @param {string} projectName - 프로젝트 이름
         * @param {object} projectData - 저장할 프로젝트 데이터
         * @returns {Promise<boolean>} 성공 여부
         */
        const saveProjectToFirestore = async (projectName, projectData) => {
            if (!db || !userId || !appId) {
                console.error("Firestore not initialized.");
                return false;
            }
            try {
                const projectDocRef = doc(db, `artifacts/${appId}/public/data/projects`, projectName);
                await setDoc(projectDocRef, {
                    ...projectData,
                    ownerId: userId, // Store the owner's userId
                    updatedAt: new Date()
                }, { merge: true }); // Merge to update existing fields without overwriting
                return true;
            } catch (error) {
                console.error("Error saving project to Firestore:", error);
                return false;
            }
        };

        /**
         * Firestore에서 모든 프로젝트 목록을 가져옵니다.
         * @returns {Promise<Array<object>>} 프로젝트 목록
         */
        const getAllProjectsFromFirestore = async () => {
            if (!db || !appId) {
                console.error("Firestore not initialized.");
                return [];
            }
            try {
                const projectsColRef = collection(db, `artifacts/${appId}/public/data/projects`);
                // Only fetch projects owned by the current user for now
                const q = query(projectsColRef, where("ownerId", "==", userId));
                const querySnapshot = await getDocs(q);
                const projects = [];
                querySnapshot.forEach((doc) => {
                    projects.push({ id: doc.id, ...doc.data() });
                });
                return projects;
            } catch (error) {
                console.error("Error getting all projects from Firestore:", error);
                return [];
            }
        };

        /**
         * Firestore에서 특정 챕터의 내용을 가져옵니다.
         * @param {string} projectId - 프로젝트 ID
         * @param {string} chapterPath - 챕터 경로 (예: "0.1.2")
         * @returns {Promise<object|null>} 챕터 내용 또는 null
         */
        const getChapterContentFromFirestore = async (projectId, chapterPath) => {
            if (!db || !userId || !appId) {
                console.error("Firestore not initialized.");
                return null;
            }
            const chapterDocRef = doc(db, `artifacts/${appId}/users/${userId}/chapter_contents`, `${projectId}_${chapterPath}`);
            const chapterDocSnap = await getDoc(chapterDocRef);
            if (chapterDocSnap.exists()) {
                return chapterDocSnap.data();
            }
            return null;
        };

        /**
         * Firestore에 특정 챕터의 내용을 저장하거나 업데이트합니다.
         * @param {string} projectId - 프로젝트 ID
         * @param {string} chapterPath - 챕터 경로
         * @param {string} sourceContent - 원본 내용
         * @param {string} translatedContent - 번역된 내용
         * @returns {Promise<boolean>} 성공 여부
         */
        const saveChapterContentToFirestore = async (projectId, chapterPath, sourceContent, translatedContent) => {
            if (!db || !userId || !appId) {
                console.error("Firestore not initialized.");
                return false;
            }
            try {
                const chapterDocRef = doc(db, `artifacts/${appId}/users/${userId}/chapter_contents`, `${projectId}_${chapterPath}`);
                await setDoc(chapterDocRef, {
                    projectId: projectId,
                    chapterPath: chapterPath,
                    source: sourceContent,
                    translated: translatedContent,
                    updatedAt: new Date()
                }, { merge: true });
                return true;
            } catch (error) {
                console.error("Error saving chapter content to Firestore:", error);
                return false;
            }
        };

        /**
         * Firestore에서 특정 프로젝트의 모든 챕터 내용을 가져옵니다.
         * @param {string} projectId - 프로젝트 ID
         * @returns {Promise<object>} { chapterPath: { source, translated } } 형태의 객체
         */
        const getAllChapterContentsForProjectFromFirestore = async (projectId) => {
            if (!db || !userId || !appId) {
                console.error("Firestore not initialized.");
                return {};
            }
            const chapterContents = {};
            try {
                const chaptersColRef = collection(db, `artifacts/${appId}/users/${userId}/chapter_contents`);
                const q = query(chaptersColRef, where("projectId", "==", projectId));
                const querySnapshot = await getDocs(q);
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    chapterContents[data.chapterPath] = { source: data.source, translated: data.translated };
                });
                return chapterContents;
            } catch (error) {
                console.error("Error getting all chapter contents from Firestore:", error);
                return {};
            }
        };

        /**
         * Firestore에서 프로젝트와 관련된 모든 챕터 내용을 삭제합니다.
         * @param {string} projectId - 삭제할 프로젝트 ID
         * @returns {Promise<boolean>} 성공 여부
         */
        const deleteProjectContentsFromFirestore = async (projectId) => {
            if (!db || !userId || !appId) {
                console.error("Firestore not initialized.");
                return false;
            }
            try {
                // Delete project document
                const projectDocRef = doc(db, `artifacts/${appId}/public/data/projects`, projectId);
                await deleteDoc(projectDocRef);

                // Delete all associated chapter contents
                const chaptersColRef = collection(db, `artifacts/${appId}/users/${userId}/chapter_contents`);
                const q = query(chaptersColRef, where("projectId", "==", projectId));
                const querySnapshot = await getDocs(q);
                const deletePromises = [];
                querySnapshot.forEach((doc) => {
                    deletePromises.push(deleteDoc(doc.ref));
                });
                await Promise.all(deletePromises);
                return true;
            } catch (error) {
                console.error("Error deleting project and contents from Firestore:", error);
                return false;
            }
        };


        // --- Application State Management (Updated to use Firestore) ---

        /**
         * 애플리케이션 상태를 로드합니다. (Firestore에서)
         */
        const loadAppState = async () => {
            showLoadingOverlay("데이터 로드 중...");
            try {
                await waitForFirebase();
                if (!db) {
                    console.error("Firebase is not ready for loading app state.");
                    return;
                }

                appState.promptTemplate = localStorage.getItem(PROMPT_TEMPLATE_KEY) || DEFAULT_PROMPT_TEMPLATE;
                
                // Get current project name from localStorage (last active project)
                const lastProjectName = localStorage.getItem(`${APP_ID}-current-project-name`);
                if (lastProjectName) {
                    const projectData = await getProjectFromFirestore(lastProjectName);
                    if (projectData && projectData.ownerId === userId) { // Only load if owned by current user
                        appState.currentProjectName = lastProjectName;
                        appState.currentJsonData = projectData.jsonContent;
                        // Load all chapter contents for the current project from Firestore
                        appState.chapterContents = await getAllChapterContentsForProjectFromFirestore(appState.currentProjectName);
                        console.log("Loaded chapter contents:", appState.chapterContents);
                    } else {
                        console.warn(`Project '${lastProjectName}' not found or not owned by current user. Resetting.`);
                        appState.currentProjectName = null;
                        appState.currentJsonData = null;
                        appState.chapterContents = {};
                    }
                }
            } catch (e) {
                console.error("Failed to load app state from Firestore:", e);
                // Fallback to default/empty state on error
                appState.currentProjectName = null;
                appState.currentJsonData = null;
                appState.chapterContents = {};
            } finally {
                hideLoadingOverlay();
            }
        };

        /**
         * 애플리케이션 상태를 저장합니다. (Firestore에)
         */
        const saveAppState = async () => {
            await waitForFirebase();
            if (!db) {
                console.error("Firebase is not ready for saving app state.");
                return;
            }
            localStorage.setItem(PROMPT_TEMPLATE_KEY, appState.promptTemplate); // Prompt template still in localStorage

            if (appState.currentProjectName) {
                const projectData = {
                    createdAt: appState.projects[appState.currentProjectName]?.createdAt || new Date(),
                    jsonContent: appState.currentJsonData,
                    materials: projectMaterialsInput.value // Always save latest materials from input
                };
                await saveProjectToFirestore(appState.currentProjectName, projectData);
                // Also update the in-memory projects list
                appState.projects[appState.currentProjectName] = { ...projectData, id: appState.currentProjectName };
                // Persist current project name in localStorage for next session
                localStorage.setItem(`${APP_ID}-current-project-name`, appState.currentProjectName);
            }
        };

        /**
         * 특정 챕터의 내용을 저장합니다. (Firestore에)
         * @param {string} path - 챕터의 경로
         * @param {string} sourceContent - 원본 내용
         * @param {string} translatedContent - 번역된 내용
         * @returns {Promise<boolean>} 저장 성공 여부
         */
        const saveChapterContent = async (path, sourceContent, translatedContent) => {
            if (!appState.currentProjectName) {
                console.error("No active project to save chapter content to.");
                return false;
            }
            showLoadingOverlay("챕터 저장 중...");
            try {
                const success = await saveChapterContentToFirestore(appState.currentProjectName, path, sourceContent, translatedContent);
                if (success) {
                    // Update in-memory cache
                    appState.chapterContents[`${appState.currentProjectName}_${path}`] = { source: sourceContent, translated: translatedContent };
                }
                return success;
            } finally {
                hideLoadingOverlay();
            }
        };

        /**
         * 특정 챕터의 내용을 로드합니다. (Firestore에서)
         * @param {string} path - 챕터의 경로
         * @returns {object} 로드된 내용 또는 빈 객체
         */
        const loadChapterContent = (path) => {
            // Try to load from in-memory cache first
            const cachedContent = appState.chapterContents[`${appState.currentProjectName}_${path}`];
            if (cachedContent) {
                return cachedContent;
            }
            // If not in cache, it means it hasn't been loaded yet in this session,
            // or it's a new project. For simplicity, we assume all chapter contents
            // for the current project are loaded into appState.chapterContents
            // when the project is switched/loaded.
            return { source: '', translated: '' };
        };


        // --- DOM Elements ---
        const sidebar = document.getElementById('sidebar');
        const menuOpenBtn = document.getElementById('menu-open-btn');
        const menuCloseBtn = document.getElementById('menu-close-btn');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const promptTemplateInput = document.getElementById('prompt-template-input');
        const saveTemplateBtn = document.getElementById('save-template-btn');
        const resetTemplateBtn = document.getElementById('reset-template-btn');
        const templateSaveStatus = document.getElementById('template-save-status');
        const jsonInput = document.getElementById('json-input');
        const renderBtn = document.getElementById('render-btn');
        const outlineContainer = document.getElementById('outline-container');
        const exportBtn = document.getElementById('export-btn');
        const welcomeScreen = document.getElementById('welcome-screen');
        const chapterContainer = document.getElementById('chapter-container');

        const projectManageBtn = document.getElementById('project-manage-btn');
        const projectModal = document.getElementById('project-modal');
        const newProjectNameInput = document.getElementById('new-project-name');
        const createProjectBtn = document.getElementById('create-project-btn');
        const newProjectStatus = document.getElementById('new-project-status');
        const projectListContainer = document.getElementById('project-list');
        const currentProjectDisplay = document.getElementById('current-project-display');
        const userIdDisplay = document.getElementById('user-id-display');
        const loadingOverlay = document.getElementById('loading-overlay');


        // New Modal Elements for Chapter Editor
        const chapterEditorModal = document.getElementById('chapter-editor-modal');
        const chapterEditorModalTitle = document.getElementById('chapter-editor-modal-title');
        const modalSourceTextarea = document.getElementById('modal-source-textarea'); // New: for original text
        const modalPromptTextarea = document.getElementById('modal-prompt-textarea');
        const modalCopyPromptBtn = document.getElementById('modal-copy-prompt-btn');
        const modalResultTextarea = document.getElementById('modal-result-textarea'); // For translated text
        const modalSaveBtn = document.getElementById('modal-save-btn');
        const modalSaveStatus = document.getElementById('modal-save-status');
        const copyStatusMessage = document.getElementById('copy-status-message');

        // Generic Modal Elements
        const messageModal = document.getElementById('message-modal');
        const messageModalTitle = document.getElementById('message-modal-title');
        const messageModalContent = document.getElementById('message-modal-content');
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationModalTitle = document.getElementById('confirmation-modal-title');
        const confirmationModalContent = document.getElementById('confirmation-modal-content');
        const confirmOkBtn = document.getElementById('confirm-ok-btn');
        const confirmCancelBtn = document.getElementById('confirm-cancel-btn');

        // New DOM elements for Project Materials
        const projectMaterialsInput = document.getElementById('project-materials-input');
        const saveProjectMaterialsBtn = document.getElementById('save-project-materials-btn');
        const projectMaterialsStatus = document.getElementById('project-materials-status');

        // ZIP file input elements
        const zipFileInput = document.getElementById('zip-file-input');
        const zipFileInputBtn = document.getElementById('zip-file-input-btn');
        const zipStatusMessage = document.getElementById('zip-status-message');

        // --- UI Utility Functions ---

        const showLoadingOverlay = (message = "처리 중...") => {
            loadingOverlay.querySelector('p').textContent = message;
            loadingOverlay.classList.remove('hidden');
        };

        const hideLoadingOverlay = () => {
            loadingOverlay.classList.add('hidden');
        };

        /**
         * 주어진 모달을 부드러운 전환 효과와 함께 엽니다.
         * @param {HTMLElement} modal - 열 모달 요소
         */
        const openModal = (modal) => {
            modal.classList.remove('hidden');
            setTimeout(() => {
                modal.classList.remove('opacity-0');
                modal.querySelector('.modal-content').classList.remove('scale-95');
            }, 10);
        };

        /**
         * 주어진 모달을 부드러운 전환 효과와 함께 닫습니다.
         * @param {HTMLElement} modal - 닫을 모달 요소
         */
        const closeModal = (modal) => {
            modal.classList.add('opacity-0');
            modal.querySelector('.modal-content').classList.add('scale-95');
            setTimeout(() => modal.classList.add('hidden'), 300);
        };

        /**
         * 사용자 지정 메시지 모달을 표시합니다.
         * @param {string} title - 메시지 모달의 제목
         * @param {string} message - 메시지 내용
         */
        const showMessageModal = (title, message) => {
            messageModalTitle.textContent = title;
            messageModalContent.textContent = message;
            openModal(messageModal);
        };

        /**
         * 사용자 지정 확인 모달을 표시합니다.
         * @param {string} title - 확인 모달의 제목
         * @param {string} message - 확인을 위한 메시지 내용
         * @returns {Promise<boolean>} 확인되면 true, 취소되면 false로 해결되는 프로미스
         */
        const showConfirmationModal = (title, message) => {
            return new Promise(resolve => {
                confirmationModalTitle.textContent = title;
                confirmationModalContent.textContent = message;
                openModal(confirmationModal);

                const handleConfirm = () => {
                    closeModal(confirmationModal);
                    confirmOkBtn.removeEventListener('click', handleConfirm);
                    confirmCancelBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };

                const handleCancel = () => {
                    closeModal(confirmationModal);
                    confirmOkBtn.removeEventListener('click', handleConfirm);
                    confirmCancelBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };

                confirmOkBtn.addEventListener('click', handleConfirm);
                confirmCancelBtn.addEventListener('click', handleCancel);
            });
        };

        // 모든 모달을 닫기 위한 이벤트 리스너
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', e => {
                if (e.target.classList.contains('close-modal-btn') || e.target.closest('.close-modal-btn') || e.target === modal) {
                    closeModal(modal);
                }
            });
        });

        const openSidebar = () => { sidebar.classList.remove('-translate-x-full'); sidebarOverlay.classList.remove('hidden'); };
        const closeSidebar = () => { sidebar.classList.add('-translate-x-full'); sidebarOverlay.classList.add('hidden'); };


        // --- Core Data & Rendering Logic ---

        /**
         * JSON 데이터에서 주어진 경로에 해당하는 노드를 찾습니다.
         * @param {string} path - 노드의 경로 (예: "0.1.2")
         * @returns {object|null} 해당 노드 객체 또는 null
         */
        const getNodeByPath = (path) => {
            if (!appState.currentJsonData || !path) return null;
            let node = { children: appState.currentJsonData.children }; // 최상위 자식을 포함하는 더미 노드로 시작
            const parts = path.split('.').map(Number);
            for (const index of parts) {
                if (!node.children?.[index]) return null;
                node = node.children[index];
            }
            return node;
        };

        /**
         * 사이드바에 목차를 렌더링합니다.
         * @param {object} data - 렌더링할 JSON 목차 데이터
         * @param {HTMLElement} parentEl - 목차 항목이 추가될 부모 DOM 요소
         * @param {string} pathPrefix - 현재 노드의 경로 접두사
         */
        const renderOutline = (data, parentEl, pathPrefix = '') => {
            parentEl.innerHTML = ''; // 기존 목차 지우기
            if (!data || !data.children || data.children.length === 0) {
                outlineContainer.innerHTML = '<p class="text-gray-400 text-sm">목차를 생성하면 여기에 표시됩니다.</p>';
                return;
            }

            const ul = document.createElement('ul'); // 현재 레벨을 위한 단일 UL 생성
            ul.className = 'space-y-1'; // 목록 항목을 위한 Tailwind 간격
            parentEl.appendChild(ul);

            (data.children || []).forEach((child, index) => {
                const path = pathPrefix ? `${pathPrefix}.${index}` : `${index}`;
                const li = document.createElement('li');
                const chapterContent = loadChapterContent(path);
                li.className = `outline-item p-2 rounded-md text-sm flex items-center ${chapterContent.translated.trim() !== '' ? 'completed' : ''}`; // 완료 클래스 추가
                li.style.paddingLeft = `${(child.level - 1) * 16 + 8}px`;
                li.dataset.path = path;
                li.innerHTML = `
                    <span class="font-medium text-gray-700 flex-grow">${child.title}</span>
                    <i class="completion-icon fas fa-check-circle text-green-500 ml-2 ${chapterContent.translated.trim() !== '' ? '' : 'hidden'}"></i>
                `;
                
                li.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // 선택된 목차 항목 강조
                    document.querySelectorAll('.outline-item.active').forEach(el => el.classList.remove('active'));
                    li.classList.add('active');

                    // 메인 콘텐츠 영역에서 해당 챕터로 스크롤
                    const targetElement = document.querySelector(`[data-path="${path}"].chapter-item`) || document.querySelector(`[data-path="${path}"].part-container`);
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // 챕터인 경우 편집기 모달 열기
                        if (targetElement.classList.contains('chapter-item')) {
                            openChapterEditorModal(path);
                        }
                    }
                });
                ul.appendChild(li); // UL에 추가

                if (child.children?.length > 0) {
                    renderOutline(child, li, path); // 현재 LI 내부에 자식 재귀적으로 렌더링
                }
            });
        };

        /**
         * 메인 콘텐츠 영역에 챕터 목록을 렌더링합니다.
         * @param {object} data - 렌더링할 JSON 목차 데이터
         */
        const renderContent = (data) => {
            welcomeScreen.classList.add('hidden');
            chapterContainer.innerHTML = '';
            chapterContainer.classList.remove('hidden');
            chapterContainer.classList.add('space-y-8');

            if (!data || !data.children || data.children.length === 0) {
                chapterContainer.innerHTML = '<p class="text-gray-500">표시할 챕터가 없습니다. JSON 구조의 `level`을 확인해주세요.</p>';
                return;
            }

            // Recursive helper function to render nodes in the main content area
            const renderMainContentNode = (node, parentEl, pathPrefix = '') => {
                const path = pathPrefix ? `${pathPrefix}.${node.index}` : `${node.index}`;

                if (node.level === 1) { // PART
                    const partContainer = document.createElement('div');
                    partContainer.className = 'part-container mb-8'; // Add margin bottom for spacing between parts
                    partContainer.dataset.path = path;
                    partContainer.innerHTML = `
                        <div class="part-header border-b-2 border-indigo-600 pb-2 mb-4">
                            <h2 class="text-2xl font-bold text-gray-800">${node.title}</h2>
                            <p class="text-gray-600 mt-1">${node.description || ''}</p>
                        </div>
                        <div class="chapters-wrapper space-y-4"></div>
                    `;
                    parentEl.appendChild(partContainer);
                    const childrenWrapper = partContainer.querySelector('.chapters-wrapper');
                    (node.children || []).forEach((child, idx) => {
                        child.index = idx; // Temporarily add index for path generation
                        renderMainContentNode(child, childrenWrapper, path);
                    });
                } else if (node.level >= 2) { // Chapter or Sub-chapter
                    const chapterItem = document.createElement('div');
                    // Calculate dynamic padding based on level for visual nesting
                    // Level 2: 0px, Level 3: 16px, Level 4: 32px, etc.
                    const paddingLeft = (node.level - 2) * 16;
                    const chapterContent = loadChapterContent(path);
                    chapterItem.className = `chapter-item bg-white rounded-xl shadow-md border border-gray-200 overflow-hidden mb-4 ${chapterContent.translated.trim() !== '' ? 'border-green-400' : ''}`;
                    chapterItem.style.paddingLeft = `${paddingLeft}px`; // Apply padding
                    chapterItem.dataset.path = path;
                    chapterItem.innerHTML = `
                        <div class="chapter-header p-5 flex justify-between items-center">
                            <h3 class="text-xl font-bold text-gray-800">${node.title}</h3>
                            <button class="open-chapter-editor-btn chapter-edit-button">
                                <i class="fas fa-edit"></i> 편집하기
                            </button>
                        </div>
                        <div class="sub-chapters-container pl-4"></div> <!-- Container for nested children -->
                    `;
                    
                    chapterItem.querySelector('.open-chapter-editor-btn').addEventListener('click', () => {
                        openChapterEditorModal(path);
                    });
                    parentEl.appendChild(chapterItem);

                    // Recursively render children (sub-chapters) if they exist
                    if (node.children && node.children.length > 0) {
                        const subChaptersContainer = chapterItem.querySelector('.sub-chapters-container');
                        (node.children || []).forEach((child, idx) => {
                            child.index = idx; // Temporarily add index
                            renderMainContentNode(child, subChaptersContainer, path);
                        });
                    }
                }
            };

            (data.children || []).forEach((node, index) => {
                node.index = index; // Add index to top-level children for path generation
                renderMainContentNode(node, chapterContainer);
            });
        };

        /**
         * 챕터 편집기 모달을 열고 주어진 챕터 경로의 데이터로 채웁니다.
         * @param {string} path - 챕터의 경로 (예: "0.1.2")
         */
        const openChapterEditorModal = (path) => {
            appState.activeChapterPath = path; // 현재 활성 챕터 경로 설정
            const node = getNodeByPath(path);
            if (!node) {
                showMessageModal('오류', '챕터 정보를 찾을 수 없습니다.');
                return;
            }

            const chapterContent = loadChapterContent(path); // Load both source and translated

            chapterEditorModalTitle.textContent = `챕터 편집: ${node.title}`;
            modalSourceTextarea.value = chapterContent.source; // Display source text
            modalPromptTextarea.value = generatePromptForNode(path);
            modalResultTextarea.value = chapterContent.translated; // Display translated text
            modalSaveStatus.textContent = ''; // Clear previous save status
            copyStatusMessage.textContent = ''; // Clear previous copy status
            modalCopyPromptBtn.innerHTML = '<i class="fas fa-copy mr-1"></i> 복사'; // Reset copy button text

            openModal(chapterEditorModal);

            // Highlight the corresponding item in the outline
            document.querySelectorAll('.outline-item.active').forEach(el => el.classList.remove('active'));
            const activeOutline = document.querySelector(`.outline-item[data-path="${path}"]`);
            if (activeOutline) activeOutline.classList.add('active');
        };

        /**
         * 전체 목차 텍스트를 생성합니다.
         * @param {object} data - 전체 JSON 데이터
         * @param {string} currentPath - 현재 활성 챕터의 경로
         * @returns {string} 전체 목차 텍스트
         */
        const generateFullOutlineText = (data, currentPath) => {
            let text = '';
            const traverse = (nodes, prefix, level) => {
                (nodes || []).forEach((node, i) => {
                    const path = prefix ? `${prefix}.${i}` : `${i}`;
                    text += `${' '.repeat(level * 2)}${path === currentPath ? '▶' : '-'} ${node.title}\n`;
                    if (node.children) traverse(node.children, path, level + 1);
                });
            };
            // Start traversal from top-level children
            traverse(data.children, '', 0);
            return text;
        };

        /**
         * 현재 파트의 목차 텍스트를 생성합니다.
         * @param {object} partNode - 현재 파트 노드
         * @param {string} currentChapterPath - 현재 활성 챕터의 경로
         * @returns {string} 현재 파트의 목차 텍스트
         */
        const generatePartOutlineText = (partNode, currentChapterPath) => {
            let outlineText = '';
            const traversePartChildren = (nodes, prefix, level) => {
                (nodes || []).forEach((node, i) => {
                    // Calculate indentation based on node's level relative to the part's level
                    const currentIndentationLevel = node.level - partNode.level;
                    const indentationSpaces = ' '.repeat(currentIndentationLevel * 2);

                    const nodePath = prefix ? `${prefix}.${i}` : `${i}`;
                    const isCurrent = nodePath === currentChapterPath;
                    
                    outlineText += `${indentationSpaces}${isCurrent ? '▶' : '-'} ${node.title}\n`;
                    if (node.children) {
                        traversePartChildren(node.children, nodePath, level + 1);
                    }
                });
            };
            traversePartChildren(partNode.children, partNode.path, partNode.level); // Start traversal from part's children
            return outlineText;
        };

        /**
         * 특정 노드에 대한 프롬프트를 생성합니다.
         * @param {string} path - 노드의 경로
         * @returns {string} 생성된 프롬프트 텍스트
         */
        const generatePromptForNode = (path) => {
            const node = getNodeByPath(path);
            if (!node) return "오류: 노드를 찾을 수 없습니다.";

            const pathParts = path.split('.').map(Number);
            // Find the top-level part (level 1)
            let partNode = null;
            let partPath = '';
            if (pathParts.length > 0) {
                partPath = pathParts[0].toString();
                partNode = getNodeByPath(partPath);
                if (partNode) {
                    partNode.path = partPath; // Ensure partNode has its path for generatePartOutlineText
                }
            }
            
            // Get project materials
            const projectData = appState.projects[appState.currentProjectName];
            const projectMaterials = projectData ? projectData.materials : '';

            // Get source content for the current chapter
            const chapterContent = loadChapterContent(path);
            const sourceText = chapterContent.source || '';

            const replacements = {
                '<<책제목>>': appState.currentJsonData.title || '',
                '<<파트>>': partNode ? partNode.title : '없음',
                '<<파트설명>>': partNode ? partNode.description : '최상위 파트입니다.',
                '<<챕터>>': node.title || '',
                '<<챕터설명>>': node.description || '',
                '<<전체목차>>': generateFullOutlineText(appState.currentJsonData, path),
                '<<현재파트목차>>': partNode ? generatePartOutlineText(partNode, path) : '',
                '<<원본텍스트>>': sourceText, // New replacement for source text
                '<<자료>>': projectMaterials
            };

            let template = appState.promptTemplate;
            // Replace variables more robustly, protecting HTML entities in variable names
            for (const [key, value] of Object.entries(replacements)) {
                // Escape special characters in the key for regex
                const regexKey = key.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                template = template.replace(new RegExp(regexKey, 'g'), value);
            }
            return template;
        };

        /**
         * 목차 및 메인 콘텐츠에서 챕터의 완료 상태를 업데이트합니다.
         * 특정 경로가 제공되면 해당 챕터만 업데이트합니다. 그렇지 않으면 모두 업데이트합니다.
         * @param {string} [chapterPathToUpdate] - 업데이트할 챕터의 선택적 경로
         */
        const updateChapterCompletionStatus = (chapterPathToUpdate = null) => {
            const allOutlineItems = document.querySelectorAll('.outline-item');
            const allChapterItems = document.querySelectorAll('.chapter-item');

            const updateItem = (item, path) => {
                const chapterContent = loadChapterContent(path);
                const hasTranslatedContent = chapterContent.translated.trim() !== '';
                if (hasTranslatedContent) {
                    item.classList.add('completed');
                    const completionIcon = item.querySelector('.completion-icon');
                    if (completionIcon) completionIcon.classList.remove('hidden');
                } else {
                    item.classList.remove('completed');
                    const completionIcon = item.querySelector('.completion-icon');
                    if (completionIcon) completionIcon.classList.add('hidden');
                }
            };

            if (chapterPathToUpdate) {
                // Update specific chapter
                const outlineItem = document.querySelector(`.outline-item[data-path="${chapterPathToUpdate}"]`);
                const chapterItem = document.querySelector(`.chapter-item[data-path="${chapterPathToUpdate}"]`);
                if (outlineItem) updateItem(outlineItem, chapterPathToUpdate);
                if (chapterItem) { // Add visual cue for main chapter item
                    const chapterContent = loadChapterContent(chapterPathToUpdate);
                    const hasTranslatedContent = chapterContent.translated.trim() !== '';
                    if (hasTranslatedContent) {
                        chapterItem.classList.add('border-green-400'); // e.g., green border when completed
                    } else {
                        chapterItem.classList.remove('border-green-400');
                    }
                }
            } else {
                // Update all chapters
                allOutlineItems.forEach(item => {
                    const path = item.dataset.path;
                    updateItem(item, path);
                });
                allChapterItems.forEach(item => {
                    const path = item.dataset.path;
                    const chapterContent = loadChapterContent(path);
                    const hasTranslatedContent = chapterContent.translated.trim() !== '';
                    if (hasTranslatedContent) {
                        item.classList.add('border-green-400');
                    } else {
                        item.classList.remove('border-green-400');
                    }
                });
            }
        };


        // --- Event Handlers ---

        menuOpenBtn.addEventListener('click', openSidebar);
        menuCloseBtn.addEventListener('click', closeSidebar);
        sidebarOverlay.addEventListener('click', closeSidebar);

        settingsBtn.addEventListener('click', () => {
            promptTemplateInput.value = appState.promptTemplate;
            templateSaveStatus.textContent = '';
            openModal(settingsModal);
        });

        saveTemplateBtn.addEventListener('click', () => {
            appState.promptTemplate = promptTemplateInput.value;
            localStorage.setItem(PROMPT_TEMPLATE_KEY, appState.promptTemplate); // Save to localStorage
            templateSaveStatus.textContent = '✅ 저장되었습니다!';
            setTimeout(() => {
                templateSaveStatus.textContent = '';
                closeModal(settingsModal);
            }, 1500);
        });

        resetTemplateBtn.addEventListener('click', async () => {
            const confirmed = await showConfirmationModal('템플릿 초기화', '템플릿을 기본값으로 되돌리시겠습니까?');
            if (confirmed) {
                appState.promptTemplate = DEFAULT_PROMPT_TEMPLATE;
                localStorage.setItem(PROMPT_TEMPLATE_KEY, appState.promptTemplate); // Save to localStorage
                promptTemplateInput.value = DEFAULT_PROMPT_TEMPLATE;
                templateSaveStatus.textContent = '🔄 초기화되었습니다.';
                setTimeout(() => { templateSaveStatus.textContent = ''; }, 2000);
            }
        });

        projectManageBtn.addEventListener('click', async () => {
            showLoadingOverlay("프로젝트 목록 로드 중...");
            await waitForFirebase();
            if (!db) {
                showMessageModal('오류', 'Firebase 초기화 실패. 프로젝트 목록을 불러올 수 없습니다.');
                hideLoadingOverlay();
                return;
            }
            appState.projects = await getAllProjectsFromFirestore();
            renderProjectList();
            newProjectNameInput.value = '';
            newProjectStatus.textContent = '';
            // Load materials for the current project when the project modal opens
            const projectData = appState.projects.find(p => p.id === appState.currentProjectName);
            projectMaterialsInput.value = projectData ? projectData.materials || '' : '';
            projectMaterialsStatus.textContent = ''; // Clear status message
            hideLoadingOverlay();
            openModal(projectModal);
        });

        createProjectBtn.addEventListener('click', async () => {
            const newName = newProjectNameInput.value.trim();
            if (!newName) {
                newProjectStatus.textContent = '프로젝트 이름을 입력해주세요.';
                newProjectStatus.style.color = 'red';
                return;
            }
            if (newName.includes('-')) {
                newProjectStatus.textContent = '프로젝트 이름에는 하이픈(-)을 사용할 수 없습니다.';
                newProjectStatus.style.color = 'red';
                return;
            }

            if (appState.projects.some(p => p.id === newName)) {
                newProjectStatus.textContent = '이미 같은 이름의 프로젝트가 존재합니다.';
                newProjectStatus.style.color = 'red';
                return;
            }

            showLoadingOverlay("새 프로젝트 생성 중...");
            try {
                const newProjectData = {
                    createdAt: new Date(),
                    jsonContent: null,
                    materials: ''
                };
                const success = await saveProjectToFirestore(newName, newProjectData);
                if (success) {
                    appState.currentProjectName = newName;
                    appState.currentJsonData = null; // Clear current JSON data for new project
                    appState.chapterContents = {}; // Clear chapter contents for new project
                    
                    // Update in-memory project list and save current project name to localStorage
                    appState.projects.push({ id: newName, ...newProjectData });
                    localStorage.setItem(`${APP_ID}-current-project-name`, newName);

                    newProjectStatus.textContent = '✅ 프로젝트가 생성되었습니다! ZIP 파일을 업로드하거나 새 JSON을 입력해주세요.';
                    newProjectStatus.style.color = 'green';
                    setTimeout(() => {
                        newProjectStatus.textContent = '';
                        closeModal(projectModal);
                        jsonInput.value = ''; // Clear JSON input for new project
                        projectMaterialsInput.value = ''; // Clear materials input for new project
                        outlineContainer.innerHTML = '<p class="text-gray-400 text-sm">목차를 생성하면 여기에 표시됩니다.</p>';
                        welcomeScreen.classList.remove('hidden');
                        chapterContainer.classList.add('hidden');
                        exportBtn.disabled = true;
                        currentProjectDisplay.textContent = newName;
                    }, 1500);
                    renderProjectList();
                } else {
                    newProjectStatus.textContent = '❌ 프로젝트 생성 실패!';
                    newProjectStatus.style.color = 'red';
                }
            } finally {
                hideLoadingOverlay();
            }
        });

        saveProjectMaterialsBtn.addEventListener('click', async () => {
            if (!appState.currentProjectName) {
                projectMaterialsStatus.textContent = '먼저 프로젝트를 선택하거나 새로 생성해주세요.';
                projectMaterialsStatus.style.color = 'red';
                return;
            }
            showLoadingOverlay("자료 저장 중...");
            try {
                const materialsContent = projectMaterialsInput.value;
                const projectData = appState.projects.find(p => p.id === appState.currentProjectName);
                if (projectData) {
                    projectData.materials = materialsContent;
                    const success = await saveProjectToFirestore(appState.currentProjectName, projectData);
                    if (success) {
                        projectMaterialsStatus.textContent = '✅ 자료가 저장되었습니다!';
                        projectMaterialsStatus.style.color = 'green';
                    } else {
                        projectMaterialsStatus.textContent = '❌ 자료 저장 실패!';
                        projectMaterialsStatus.style.color = 'red';
                    }
                } else {
                    projectMaterialsStatus.textContent = '❌ 현재 프로젝트를 찾을 수 없습니다.';
                    projectMaterialsStatus.style.color = 'red';
                }
            } finally {
                hideLoadingOverlay();
                setTimeout(() => { projectMaterialsStatus.textContent = ''; }, 2000);
            }
        });

        /**
         * 프로젝트 목록을 렌더링합니다.
         */
        const renderProjectList = () => {
            projectListContainer.innerHTML = '';
            // appState.projects는 이제 Firestore에서 로드된 객체 배열입니다.
            const projectNames = appState.projects.map(p => p.id);

            if (projectNames.length === 0) {
                projectListContainer.innerHTML = '<p class="text-gray-400 text-sm">저장된 프로젝트가 없습니다.</p>';
                return;
            }

            projectNames.forEach(name => {
                const projectItem = document.createElement('div');
                projectItem.className = `project-item ${appState.currentProjectName === name ? 'active-project' : ''}`;
                projectItem.innerHTML = `
                    <span class="flex-grow">${name}</span>
                    <button data-project-name="${name}" class="delete-project-btn"><i class="fas fa-trash-alt"></i></button>
                `;
                projectItem.querySelector('span').addEventListener('click', () => switchProject(name));
                projectItem.querySelector('.delete-project-btn').addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent item click on delete
                    deleteProject(name);
                });
                projectListContainer.appendChild(projectItem);
            });
        };

        /**
         * 프로젝트를 전환합니다.
         * @param {string} projectName - 전환할 프로젝트 이름
         */
        const switchProject = async (projectName) => {
            showLoadingOverlay("프로젝트 로드 중...");
            await waitForFirebase();
            if (!db) {
                showMessageModal('오류', 'Firebase 초기화 실패. 프로젝트를 전환할 수 없습니다.');
                hideLoadingOverlay();
                return;
            }

            try {
                const projectData = await getProjectFromFirestore(projectName);
                if (projectData && projectData.ownerId === userId) {
                    appState.currentProjectName = projectName;
                    appState.currentJsonData = projectData.jsonContent;
                    jsonInput.value = appState.currentJsonData ? JSON.stringify(appState.currentJsonData, null, 2) : '';
                    projectMaterialsInput.value = projectData.materials || ''; // Load materials

                    // Load all chapter contents for the new project from Firestore
                    appState.chapterContents = await getAllChapterContentsForProjectFromFirestore(appState.currentProjectName);
                    console.log("Switched to project. Loaded chapter contents:", appState.chapterContents);

                    // Persist current project name in localStorage
                    localStorage.setItem(`${APP_ID}-current-project-name`, projectName);

                    renderOutline(appState.currentJsonData, outlineContainer);
                    renderContent(appState.currentJsonData);
                    exportBtn.disabled = !appState.currentJsonData;
                    closeModal(projectModal);
                    closeSidebar(); // Close sidebar on mobile
                    updateChapterCompletionStatus(); // Update status on project switch
                    currentProjectDisplay.textContent = projectName;
                } else {
                    showMessageModal('프로젝트 로드 실패', '프로젝트 데이터를 불러오는 데 실패했습니다. 해당 프로젝트가 존재하지 않거나 소유자가 아닙니다.');
                    jsonInput.value = '';
                    projectMaterialsInput.value = '';
                    outlineContainer.innerHTML = '<p class="text-gray-400 text-sm">목차를 생성하면 여기에 표시됩니다.</p>';
                    welcomeScreen.classList.remove('hidden');
                    chapterContainer.classList.add('hidden');
                    appState.currentJsonData = null;
                    exportBtn.disabled = true;
                    currentProjectDisplay.textContent = '선택되지 않음';
                }
            } catch (error) {
                showMessageModal('프로젝트 로드 오류', `프로젝트 로드 중 오류가 발생했습니다: ${error.message}`);
                console.error(error);
            } finally {
                hideLoadingOverlay();
            }
        };

        /**
         * 프로젝트를 삭제합니다.
         * @param {string} projectName - 삭제할 프로젝트 이름
         */
        const deleteProject = async (projectName) => {
            const confirmed = await showConfirmationModal('프로젝트 삭제', `'${projectName}' 프로젝트를 정말 삭제하시겠습니까? 관련된 모든 내용이 삭제됩니다.`);
            if (confirmed) {
                showLoadingOverlay("프로젝트 삭제 중...");
                try {
                    const success = await deleteProjectContentsFromFirestore(projectName);
                    if (success) {
                        // Remove from in-memory list
                        appState.projects = appState.projects.filter(p => p.id !== projectName);
                        
                        if (appState.currentProjectName === projectName) {
                            appState.currentProjectName = null;
                            appState.currentJsonData = null;
                            appState.chapterContents = {}; // Clear in-memory chapter contents
                            localStorage.removeItem(`${APP_ID}-current-project-name`); // Remove from localStorage
                            jsonInput.value = '';
                            projectMaterialsInput.value = '';
                            outlineContainer.innerHTML = '<p class="text-gray-400 text-sm">목차를 생성하면 여기에 표시됩니다.</p>';
                            welcomeScreen.classList.remove('hidden');
                            chapterContainer.classList.add('hidden');
                            exportBtn.disabled = true;
                            currentProjectDisplay.textContent = '선택되지 않음';
                        }
                        renderProjectList(); // Refresh list
                        showMessageModal('삭제 완료', `'${projectName}' 프로젝트가 삭제되었습니다.`);
                    } else {
                        showMessageModal('삭제 실패', `'${projectName}' 프로젝트 삭제에 실패했습니다.`);
                    }
                } catch (error) {
                    showMessageModal('삭제 오류', `프로젝트 삭제 중 오류가 발생했습니다: ${error.message}`);
                    console.error(error);
                } finally {
                    hideLoadingOverlay();
                }
            }
        };

        renderBtn.addEventListener('click', async () => {
            if (!appState.currentProjectName) {
                showMessageModal('프로젝트 필요', '먼저 프로젝트를 선택하거나 새로 생성해주세요.');
                return;
            }
            // JSON 입력란이 비어있는지 확인
            if (!jsonInput.value.trim()) {
                showMessageModal('입력 오류', '목차 JSON을 입력하거나 ZIP 파일을 업로드해주세요.');
                return;
            }
            showLoadingOverlay("목차 생성 및 저장 중...");
            try {
                const jsonData = JSON.parse(jsonInput.value);
                if (!jsonData.children) throw new Error("JSON 최상위에 'children' 배열이 없습니다.");
                if (!jsonData.title) throw new Error("JSON 최상위에 'title' 속성이 없습니다. 책 제목으로 사용될 예정이니 추가해주세요.");

                if (jsonData.title !== appState.currentProjectName) {
                    const confirmed = await showConfirmationModal(
                        '프로젝트 이름 불일치',
                        `현재 프로젝트 '${appState.currentProjectName}'가 아닌 JSON의 제목 '${jsonData.title}'으로 로드하시겠습니까? 아니오를 선택하면 현재 프로젝트로 돌아가고, 예는 JSON 제목으로 새 프로젝트를 생성하거나 기존 프로젝트를 불러옵니다.`
                    );
                    if (!confirmed) {
                        // Revert to current project, but hide loading overlay first
                        hideLoadingOverlay();
                        switchProject(appState.currentProjectName); 
                        return;
                    } else {
                        // User chose to switch to the new project title from JSON
                        const existingProject = await getProjectFromFirestore(jsonData.title);
                        if (!existingProject) { // If new title is not an existing project, create it
                            const newProjectData = { createdAt: new Date(), jsonContent: null, materials: '' };
                            await saveProjectToFirestore(jsonData.title, newProjectData);
                            // Add to in-memory list
                            appState.projects.push({ id: jsonData.title, ...newProjectData });
                        }
                        appState.currentProjectName = jsonData.title;
                        currentProjectDisplay.textContent = jsonData.title;
                    }
                }
                
                appState.currentJsonData = jsonData;
                // Save JSON and current materials to Firestore
                const projectDataToSave = {
                    createdAt: appState.projects.find(p => p.id === appState.currentProjectName)?.createdAt || new Date(),
                    jsonContent: appState.currentJsonData,
                    materials: projectMaterialsInput.value
                };
                await saveProjectToFirestore(appState.currentProjectName, projectDataToSave);
                // Also update the in-memory projects list
                appState.projects = appState.projects.map(p => p.id === appState.currentProjectName ? { ...p, ...projectDataToSave } : p);
                
                // Clear existing chapter contents in memory for this project as JSON might have changed
                appState.chapterContents = await getAllChapterContentsForProjectFromFirestore(appState.currentProjectName);


                renderOutline(appState.currentJsonData, outlineContainer);
                renderContent(appState.currentJsonData);
                exportBtn.disabled = false;
                updateChapterCompletionStatus();
            } catch (error) {
                showMessageModal('JSON 처리 오류', `JSON 처리 중 오류가 발생했습니다: ${error.message}`);
                console.error(error);
            } finally {
                hideLoadingOverlay();
            }
        });

        modalCopyPromptBtn.addEventListener('click', () => {
            const promptTextarea = modalPromptTextarea;
            promptTextarea.focus();
            promptTextarea.select();

            let copiedSuccessfully = false;

            try {
                // Prioritize document.execCommand('copy') for better compatibility in iframes
                copiedSuccessfully = document.execCommand('copy');
                if (copiedSuccessfully) {
                    copyStatusMessage.textContent = '✅ 프롬프트가 복사되었습니다!';
                    copyStatusMessage.style.color = 'green';
                    modalCopyPromptBtn.innerHTML = '<i class="fas fa-check mr-1"></i> 복사 완료!';
                } else {
                    throw new Error('execCommand failed'); // If execCommand returns false
                }
            } catch (execErr) {
                console.error('Failed to copy text using execCommand: ', execErr);
                copyStatusMessage.textContent = '❌ 복사 실패! 브라우저 설정에서 클립보드 접근을 허용해주세요.';
                copyStatusMessage.style.color = 'red';
                modalCopyPromptBtn.innerHTML = '<i class="fas fa-times mr-1"></i> 복사 실패';
            } finally {
                // Deselect text
                promptTextarea.setSelectionRange(0, 0);
                if (copiedSuccessfully) {
                    setTimeout(() => {
                        closeModal(chapterEditorModal); // 복사 성공 시 모달 닫기
                        copyStatusMessage.textContent = '';
                        modalCopyPromptBtn.innerHTML = '<i class="fas fa-copy mr-1"></i> 복사';
                    }, 500); // 짧은 지연 후 닫기
                } else {
                    setTimeout(() => {
                        copyStatusMessage.textContent = '';
                        modalCopyPromptBtn.innerHTML = '<i class="fas fa-copy mr-1"></i> 복사';
                    }, 3000);
                }
            }
        });

        modalSaveBtn.addEventListener('click', async () => {
            if (!appState.activeChapterPath) {
                showMessageModal('오류', '저장할 챕터가 선택되지 않았습니다.');
                return;
            }
            const sourceContent = modalSourceTextarea.value;
            const translatedContent = modalResultTextarea.value;

            modalSaveStatus.innerHTML = '<span class="text-blue-500">저장 중...</span>';
            try {
                if (await saveChapterContent(appState.currentProjectName, appState.activeChapterPath, sourceContent, translatedContent)) {
                    modalSaveStatus.innerHTML = '<span class="text-green-500">✅ 저장 완료!</span>';
                    updateChapterCompletionStatus(appState.activeChapterPath); // Update status of saved chapter
                } else {
                    modalSaveStatus.innerHTML = '<span class="text-red-500">❌ 저장 실패!</span>';
                }
            } catch (error) {
                console.error("Error saving chapter:", error);
                modalSaveStatus.innerHTML = '<span class="text-red-500">❌ 저장 중 오류 발생!</span>';
            } finally {
                setTimeout(() => { modalSaveStatus.innerHTML = ''; }, 2000);
            }
        });

        exportBtn.addEventListener('click', () => {
            if (!appState.currentJsonData || !appState.currentProjectName) {
                showMessageModal('내용 없음', '먼저 목차를 생성하거나 프로젝트를 선택해주세요.');
                return;
            }

            let fullText = `# ${appState.currentJsonData.title || 'Untitled Book'}\n\n`;

            const appendContent = (nodes, currentPrefix = '') => {
                (nodes || []).forEach((node, index) => {
                    const nodePath = currentPrefix ? `${currentPrefix}.${index}` : `${index}`;

                    if (node.level === 1) { // Part
                        fullText += `## ${node.title}\n\n`;
                        if (node.description) {
                            fullText += `${node.description}\n\n`;
                        }
                        appendContent(node.children, nodePath);
                    } else if (node.level >= 2) { // Chapter or Sub-chapter
                        const content = loadChapterContent(nodePath).translated; // Load translated content
                        fullText += `### ${node.title}\n\n`;
                        if (content) {
                            fullText += `${content}\n\n`;
                        }
                        if (node.children) { // Handle potential sub-chapters within a chapter
                             appendContent(node.children, nodePath);
                        }
                    }
                });
            };

            appendContent(appState.currentJsonData.children);

            const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
            const filename = `${appState.currentProjectName}_translated.md`; // Use currentProjectName for filename
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        });

        // --- ZIP File Handling ---
        zipFileInputBtn.addEventListener('click', () => {
            zipFileInput.click(); // Trigger the hidden file input click
        });

        zipFileInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            if (!appState.currentProjectName) {
                showMessageModal('프로젝트 필요', 'ZIP 파일을 업로드하기 전에 먼저 프로젝트를 선택하거나 새로 생성해주세요.');
                zipFileInput.value = ''; // Clear the input
                return;
            }

            showLoadingOverlay("ZIP 파일 처리 중...");

            try {
                const zip = await JSZip.loadAsync(file);
                const zipEntries = []; // Store zipEntry objects directly
                const rootTitle = file.name.replace(/\.zip$/i, ''); // Use zip file name as book title

                zip.forEach((relativePath, zipEntry) => {
                    if (!zipEntry.dir && relativePath.endsWith('.txt')) {
                        zipEntries.push({
                            relativePath: relativePath,
                            zipEntry: zipEntry
                        });
                    }
                });

                if (zipEntries.length === 0) {
                    showMessageModal('파일 없음', 'ZIP 파일 내에 .txt 파일이 없습니다.');
                    zipStatusMessage.textContent = 'ZIP 파일 내에 .txt 파일이 없습니다.';
                    zipStatusMessage.style.color = 'red';
                    return;
                }

                // Sort zipEntries by path for consistent tree building
                zipEntries.sort((a, b) => a.relativePath.localeCompare(b.relativePath));

                const jsonStructure = {
                    title: rootTitle,
                    children: []
                };

                // First pass: Build the JSON structure (outline)
                zipEntries.forEach(entry => {
                    const parts = entry.relativePath.split('/');
                    let currentChildren = jsonStructure.children;
                    let currentNumericalPathSegments = []; // This will track the numerical path for the current node being processed

                    for (let i = 0; i < parts.length; i++) {
                        const partName = parts[i];
                        const isFile = (i === parts.length - 1);
                        const title = isFile ? partName.replace(/\.txt$/i, '') : partName;

                        let foundNode = null;
                        // Try to find existing node at current level
                        for(let j = 0; j < currentChildren.length; j++) {
                            if (currentChildren[j].title === title && (isFile ? !currentChildren[j].children : currentChildren[j].children)) {
                                foundNode = currentChildren[j];
                                currentNumericalPathSegments.push(j); // Add index to numerical path
                                break;
                            }
                        }

                        if (!foundNode) {
                            // Create new node
                            foundNode = {
                                title: title,
                                level: currentNumericalPathSegments.length + 1, // Calculate level based on path depth
                                description: isFile ? `원본 파일: ${entry.relativePath}` : `폴더: ${partName}`,
                                zipPath: isFile ? entry.relativePath : undefined // Store original zip path for files
                            };
                            if (!isFile) {
                                foundNode.children = []; // It's a folder
                            }
                            currentChildren.push(foundNode);
                            currentNumericalPathSegments.push(currentChildren.length - 1); // Add new index
                        }
                        
                        // Update currentChildren for next iteration if it's a folder
                        if (!isFile) {
                            currentChildren = foundNode.children;
                        }
                    }
                });

                // Second pass: Assign numerical paths to all nodes and store content in Firestore
                const assignNumericalPathsAndStoreContent = async (nodes, parentNumericalPath = '') => {
                    for (let i = 0; i < nodes.length; i++) {
                        const node = nodes[i];
                        const currentNumericalPath = parentNumericalPath ? `${parentNumericalPath}.${i}` : `${i}`;
                        node.path = currentNumericalPath; // Assign the numerical path

                        if (node.zipPath) { // This is a file/chapter node
                            const sourceContent = await zip.file(node.zipPath).async('string');
                            // Save source content to Firestore. Translated content is initially empty.
                            await saveChapterContentToFirestore(appState.currentProjectName, node.path, sourceContent, '');
                            // Also update in-memory cache
                            appState.chapterContents[`${appState.currentProjectName}_${node.path}`] = { source: sourceContent, translated: '' };
                        }

                        if (node.children) {
                            await assignNumericalPathsAndStoreContent(node.children, currentNumericalPath);
                        }
                    }
                }

                // Update the main project JSON in Firestore
                const projectDataToSave = {
                    createdAt: appState.projects.find(p => p.id === appState.currentProjectName)?.createdAt || new Date(),
                    jsonContent: jsonStructure,
                    materials: projectMaterialsInput.value
                };
                await saveProjectToFirestore(appState.currentProjectName, projectDataToSave);
                // Also update the in-memory projects list
                appState.projects = appState.projects.map(p => p.id === appState.currentProjectName ? { ...p, ...projectDataToSave } : p);

                appState.currentJsonData = jsonStructure;
                
                renderOutline(appState.currentJsonData, outlineContainer);
                renderContent(appState.currentJsonData);
                exportBtn.disabled = false;
                updateChapterCompletionStatus();

                zipStatusMessage.textContent = '✅ ZIP 파일 처리 완료!';
                zipStatusMessage.style.color = 'green';
                setTimeout(() => zipStatusMessage.textContent = '', 3000);

            } catch (error) {
                showMessageModal('ZIP 처리 오류', `ZIP 파일 처리 중 오류가 발생했습니다: ${error.message}`);
                zipStatusMessage.textContent = '❌ ZIP 파일 처리 실패!';
                zipStatusMessage.style.color = 'red';
                console.error(error);
            } finally {
                hideLoadingOverlay();
                zipFileInput.value = ''; // Clear the file input to allow re-uploading the same file
            }
        });


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            showLoadingOverlay("앱 초기화 중...");
            await waitForFirebase(); // Wait for Firebase to be ready
            if (!db) {
                hideLoadingOverlay();
                showMessageModal('오류', 'Firebase 초기화에 실패했습니다. 앱을 사용할 수 없습니다.');
                return;
            }

            await loadAppState(); // Load state from Firestore

            promptTemplateInput.value = appState.promptTemplate; // Set initial template input

            if (appState.currentProjectName && appState.currentJsonData) {
                jsonInput.value = JSON.stringify(appState.currentJsonData, null, 2);
                // Load materials from the project data in appState.projects
                const currentProjectData = appState.projects.find(p => p.id === appState.currentProjectName);
                projectMaterialsInput.value = currentProjectData ? currentProjectData.materials || '' : '';
                
                renderOutline(appState.currentJsonData, outlineContainer);
                renderContent(appState.currentJsonData);
                exportBtn.disabled = false;
                currentProjectDisplay.textContent = appState.currentProjectName;
                updateChapterCompletionStatus();
            } else {
                welcomeScreen.classList.remove('hidden');
                chapterContainer.classList.add('hidden');
                exportBtn.disabled = true;
                currentProjectDisplay.textContent = '선택되지 않음';
            }
            hideLoadingOverlay();
        });
    </script>
</body>
</html>
