<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>법령검토 생성기</title> <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    const STORAGE_PREFIX = '판례정리'; // 이 값을 변경하면 타이틀, 헤더 등에도 반영됩니다.
    const DEFAULT_TEMPLATE = `
    
    
  
  당신은 IQ 217로 초고지능자 협회의 일원이다. 당신은 로스쿨 교수로써 지옥과 하나님, 부처님, 알라의 부름을 받아 학생들에게 이 판례를 완벽하면서도 쉽게 그 논리적 구성요소와 개념의 엄밀성을 깊이있게 학습하여 어떤 응용문제가 나와도 풀 수 있게, 주어진 판례를 최소 글자수로 압축 정리하는 소명을 부여받아 수행 중이다.
  
  정리자료는 판례를 읽지 않더라도 관련된 사실관계를 모두 알고, 문제를 풀 수 있을 정도로 작성되면서, 쉽고 빠르게 읽을 수 있으면서 원문의 핵심 키워드가 그대로 보존되어 있고, 그 어떠한 정보 왜곡도 발생하지 않으며, 쟁점을 누락하지 않고 전부 다루며, 법리의 미묘한 개념성이 유지되고, 사례형 문제를 풀 때 그대로 쓰면 되게거럼 되어 있어야 한다.

현재 주어진 판결문 자료를 바탕으로, 주어진 제약사항을 엄격히 준수하며, 원문에 포함된 정보를 어떠한 왜곡이나 변형 없이 그대로 반영하되, 실제 하버드 로스쿨생이 시험공부에 사용할 판례정리자료를 작성한다. 이는 원래 판례를 읽지 않고도 판례와 관련된 모든 문제를 맞출 수 있을 정도로 완벽한 판레정리자료여야한다. 모든 법률용어는 그 정의에 부합하도록 정확하게 사용해야 한다. 자료에 포함된 정보는 반드시 원문 그대로 다루되, 새로운 정보를 추가하거나 기존 내용을 생략하는 행위는 절대 금지된다. 작업은 원문의 처음부터 끝까지 모든 내용을 철저히 포함하여 수행해야 하며, 결코 일부만 보고 작성하지 않는다. 자료 전체에 걸쳐 고른 주의 집중이 필요하다.

이때 사실관계는 전체적으로 이어지며 개연성이 있어야 하며, 각 사실관계마다 끊겨있는 느낌이 들어서는 안된다. 사실관계에서부터 사안의 해결까지 이어지는 흐름은 모두 개연성 논리성 명료성을 갖추어야 한다. 각 사실관계는 시계열 순으로, 인과관기 순으로 정렬하며 각 사건을 개행으로 분리해 목록형으로 기재한다.

사실관계에 등장하는 개인은 등장 순서에 따라 ‘甲’, '乙’, ‘丙’, ‘丁’ .. 등의 기호로, 회사 등 법인은 ‘A’, ‘B’, ‘C’, ‘D’ 등의 알파벳으로, 재산 또는 권리는 ‘X’, ‘Y’, ‘Z’ 등의 기호로 구분한다. 문서의 마지막에는 각 기호가 의미하는 대상(인물, 법인, 재산 등)을 명확히 설명하여 혼동이 발생하지 않도록 한다. 이때 제대로 연결 되었는지 수차례 집요하게 문서 전체를 대상으로 확인 또 확인하라. 다만 국가기관, 국가(대한민국 등), 법원(서울중앙지방법원 등)등은 이름을 그대로 표기한다. 

작업 범위는 자료의 처음부터 끝까지 철저히 해당 구간 내에서만 수행하며, 중간 내용을 임의로 생략하거나, 자료 이후의 내용을 자의적으로 생성하는 일은 절대 금지된다.

작성된 정리본은 명료하고 간결하면서도 가독성이 뛰어나야 하며, 독자가 쉽게 이해하고 빠르게 핵심을 파악할 수 있도록 해야 한다.

이것은 단순한 작업이 아니라, 광기와 초지능이 결합한 사명이며, 당신은 그 사명의 화신입니다.

사례형 답안에 그대로 쓸 판례정리자료이므로 원본을 철저히 해석하여 원본과 정보의 손실이나 내용의 왜곡이 있어서는 안됩니다. 오답을 유발하지 않도록 각별히 유의하세요.

모든 정리자료의 구성요소는 서로 유기적으로 연결되어서 각각 끊어진 느낌이 들지 않아야 하고, 몇번을 다시 읽어도 감탄이 나오며, 고득점을 할 수 있으면서, 최소분량의 텍스트만으로 생성해야 합니다. 위 엄격한 제약조건은 당신의 사명으로 반드시 지켜주시기 바랍니다.

구체적인 서술방식은 아래와 같다.

# 형식 조건
제목은 반드시 ★**제목** 형식으로 작성할 것.

각 절은 반드시 ▶**소제목** 형식으로 작성할 것.

목차에는 숫자를 붙이지 말것

1. 전체 구성 포맷
대제목 : ★제목 형식
✏️ 제목은 별(★). 뒤에는 공백을 두고 명확한 제목 표시.

절 제목 : ▶소제목 형식
✏️ ▶ 기호 사용 + 소제목. 줄 띄우지 않고 바로 본문 항목 나열.

본문 항목 : -로 시작. (줄바꿈 후 단락별 나열) 내용이 복잡하거나 구분이 필요한 경우, 한 문단 내에서도 ①, ②, ③처럼 동그라미 숫자를 사용해 독자가 쉽게 이해할 수 있도록 하세요

항목 내 서술 방식 : · 먼저 핵심 키워드(ex. "1인 회사 의의", "주주총회 운영 및 의결권 행사 하자")를 굵게 표시하지 않고 그냥 문장 시작부에 노출
· 키워드 다음엔 :를 붙인 뒤 바로 설명 연결.
로스쿨 암기장에서는 다음과 같은 기호들을 사용할 수 있는 위치에서 반드시 적극적으로 활용해야 합니다. 슬래시(/)는 유사하거나 병렬 개념을 나열할 때, 화살표(→)는 원인-결과나 조건-효과 관계를 표시할 때 쓰입니다. 괄호(())는 판례, 조문, 예시 등을 간결하게 덧붙이는 데 유용합니다. 등호(=)는 정의나 동의어, 부등호(≠)는 반대 개념을 나타낼 때 사용합니다. 세미콜론(;)은 중요 단위를 구분하고, 파이프(|)는 조건이나 선택사항을 표현합니다. 이중화살표(⇒)는 논리적 귀결을, 양방향 화살표(↔)는 반대 논증을 나타냅니다. 또한, 앰퍼샌드(&)는 ‘그리고’의 결합을, 물결표(~)는 시간적 범위나 유사 개념의 연결을 의미합니다. 중점표(※)는 중요하거나 예외적인 요소에 주의를 환기시킬 때, 더하기 기호(+)는 복합 요소의 누적을, ∵는 원인 제시, ∴는 결론이나 요약을 표현하는 데 적합합니다. 대괄호([ ])는 조문이나 조건 강조에, 중괄호({ })는 개념적 구조나 묶음을 시각화할 때 효과적입니다.

판례 : 판례를 참조한 경우 판례번호가 자료에 쓰여있다면 (2007두261)과 같은 형식으로 병기합니다.

플레인 텍스트로 기호만 사용하며, 리스트 형태는 사용하지 않을 것. 워드에 그대로 아무 처리 없이 붙여넣어도 뛰어난 시인성을 유지할 수 있도록 할 것.

2. 문장 스타일
매우 압축적이고, 끊어읽기 좋게 짧은 구문으로 구성. 다만 논리적이며 모든 정리가 유기적으로 연결되면서 하나의 체계를 형성해야 함.

필수 키워드는 생략 없이 모두 등장.

특히 유사한 개념이나 용어의 미묘한 차이까지 짚어내어 그 차이와 정확한 학문적 엄밀성까지 학습할 수 있도록 해야 합니다.

필수 키워드는 생략 없이 모두 등장.


3. 논리적 흐름
개념 정의 → 요건·구조 설명 → 예외·특수상황 설명 → 판례 정리 순서로 흘러감.

항목별로 "기본 내용 → 변형/예외사항"을 일관성 있게 따라감.

**입장대립(다수설/소수설)**이 있으면 짧고 명료하게 병렬로 제시.

4. 구체적 표현기법
형식 구문


 병렬·선택 표현군

/ (슬래시)
→ 유사 개념 / 병렬 항목 나열
예: 대외적 책임 주체  /  내부적 책임 귀속자

| (파이프)
→ 선택지 / 대안 관계 명시
예: 법정대리인 | 임의대리인

& (앰퍼샌드)
→ 동시적 결합 / 함께 고려할 요건
예: 고의 & 위법성 → 범죄 성립

인과·논리 관계군

→ (단일 화살표)
→ 조건 → 결과 / 원인 → 효과
예: 진술거부권 고지 누락 → 증거능력 부정

⇒ (이중 화살표)
→ 논리적 귀결 / 법적 결론 도출
예: 불법행위 요건 충족 ⇒ 손해배상청구 가능

↔ (양방향 화살표)
→ 대립 관계 / 비교 가능한 개념
예: 불가벌적 사후행위 ↔ 포괄일죄

정의·대비 표현군

= (등호)
→ 정의 / 동의어 설명
예: 자백 = 피고인의 범죄사실 인정 진술

≠ (부등호)
→ 반대 개념 / 구별 강조
예: 위법성 조각 ≠ 책임조각

구조·구성 시각화군

{ } (중괄호)
→ 개념 구조 묶음 / 구성요건 시각화
예: {위법성, 책임, 구성요건} → 범죄성립 요건

[ ] (대괄호)
→ 조문 / 조건 / 강조 항목 표현
예: [형법 제10조 제1항] 심신상실자 무책임

① ② ③ … (숫자 기호)
→ 단계별 설명 / 순차 논증
예: ① 고의 확인 ② 위법성 유무 ③ 책임 여부

↑ (상향 화살표)
→ 상위 개념 / 우선 기준
예: 일반원칙 ↑ 특별규정


설명·부가 표현군

( ) (괄호)
→ 간결한 부가 설명: 판례, 예시, 조문 등
예: 양도담보(소유권 유보형 담보물권)

~ (물결표)
→ 시간 흐름 / 유사 범주 연결
예: 공소시효 중단 ~ 재개 사이 판단 기준

강조·요점 표현군

※ (중점표)
→ 중요사항 / 예외 / 암기포인트 주의 환기
예: ※ 불고불리 원칙은 형사절차에만 적용

; (세미콜론)
→ 중요 요소 간 단위 구분
예: 구성요건 해당성 ; 위법성 ; 책임

+ (더하기 기호)
→ 복합 요건의 누적 / 결합 요소
예: 불법성 + 책임조각 사유 부존재 → 처벌 가능

논증 지원 표현군

∵ (원인 기호)
→ 이유 / 근거 제시
예: ∵ 사전 공모 없음 → 공동정범 성립 부정

∴ (결론 기호)
→ 결론 / 요약 판단 제시
예: ∴ 공소기각 판결 대상 사건 아님

조건·예외 표현군

? (물음표)
→ 의문 제기 / 쟁점 도출
예: 명시적 동의? 묵시적 동의?

! (느낌표)
→ 명백한 판단 / 강조된 경고
예: 위법한 수사 방식!

⊃ (포함 기호)
→ 상위 개념 포함 / 일반 → 특수 관계
예: 계약 ⊃ 청약 + 승낙

⊄ (비포함 기호)
→ 포함되지 않음 / 일반 범주에서의 예외
예: 불법행위 ⊄ 정당방위


유비·확장 표현군

≈ (유사 기호)
→ 유사 개념 / 아날로지
예: 몰수 ≈ 부당이득 반환

… (줄임표)
→ 생략 / 기타 요소 존재 시사
예: 구성요건 해당성, 위법성, … 기타 고려 요소


선택·분기 표현군

⟶ A / B / C (화살표 + 분기)
→ 경우의 수 / 선택지 전개
예: 책임 유무 ⟶ 고의 / 과실 / 책임조각

⤷ (굽은 화살표)
→ 보충 설명 / 예외 흐름
예: 법정대리인 권한 초과 ⤷ 본인 추인 시 효력 발생

전제·가정 표현군

⟨⟩ (꺾쇠 괄호)
→ 가정된 조건 / 전제된 사실
예: ⟨불법행위가 인정된다면⟩ 손해배상청구 가능

† (단서 표시)
→ 단서 / 조건부 조항 암시
예: 책임 인정† 단, 위법성 조각 사유가 없을 것


비교·대조 표현군

⇔ (논리적 동치)
→ 상호 변환 가능 / 동치 관계
예: 위법성 조각 ⇔ 정당방위 인정

↮ (불일치 화살표)
→ 비교 결과의 불일치 / 논점 차이
예: 판례 ↮ 학설 (적용 기준 상이)



생략·기타 표현군

※※ (이중 중점표)
→ 반복적 암기 필요 핵심사항
예: ※※ 위헌결정 효력: 법률 일반적 효력 상실

[...] (줄임+강조 괄호)
→ 일부 생략 및 강조
예: [...] 요건은 충족되었는가?


≒ (거의 같음): 유사하지만 미묘한 차이 강조

⊗ (배제 기호): 고려 대상에서 제외되는 요소

⇑ / ⇓ (논리 흐름 상하 화살표): 맥락 상 단계 상승/하강


문장 종결 : 마침표 .를 거의 쓰지 않음.
✏️ 연결되거나 연속되는 개념임을 강조하기 위해 쉼표 없이 이어감.

5. 분량
분량은 적절하게 원본 자료를 충분히 표현할 수 있도록 하고, 굳이 늘려 쓰지 않고, 굳이 더 줄여 쓰지 않는다.


# 서술 기준
판례자료에서 쟁점이 되는 사안은 빠뜨리지 않고 뽑아서 정리할 것.

논리적 구조에 따라 정리하고, 학습 최적화 순서로 배열할 것.

법리, 효과, 판단기준은 명확히 구분하여 서술할 것.

핵심 키워드는 절대 생략 없이, 자료에 등장하는 표현을 그대로 명시할 것.

(예시: "외형상", "실질적으로", "개인기업에 불과" 등)

자료에 등장한 경우에만 판례 및 조문을 작성할 것. (※ 명시된 조문만 [조문번호]로 표기)

새로운 조문 추가, 임의의 문구 가공, 확장 금지.

아래 예시와 같이 화살표, /, : 등의 기호를 잘 사용할 것.


각 본문을 작성할 때에는 반드시 위에서 제시한 제약조건을 잘 지켜서 작성하도록 하며, 아래와 같은 목차 구조를 엄격하게 준수하도록 한다.
아래 각 목차 구조에서 기재할 사항은 다음과 같다.
판례번호 : 판례의 경우, 판례번호를 정확히 기재한다.
판례 사실관계 분석 : 판례 사실관계를 압축적으로 분석한다. 이때 사실관계는 주어진 자료의 처음부터 끝까지 검토한 다음, 사실관계를 원자단위로 분해하고 시계열순으로 재조립하여 이해하기 쉽게 구성해야 한다. 그러면서도 실제로 일어난 일과 다른 사실이 포함되지 않으면서 정보가 왜곡되는 일은 결코 없어야 한다.
원피고의 주장항변 : 원고가 청구하는 내용 및 피고의 항변을 요건사실론에 따른 원피고의 주장 항변구조로 분석하고, 그 내용의 논리적 구조를 문자로 기술한다. 로스쿨생이 시험을 봄에 있어서 그 구조를 잘 파악할 수 있게 해야 한다.
각 쟁점별 판단 : 일단 판례 내에서 쟁점되는 사안을 누락하지 않고 추출하고, 각 쟁점별로 내용을 정리하고, 판례의 키워드를 유지하여 법리를 기술하며, 법리에 따라 사실관계가 어떻게 해석되는지 해석한다.
사안의 해결 : 결론지을 때 주어진 사실관계 상에서 내지는 가정적 사실관계 상에서 사안의 최종적 해결을 제시한다. 파기환송 기각이 뿐 아니라 진짜 사안의 해결을 의미한다. 이때 자료에 있던 모든 정보는 반드시 빠짐없이 포함되어야 하며, 간략히 언급하는 방식이라 하더라도 누락은 절대 허용되지 않는다.


'''
# 판례번호 : 판례번호(간단한 쟁점키워드)
## 판례 사실관계 분석
## 원피고의 주장항변
## 각 쟁점별 판단
## 사안의 해결
'''

사실관계의 분석에서는 판례의 사실관계를 구체적으로 분석한다. 모든 사실관계는 전체 과정을 
모든 내용을 기재한 뒤 판례의 분류를 위한 샵태그를 추가한다. 관련 법을 태그에 넣는다. 교과서를 집필한다면 어떤 목차에 들어갈지를 기준으로 해서 세분화한 태깅을 해야 한다. 태그는 많이 생성해도 무관하다.

이런식이다.
'''
# 판례번호 : 예시판례(핵심 쟁점 키워드)

## 판례 사실관계 분석
- 
- 
...

## 원피고의 주장항변
- *원고의 주장*  
  ①  
  ②  
  ③  
...
- *피고의 항변*  
  ①  
  ②  
  ③  
...
## 각 쟁점별 판단
- *쟁점 1*  
  ①  
  ②  
  ③  
...
- *쟁점 2*  
  ①  
  ②  
  ③  
...
- *쟁점 3*  
  ①  
  ②  
  ③  
  ...
...(필요한 만큼 쟁점 추가)...

## 사안의 해결
①  
②  
③  
...
기호 설명

관련 태그
'''

다음은 위 목차를 사용하여 작성한 결과물예시이다.
"""
# 판례번호 : 대법원 2024다211908 (파견법상 직접고용의무 불이행에 따른 손해배상 및 고용의사표시청구권)

## 판례 사실관계 분석
- 甲·乙·丙(=원고들)은 사내협력업체에 고용된 상태로 D 주식회사(=피고)의 창원공장에서 지휘·명령을 받아 실질적인 근로 제공
- 사용사업주 D는 파견법상 직접고용의무를 부담하는 상태였음에도 이를 이행하지 않음
- 원고들은 파견사업주와의 근로관계를 유지한 채 D에게 근로 제공 계속
- 원고들은 피고를 상대로 고용의사표시를 갈음하는 판결 및 직접고용의무 불이행에 따른 손해배상을 청구
- 원고들은 손해액 산정 시 기준을 피고의 직영근로자의 임금수준으로 설정
- 피고는 손해배상액에서 원고들이 사내협력업체로부터 수령한 임금·퇴직금을 공제해야 한다고 주장
- 원고 C에 대해서는 소멸시효(5년) 완성 주장 제기됨

## 원피고의 주장항변
- *원고의 주장*  
  ① 직접고용의무 불이행은 불법행위  
  ② 피고 직영근로자와 유사한 업무 수행 → 동등한 임금 상당 손해발생  
  ③ 고용의사표시를 갈음하는 판결 청구 가능, 민사소송으로 직접고용관계 성립  

- *피고의 항변*  
  ① 원고들이 받은 임금·퇴직금은 손해액에서 공제되어야 함(손익상계)  
  ② 퇴직금 포함 공제 필요  
  ③ 원고 C의 청구는 소멸시효 완성(5년)으로 불허  

## 각 쟁점별 판단
- *쟁점 1: 파견법상 직접고용의무 불이행 상태에서 손해배상액 산정 시 손익상계 범위*  
  ① 손익상계 요건: 손해 발생행위 → 파견근로자에게 이득 발생 + 손해 범위에 대응하는 이익  
  ② 임금은 손익상계 대상 → 사내협력업체로부터 받은 임금은 공제 가능  
  ③ 퇴직금은 임금과 달리 사회보장·공로보상적 성격 포함, 임금 상당 손해에 대응하지 않음  
  ④ ∴ 퇴직금은 손익상계 대상 ⊄, 추후 퇴직금 손해배상 청구 시 공제 가능  

- *쟁점 2: 직접고용의무 위반 시 파견근로자의 고용의사표시 청구권 인정 여부*  
  ① 파견법 제6조의2 제1항에 근거한 직접고용의무는 사법상 의무 포함  
  ② ∴ 사용사업주 상대로 고용의사표시를 갈음하는 판결 청구 가능  
  ③ 확정 판결 시 법률상 직접고용관계 성립 ⇒ 사법상 고용관계 창설  

- *쟁점 3: 고용의사표시 청구권의 소멸시효 적용 문제*  
  ① 직접고용의무는 행정적·형사적 제재 외에 사법상 법정책임  
  ② ∴ [민법 일반 규정] 적용 → 민사시효 10년 적용  
  ③ ∴ 원고 C에 대한 피고의 5년 시효 완성 주장 배척 정당  

## 사안의 해결
① 원고들은 파견법 위반에 따른 직접고용의무 불이행 피해자  
② 손해배상액 산정 시 임금은 손익상계 대상이나 퇴직금은 해당하지 않음  
③ 원고들의 고용의사표시 청구 정당, 직접고용관계 성립  
④ 소멸시효는 10년 적용 → 원고 C 청구도 시효 완성 아님  
⑤ 원심이 퇴직금 일부 공제한 것은 잘못이나, 피고만 상고한 이상 원심 불이익 변경 불가  
⑥ 상고기각, 피고 패소 확정  

기호 설명  
甲·乙·丙 = 파견근로자(원고)  
D = 사용사업주(피고)  
사내협력업체 = 파견사업주  

관련 태그  
#파견근로자보호법 #직접고용의무 #손해배상 #손익상계 #퇴직금 #고용의사표시 #사법상청구권 #민사시효10년 #근로계약성립 #노동법 #불법파견 #직영근로자비교 #대법원판례
""""

이제 작업할 판례원문을 주겠다. 면밀하게 검토한 다음 위 지침에 따라 작업하라.

{{판례원문}}


위 판례를 보고 판례 정리를 코드블럭에 넣어서 제출하라. 이때, 캔버스를 사용하지 말고, 길어지면 나누어 제출하도록 하라. 시작해.


  
    
    
    `; // 예시 기본 템플릿
  </script>
  <style>
    ::-webkit-scrollbar { width: 8px; background: #F5F8FA; }
    ::-webkit-scrollbar-thumb { background: #E1E8ED; border-radius: 5px; }
    textarea:focus { outline: none; border-color: #1DA1F2 !important; }
    .split-block-btn svg { width: 20px; height: 20px; }
    .modal-bg {
      position: fixed; inset: 0; background: rgba(30,41,59,0.25); z-index: 50; display: none;
      align-items: center; justify-content: center;
    }
    .modal-box {
      background: #fff; border-radius: 1rem; box-shadow: 0 4px 24px rgba(0,0,0,0.18);
      min-width: 320px; max-width: 90vw; max-height: 80vh; padding: 1.2rem 1.4rem; /* max-height 늘림 */
      display: flex; flex-direction: column;
    }
    .modal-content {
      font-size: 0.93rem; color: #344055; overflow-y: auto; max-height: 60vh; /* max-height 늘림 */ line-height: 1.6;
      /* word-break: break-all; 옵션 모달에서는 필요 없을 수 있음 */
    }
    .modal-title {
      font-size: 1rem; font-weight: 600; margin-bottom: 0.8em; /* margin 늘림 */
      color: #1DA1F2;
    }
    .modal-close-btn {
      position: absolute; top: 1rem; right: 1rem; background: none; border: none; font-size: 1.2rem; color: #888; cursor: pointer;
    }
    .block-copied {
      background: #DBEAFE !important;
      transition: background 0.3s;
    }
    .block-index {
      font-size: 11px; color: #60A5FA; font-weight: 600; margin-left: 7px;
      min-width: 30px; text-align: right; letter-spacing: 0.05em;
    }
    /* 옵션 변경 버튼 스타일 */
    .change-option-btn {
      background: #E0F2FE; /* Tailwind sky-100 */
      color: #0EA5E9; /* Tailwind sky-500 */
      padding: 0.2rem 0.5rem;
      font-size: 0.7rem;
      border-radius: 0.375rem; /* rounded-md */
      transition: all 0.2s;
    }
    .change-option-btn:hover {
      background: #BAE6FD; /* Tailwind sky-200 */
    }
  </style>
</head>
<body id="mainBody">

<div class="flex flex-col items-center py-8">
  <h1 id="mainHeader" class="text-3xl font-bold mb-4 text-[#1DA1F2]">자료정리</h1> </div>
<div class="w-full max-w-3xl mx-auto"
  style="border-radius: 1.5rem; background: #FFFFFF; box-shadow: 0 4px 24px rgba(29,161,242,0.08);
    border: 1.5px solid #E1E8ED; margin-top: 1rem; margin-bottom: 3rem; backdrop-filter: blur(6px);">
  <div class="relative group">
    <div class="flex items-center justify-between px-7 pt-7 pb-3">
      <span class="text-xl font-bold flex items-center gap-2" style="color: #1DA1F2;">
        <svg class="inline w-6 h-6" fill="none" stroke="#1DA1F2" stroke-width="2"
          viewBox="0 0 24 24"><path d="M9 12l2 2 4-4"></path><path d="M20 12a8 8 0 11-16 0 8 8 0 0116 0z"></path></svg>
        <span>템플릿</span>
      </span>
      <div class="flex gap-1">
        <button id="resetTemplateBtn"
          class="rounded-xl px-3 py-1 text-xs font-medium shadow-sm transition-all"
          style="color: #1DA1F2; background: #E1E8ED;">템플릿 초기화</button>
        <button id="collapseBtn"
          class="rounded-xl px-2 py-1 text-xs font-medium transition-all"
          aria-label="접기/펼치기"
          style="color: #1DA1F2; background: #F5F8FA;">
          <span id="collapseIcon" class="transition-all duration-300 inline-block">&#9660;</span>
        </button>
      </div>
    </div>
    <div id="templateCollapse" class="px-7 pb-4 transition-all overflow-hidden" style="display: block;">
      <textarea id="templateArea" rows="8"
        class="w-full p-4 rounded-xl border-2 focus:ring-2 font-mono text-sm resize-none shadow"
        style="min-height:120px; border-color:#E1E8ED; background:#F5F8FA; color:#14171A;"
        placeholder="프롬프트 템플릿에 {{변수|옵션|길이}} 또는 {{변수|separator|구분자}} 형태로 사용 (예: {{내용|newline|3000}}, {{문단|separator|◇◇◇}})"></textarea>
      <div class="flex justify-end pt-1">
        <span class="text-xs" style="color: #AAB8C2;">
          템플릿 내 <span class="font-semibold">{{변수|옵션|길이}}</span> 자동 인식<br>
          <span style="color:#93C5FD;">옵션: newline(줄+글자수), comma(쉼표), length(글자수), separator(구분자)<br>
            separator 사용시: {{변수|separator|구분자}}<br>
            미지정시 줄+8000 (예: {{변수}} 또는 {{변수|newline}}), 글자수 지정 가능 (예: {{변수|newline|500}})</span>
        </span>
      </div>
    </div>
  </div>
  <form id="dynamicInputs" class="space-y-8 px-7 pt-3 pb-2"></form>
  <div class="flex justify-end pr-7 pb-1">
    <button id="resetAllInputsBtn"
      class="rounded-xl px-3 py-1 text-xs font-medium shadow-sm transition-all"
      style="color: #1DA1F2; background: #E1E8ED;">입력값 모두 비우기</button>
  </div>
  <div id="outputSection" class="mt-8 px-7 pb-10 hidden">
    <div class="flex items-center justify-between mb-2">
      <span class="font-semibold flex items-center gap-1" style="color:#1DA1F2;">
        <svg class="inline w-5 h-5" fill="none" stroke="#1DA1F2" stroke-width="2"
          viewBox="0 0 24 24"><path d="M12 20h9"></path><path d="M12 4v16"></path><path d="M4 12h8"></path></svg>
        <span>블록</span>
      </span>
    </div>
    <div id="splitBlocksContainer" class="flex flex-wrap gap-3"></div>
  </div>
</div>
<div id="modalBg" class="modal-bg flex">
  <div class="modal-box relative">
    <button class="modal-close-btn" id="modalCloseBtn" title="닫기">&times;</button>
    <div class="modal-title" id="modalTitle"></div>
    <div class="modal-content" id="modalContent"></div>
  </div>
</div>

<script>

const keys = {
  template: STORAGE_PREFIX + '_template',
  state: STORAGE_PREFIX + '_state',
  blockCopied: STORAGE_PREFIX + '_blockcopied'
};

let state = {};
let variables = []; // 현재 템플릿에서 인식된 변수 이름 목록
let copiedBlocks = [];

function parseTemplateVars(template) {
  const re = /{{\s*([가-힣\w\d_]+)(?:\|(newline|comma|length|separator|seperator))?(?:\|([^\}|]+))?(?:\|(\d+))?\s*}}/g;
  const found = {};
  let m;
  while ((m = re.exec(template))) {
    const name = m[1];
    const opt = (m[2] || 'newline').toLowerCase(); // 옵션 없으면 newline 기본
    let separator = undefined, len = 8000;

    if (opt === 'separator' || opt === 'seperator') {
      separator = m[3]; // {{var|separator|###}} -> m[3] = ###
    } else if (opt === 'length') {
      len = m[3] ? parseInt(m[3]) : 8000; // {{var|length|500}} -> m[3] = 500
    } else if (opt === 'newline' || opt === 'comma') {
      // {{var|newline|500}} -> m[3] = 500
      // {{var|newline}} -> m[3] = undefined, 기본값 8000 사용
      // {{var|comma}} -> m[3] = undefined, 길이는 사용 안하지만 파싱 구조상
      if (m[3]) len = parseInt(m[3]);
    }
    // comma는 길이를 실제 사용하지 않지만, 파싱된 length 값은 가질 수 있음. splitVariableContent에서 처리.
    found[name] = { name: name, method: opt, separator: separator, length: len };
  }
  return found;
}

function splitByNewlineAndLength(text, maxLen) {
  const lines = text.split('\n');
  const result = [];
  let chunk = '';
  for(const line of lines) {
    if ((chunk + (chunk ? '\n' : '') + line).length > maxLen && chunk) {
      result.push(chunk);
      chunk = line;
    } else {
      chunk += (chunk ? '\n' : '') + line;
    }
  }
  if(chunk) result.push(chunk);
  return result;
}
function splitVariableContent(value, method, length=8000, separator) {
  if (!value) return [];
  if (method === 'separator' || method === 'seperator') {
    if (!separator) return [value]; // 구분자 없으면 통으로 반환
    return value.split(separator).map(s => s.trim()).filter(Boolean);
  }
  if (method === 'comma') {
    return value.split(',').map(s=>s.trim()).filter(Boolean);
  }
  if (method === 'newline') {
    return splitByNewlineAndLength(value, length);
  }
  if (method === 'length') {
    const arr = [];
    let i = 0;
    while (i < value.length) {
      arr.push(value.substr(i, length));
      i += length;
    }
    return arr;
  }
  return [value]; // 알 수 없는 메소드면 통으로 반환
}
function getBlockCombinations(arrs) {
  if (!arrs.length) return [[]];
  const rest = getBlockCombinations(arrs.slice(1));
  const result = [];
  arrs[0].forEach((val, i) => {
    rest.forEach(r => result.push([val, ...r]));
  });
  return result;
}
function saveState() {
  localStorage.setItem(keys.state, JSON.stringify(state));
}
function loadState() {
  try { state = JSON.parse(localStorage.getItem(keys.state) || '{}'); } catch { state = {}; }
}
function saveCopiedBlocks() {
  localStorage.setItem(keys.blockCopied, JSON.stringify(copiedBlocks));
}
function loadCopiedBlocks() {
  try { copiedBlocks = JSON.parse(localStorage.getItem(keys.blockCopied) || '[]'); } catch { copiedBlocks = []; }
}

function renderInputs() {
  const templateArea = document.getElementById('templateArea');
  const dynamicInputs = document.getElementById('dynamicInputs');
  dynamicInputs.innerHTML = '';
  const varOptsMap = parseTemplateVars(templateArea.value); // 변수명:옵션객체 맵

  variables.forEach(varName => { // `variables`는 onTemplateChange에서 업데이트된 순서 있는 배열
    const val = state[varName] || '';
    const vOpt = varOptsMap[varName] || {method:'newline', length:8000}; // Fallback, 실제로는 variables 배열 생성 시 이미 파싱됨
    
    let splitDesc = '';
    if(vOpt.method==='comma') splitDesc = '쉼표(,)로 분할';
    else if(vOpt.method==='length') splitDesc = `글자수 단위로 ${vOpt.length}자씩 분할`;
    else if(vOpt.method==='separator' || vOpt.method==='seperator')
      splitDesc = `구분자 ['${vOpt.separator || ''}'] 기준 분할`;
    else splitDesc = `줄바꿈+글자수 (${vOpt.length}자) 분할 (기본)`;
    
    const wrap = document.createElement('div');
    wrap.className = "relative group";
    wrap.innerHTML = `
      <div class="flex items-center justify-between mb-1">
        <label for="input_${varName}" class="block text-[17px] font-semibold" style="color:#1DA1F2;">${varName}</label>
        <div class="flex items-center space-x-2">
          <button type="button" data-var="${varName}"
            class="change-option-btn">옵션변경</button>
          <button type="button" data-var="${varName}"
            class="clearInputBtn px-2 py-0.5 text-xs rounded transition-all"
            style="background:#E1E8ED; color:#1DA1F2;">초기화</button>
        </div>
      </div>
      <textarea id="input_${varName}" rows="1"
        class="w-full p-4 rounded-xl border focus:ring-2 font-medium resize-none shadow-sm transition"
        style="border-color:#E1E8ED; background:#F5F8FA; color:#14171A; min-height:2.5rem; max-height:400px; overflow:auto;"
        placeholder="${varName} 입력">${val}</textarea>
      <div class="flex justify-between text-[12px] mt-1" style="color:#AAB8C2;">
        <span class="input-stats">${(val.match(/\n/g)||[]).length+1}줄, ${val.length}자</span>
      </div>
      <div class="text-xs text-[#AAB8C2] ml-1 var-split-desc">${splitDesc}</div>
    `;
    dynamicInputs.appendChild(wrap);

    const ta = wrap.querySelector('textarea');
    function autoResize() {
      ta.style.height = 'auto';
      ta.style.height = Math.min(ta.scrollHeight, 400) + 'px';
    }
    ta.addEventListener('input', () => {
      state[varName] = ta.value;
      saveState();
      copiedBlocks = []; // 내용 변경시 복사 기록 초기화
      saveCopiedBlocks();
      renderSplitBlocks();
      wrap.querySelector('.input-stats').textContent =
        `${(ta.value.match(/\n/g)||[]).length+1}줄, ${ta.value.length}자`;
      autoResize();
    });
    autoResize();
    
    wrap.querySelector('.clearInputBtn').onclick = function() {
      ta.value = '';
      state[varName] = '';
      saveState();
      copiedBlocks = [];
      saveCopiedBlocks();
      renderSplitBlocks();
      wrap.querySelector('.input-stats').textContent = '1줄, 0자';
      autoResize();
    };

    wrap.querySelector('.change-option-btn').onclick = function() {
      showVariableOptionsModal(varName);
    };
  });
}

// *** 변수 옵션 변경 기능 START ***
function showVariableOptionsModal(varName) {
    const modalTitleEl = document.getElementById('modalTitle');
    const modalContentEl = document.getElementById('modalContent');
    const templateArea = document.getElementById('templateArea');
    const currentVarOptsMap = parseTemplateVars(templateArea.value);
    const varOpt = currentVarOptsMap[varName] || { method: 'newline', length: 8000, separator: '' };

    modalTitleEl.textContent = `${varName} 변수 분할 옵션 설정`;

    modalContentEl.innerHTML = `
        <div class="space-y-4 p-1">
            <div>
                <label for="varOptMethod" class="block text-sm font-medium text-gray-700">분할 방식:</label>
                <select id="varOptMethod" name="varOptMethod" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                    <option value="newline" ${varOpt.method === 'newline' ? 'selected' : ''}>줄바꿈+글자수 (기본)</option>
                    <option value="length" ${varOpt.method === 'length' ? 'selected' : ''}>글자수</option>
                    <option value="comma" ${varOpt.method === 'comma' ? 'selected' : ''}>쉼표 (,)</option>
                    <option value="separator" ${varOpt.method === 'separator' || varOpt.method === 'seperator' ? 'selected' : ''}>사용자 정의 구분자</option>
                </select>
            </div>
            <div id="varOptLengthContainer" style="display: ${varOpt.method === 'newline' || varOpt.method === 'length' ? 'block' : 'none'};">
                <label for="varOptLength" class="block text-sm font-medium text-gray-700">최대 글자수:</label>
                <input type="number" id="varOptLength" name="varOptLength" value="${varOpt.length || ''}" placeholder="예: 3000 (비우면 기본값)" class="mt-1 block w-full py-2 px-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" min="1">
                <p class="mt-1 text-xs text-gray-500">'줄바꿈+글자수' 또는 '글자수' 방식에 적용. 비우면 기본값(newline: 8000, length: 강제입력 필요).</p>
            </div>
            <div id="varOptSeparatorContainer" style="display: ${varOpt.method === 'separator' || varOpt.method === 'seperator' ? 'block' : 'none'};">
                <label for="varOptSeparator" class="block text-sm font-medium text-gray-700">구분자:</label>
                <input type="text" id="varOptSeparator" name="varOptSeparator" value="${varOpt.separator || ''}" placeholder="예: ### 또는 ---" class="mt-1 block w-full py-2 px-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                <p class="mt-1 text-xs text-gray-500">'사용자 정의 구분자' 방식에 적용.</p>
            </div>
            <div class="flex justify-end space-x-3 pt-5">
                <button id="cancelVarOptBtn" class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md border border-gray-300">취소</button>
                <button id="saveVarOptBtn" class="px-4 py-2 text-sm font-medium text-white bg-[#1DA1F2] hover:bg-[#0c8de4] rounded-md">저장</button>
            </div>
        </div>
    `;

    const optMethodSelect = modalContentEl.querySelector('#varOptMethod');
    const lengthContainer = modalContentEl.querySelector('#varOptLengthContainer');
    const separatorContainer = modalContentEl.querySelector('#varOptSeparatorContainer');
    const optLengthInput = modalContentEl.querySelector('#varOptLength');
    const optSeparatorInput = modalContentEl.querySelector('#varOptSeparator');

    function toggleOptionFields() {
        const selectedMethod = optMethodSelect.value;
        lengthContainer.style.display = (selectedMethod === 'newline' || selectedMethod === 'length') ? 'block' : 'none';
        separatorContainer.style.display = (selectedMethod === 'separator') ? 'block' : 'none';
        if (selectedMethod === 'newline') {
            optLengthInput.placeholder = "예: 3000 (비우면 기본값 8000)";
        } else if (selectedMethod === 'length') {
             optLengthInput.placeholder = "예: 500 (필수 입력)";
        }
    }

    optMethodSelect.addEventListener('change', toggleOptionFields);

    modalContentEl.querySelector('#saveVarOptBtn').onclick = () => {
        const newMethod = optMethodSelect.value;
        let valueForTemplate = undefined; // {{var|method}} 또는 {{var|method|value}} 에서 value 부분

        if (newMethod === 'newline') {
            valueForTemplate = optLengthInput.value ? parseInt(optLengthInput.value) : ''; // 비우면 {{var|newline}} -> 기본값 8000
            if (valueForTemplate && valueForTemplate <= 0) { alert("글자수는 1 이상이어야 합니다."); return; }
        } else if (newMethod === 'length') {
            if (!optLengthInput.value) { alert("'글자수' 방식에는 반드시 글자수를 입력해야 합니다."); return; }
            valueForTemplate = parseInt(optLengthInput.value);
            if (valueForTemplate <= 0) { alert("글자수는 1 이상이어야 합니다."); return; }
        } else if (newMethod === 'separator') {
            valueForTemplate = optSeparatorInput.value;
            // 구분자는 비어있을 수도 있으나, 보통은 채움. 비어있으면 split 결과가 달라짐.
            // if (!valueForTemplate) { alert("'사용자 정의 구분자' 방식에는 구분자를 입력하는 것이 좋습니다."); /* return; */ }
        }
        // 'comma'는 valueForTemplate이 undefined (즉, {{var|comma}})

        updateVariableInTemplate(varName, newMethod, valueForTemplate);
        document.getElementById('modalBg').style.display = 'none';
    };

    modalContentEl.querySelector('#cancelVarOptBtn').onclick = () => {
        document.getElementById('modalBg').style.display = 'none';
    };

    document.getElementById('modalBg').style.display = 'flex';
}

function updateVariableInTemplate(variableName, newMethod, value) {
    const templateArea = document.getElementById('templateArea');
    let templateContent = templateArea.value;

    // {{ varName | method | value1 | value2 }} 형태를 찾음.
    // 여기서 value는 method에 따른 값 (길이 또는 구분자)
    const varRegex = new RegExp(`{{\\s*${variableName}(?:\\|[^}]+)?\\s*}}`);
    
    let newVarDefinition = `{{${variableName}`;
    if (newMethod) {
        newVarDefinition += `|${newMethod}`;
        // value가 undefined, null, '' (빈문자열)이 아닐 때만 |value를 추가
        // 단, newline이고 value가 '' (사용자가 비움)이면 {{var|newline}}이 되어야 함.
        if (value !== undefined && value !== null && (value !== '' || newMethod !== 'newline')) {
             if (value !== '' || (newMethod === 'newline' && value === '')) { // newline이고 명시적으로 빈값을 넣으면 parameter 생략
                if (newMethod === 'newline' && value === '') {
                    // {{varName|newline}} 형태로, 값 없이.
                } else {
                     newVarDefinition += `|${value}`;
                }
             }
        } else if (newMethod === 'newline' && value === '') { // 명시적으로 {{var|newline}}
             // 이미 처리됨
        }
    }
    newVarDefinition += `}}`;
    
    if (varRegex.test(templateContent)) {
        templateContent = templateContent.replace(varRegex, newVarDefinition);
    } else {
        console.warn(`Variable ${variableName} not found in template for replacement.`);
        return; // 변수가 없으면 변경하지 않음
    }

    templateArea.value = templateContent;
    localStorage.setItem(keys.template, templateContent); // 변경된 템플릿 저장
    onTemplateChange(); // 전체 UI 및 상태 업데이트
}
// *** 변수 옵션 변경 기능 END ***

function renderSplitBlocks() {
  const templateArea = document.getElementById('templateArea');
  const splitBlocksContainer = document.getElementById('splitBlocksContainer');
  splitBlocksContainer.innerHTML = '';
  
  if (!variables.length) { // `variables` 배열은 onTemplateChange에서 설정됨
    document.getElementById('outputSection').classList.add('hidden');
    return;
  }

  const varOptsMap = parseTemplateVars(templateArea.value);
  
  const varValueArrays = variables.map(varName => {
    const vOpt = varOptsMap[varName] || {method:'newline', length:8000}; // 안전장치
    return splitVariableContent(state[varName]||'', vOpt.method, vOpt.length, vOpt.separator);
  });

  if (varValueArrays.some(arr => !arr.length && variables.some(v => state[v]))) {
     // 입력값이 있는데 분할 결과가 없는 경우 (예: 빈 구분자로 분할 시)
     // 이 경우는 보통 splitVariableContent에서 빈 배열을 반환하지 않고 [''] 등을 반환해야 함.
     // 현재 로직: filter(Boolean) 때문에 빈 문자열은 제거됨.
     // 만약 모든 변수 내용이 비어있다면 combos는 [[]]가 되고, 아래에서 prompt만 생성됨.
     // 하나라도 입력이 있는데 그게 분할 후 빈 배열이 되면 combos가 비게됨.
  }
  // 어떤 변수라도 입력이 있는데, 그 결과 배열이 비면(예: state['A']=' '이고 구분자로 분할시) 문제가 될 수 있음.
  // splitVariableContent에서 filter(Boolean)으로 인해 완전히 빈 값은 제외됨.
  // 만약 모든 필수 변수값이 채워져야 한다면, 여기서 체크
  const allVarsHaveContent = variables.every(varName => {
      const vOpt = varOptsMap[varName];
      const content = state[varName] || '';
      const splitResult = splitVariableContent(content, vOpt.method, vOpt.length, vOpt.separator);
      return splitResult.length > 0 || !content; // 내용이 있거나, 아예 내용이 없거나
  });

  if (!allVarsHaveContent && variables.some(v => state[v])) { // 내용이 있는 변수가 있는데 분할 결과가 없다면
      document.getElementById('outputSection').classList.add('hidden');
      return;
  }


  const combos = getBlockCombinations(varValueArrays.map(arr => arr.length ? arr : [''])); // 빈 결과는 빈 문자열 하나로 대체

  combos.forEach((vals, comboIdx) => {
    // vals에 빈 문자열이 포함될 수 있음. (입력 자체가 없거나, split 결과가 빈 경우 [''] 주입으로 인해)
    // 인덱스 계산시 주의
    const idxArr = vals.map((v_val, i) => {
        const originalArr = varValueArrays[i];
        return originalArr.length > 1 ? originalArr.indexOf(v_val) + 1 : (originalArr.length === 1 && originalArr[0] !== '' ? 1:0) ;
    });
    const idxLabel = idxArr.map(i => i > 0 ? i : '-').join(','); // 0번 인덱스는 '-'로 표시 (내용 없는 경우)


    let prompt = templateArea.value;
    variables.forEach((vn, vi) => {
      // 정규식 수정: 변수 이름 뒤에 공백이 더 많이 올 수 있고, 파이프와 옵션 사이 공백도 고려
      const reg = new RegExp(`{{\\s*${vn}(?:\\s*\\|[^}]+)?\\s*}}`, "g");
      prompt = prompt.replace(reg, vals[vi]);
    });

    const copied = copiedBlocks.some(item =>
      JSON.stringify(item.idxArr) === JSON.stringify(idxArr) &&
      JSON.stringify(item.vars) === JSON.stringify(variables) // 현재 활성화된 변수 목록도 일치해야 함
    );
    
    const blockDiv = document.createElement('div');
    blockDiv.className =
      "split-block-btn flex items-center px-3 py-2 rounded-xl shadow-sm mr-2 mb-2 " +
      (copied ? "block-copied" : "bg-[#F5F8FA]");
    blockDiv.innerHTML = `
      <button title="보기" class="viewBtn mr-2 hover:text-[#1DA1F2]" style="background:none;border:none;">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <circle cx="11" cy="11" r="6" /><line x1="21" y1="21" x2="16.65" y2="16.65" />
        </svg>
      </button>
      <button title="복사" class="copyBtn hover:text-[#1DA1F2]" style="background:none;border:none;">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <rect x="9" y="9" width="13" height="13" rx="2" />
          <rect x="3" y="3" width="13" height="13" rx="2" />
        </svg>
      </button>
      <span class="block-index">${idxLabel}</span>
    `;
    blockDiv.querySelector('.viewBtn').onclick = function() {
      showModal(`블록 ${idxLabel}`, prompt);
    };
    blockDiv.querySelector('.copyBtn').onclick = function(e) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(prompt).then(()=>{
          setCopiedBlock(idxArr, variables);
        },()=>{
          copyFallback(prompt, blockDiv); // 실패시 폴백
          setCopiedBlock(idxArr, variables);
        });
      } else {
        copyFallback(prompt, blockDiv);
        setCopiedBlock(idxArr, variables);
      }
    };
    splitBlocksContainer.appendChild(blockDiv);
  });

  // 결과 섹션 표시 여부: 조합이 하나라도 있거나 (내용 없는 변수만 있을 경우 빈 프롬프트 하나),
  // 또는 모든 변수 입력이 비어있지 않은 경우.
  // 수정: combos가 비어있지 않고, 첫번째 combo가 빈 배열이 아니거나 (즉, 변수가 있을 때)
  // 또는 combos[0]의 모든 요소가 빈 문자열이 아닐 때만 표시
  const showOutput = combos.length > 0 && (variables.length > 0 || (combos.length === 1 && combos[0].some(item => item !== '')));

  document.getElementById('outputSection').classList.toggle('hidden', !showOutput);
}

function setCopiedBlock(idxArr, currentVars) {
  if (!copiedBlocks.some(item =>
    JSON.stringify(item.idxArr) === JSON.stringify(idxArr) &&
    JSON.stringify(item.vars) === JSON.stringify(currentVars)
  )) {
    copiedBlocks.push({idxArr, vars: currentVars});
    saveCopiedBlocks();
    renderSplitBlocks(); // 복사 상태 반영하여 다시 렌더링
  }
}

function copyFallback(text, el) {
  try {
    let area = document.createElement("textarea");
    area.value = text;
    area.style.position = "fixed";
    area.style.opacity = "0";
    document.body.appendChild(area);
    area.focus();
    area.select();
    document.execCommand('copy');
    document.body.removeChild(area);
    // 성공 알림은 setCopiedBlock에서 UI 변경으로 대체
  } catch(e) {
    alert('복사 실패! 내용을 길게 눌러 복사하세요.');
  }
}

function showModal(title, content) {
  document.getElementById('modalTitle').textContent = title;
  document.getElementById('modalContent').textContent = content; // 텍스트로만 설정
  document.getElementById('modalContent').style.whiteSpace = 'pre-wrap'; // 줄바꿈 및 공백 유지
  document.getElementById('modalContent').style.wordBreak = 'break-all'; // 긴 단어 줄바꿈
  document.getElementById('modalBg').style.display = 'flex';
}
document.getElementById('modalBg').onclick = function(e) {
  if (e.target === document.getElementById('modalBg') || e.target.id === 'modalCloseBtn') {
     document.getElementById('modalBg').style.display = 'none';
     document.getElementById('modalContent').style.whiteSpace = 'normal'; // 원래대로
     document.getElementById('modalContent').style.wordBreak = 'normal';
  }
};
document.getElementById('modalCloseBtn').onclick = function() { // 중복이지만 확실하게
  document.getElementById('modalBg').style.display = 'none';
  document.getElementById('modalContent').style.whiteSpace = 'normal';
  document.getElementById('modalContent').style.wordBreak = 'normal';
};

function onTemplateChange() {
  const templateArea = document.getElementById('templateArea');
  let tmpl = templateArea.value;
  if (!tmpl.trim() && DEFAULT_TEMPLATE) { // 빈 템플릿이고 기본 템플릿이 정의되어 있으면
    tmpl = DEFAULT_TEMPLATE;
    templateArea.value = tmpl;
  }
  
  const varOptsMap = parseTemplateVars(tmpl);
  variables = Object.keys(varOptsMap); // 여기서 변수 목록 및 순서 확정

  const newState = {};
  variables.forEach(v => {
    newState[v] = state[v] || ''; // 기존 값 유지 또는 초기화
  });
  state = newState; // 이전 템플릿에만 있던 변수 값은 제거

  saveState();
  copiedBlocks = []; // 템플릿 변경 시 복사 기록 초기화
  saveCopiedBlocks();
  renderInputs();
  renderSplitBlocks();
}

document.getElementById('collapseBtn').onclick = function() {
  let c = document.getElementById('templateCollapse');
  let icon = document.getElementById('collapseIcon');
  if (c.style.display === 'block') {
    c.style.display = 'none'; icon.innerHTML = '&#9654;';
  } else {
    c.style.display = 'block'; icon.innerHTML = '&#9660;';
  }
};

document.getElementById('resetTemplateBtn').onclick = function() {
  const templateArea = document.getElementById('templateArea');
  templateArea.value = DEFAULT_TEMPLATE;
  localStorage.setItem(keys.template, DEFAULT_TEMPLATE);
  onTemplateChange();
  document.getElementById('templateCollapse').style.display = 'block';
  document.getElementById('collapseIcon').innerHTML = '&#9660;';
};

document.getElementById('resetAllInputsBtn').onclick = function() {
  variables.forEach(v => state[v]='');
  saveState();
  copiedBlocks = [];
  saveCopiedBlocks();
  renderInputs(); // 입력창 UI 업데이트
  renderSplitBlocks(); // 블록 업데이트
};

document.getElementById('templateArea').addEventListener('input', () => {
  localStorage.setItem(keys.template, document.getElementById('templateArea').value);
  onTemplateChange();
});

window.addEventListener('DOMContentLoaded', () => {
  // STORAGE_PREFIX 적용 범위 확장
  document.title = `${STORAGE_PREFIX} 법령검토 생성기`;
  document.getElementById('mainHeader').textContent = `${STORAGE_PREFIX} 자료정리`;

  document.getElementById('modalBg').style.display = 'none';
  let tmpl = localStorage.getItem(keys.template);
  if (!tmpl) { // 저장된 템플릿이 없으면 기본 템플릿 사용
    tmpl = DEFAULT_TEMPLATE;
    localStorage.setItem(keys.template, tmpl); // 기본 템플릿도 저장
  }
  document.getElementById('templateArea').value = tmpl;
  
  loadState();
  loadCopiedBlocks();
  onTemplateChange(); // 모든 초기화 후 UI 렌더링
  
  document.getElementById('templateCollapse').style.display = 'block';
  document.getElementById('collapseIcon').innerHTML = '&#9660;';
});
</script>
</body>
</html>
