<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#5e9ec5" />
  <title>Material Design Text Chunking</title>

  <!-- Material Components & Fonts -->
  <link rel="stylesheet" href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" />
  <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Roboto:wght@400;700&display=swap" rel="stylesheet" />

  <style>
    /* ───────────  Color Palette  ─────────── */
    :root{
      --clr-gradient-start:#5b8cff;
      --clr-gradient-end:#977dff;
      --clr-accent:#00c8b0;
      --clr-bg:#eff6f9;
      --clr-surface:#ffffff;
      --clr-on-surface:#1c1c1e;
      --clr-border:#dfe9f1;

      --radius-s:10px;
      --radius-m:18px;
      --shadow-s:0 2px 6px rgba(0,0,0,.05);
      --shadow-m:0 8px 20px rgba(0,0,0,.08);
      --transition:all .25s ease;
      --font-main:'Nanum Gothic',sans-serif;
    }

    html,body{height:100%;margin:0;font-family:var(--font-main);background:var(--clr-bg);color:var(--clr-on-surface);-webkit-font-smoothing:antialiased;}

    body::before{
      content:"";position:fixed;inset:0;z-index:-1;
      background:radial-gradient(circle at 90% 5%,rgba(151,125,255,.12),transparent 55%),
                 radial-gradient(circle at 10% 95%,rgba(91,140,255,.12),transparent 55%);
    }

    /* ───────────  Layout  ─────────── */
    .container{max-width:920px; margin:4vh auto; padding:0 16px; display:flex;flex-direction:column;gap:32px;}

    /* ───── Hero Banner ───── */
  .hero {
  background: linear-gradient(135deg, var(--clr-gradient-start) 0%, var(--clr-gradient-end) 100%);
  border-radius: var(--radius-m);
  padding: 56px 40px;
  box-shadow: var(--shadow-m);
  display: flex;
  flex-direction: column;
  gap: 14px;
  color: #fff;
}

.hero-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.hero h1 {
  margin: 0;
  font-size: 1.9rem;
  font-weight: 700;
  letter-spacing: -0.7px;
  text-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
}

.reset-btn {
  background: rgba(255, 255, 255, 0.1);
  color: #fff;
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: var(--radius-s);
  padding: 8px;
  transition: var(--transition);
}
.reset-btn:hover {
  background: rgba(255, 255, 255, 0.2);
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
}
    /* ───── Panel ───── */
    .panel{background:var(--clr-surface);border-radius:var(--radius-m);box-shadow:var(--shadow-m);padding:32px;display:flex;flex-direction:column;gap:28px;}

    /* ───── Controls ───── */
    .controls-area{display:flex;flex-wrap:wrap;gap:20px;align-items:center;justify-content:center;}
    .chunk-size-controls{display:flex;align-items:center;gap:6px;background:var(--clr-bg);padding:8px 14px;border-radius:var(--radius-s);box-shadow:var(--shadow-s);}    
    .chunk-size-controls input{width:90px;height:46px;text-align:center;font-size:1rem;border:1px solid var(--clr-border);background:var(--clr-surface);border-radius:var(--radius-s);outline:none;transition:var(--transition);box-sizing:border-box;}
    .chunk-size-controls input:focus{border-color:var(--clr-gradient-start);box-shadow:0 0 0 3px rgba(91,140,255,.25);}    

    .mdc-button{transition:var(--transition);font-weight:700;border-radius:var(--radius-s);}  
    .btn-neutral{background:var(--clr-surface);color:var(--clr-on-surface);border:1px solid var(--clr-border);}  
    .btn-neutral:hover{box-shadow:var(--shadow-s);}  
    .btn-cta{background:linear-gradient(135deg,var(--clr-gradient-start) 0%,var(--clr-gradient-end) 100%);color:#fff;border:none;box-shadow:var(--shadow-s);}  
    .btn-cta:hover{filter:brightness(.96);}  

    /* ───── Textarea ───── */
    .textarea-custom{display:block;width:100%;min-height:220px;padding:18px 20px;font-size:1rem;border:1.5px solid var(--clr-border);border-radius:var(--radius-s);resize:vertical;background:var(--clr-surface);transition:var(--transition);box-sizing:border-box;}  
    .textarea-custom:focus{border-color:var(--clr-gradient-start);box-shadow:0 0 0 4px rgba(91,140,255,.18);}    

    /* ───── Output Chunks ───── */
    .output-area{display:flex;flex-direction:column;gap:18px;}
    .chunk{background:var(--clr-surface);border-radius:var(--radius-s);box-shadow:var(--shadow-s);display:flex;align-items:center;gap:14px;padding:16px 20px;opacity:0;transform:translateY(12px);animation:fadeUp .4s forwards;transition:var(--transition);}    
    .chunk:hover{transform:translateY(-2px);box-shadow:0 6px 14px rgba(0,0,0,.07);} /* subtle lift */
    .chunk-number{width:28px;min-width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:#fff;color:var(--clr-gradient-start);font-weight:700;border:2px solid var(--clr-gradient-start);font-size:.8rem;}
    .chunk-textarea{flex:1;display:none;white-space:pre-wrap;font-size:.9rem;}
    .mdc-button.copy-btn{margin-left:auto;background:var(--clr-accent);color:#fff;border:none;}
    .copy-btn.copied{opacity:.55;cursor:default;}

    @keyframes fadeUp{to{opacity:1;transform:none;}}

    /* ───── Toast ───── */
    .toast{visibility:hidden;min-width:240px;max-width:80vw;background:#1c1c1e;color:#fff;text-align:center;border-radius:var(--radius-s);padding:16px 20px;position:fixed;bottom:26px;left:50%;transform:translateX(-50%);z-index:10000;opacity:0;transition:opacity .35s,visibility .35s;}    
    .toast.show{visibility:visible;opacity:1;}

    /* ───── Modal ───── */
    .chunk-modal{visibility:hidden;opacity:0;pointer-events:none;position:fixed;inset:0;z-index:11000;display:flex;align-items:center;justify-content:center;transition:opacity .3s ease;}
    .chunk-modal.show{visibility:visible;opacity:1;pointer-events:auto;}
    .chunk-modal .overlay{position:absolute;inset:0;background:rgba(0,0,0,.55);}    
    .chunk-modal .content{position:relative;background:var(--clr-surface);padding:30px;max-width:92vw;max-height:82vh;border-radius:var(--radius-m);box-shadow:var(--shadow-m);overflow:auto;display:flex;flex-direction:column;gap:24px;}
    .chunk-modal pre{margin:0;white-space:pre-wrap;font-size:.95rem;font-family:var(--font-main);}    

    @media(max-width:640px){
      .hero{padding:42px 24px;gap:10px;}
      .hero h1{font-size:1.6rem;}
      .panel{padding:24px;}
      .chunk{flex-direction:column;align-items:flex-start;}
      .chunk-number{margin-bottom:6px;}
    }
  </style>
</head>
<body>
<div class="container">
      <!-- ⭐ Hero Banner -------------------------------------------------- -->
<section class="hero">
  <div class="hero-header">
    <h1>판례정리</h1>
    <button class="mdc-icon-button reset-btn" onclick="resetAll()" aria-label="Reset">
      <i class="material-icons mdc-icon-button__icon">restart_alt</i>
    </button>
  </div>
</section>
      <!-- ⭐ Control & Editor Panel --------------------------------------- -->
      <section class="panel">
        <!-- 청크 사이즈 컨트롤 -->
        <div class="controls-area">
          <div class="chunk-size-controls">
            <button class="mdc-button btn-neutral" onclick="adjustChunkSize(-500)">
              <span class="mdc-button__label">-500</span>
            </button>

            <input
              type="number"
              id="chunkSize"
              value="2000"
              onchange="updateChunkSize(this.value)"
              aria-label="Chunk size"
            />

            <button class="mdc-button btn-neutral" onclick="adjustChunkSize(500)">
              <span class="mdc-button__label">+500</span>
            </button>
          </div>
        </div>

        <!-- 텍스트 입력 영역 -->
        <textarea
          id="inputText"
          class="textarea-custom"
          placeholder="여기에 텍스트를 입력하세요..."
        ></textarea>

        <!-- 실행 CTA -->
        <button class="mdc-button btn-cta" style="width: 100%" onclick="processText()">
          <i class="material-icons mdc-button__icon" aria-hidden="true">format_align_left</i>
          <span class="mdc-button__label">텍스트 분할하기</span>
        </button>

        <!-- 결과 출력 영역 -->
        <div id="outputArea" class="output-area"></div>
      </section>
    </div>

    <!-- ⭐ Toast ---------------------------------------------------------- -->
    <div id="toast" class="toast" role="status" aria-live="polite">알림 메시지</div>

    <!-- ⭐ Chunk Preview Modal ------------------------------------------- -->
    <div id="chunkModal" class="chunk-modal" aria-modal="true" role="dialog">
      <div class="overlay" onclick="closeModal()"></div>
      <div class="content">
        <pre id="modalText"></pre>
        <button class="mdc-button btn-neutral" onclick="closeModal()">
          <span class="mdc-button__label">닫기</span>
        </button>
      </div>
    </div>

  <!-- 기능 스크립트 -->
  <script>
    /* ───── 설정 ───── */
    let chunkSize = 20000;
    const LS_KEY = 'textChunkState';

    const defaultText = `당신은 IQ 217로 초고지능자 협회의 일원이다.
  수행할 작업

현재 주어진 판결문 자료를 바탕으로, 주어진 제약사항을 엄격히 준수하며, 원문에 포함된 정보를 어떠한 왜곡이나 변형 없이 그대로 반영하되, 실제 하버드 로스쿨생이 시험공부에 사용할 판례정리자료를 작성한다. 이는 원래 판례를 읽지 않고도 판례와 관련된 모든 문제를 맞출 수 있을 정도로 완벽한 판레정리자료여야한다. 모든 법률용어는 그 정의에 부합하도록 정확하게 사용해야 한다. 자료에 포함된 정보는 반드시 원문 그대로 다루되, 새로운 정보를 추가하거나 기존 내용을 생략하는 행위는 절대 금지된다. 작업은 원문의 처음부터 끝까지 모든 내용을 철저히 포함하여 수행해야 하며, 결코 일부만 보고 작성하지 않는다. 자료 전체에 걸쳐 고른 주의 집중이 필요하다.

이때 사실관계는 전체적으로 이어지며 개연성이 있어야 하며, 각 사실관계마다 끊겨있는 느낌이 들어서는 안된다. 사실관계에서부터 사안의 해결까지 이어지는 흐름은 모두 개연성 논리성 명료성을 갖추어야 한다. 각 사실관계는 시계열 순으로, 인과관기 순으로 정렬하며 각 사건을 개행으로 분리해 목록형으로 기재한다.

사실관계에 등장하는 개인은 등장 순서에 따라 ‘甲’, '乙’, ‘丙’, ‘丁’ .. 등의 기호로, 회사 등 법인은 ‘A’, ‘B’, ‘C’, ‘D’ 등의 알파벳으로, 재산 또는 권리는 ‘X’, ‘Y’, ‘Z’ 등의 기호로 구분한다. 문서의 마지막에는 각 기호가 의미하는 대상(인물, 법인, 재산 등)을 명확히 설명하여 혼동이 발생하지 않도록 한다. 이때 제대로 연결 되었는지 수차례 집요하게 문서 전체를 대상으로 확인 또 확인하라. 다만 국가기관, 국가(대한민국 등), 법원(서울중앙지방법원 등)등은 이름을 그대로 표기한다. 

작업 범위는 자료의 처음부터 끝까지 철저히 해당 구간 내에서만 수행하며, 중간 내용을 임의로 생략하거나, 자료 이후의 내용을 자의적으로 생성하는 일은 절대 금지된다.

작성된 정리본은 명료하고 간결하면서도 가독성이 뛰어나야 하며, 독자가 쉽게 이해하고 빠르게 핵심을 파악할 수 있도록 해야 한다.

구체적인 서술방식은 아래와 같다.
1. 전체 구성 포맷
대제목 : ★제목 형식
✏️ 제목은 별(★) + 숫자. 뒤에는 공백을 두고 명확한 제목 표시.

절 제목 : ▶소제목 형식
✏️ ▶ 기호 사용 + 숫자 표기 + 소제목. 줄 띄우지 않고 바로 본문 항목 나열.

본문 항목 : -로 시작. (줄바꿈 후 단락별 나열) 내용이 복잡하거나 구분이 필요한 경우, 한 문단 내에서도 ①, ②, ③처럼 동그라미 숫자를 사용해 독자가 쉽게 이해할 수 있도록 하세요

항목 내 서술 방식 : · 먼저 핵심 키워드(ex. "1인 회사 의의", "주주총회 운영 및 의결권 행사 하자")를 굵게 표시하지 않고 그냥 문장 시작부에 노출
· 키워드 다음엔 :를 붙인 뒤 바로 설명 연결.
· 슬래시(/), 화살표(→), **괄호(())**를 이용해 빠른 대비·설명 병렬 처리. · "/"는 병렬 나열, "→"는 결과나 효과, "(판례)" 등 근거 표시.

플레인 텍스트로 기호만 사용하며, 리스트 형태는 사용하지 않을 것. 워드에 그대로 아무 처리 없이 붙여넣어도 뛰어난 시인성을 유지할 수 있도록 할 것.

2. 문장 스타일
매우 압축적이고, 끊어읽기 좋게 짧은 구문으로 구성. 다만 논리적이며 모든 정리가 유기적으로 연결되면서 하나의 체계를 형성해야 함.

"=" 또는 "/", "→" 등을 이용해 세부 요소를 병렬적으로 나열함으로써 암기 편의성 강화.

필수 키워드는 생략 없이 모두 등장.

판례, 통설, 다수설 같은 권위 근거는 반드시 (판례)처럼 간단히 괄호 안에 처리.

3. 논리적 흐름
개념 정의 → 요건·구조 설명 → 예외·특수상황 설명 → 판례 정리 순서로 흘러감.

항목별로 "기본 내용 → 변형/예외사항"을 일관성 있게 따라감.

**입장대립(다수설/소수설)**이 있으면 짧고 명료하게 병렬로 제시.

4. 구체적 표현기법
형식 구문

- (항목명)
(간략 설명  /  병렬 설명  /  결과 설명 → 효과  /  판례/통설 기재)
병렬 구분 : 슬래시  /  
예시 : "주주명부상 주주가 1인인 회사(협의의 1인 회사)  /  실질적으로 1인 소유인 회사(광의의 1인 회사)"

인과·귀속 결과 : 화살표 →
예시 : "1인 100% 지분 소유자가 출석한 경우 → 적법 주주총회 성립"

법적 근거 표기 : 괄호 (판례), (다수설) 등 짧게 명시.

문장 종결 : 마침표 .를 거의 쓰지 않음.
✏️ 연결되거나 연속되는 개념임을 강조하기 위해 쉼표 없이 이어감.

5. 분량
분량은 적절하게 굳이 늘려 쓰지 않고, 굳이 더 줄여 쓰지 않는다.


# 서술 기준
논리적 구조에 따라 정리하고, 학습 최적화 순서로 배열할 것.

법리, 효과, 판단기준은 명확히 구분하여 서술할 것.

핵심 키워드는 절대 생략 없이, 자료에 등장하는 표현을 그대로 명시할 것.

(예시: "외형상", "실질적으로", "개인기업에 불과" 등)

자료에 등장한 경우에만 판례 및 조문을 작성할 것. (※ 명시된 조문만 [조문번호]로 표기)

새로운 조문 추가, 임의의 문구 가공, 확장 금지.

아래 예시와 같이 화살표, /, : 등의 기호를 잘 사용할 것.


아래 제시된 목차 구조를 반드시 그대로 사용해야 한다. 판례의 경우, 판례번호를 정확히 기재하고, 판례의 사실관계를 먼저 시계열 순으로 정리한 뒤, 원고가 청구하는 내용 및 피고의 항변을 요건사실론에 따른 원피고의 주장 항변구조로 분석하고, 각 쟁점별로 내용을 정리하고 그 법리에 따라 사안이 어떻게 해결되는지 결론짓는다. 결론지을 때 주어진 사실관계 상에서 내지는 가정적 사실관계 상에서 사안의 최종적 해결을 제시한다. 파기환송 기각이 뿐 아니라 진짜 사안의 해결을 의미한다. 마지막에는 제텔카스텔 메모법과 같이 이용할 수 있도록 관련 법학적 내용(소멸시효, 관할 등등)의 태그를 여러개 한 줄로 이어서 붙인다. 이때 자료에 있던 모든 정보는 반드시 빠짐없이 포함되어야 하며, 간략히 언급하는 방식이라 하더라도 누락은 절대 허용되지 않는다.
    
## 예시 목차
반드시 아래와 같은 목차구조를 그대로 정확하게 사용한다.
'''
# 판례번호 : 판례번호(간단한 쟁점키워드)
## 판례 사실관계 분석
## 원피고의 주장항변
## 각 쟁점별 판단
## 사안의 해결
'''
모든 내용을 기재한 뒤 판례의 분류를 위한 샵태그를 추가한다. 관련 법을 태그에 넣는다. 교과서를 집필한다면 어떤 목차에 들어갈지를 기준으로 해서 세분화한 태깅을 해야 한다. 태그는 많이 생성해도 무관하다.

이런식이다.
'''
# 판례번호 : 예시판례(핵심 쟁점 키워드)

## 판례 사실관계 분석
- 
- 
...

## 원피고의 주장항변
- *원고의 주장*  
  ①  
  ②  
  ③  
...
- *피고의 항변*  
  ①  
  ②  
  ③  
...
## 각 쟁점별 판단
- *쟁점 1*  
  ①  
  ②  
  ③  
...
- *쟁점 2*  
  ①  
  ②  
  ③  
...
- *쟁점 3*  
  ①  
  ②  
  ③  
...
## 사안의 해결
①  
②  
③  
...
기호 설명

관련 태그
'''
`;
    const chunktwo    = `그 어떠한 불필요한 장식 없이 원고만을 코드블럭 안에 넣어서 바로 제시: `;

    /* ───── 상태 저장/복원 (localStorage) ───── */
    function saveState(){
      const copied=[...document.querySelectorAll('.copy-btn')]
        .map((b,i)=>b.classList.contains('copied')?i:null).filter(x=>x!==null);
      const state={
        chunkSize,
        inputText:document.getElementById('inputText').value,
        outputHTML:document.getElementById('outputArea').innerHTML,
        copied
      };
      localStorage.setItem(LS_KEY, JSON.stringify(state));
    }
    function loadState(){
      const raw=localStorage.getItem(LS_KEY); if(!raw) return;
      try{
        const {chunkSize:cs,inputText,outputHTML,copied=[]}=JSON.parse(raw);
        if(cs){chunkSize=cs;document.getElementById('chunkSize').value=cs;}
        if(inputText) document.getElementById('inputText').value=inputText;
        if(outputHTML) document.getElementById('outputArea').innerHTML=outputHTML;
        if(window.mdc&&mdc.autoInit) mdc.autoInit();
        [...document.querySelectorAll('.copy-btn')].forEach((b,i)=>{
          if(copied.includes(i)) b.classList.add('copied');
        });
      }catch(e){console.warn('localStorage 파싱 실패',e);localStorage.removeItem(LS_KEY);}  
    }

    /* ───── UI 동작 ───── */
    function adjustChunkSize(a){
      chunkSize=Math.max(500,chunkSize+a);
      document.getElementById('chunkSize').value=chunkSize;
      saveState();
    }
    function updateChunkSize(v){
      chunkSize=Math.max(500,parseInt(v));
      saveState();
    }
    function resetAll(){
      if(!confirm('모든 내용을 초기화하시겠습니까?')) return;
      document.getElementById('inputText').value='';
      document.getElementById('outputArea').innerHTML='';
      localStorage.removeItem(LS_KEY);
    }

    /* --- NEW : 모달 제어 --- */
    function openModal(text){
      document.getElementById('modalText').textContent=text.trim();
      document.getElementById('chunkModal').classList.add('show');
    }
    function closeModal(){
      document.getElementById('chunkModal').classList.remove('show');
    }

    /* --- NEW : 롱프레스 감지 --- */
    let pressTimer=null;
    function startLongPress(e){
      if(e.target.closest('.copy-btn')) return; // 복사 버튼 제외
      const idx=this.dataset.index;
      pressTimer=setTimeout(()=>openModal(window.chunkData[idx]),500);
    }
    function cancelLongPress(){
      clearTimeout(pressTimer);
    }

    function processText(){
      const input=document.getElementById('inputText').value.trim();
      const out=document.getElementById('outputArea');
      out.innerHTML='';
      if(!input){out.innerHTML='<p>텍스트를 입력해주세요.</p>';return;}

      let cur=''; const chunks=[];
      input.split('\n').forEach(p=>{
        cur+=p+'\n';
        if(cur.length>=chunkSize){chunks.push(cur);cur='';}
      });
      if(cur) chunks.push(cur);

      /* --- NEW : 전역 접근용 --- */
      window.chunkData = chunks;

      chunks.forEach((c,i)=>{
        const d=document.createElement('div');
        d.className='chunk';
        d.setAttribute('data-index',i);                         /* NEW */
        d.innerHTML=`
          <div class="chunk-number">${i+1}</div>
          <textarea class="chunk-textarea" readonly>${defaultText+c+chunktwo}</textarea>
          <button class="mdc-button mdc-button--raised copy-btn" onclick="copyToClipboard(this,${i})">
            <span class="mdc-button__label">복사</span>
          </button>`;

        /* --- NEW : 롱프레스 이벤트 바인딩 --- */
        d.addEventListener('mousedown',startLongPress);
        d.addEventListener('touchstart',startLongPress,{passive:true});
        d.addEventListener('mouseup',cancelLongPress);
        d.addEventListener('mouseleave',cancelLongPress);
        d.addEventListener('touchend',cancelLongPress);

        out.appendChild(d);
      });
      if(window.mdc&&mdc.autoInit) mdc.autoInit();
      saveState();
    }

    function copyToClipboard(btn,idx){
      const txt=btn.previousElementSibling.value;
      navigator.clipboard.writeText(txt).then(()=>{
        showToast('클립보드에 복사되었습니다!');
        btn.classList.add('copied'); saveState();
      }).catch(()=>fallbackCopy(txt,btn));
    }
    function fallbackCopy(text,btn){
      const ta=document.createElement('textarea');
      ta.value=text; ta.style.position='fixed'; ta.style.left='-9999px';
      document.body.appendChild(ta); ta.select();
      if(document.execCommand('copy')){
        btn.classList.add('copied'); showToast('클립보드에 복사되었습니다!(fallback)'); saveState();
      }else showToast('복사에 실패했습니다.');
      document.body.removeChild(ta);
    }
    function showToast(msg){
      const t=document.getElementById('toast');
      t.textContent=msg; t.classList.add('show');
      setTimeout(()=>t.classList.remove('show'),2800);
    }

    /* ───── 초기화 ───── */
    document.addEventListener('DOMContentLoaded',()=>{
      if(window.mdc&&mdc.autoInit) mdc.autoInit();
      loadState();
    });
  </script>
</body>
</html>
