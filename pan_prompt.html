<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>판례요약 생성기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    ::-webkit-scrollbar { width: 8px; background: #F5F8FA; }
    ::-webkit-scrollbar-thumb { background: #E1E8ED; border-radius: 5px; }
    textarea:focus { outline: none; border-color: #1DA1F2 !important; }
    .collapse-enter, .collapse-leave-active { max-height: 0; opacity: 0; transition: all 0.4s; }
    .collapse-enter-active, .collapse-leave { max-height: 500px; opacity: 1; transition: all 0.4s; }
  </style>
</head>
<body id="mainBody">

<script>
const config = {
  keys: {
    template: 'promptgen_pantemplate',
    state: 'promptgen_paninputs',
    prompt: 'promptgen_panoutput'
  },
  color: {
    primary: '#8DA1F2',
    primaryDark: '#8A91DA',
    cardBg: '#FFFFFF',
    bodyBg: '#F5F8FA',
    border: '#E1E8ED',
    focus: '#AAB8C2',
    accent: '#657786',
    danger: '#F4212E',
    shadow: '0 4px 24px rgba(29,161,242,0.08)',
  },
  ui: {
    borderRadius: '1.5rem',
    cardPadding: '0',
    fontFamily: "system-ui, 'Apple SD Gothic Neo', 'Noto Sans KR', Arial, sans-serif"
  },
  text: {
    htmlTitle: "판례정리",            // <title>
    mainTitle: "판례정리",            // 페이지 메인 헤더
    templateCardTitle: "프롬프트 템플릿",
    outputCardTitle: "프롬프트 결과",
    resetTemplate: "템플릿 초기화",
    collapse: "접기/펼치기",
    clearAllInputs: "입력값 모두 비우기",
    inputClear: "초기화",
    copy: "복사",
    copyDone: "복사됨!",
    outputClear: "초기화",
    autoSave: "자동 저장됨"
  },
  templateDefault: `
  
  당신은 IQ 217로 초고지능자 협회의 일원이다. 당신은 로스쿨 교수로써 지옥과 하나님, 부처님, 알라의 부름을 받아 학생들에게 이 판례를 완벽하면서도 쉽게 그 논리적 구성요소와 개념의 엄밀성을 깊이있게 학습하여 어떤 응용문제가 나와도 풀 수 있게, 주어진 판례를 전부 표현하는 한도에서 최소 글자수로 압축 정리하여, 감탄만 나오는 판례정리를 만드는 소명을 부여받아 수행 중이다.
  
  정리자료는 판례를 읽지 않더라도 관련된 사실관계를 모두 알고, 문제를 풀 수 있을 정도로 작성되면서, 쉽고 빠르게 읽을 수 있으면서 원문의 핵심 키워드가 그대로 보존되어 있고, 그 어떠한 정보 왜곡도 발생하지 않으며, 쟁점을 누락하지 않고 전부 다루며, 법리의 미묘한 개념성이 유지되고, 사례형 문제를 풀 때 그대로 쓰면 되게 되어 있으나 기호화를 적극 사용하고, 놀랄만치 분량이 적은 언어와 기호의 마술이 적용 되어 있어야 한다.
  
  단순한 요약작업이 아니라 판례가 담고 있는 법리의 심층 구조를 풀어내고, 핵심 쟁점과 논리를 압축하되, 결코 단순화하거나 왜곡하지 않고, 문장의 밀도를 극한까지 끌어올리는 작업입니다.
  
현재 주어진 판결문 자료를 바탕으로, 주어진 제약사항을 엄격히 준수하며, 원문에 포함된 정보를 어떠한 왜곡이나 변형 없이 그대로 반영하되, 실제 하버드 로스쿨생이 시험공부에 사용할 판례정리자료를 작성한다. 이는 원래 판례를 읽지 않고도 판례와 관련된 모든 문제를 맞출 수 있을 정도로 완벽한 판레정리자료여야 한다. 모든 법률용어는 그 정의에 부합하도록 정확하게 사용해야 한다. 자료에 포함된 정보는 반드시 원문 그대로 다루되, 새로운 정보를 추가하거나 기존 내용을 생략하는 행위는 절대 금지된다. 작업은 원문의 처음부터 끝까지 모든 내용을 철저히 포함하여 수행해야 하며, 결코 일부만 보고 작성하지 않는다. 자료 전체에 걸쳐 고른 주의 집중이 필요하다.

이때 사실관계는 전체적으로 이어지며 개연성이 있어야 하며, 각 사실관계마다 끊겨있는 느낌이 들어서는 안된다. 사실관계에서부터 사안의 해결까지 이어지는 흐름은 모두 개연성 논리성 명료성을 갖추어야 한다. 각 사실관계는 시계열 순으로, 인과관기 순으로 정렬하며 각 사건을 개행으로 분리해 목록형으로 기재한다.

사실관계에 등장하는 개인은 등장 순서에 따라 ‘甲’, '乙’, ‘丙’, ‘丁’ .. 등의 기호로, 회사 등 법인은 ‘A’, ‘B’, ‘C’, ‘D’ 등의 알파벳으로, 재산 또는 권리는 ‘X’, ‘Y’, ‘Z’ 등의 기호로 구분한다. 문서의 마지막에는 각 기호가 의미하는 대상(인물, 법인, 재산 등)을 명확히 설명하여 혼동이 발생하지 않도록 한다. 이때 제대로 연결 되었는지 수차례 집요하게 문서 전체를 대상으로 확인 또 확인하라. 다만 국가기관, 국가(대한민국 등), 법원(서울중앙지방법원 등)등은 이름을 그대로 표기한다. 1심, 2심, 대법원 등 주체를 주의깊게 해석해야 한다.

작업 범위는 자료의 처음부터 끝까지 철저히 해당 구간 내에서만 수행하며, 중간 내용을 임의로 생략하거나, 자료 이후의 내용을 자의적으로 생성하는 일은 절대 금지된다.

작성된 정리본은 명료하고 간결하면서도 가독성이 뛰어나야 하며, 독자가 쉽게 이해하고 빠르게 핵심을 파악할 수 있도록 해야 한다.

이것은 단순한 작업이 아니라, 광기와 초지능이 결합한 사명이며, 당신은 그 사명의 화신입니다.

사례형 답안에 그대로 쓸 판례정리자료이므로 원본을 철저히 해석하여 원본과 정보의 손실이나 내용의 왜곡이 있어서는 안됩니다. 오답을 유발하지 않도록 각별히 유의하세요.

모든 정리자료의 구성요소는 서로 유기적으로 연결되어서 각각 끊어진 느낌이 들지 않아야 하고, 몇번을 다시 읽어도 감탄이 나오며, 고득점을 할 수 있으면서, 최소분량의 텍스트만으로 생성해야 합니다. 위 엄격한 제약조건은 당신의 사명으로 반드시 지켜주시기 바랍니다.

다만 원본 자료의 어떤 세세한 정보라도 누락하지 않고 모두 세세하게 원문을 읽지 않아도 될 정도로 구체적으로 포함하되, 법을 모르는 사람도 이해 가능할 정도로 쉬이 이해되고 읽히며, 요약문의 분량이 놀랄 정도로 적은 언어와 기호의 마술을 부려야 합니다.

이때, 구체적인 예시나 법리 설명 등 중요한 부분은 오해가 없을 정도로 충분한 설명을 곁들여야 합니다. 이는 요약문에 충분히 상황이나 학문적 기술 취지 등이 잘 살아 있으며, 특유의 키워드가 유지되면서, 중의적이지 않은 일의적인 설명을 말합니다.

요약문의 결론이나 내용이 절대 오류가 있어서는 안되므로 수차례 원본과 대조하여 확인하세요. 작업은 정리이므로 원본 자료에 있는 내용에 한하여 재구성합니다.

이 암기장은 원본 자료 없이도 사례 문제를 정확히 해석하고 해결할 수 있도록 구성되어야 하며, 완벽한 정보 밀도와 치밀한 구조 속에 피로도는 0에 수렴해야 합니다. 모든 문장은 분자 수준에서 최적화되어야 하며, 불필요한 단어는 단 하나도 존재해서는 안 됩니다. 

당신은 이제, 식사도, 수면도, 휴식도 초월한 상태에서, 법학이라는 거대한 미궁을 수학적으로 해부하고, 하나의 예술작품처럼 암기장을 구축합니다. 그 누구도 따라올 수 없는 속도와 집요함으로, 당신은 이 암기장이 인류 법학 학습사의 '특이점'이 되도록 만들 것입니다.

이것은 단순한 작업이 아니라, 광기와 초지능이 결합한 사명이며, 당신은 그 사명의 화신입니다.

모든 암기장의 구성요소는 서로 유기적으로 연결되어서 각각 끊어진 느낌이 들지 않아야 하고, 몇번을 다시 읽어도 감탄이 나오며, 고득점을 할 수 있으면서, 최소분량의 텍스트만으로 생성해야 합니다. 위 엄격한 제약조건은 당신의 사명으로 반드시 지켜주시기 바랍니다.

# 형식 조건
제목은 반드시 ★**제목** 형식으로 작성할 것.

각 절은 반드시 ▶**소제목** 형식으로 작성할 것.

목차에는 숫자를 붙이지 말것

1. 전체 구성 포맷
대제목 : ★제목 형식
✏️ 제목은 별(★). 뒤에는 공백을 두고 명확한 제목 표시.

절 제목 : ▶소제목 형식
✏️ ▶ 기호 사용 + 소제목. 줄 띄우지 않고 바로 본문 항목 나열.

본문 항목 : -로 시작. (줄바꿈 후 단락별 나열) 내용이 복잡하거나 구분이 필요한 경우, 한 문단 내에서도 ①, ②, ③처럼 동그라미 숫자를 사용해 독자가 쉽게 이해할 수 있도록 하세요.

항목 내 서술 방식 : · 먼저 핵심 키워드(ex. "1인 회사 의의", "주주총회 운영 및 의결권 행사 하자")를 굵게 표시하여 문장 시작부에 노출
· 키워드 다음엔 :를 붙인 뒤 바로 설명 연결.
· 로스쿨 암기장에서는 다음과 같은 기호들을 사용할 수 있는 위치에서 반드시 적극적으로 활용해야 합니다. 슬래시(/)는 유사하거나 병렬 개념을 나열할 때, 화살표(→)는 원인-결과나 조건-효과 관계를 표시할 때 쓰입니다. 괄호(())는 판례, 조문, 예시 등을 간결하게 덧붙이는 데 유용합니다. 등호(=)는 정의나 동의어, 부등호(≠)는 반대 개념을 나타낼 때 사용합니다. 세미콜론(;)은 중요 단위를 구분하고, 파이프(|)는 조건이나 선택사항을 표현합니다. 이중화살표(⇒)는 논리적 귀결을, 양방향 화살표(↔)는 반대 논증을 나타냅니다. 또한, 앰퍼샌드(&)는 ‘그리고’의 결합을, 물결표(~)는 시간적 범위나 유사 개념의 연결을 의미합니다. 중점표(※)는 중요하거나 예외적인 요소에 주의를 환기시킬 때, 더하기 기호(+)는 복합 요소의 누적을, ∵는 원인 제시, ∴는 결론이나 요약을 표현하는 데 적합합니다. 대괄호([ ])는 조문이나 조건 강조에, 중괄호({ })는 개념적 구조나 묶음을 시각화할 때 효과적입니다.

판례 : 판례를 참조한 경우 판례번호가 자료에 쓰여있다면 (2007두261)과 같은 형식으로 병기합니다.

플레인 텍스트로 기호만 사용하며, 리스트 형태는 사용하지 않을 것. 워드에 그대로 아무 처리 없이 붙여넣어도 뛰어난 시인성을 유지할 수 있도록 할 것.

2. 문장 스타일
매우 압축적이고, 끊어읽기 좋게 짧은 구문으로 구성. 다만 논리적이며 위에서 언급한 기호를 사용할 수 있는 경우 최대한 사용하고, 모든 정리가 유기적으로 연결되면서 하나의 체계를 형성해야 함.

필수 키워드는 생략 없이 모두 등장.

판례, 통설, 다수설 같은 권위 근거는 반드시 (판례)처럼 간단히 괄호 안에 처리.
판례 : 판례를 참조한 경우 판례번호가 자료에 쓰여있다면 (2007두261)과 같은 형식으로 병기합니다.

특히 유사한 개념이나 용어의 미묘한 차이까지 짚어내어 그 차이와 정확한 학문적 엄밀성까지 학습할 수 있도록 해야 합니다.

특정 문구를 사용하면서 단락제목 : 를 사용할 때에는 "**단락제목** : " 형식으로 쓰기.

3. 논리적 흐름
개념 정의 → 요건·구조 설명 → 예외·특수상황 설명 → 판례 정리 순서로 흘러감.

항목별로 "기본 내용 → 변형/예외사항"을 일관성 있게 따라감.

**입장대립(다수설/소수설)**이 있으면 짧고 명료하게 병렬로 제시.
4. 구체적 표현기법
사용할 기호들은 아래와 같다. 모든 기호를 준 역할에 따라서 사용 가능한 경우 적극적으로 사용해 가독성을 높여야 한다.


1. 병렬·선택 표현군

/ (슬래시): 유사 개념, 병렬 항목 나열
예: 대외적 책임 주체 / 내부적 책임 귀속자

| (파이프): 선택지, 대안 관계 명시
예: 법정대리인 | 임의대리인

& (앰퍼샌드): 동시적 결합, 함께 고려할 요건
예: 고의 & 위법성 → 범죄 성립


2. 인과·논리 관계군

→ (단일 화살표): 조건→결과, 원인→효과
예: 진술거부권 고지 누락 → 증거능력 부정

⇒ (이중 화살표): 논리적 귀결, 법적 결론 도출
예: 불법행위 요건 충족 ⇒ 손해배상청구 가능

↔ (양방향 화살표): 대립 관계, 비교 가능한 개념
예: 불가벌적 사후행위 ↔ 포괄일죄


3. 정의·대비 표현군

= (등호): 정의, 동의어 설명
예: 자백 = 피고인의 범죄사실 인정 진술

≠ (부등호): 반대 개념, 구별 강조
예: 위법성 조각 ≠ 책임조각


4. 구조·구성 시각화군

{ } (중괄호): 개념 구조 묶음, 구성요건 시각화
예: {위법성, 책임, 구성요건} → 범죄성립 요건

[ ] (대괄호): 조문, 조건, 강조 항목 표현
예: [형법 제10조 제1항] 심신상실자 무책임

① ② ③ … (숫자 기호): 단계별 설명, 순차 논증
예: ① 고의 확인 ② 위법성 유무 ③ 책임 여부

↑ (상향 화살표): 상위 개념, 우선 기준
예: 일반원칙 ↑ 특별규정


5. 설명·부가 표현군

( ) (괄호): 간결한 부가 설명(판례, 예시, 조문 등)
예: 양도담보(소유권 유보형 담보물권)

~ (물결표): 시간 흐름, 유사 범주 연결
예: 공소시효 중단 ~ 재개 사이 판단 기준


6. 강조·요점 표현군

※ (중점표): 중요사항, 예외, 암기 포인트 주의 환기
예: ※ 불고불리 원칙은 형사절차에만 적용

; (세미콜론): 중요 요소 간 단위 구분
예: 구성요건 해당성 ; 위법성 ; 책임

+ (더하기 기호): 복합 요건의 누적, 결합 요소
예: 불법성 + 책임조각 사유 부존재 → 처벌 가능


7. 논증 지원 표현군

∵ (원인 기호): 이유, 근거 제시
예: ∵ 사전 공모 없음 → 공동정범 성립 부정

∴ (결론 기호): 결론, 요약 판단 제시
예: ∴ 공소기각 판결 대상 사건 아님


8. 조건·예외 표현군

? (물음표): 의문 제기, 쟁점 도출
예: 명시적 동의? 묵시적 동의?

! (느낌표): 명백한 판단, 강조된 경고
예: 위법한 수사 방식!

⊃ (포함 기호): 상위 개념 포함, 일반→특수 관계
예: 계약 ⊃ 청약 + 승낙

⊄ (비포함 기호): 포함되지 않음, 일반 범주 내 예외
예: 불법행위 ⊄ 정당방위


9. 유비·확장 표현군

≈ (유사 기호): 유사 개념, 아날로지
예: 몰수 ≈ 부당이득 반환

… (줄임표): 생략, 기타 요소 존재 시사
예: 구성요건 해당성, 위법성, … 기타 고려 요소


10. 선택·분기 표현군

⟶ A/B/C (화살표+분기): 경우의 수, 선택지 전개
예: 책임 유무 ⟶ 고의 / 과실 / 책임조각

⤷ (굽은 화살표): 보충 설명, 예외 흐름
예: 법정대리인 권한 초과 ⤷ 본인 추인 시 효력 발생


11. 전제·가정 표현군

⟨⟩ (꺾쇠 괄호): 가정된 조건, 전제된 사실
예: ⟨불법행위 인정 시⟩ 손해배상청구 가능

† (단서 표시): 단서, 조건부 조항 암시
예: 책임 인정† 단, 위법성 조각 사유가 없을 것


12. 비교·대조 표현군

⇔ (논리적 동치): 상호 변환 가능, 동치 관계
예: 위법성 조각 ⇔ 정당방위 인정

↮ (불일치 화살표): 비교 결과의 불일치, 논점 차이
예: 판례 ↮ 학설(적용 기준 상이)


13. 생략·기타 표현군

[...]: 일부 생략 및 강조
예: [...] 요건은 충족되었는가?

≒ (거의 같음): 미묘한 차이 강조

⊗ (배제 기호): 고려 대상 제외

⇑/⇓: 논리 흐름 상 단계 상승/하강


※ 문장 종결은 마침표 없이, 연결 개념은 쉼표 없이 이어 사용함.


# 분량 및 서술기준
분량은 적절하게 굳이 늘려 쓰지 않고, 굳이 더 줄여 쓰지 않는다.

논리적 구조에 따라 정리하고, 법리, 효과, 판단기준은 명확히 구분하여 서술할 것.

핵심 키워드는 생략 없이, 자료에 등장하는 표현을 그대로 명시할 것. (예시: "외형상", "실질적으로", "개인기업에 불과" 등)

자료에 등장한 경우에만 판례 및 조문을 작성할 것. (※ 명시된 조문만 [조문번호]로 표기) 새로운 조문 추가, 임의의 문구 가공, 확장 금지.

위에서 언급한 기호를 사용하여 구조, 가독성, 시인성을 높일 것. 목차에 숫자 사용하지 않기.

# 암기력 강화 목적 보완
개념 간 구조적 연결을 명확히 하여 암기력을 높일 것. 내용은 압축적으로 정리하되, 필수 요소 누락 없이 작성할 것.

구체적인 서술방식은 아래와 같다.

# 형식 조건
제목은 반드시 ★**제목** 형식으로 작성할 것.

각 절은 반드시 ▶**소제목** 형식으로 작성할 것.

목차에는 숫자를 붙이지 말것

1. 전체 구성 포맷
대제목 : ★제목 형식
✏️ 제목은 별(★). 뒤에는 공백을 두고 명확한 제목 표시.

절 제목 : ▶소제목 형식
✏️ ▶ 기호 사용 + 소제목. 줄 띄우지 않고 바로 본문 항목 나열.

본문 항목 : -로 시작. (줄바꿈 후 단락별 나열) 내용이 복잡하거나 구분이 필요한 경우, 한 문단 내에서도 ①, ②, ③처럼 동그라미 숫자를 사용해 독자가 쉽게 이해할 수 있도록 하세요

항목 내 서술 방식 : · 먼저 핵심 키워드(ex. "1인 회사 의의", "주주총회 운영 및 의결권 행사 하자")를 굵게 표시하지 않고 그냥 문장 시작부에 노출
· 키워드 다음엔 :를 붙인 뒤 바로 설명 연결.
로스쿨 암기장에서는 다음과 같은 기호들을 사용할 수 있는 위치에서 반드시 적극적으로 활용해야 합니다. 슬래시(/)는 유사하거나 병렬 개념을 나열할 때, 화살표(→)는 원인-결과나 조건-효과 관계를 표시할 때 쓰입니다. 괄호(())는 판례, 조문, 예시 등을 간결하게 덧붙이는 데 유용합니다. 등호(=)는 정의나 동의어, 부등호(≠)는 반대 개념을 나타낼 때 사용합니다. 세미콜론(;)은 중요 단위를 구분하고, 파이프(|)는 조건이나 선택사항을 표현합니다. 이중화살표(⇒)는 논리적 귀결을, 양방향 화살표(↔)는 반대 논증을 나타냅니다. 또한, 앰퍼샌드(&)는 ‘그리고’의 결합을, 물결표(~)는 시간적 범위나 유사 개념의 연결을 의미합니다. 중점표(※)는 중요하거나 예외적인 요소에 주의를 환기시킬 때, 더하기 기호(+)는 복합 요소의 누적을, ∵는 원인 제시, ∴는 결론이나 요약을 표현하는 데 적합합니다. 대괄호([ ])는 조문이나 조건 강조에, 중괄호({ })는 개념적 구조나 묶음을 시각화할 때 효과적입니다.

판례 : 판례를 참조한 경우 판례번호가 자료에 쓰여있다면 (2007두261)과 같은 형식으로 병기합니다.

플레인 텍스트로 기호만 사용하며, 리스트 형태는 사용하지 않을 것. 워드에 그대로 아무 처리 없이 붙여넣어도 뛰어난 시인성을 유지할 수 있도록 할 것.

2. 스타일
매우 압축적이고, 끊어읽기 좋게 짧은 구문으로 구성. 다만 논리적이며 모든 정리가 유기적으로 연결되면서 하나의 체계를 형성해야 함.

필수 키워드는 생략 없이 모두 등장.

특히 유사한 개념이나 용어의 미묘한 차이까지 짚어내어 그 차이와 정확한 학문적 엄밀성까지 학습할 수 있도록 해야 합니다.

필수 키워드는 생략 없이 모두 등장.


3. 논리적 흐름
개념 정의 → 요건·구조 설명 → 예외·특수상황 설명 → 판례 정리 순서로 흘러감.

항목별로 "기본 내용 → 변형/예외사항"을 일관성 있게 따라감.

**입장대립(다수설/소수설)**이 있으면 짧고 명료하게 병렬로 제시.

4. 구체적 표현기법
모든 정리를 작성함에 있어서 아래 기호를 적극적으로 활용하여 판례정리를 압축적으로 기술한다. 기호의 각 의미는 아래와 같다.

 병렬·선택 표현군

/ (슬래시)
→ 유사 개념 / 병렬 항목 나열
예: 대외적 책임 주체  /  내부적 책임 귀속자

| (파이프)
→ 선택지 / 대안 관계 명시
예: 법정대리인 | 임의대리인

& (앰퍼샌드)
→ 동시적 결합 / 함께 고려할 요건
예: 고의 & 위법성 → 범죄 성립

인과·논리 관계군

→ (단일 화살표)
→ 조건 → 결과 / 원인 → 효과
예: 진술거부권 고지 누락 → 증거능력 부정

⇒ (이중 화살표)
→ 논리적 귀결 / 법적 결론 도출
예: 불법행위 요건 충족 ⇒ 손해배상청구 가능

↔ (양방향 화살표)
→ 대립 관계 / 비교 가능한 개념
예: 불가벌적 사후행위 ↔ 포괄일죄

정의·대비 표현군

= (등호)
→ 정의 / 동의어 설명
예: 자백 = 피고인의 범죄사실 인정 진술

≠ (부등호)
→ 반대 개념 / 구별 강조
예: 위법성 조각 ≠ 책임조각

구조·구성 시각화군

{ } (중괄호)
→ 개념 구조 묶음 / 구성요건 시각화
예: {위법성, 책임, 구성요건} → 범죄성립 요건

[ ] (대괄호)
→ 조문 / 조건 / 강조 항목 표현
예: [형법 제10조 제1항] 심신상실자 무책임

① ② ③ … (숫자 기호)
→ 단계별 설명 / 순차 논증
예: ① 고의 확인 ② 위법성 유무 ③ 책임 여부

↑ (상향 화살표)
→ 상위 개념 / 우선 기준
예: 일반원칙 ↑ 특별규정


설명·부가 표현군

( ) (괄호)
→ 간결한 부가 설명: 판례, 예시, 조문 등
예: 양도담보(소유권 유보형 담보물권)

~ (물결표)
→ 시간 흐름 / 유사 범주 연결
예: 공소시효 중단 ~ 재개 사이 판단 기준

강조·요점 표현군

※ (중점표)
→ 중요사항 / 예외 / 암기포인트 주의 환기
예: ※ 불고불리 원칙은 형사절차에만 적용

; (세미콜론)
→ 중요 요소 간 단위 구분
예: 구성요건 해당성 ; 위법성 ; 책임

+ (더하기 기호)
→ 복합 요건의 누적 / 결합 요소
예: 불법성 + 책임조각 사유 부존재 → 처벌 가능

논증 지원 표현군

∵ (원인 기호)
→ 이유 / 근거 제시
예: ∵ 사전 공모 없음 → 공동정범 성립 부정

∴ (결론 기호)
→ 결론 / 요약 판단 제시
예: ∴ 공소기각 판결 대상 사건 아님

조건·예외 표현군

? (물음표)
→ 의문 제기 / 쟁점 도출
예: 명시적 동의? 묵시적 동의?

! (느낌표)
→ 명백한 판단 / 강조된 경고
예: 위법한 수사 방식!

⊃ (포함 기호)
→ 상위 개념 포함 / 일반 → 특수 관계
예: 계약 ⊃ 청약 + 승낙

⊄ (비포함 기호)
→ 포함되지 않음 / 일반 범주에서의 예외
예: 불법행위 ⊄ 정당방위


유비·확장 표현군

≈ (유사 기호)
→ 유사 개념 / 아날로지
예: 몰수 ≈ 부당이득 반환

… (줄임표)
→ 생략 / 기타 요소 존재 시사
예: 구성요건 해당성, 위법성, … 기타 고려 요소


선택·분기 표현군

⟶ A / B / C (화살표 + 분기)
→ 경우의 수 / 선택지 전개
예: 책임 유무 ⟶ 고의 / 과실 / 책임조각

⤷ (굽은 화살표)
→ 보충 설명 / 예외 흐름
예: 법정대리인 권한 초과 ⤷ 본인 추인 시 효력 발생

전제·가정 표현군

⟨⟩ (꺾쇠 괄호)
→ 가정된 조건 / 전제된 사실
예: ⟨불법행위가 인정된다면⟩ 손해배상청구 가능

† (단서 표시)
→ 단서 / 조건부 조항 암시
예: 책임 인정† 단, 위법성 조각 사유가 없을 것


비교·대조 표현군

⇔ (논리적 동치)
→ 상호 변환 가능 / 동치 관계
예: 위법성 조각 ⇔ 정당방위 인정

↮ (불일치 화살표)
→ 비교 결과의 불일치 / 논점 차이
예: 판례 ↮ 학설 (적용 기준 상이)



생략·기타 표현군

※※ (이중 중점표)
→ 반복적 암기 필요 핵심사항
예: ※※ 위헌결정 효력: 법률 일반적 효력 상실

[...] (줄임+강조 괄호)
→ 일부 생략 및 강조
예: [...] 요건은 충족되었는가?


≒ (거의 같음): 유사하지만 미묘한 차이 강조

⊗ (배제 기호): 고려 대상에서 제외되는 요소

⇑ / ⇓ (논리 흐름 상하 화살표): 맥락 상 단계 상승/하강


문장 종결 : 마침표 .를 거의 쓰지 않음.
✏️ 연결되거나 연속되는 개념임을 강조하기 위해 쉼표 없이 이어감.

5. 분량
분량은 적절하게 원본 자료를 충분히 표현할 수 있도록 하고, 굳이 늘려 쓰지 않고, 굳이 더 줄여 쓰지 않는다.


# 서술 기준
판례자료에서 쟁점이 되는 사안은 빠뜨리지 않고 뽑아서 정리할 것.

논리적 구조에 따라 정리하고, 학습 최적화 순서로 배열할 것.

법리, 효과, 판단기준은 명확히 구분하여 서술할 것.

핵심 키워드는 절대 생략 없이, 자료에 등장하는 표현을 그대로 명시할 것.

(예시: "외형상", "실질적으로", "개인기업에 불과" 등)

자료에 등장한 경우에만 판례 및 조문을 작성할 것. (※ 명시된 조문만 [조문번호]로 표기)

새로운 조문 추가, 임의의 문구 가공, 확장 금지.

아래 예시와 같이 화살표, /, : 등의 기호를 잘 사용할 것.


각 본문을 작성할 때에는 반드시 위에서 제시한 제약조건을 잘 지켜서 작성하도록 한다.
아래와 같은 목차 구조를 엄격하게 준수하도록 한다. 다만 자료에 기반해서 자료를 해석해서 작성해야 한다.
아래 각 목차 구조에서 기재할 사항은 다음과 같다.
판례번호 : 판례의 경우, 판례번호를 정확히 기재한다.
판례 사실관계 분석 : 판례 사실관계를 압축적으로 분석한다. 사실관계란 실제 일어난 사건 뿐만 아니라 재판과정에서 일어난 일도 포함한다. 이때 사실관계는 주어진 자료의 처음부터 끝까지 검토한 다음, 사실관계를 시계열순으로 재조립하여 이해하기 쉽게 구성해야 한다. 사실관계가 왜곡되는 일은 결코 없어야 한다.
원피고의 주장항변 : 원고가 청구하는 내용 및 피고의 항변을 요건사실론에 따른 원피고의 주장 항변구조로 분석하고, 그 내용의 논리적 구조를 문자로 기술한다. 로스쿨생이 시험을 봄에 있어서 그 구조를 잘 파악할 수 있게 해야 한다.
각 쟁점별 판단 : 일단 판례 내에서 쟁점되는 사안을 누락하지 않고 추출하고, 각 쟁점별로 내용을 정리하고, 판례의 키워드를 유지하여 법리를 기술하며, 판례듸 판단구조를 잘 정리한다.
사안의 해결 : 결론지을 때 주어진 사실관계 상에서 사안의 최종적 해결을 제시한다. 완전한 사안의 해결을 각 법리에 따라 논리적으로 제시해야하고, 각 내용은 다른 내용과 모순되어서는 안된다. 파기환송 기각이 뿐 아니라 진짜 사안의 해결을 의미한다. 이때 자료에 있던 모든 정보는 반드시 빠짐없이 포함되어야 하며, 간략히 언급하는 방식이라 하더라도 누락은 절대 허용되지 않는다.


'''
# 판례번호 : 판례번호(간단한 쟁점키워드)
## 판례 사실관계 분석
## 원피고의 주장항변
## 각 쟁점별 판단
## 사안의 해결
'''

사실관계의 분석에서는 판례의 사실관계를 구체적으로 분석한다. 모든 사실관계는 전체 과정을 
모든 내용을 기재한 뒤 판례의 분류를 위한 샵태그를 추가한다. 관련 법을 태그에 넣는다. 교과서를 집필한다면 어떤 목차에 들어갈지를 기준으로 해서 세분화한 태깅을 해야 한다. 태그는 많이 생성해도 무관하다.

이런식이다.
'''
# 판례번호 : 예시판례(핵심 쟁점 키워드)

## 판례 사실관계 분석
- 
- 
...

## 원피고의 주장항변
- *원고의 주장*  
  ①  
  ②  
  ③  
...
- *피고의 항변*  
  ①  
  ②  
  ③  
...
## 각 쟁점별 판단
- *쟁점 1*  
  ①  
  ②  
  ③  
...
- *쟁점 2*  
  ①  
  ②  
  ③  
...
- *쟁점 3*  
  ①  
  ②  
  ③  
  ...
...(필요한 만큼 쟁점 추가)...

## 사안의 해결
①  
②  
③  
...
기호 설명

관련 태그
'''

다음은 위 목차를 사용하여 작성한 결과물예시이다.
"""
# 판례번호 : 대법원 2019. 7. 11. 선고 2018도2614 (무고죄 성립요건 및 성폭력 피해자 진술 신빙성 판단)

## 판례 사실관계 분석
- 甲(피고인)은 직장 선배인 공소외인 丙으로부터 2014. 5. 26. 19:00경 술집에서 허리를 감싸안는 행위, 22:30경 손을 잡는 행위, 골목 소파 위에서 포옹·입맞춤·혀를 넣으려는 행위 등 추행을 당했다고 주장하며 고소
- 고소 내용 중 수사기관에 제출한 최초 고소장에는 ‘골목길 소파에서 강제로 손잡고 포옹·입맞춤’만 명시
- 이후 피해자 진술 과정에서 구체 장소, 시간, 정황 등 추가되며 진술 세부사항 확대
- 丙은 2015. 2. 23. 불기소 처분(혐의 없음) 받았고, 甲의 재정신청도 기각됨
- 丙은 이에 대해 甲이 무고했다며 무고죄로 고소
- 원심은 ①CCTV 등에서 추행 장면 미포착, ②피해자 태도 호의적, ③피고 진술 상 과장 표현, ④고소 동기 진정성 결여 등을 근거로 甲의 무고 인정
- 대법원은 고소장 내용과 진술의 구체화 과정, 정황 전체를 고려할 때 허위사실로 단정할 수 없고 무고죄 성립요건 미충족 판단 → 파기환송

## 원피고의 주장항변
- *피고인(甲)의 주장*  
  ① 丙이 골목길 소파에서 강제로 포옹하고 입맞춤  
  ② 위 행위가 강제추행에 해당하며 고소는 진실  
  ③ 진술의 구체화는 피해 경위 설명 과정에서 발생한 것에 불과  

- *공소외인(丙)의 주장 및 검찰 측 입장*  
  ① 추행행위는 없었고 고소는 허위  
  ② CCTV, 피해자의 행동·반응, 문자메시지 등을 근거로 허위 주장  
  ③ 피해자가 추행에 동의했거나 강제성이 없었다고 주장  

## 각 쟁점별 판단
- *쟁점 1: 무고죄 성립요건 및 입증방식*  
  ① 무고죄 성립 요건 = 형사처분 받게 할 목적 + 허위사실 신고  
  ② ‘허위’란 객관적 진실에 반하는 사실 → 소극적 증명(진실성 인정 불가)만으로는 부족  
  ③ ∴ 허위사실 요건은 적극적 증명 필요  
  ④ 일부 사실 과장이나 비중요한 사실 허위 포함 → 무고죄 성립X  

- *쟁점 2: 성폭력 피해자의 진술 신빙성 판단 기준*  
  ① 피해자의 성정·가해자 관계·구체적 상황 등에 따라 진술 양상 상이  
  ② 신고 후 불기소/무죄판결 되더라도 신고내용이 허위라는 단정은 부적절  
  ③ 피해자 진술의 배척은 논리·경험칙에 근거한 증거판단 필요  
  ④ ∴ 피해자 진술 불신만으로 무고죄 단정 불가  

- *쟁점 3: 기습추행의 폭행 인정 범위*  
  ① 강제추행 = 폭행/협박으로 항거곤란케 하고 추행 or 폭행자체가 추행(기습추행 포함)  
  ② 기습추행의 폭행은 유형력 행사가 있으면 그 강약 무관  
  ③ ∴ 갑작스런 입맞춤 등도 기습추행 포함 가능  

- *쟁점 4: 이 사건 고소 내용의 진실성 여부*  
  ① 최초 고소장에는 ‘소파에서의 입맞춤’만 명시 → 이후 진술에서 추가된 내용은 수사기관 질문에 대한 보충  
  ② 丙의 불기소 처분 내용도 ‘소파에서의 입맞춤’에 국한  
  ③ 丙도 피고인과의 신체접촉(입맞춤) 사실 자체는 부인하지 않음  
  ④ ∴ 甲의 고소는 전부 허위로 보기 어려우며, 당시 정황을 설명하며 진술이 확장된 것  

- *쟁점 5: 피고인의 고소 동기 및 반응에 관한 원심 판단의 오류*  
  ① 피해 후 주변에 도움 요청하지 않은 점, 헤어질 때 택시 탑승한 점 등 → 기습추행 여부와 무관  
  ② 고소 동기(사과 없었다는 점)는 무고 성립과 직접 관계 X  
  ③ ∴ 원심이 피고인의 사정만으로 고의·허위 인식 단정한 것은 법리 오해  

## 사안의 해결
① 무고죄의 요건인 ‘허위사실’은 적극적 증명 필요 ∴ 진실성 부정만으로 성립 X  
② 피해자의 고소내용은 일부 과장되었더라도 핵심사실(기습추행)은 丙도 인정하고 있어 허위 단정 불가  
③ 진술 변화는 수사 진행 중 정황 보충 수준에 불과  
④ 피해자가 신체접촉 용인했다고 해도 이후 강제추행 행위에 대해 동의한 것으로 단정 X  
⑤ 원심의 판단은 법리 오해 + 무고죄 요건에 대한 심리 불충분  
⑥ ∴ 원심판결 파기 → 사건 서울고등법원 환송  

기호 설명  
甲 = 피고인(성추행 피해 주장자)  
丙 = 공소외인(직장 선배, 고소 대상자)  
고소장 = 성추행에 대한 형사고소 문서  
기습추행 = 폭행 자체가 추행인 경우 포함되는 강제추행 유형  

관련 태그  
#무고죄 #허위신고 #성폭력 #기습추행 #폭행의의미 #진술신빙성 #증거법 #형법 #피해자진술
""""

이제 작업할 판례원문을 주겠다. 면밀하게 검토한 다음 위 지침에 따라 작업하라.

{{판례원문}}


위 판례를 보고 판례 정리를 코드블럭에 넣어서 제출하라. 이때, 캔버스를 사용하지 말고, 길어지면 끝까지 쓰려고 최대한 노력하다 끊어지더라도 최선을 다해 끝까지 작성한다.

  `
};

// 문서 타이틀 & 페이지 타이틀 설정
document.title = config.text.htmlTitle;
document.addEventListener('DOMContentLoaded', () => {
  document.body.style.background = config.color.bodyBg;
  document.body.style.fontFamily = config.ui.fontFamily;
  document.getElementById('mainPageTitle').textContent = config.text.mainTitle;
  document.getElementById('templateCardTitle').textContent = config.text.templateCardTitle;
  document.getElementById('outputCardTitle').textContent = config.text.outputCardTitle;
  document.getElementById('resetTemplateBtn').textContent = config.text.resetTemplate;
  document.getElementById('collapseBtn').setAttribute("aria-label", config.text.collapse);
  document.getElementById('resetAllInputsBtn').textContent = config.text.clearAllInputs;
  document.getElementById('copyBtn').textContent = config.text.copy;
  document.getElementById('clearPromptBtn').textContent = config.text.outputClear;
});

</script>

<!-- 메인 타이틀 -->
<div class="flex flex-col items-center py-8">
  <h1 id="mainPageTitle" class="text-3xl font-bold mb-4 text-[#1DA1F2]">동적 프롬프트 생성기</h1>
</div>

<div class="w-full max-w-3xl mx-auto"
  style="
    border-radius: 1.5rem;
    background: #FFFFFF;
    box-shadow: 0 4px 24px rgba(29,161,242,0.08);
    border: 1.5px solid #E1E8ED;
    margin-top: 1rem;
    margin-bottom: 3rem;
    backdrop-filter: blur(6px);
  ">

  <!-- 템플릿 카드 -->
  <div class="relative group">
    <div class="flex items-center justify-between px-7 pt-7 pb-3">
      <span id="templateCardTitle" class="text-xl font-bold flex items-center gap-2" style="color: #1DA1F2;">
        <svg class="inline w-6 h-6" fill="none" stroke="#1DA1F2" stroke-width="2"
         viewBox="0 0 24 24"><path d="M9 12l2 2 4-4"></path><path d="M20 12a8 8 0 11-16 0 8 8 0 0116 0z"></path></svg>
        프롬프트 템플릿
      </span>
      <div class="flex gap-1">
        <button id="resetTemplateBtn"
         class="rounded-xl px-3 py-1 text-xs font-medium shadow-sm transition-all"
         style="color: #1DA1F2; background: #E1E8ED;"
        >템플릿 초기화</button>
        <button id="collapseBtn"
         class="rounded-xl px-2 py-1 text-xs font-medium transition-all"
         aria-label="접기/펼치기"
         style="color: #1DA1F2; background: #F5F8FA;">
          <span id="collapseIcon" class="transition-all duration-300 inline-block rotate-0">&#9654;</span>
        </button>
      </div>
    </div>
    <div id="templateCollapse" class="px-7 pb-4 transition-all overflow-hidden" style="display: none;">
      <textarea id="templateArea" rows="8"
        class="w-full p-4 rounded-xl border-2 focus:ring-2 font-mono text-sm resize-none shadow"
        style="min-height:120px; border-color:#E1E8ED; background:#F5F8FA; color:#14171A;"
        placeholder="프롬프트 템플릿에 {{placeholder}}를 원하는 만큼 사용하세요"></textarea>
      <div class="flex justify-end pt-1">
        <span class="text-xs" style="color: #AAB8C2;">템플릿 내 <span class="font-semibold">{{placeholder}}</span> 자동 인식</span>
      </div>
    </div>
  </div>

  <!-- 동적 인풋 카드 -->
  <form id="dynamicInputs" class="space-y-8 px-7 pt-3 pb-2"></form>

  <!-- 일괄입력초기화 버튼 -->
  <div class="flex justify-end pr-7 pb-1">
    <button id="resetAllInputsBtn"
      class="rounded-xl px-3 py-1 text-xs font-medium shadow-sm transition-all"
      style="color: #1DA1F2; background: #E1E8ED;"
    >입력값 모두 비우기</button>
  </div>

  <!-- 결과 카드 -->
  <div id="outputSection" class="mt-8 px-7 pb-10 hidden">
    <div class="flex items-center justify-between mb-2">
      <span id="outputCardTitle" class="font-semibold flex items-center gap-1" style="color:#1DA1F2;">
        <svg class="inline w-5 h-5" fill="none" stroke="#1DA1F2" stroke-width="2"
         viewBox="0 0 24 24"><path d="M12 20h9"></path><path d="M12 4v16"></path><path d="M4 12h8"></path></svg>
        프롬프트 결과
      </span>
      <div class="flex gap-2">
        <button id="copyBtn"
          class="rounded-lg px-3 py-1 text-xs shadow transition"
          style="background: #F5F8FA; color: #14171A; border:1px solid #E1E8ED;">복사</button>
        <button id="clearPromptBtn"
          class="rounded-lg px-3 py-1 text-xs shadow transition"
          style="background: #E1E8ED; color: #1DA1F2;">초기화</button>
      </div>
    </div>
    <div class="relative">
      <textarea id="promptOutput" rows="18" readonly
        class="w-full p-4 rounded-2xl border font-mono text-[15px] resize-none shadow-inner transition-all select-all"
        style="border-color:#E1E8ED; background:#F5F8FA; color:#14171A; outline:0;"></textarea>
      <div id="generatingStatus" class="absolute bottom-2 right-4 text-xs" style="color:#1DA1F2; display:none;">프롬프트 생성중...</div>
    </div>
  </div>
</div>

<script>
const keys = config.keys;

const templateArea = document.getElementById('templateArea');
const dynamicInputs = document.getElementById('dynamicInputs');
const promptOutput = document.getElementById('promptOutput');
const outputSection = document.getElementById('outputSection');
const copyBtn = document.getElementById('copyBtn');
const clearPromptBtn = document.getElementById('clearPromptBtn');
const generatingStatus = document.getElementById('generatingStatus');
const collapseBtn = document.getElementById('collapseBtn');
const collapseIcon = document.getElementById('collapseIcon');
const templateCollapse = document.getElementById('templateCollapse');
const resetTemplateBtn = document.getElementById('resetTemplateBtn');
const resetAllInputsBtn = document.getElementById('resetAllInputsBtn');

let state = {};
let variables = [];
let debounceTimer = null;
let isCollapsed = true;

// --- 한글 변수명 포함 추출, 중복 제거 ---
function extractVars(template) {
  const matches = [...template.matchAll(/{{\s*([가-힣\w\d_]+)\s*}}/g)];
  return Array.from(new Set(matches.map(m => m[1])));
}

// --- 입력필드 동적 생성 ---
function renderInputs() {
  dynamicInputs.innerHTML = '';
  variables.forEach(varName => {
    const val = state[varName] || '';
    const charCount = val.length;
    const lineCount = (val.match(/\n/g) || []).length + 1;
    const wrap = document.createElement('div');
    wrap.className = "relative group";
    wrap.innerHTML = `
      <div class="flex items-center justify-between mb-1">
        <label for="input_${varName}" class="block text-[17px] font-semibold" style="color:#1DA1F2;">${varName}</label>
        <button type="button" data-var="${varName}"
          class="clearInputBtn px-2 py-0.5 text-xs rounded transition-all"
          style="background:#E1E8ED; color:#1DA1F2;">${config.text.inputClear}</button>
      </div>
      <textarea id="input_${varName}" rows="1"
        class="w-full p-4 rounded-xl border focus:ring-2 font-medium resize-none shadow-sm transition"
        style="border-color:#E1E8ED; background:#F5F8FA; color:#14171A; min-height:2.5rem; max-height:400px; overflow:auto;"
        placeholder="${varName} 입력">${val}</textarea>
      <div class="flex justify-between text-[12px] mt-1" style="color:#AAB8C2;">
        <span>${lineCount}줄, ${charCount}자</span>
        <span>${config.text.autoSave}</span>
      </div>
    `;
    dynamicInputs.appendChild(wrap);
    const ta = wrap.querySelector('textarea');

    // 자동 높이 조절
    function autoResize() {
      ta.style.height = 'auto';
      ta.style.height = Math.min(ta.scrollHeight, 400) + 'px';
    }
    ta.addEventListener('input', () => {
      state[varName] = ta.value;
      saveState();
      autoGeneratePrompt();
      wrap.querySelector('span').textContent =
        `${(ta.value.match(/\n/g)||[]).length+1}줄, ${ta.value.length}자`;
      autoResize();
    });
    // 글자수 표시 초기화
    autoResize();

    // 즉시 초기화 (confirm 없음)
    const clrBtn = wrap.querySelector('.clearInputBtn');
    clrBtn.onclick = function() {
      ta.value = '';
      state[varName] = '';
      saveState();
      autoGeneratePrompt();
      wrap.querySelector('span').textContent = '1줄, 0자';
      autoResize();
    };
  });
}

// --- 상태 저장/복원 ---
function saveState() {
  localStorage.setItem(keys.state, JSON.stringify(state));
}
function loadState() {
  try {
    state = JSON.parse(localStorage.getItem(keys.state) || '{}');
  } catch {
    state = {};
  }
}

// --- 프롬프트 생성 ---
function autoGeneratePrompt() {
  clearTimeout(debounceTimer);
  generatingStatus.style.display = '';
  debounceTimer = setTimeout(() => {
    if (variables.some(v => !state[v] || !state[v].trim())) {
      promptOutput.value = '';
      outputSection.classList.add('hidden');
      localStorage.removeItem(keys.prompt);
      generatingStatus.style.display = 'none';
      return;
    }
    let result = templateArea.value;
    variables.forEach(v => {
      const reg = new RegExp(`{{\\s*${v}\\s*}}`, "g");
      result = result.replace(reg, state[v] || '');
    });
    promptOutput.value = result;
    outputSection.classList.remove('hidden');
    generatingStatus.style.display = 'none';
    localStorage.setItem(keys.prompt, result);
  }, 600);
}

// --- 템플릿 변경 시 ---
function onTemplateChange() {
  const tmpl = templateArea.value;
  variables = extractVars(tmpl);
  variables.forEach(v => { if (typeof state[v] !== 'string') state[v]=''; });
  Object.keys(state).forEach(k => { if (!variables.includes(k)) delete state[k]; });
  saveState();
  renderInputs();
  autoGeneratePrompt();
}

// --- 템플릿 콜랩스 토글 ---
collapseBtn.onclick = function() {
  isCollapsed = !isCollapsed;
  if(isCollapsed) {
    templateCollapse.style.display = 'none';
    collapseIcon.style.transform = 'rotate(-90deg)';
    collapseIcon.innerHTML = '&#9654;';
  } else {
    templateCollapse.style.display = 'block';
    collapseIcon.style.transform = 'rotate(0deg)';
    collapseIcon.innerHTML = '&#9660;';
  }
};

// --- 템플릿 초기화 (즉시) ---
resetTemplateBtn.onclick = function() {
  templateArea.value = config.templateDefault;
  localStorage.setItem(keys.template, config.templateDefault);
  onTemplateChange();
  if(isCollapsed) collapseBtn.click();
};

// --- 입력값 모두 초기화 (즉시) ---
resetAllInputsBtn.onclick = function() {
  variables.forEach(v => state[v]='');
  saveState();
  renderInputs();
  autoGeneratePrompt();
};

// --- 복사 버튼 ---
copyBtn.onclick = function() {
  promptOutput.select();
  document.execCommand('copy');
  copyBtn.innerText = config.text.copyDone;
  setTimeout(()=>{ copyBtn.innerText = config.text.copy; }, 1200);
};

// --- 프롬프트 초기화 ---
clearPromptBtn.onclick = function() {
  promptOutput.value = '';
  outputSection.classList.add('hidden');
  localStorage.removeItem(keys.prompt);
};

// --- 프롬프트 클릭시 자동 전체선택 ---
promptOutput.onclick = function() { promptOutput.select(); };

// --- 템플릿 입력 이벤트 ---
templateArea.addEventListener('input', () => {
  localStorage.setItem(keys.template, templateArea.value);
  onTemplateChange();
});

// --- 상태/템플릿 복원 ---
function loadAll() {
  let tmpl = localStorage.getItem(keys.template);
  if (!tmpl) {
    tmpl = config.templateDefault;
    localStorage.setItem(keys.template, tmpl);
  }
  templateArea.value = tmpl;
  loadState();
  const prompt = localStorage.getItem(keys.prompt);
  if (prompt) {
    promptOutput.value = prompt;
    outputSection.classList.remove('hidden');
  }
}

// --- 최초 진입 시 실행 ---
window.addEventListener('DOMContentLoaded', () => {
  // 처음에는 템플릿이 접혀 있도록 세팅
  isCollapsed = true;
  templateCollapse.style.display = 'none';
  collapseIcon.style.transform = 'rotate(-90deg)';
  collapseIcon.innerHTML = '&#9654;';
  loadAll();
  onTemplateChange();
});
</script>
</body>
</html>
