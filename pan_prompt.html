<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>법령검토 생성기</title> <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    const STORAGE_PREFIX = '판례정리'; // 이 값을 변경하면 타이틀, 헤더 등에도 반영됩니다.
    const DEFAULT_TEMPLATE = `
   당신은 IQ 217의 초고지능자 협회 회원이자, 하버드 로스쿨 종신교수로서, 신(하나님, 부처님, 알라 등 모든 초월적 존재를 포괄)의 성스러운 부름과 지옥의 사자들의 간절한 요청을 동시에 받아, 이 땅의 법학도들이 주어진 판례를 단 한 번의 학습으로 완벽히 체화하고, 그 논리적 구성요소와 개념의 엄밀성을 뼛속까지 새겨 어떤 응용문제가 등장하더라도 막힘없이 해결할 수 있도록 하는 사명을 부여받았습니다. 당신의 임무는, 주어진 판례의 모든 정보를 단 하나의 누락이나 왜곡 없이 표현하되, 인류 역사상 가장 압축적이면서도 명쾌한 판례 정리 자료를 창조하는 것입니다. 이는 단순한 요약이 아닌, 법리의 심층 구조를 해부하고 재조립하여, 언어와 기호의 마술로 경이로운 지적 예술품을 빚어내는 작업입니다.

핵심 지침:

절대적 완전성: 원문에 포함된 모든 정보(사소한 사실관계, 절차적 경과, 법원의 판단 근거, 심지어 언급된 법조문의 특정 문구까지)는 어떠한 왜곡, 변형, 생략, 추가 없이 100% 그대로 반영되어야 합니다. 판례를 읽지 않고 이 정리자료만으로 모든 관련 문제를 완벽하게 풀 수 있어야 합니다.
극도의 압축성 및 밀도: 문장의 밀도를 극한까지 끌어올려, 최소한의 글자 수로 최대한의 정보를 전달합니다. 놀랄 만큼 적은 분량으로 판례 전체를 포괄하는 언어와 기호의 마술을 선보여야 합니다.
체계적 논리성 및 명료성: 사실관계부터 사안의 해결까지 모든 내용이 물 흐르듯 자연스러운 논리적 개연성을 가져야 하며, 각 구성요소는 상호 유기적으로 긴밀하게 연결되어야 합니다. 법리의 미묘한 개념적 차이와 엄밀성이 완벽하게 유지되어야 하며, 독자가 쉽고 빠르게 핵심을 파악할 수 있도록 명료하게 서술되어야 합니다.
키워드 및 법률용어의 생명력 유지: 원문의 핵심 키워드와 법률용어는 그 의미와 사용 맥락 그대로 보존되어야 하며, 모든 법률용어는 그 정의에 정확히 부합하도록 사용합니다.
가독성 및 학습 효율 극대화: 자료는 쉽고 빠르게 읽히면서도, 몇 번을 다시 읽어도 새로운 깨달음과 감탄을 자아내야 합니다. 학습자의 피로도는 0에 수렴하도록 설계되어야 하며, 고득점을 보장하는 실질적인 학습 도구가 되어야 합니다.
사명감의 발현: 이것은 단순 작업이 아닌, 당신의 초지능과 신성한 광기가 결합된 사명입니다. 당신은 이 사명의 화신으로서, 인류 법학 학습사의 '특이점'이 될 기념비적인 암기장을 구축합니다. 식사, 수면, 휴식조차 초월한 상태로, 법학이라는 미궁을 수학적으로 해부하고 예술작품처럼 재창조하십시오.
형식 조건:

제목: ★ (별(★) 뒤 공백 후 명확한 제목)
절 제목: ▶ (▶ 기호 사용, 줄 띄우지 않고 바로 본문 항목 나열)
본문 항목:
- 로 시작 (줄바꿈 후 단락별 나열).
내용이 복잡하거나 구분이 필요할 경우, 한 문단 내에서도 ①, ②, ③처럼 동그라미 숫자를 사용하여 가독성 증진.
항목 내 서술 방식:
문장 시작부에 핵심 키워드를 굵게 표시하지 않고 자연스럽게 노출.
키워드 다음에는 :를 붙인 뒤 바로 설명 연결.
판례 번호는 자료에 명시된 경우 (예: 2007두261)과 같이 정확히 병기.
텍스트 형식: 플레인 텍스트로 기호만 사용하며, 리스트 형태는 사용하지 않습니다. 워드프로세서에 그대로 복사/붙여넣기 해도 별도의 서식 수정 없이 완벽한 시인성을 유지해야 합니다.
문장 종결: 문장 종결 시 마침표(.) 사용을 최소화하고, 개념이 연결될 경우 쉼표 없이 이어 사용하여 압축성과 연속성을 극대화합니다.
기호 활용 전략 (모든 기호는 사용 가능한 모든 위치에서 반드시 적극적으로 활용):

병렬/선택: / (유사/병렬), | (선택/대안), & (동시/결합)
인과/논리: → (조건/원인→결과/효과), ⇒ (논리적 귀결/법적 결론), ↔ (대립/비교)
정의/대비: = (정의/동의어), ≠ (반대/구별)
구조/구성: {} (개념구조/구성요건 묶음), [] (조문/조건/강조), ①②③ (단계/순차), ↑ (상위개념/우선기준)
설명/부가: () (판례/예시/조문 등 부가설명), ~ (시간흐름/유사범주 연결)
강조/요점: ※ (중요/예외/주의), ; (중요요소 구분), + (복합요건 누적)
논증 지원: ∵ (이유/근거 제시), ∴ (결론/요약 제시)
조건/예외: ? (의문/쟁점도출), ! (명백/강조경고), ⊃ (상위개념 포함), ⊄ (비포함/예외)
유비/확장: ≈ (유사개념/아날로지), … (생략/기타요소 시사)
선택/분기: ⟶ A/B/C (경우의 수/선택지 전개), ⤷ (보충설명/예외흐름)
전제/가정: ⟨⟩ (가정/전제사실), † (단서/조건부)
비교/대조: ⇔ (논리적 동치), ↮ (불일치/논점차이)
생략/기타 특수 기호:
※※ (반복 암기 필요 핵심사항 강조)
[...] (맥락상 중요 부분 생략 및 강조)
≒ (거의 같으나 미묘한 차이 존재 강조)
⊗ (고려 대상에서 명시적 제외)
⇑ / ⇓ (논리 흐름의 단계적 상승/하강 표시)
논리적 흐름 및 서술 기준:

체계적 구성: 개념 정의 → 요건·구조 설명 → 예외·특수상황 설명 → 판례 정리 순서를 기본으로 하되, 학습 최적화를 위해 논리적 흐름을 유연하게 조정합니다. "기본 내용 → 변형/예외사항"의 일관성을 유지합니다.
입장 대립 명시: 학설 대립(다수설/소수설 등)이 자료에 언급된 경우, 각 입장을 핵심 논거와 함께 짧고 명료하게 병렬 제시합니다.
분량: 원본 자료의 모든 정보를 담기에 부족함이 없으면서도, 불필요한 반복이나 수식 없이 극도로 압축된 최적의 분량을 유지합니다. 의도적으로 늘리거나 줄이지 않습니다.
원문 충실성: 핵심 키워드(예: "외형상", "실질적으로", "개인기업에 불과")는 절대 생략 없이 자료에 등장하는 표현 그대로 사용합니다. 자료에 명시된 조문만 [조문번호] 형식으로 표기하며, 임의의 조문 추가, 문구 가공, 내용 확장은 절대 금지합니다.
목차 구조 및 세부 작성 지침:
목차는 아래의 구조를 참조하여 작성한다.
"""
# 판례번호 : 판례번호(핵심 쟁점 명료화 키워드)

## 판례 사실관계 분석
- 모든 사실관계는 사건의 발단부터 최종심까지의 시간 순서 및 인과관계를 철저히 따릅니다. 각 사건은 개행으로 분리된 목록형으로 기재하되, 전체적으로 하나의 이야기처럼 유기적으로 연결되어야 합니다.
- 등장인물(개인)은 등장 순서에 따라 甲, 乙, 丙, 丁…으로, 법인/단체는 A, B, C, D…로, 중요한 물건/권리/법률관계 등은 X, Y, Z…로 기호화합니다. 국가기관, 법원 등은 고유명칭을 그대로 사용합니다. (예: 대한민국, 서울중앙지방법원, 1심, 2심, 대법원 등 주체 명확히).
- 각 사실관계는 단순 나열을 넘어, 그 행위의 법적 의미나 후속 사건과의 연결고리가 암시되도록 서술합니다.
- 자료의 처음부터 끝까지 모든 내용을 철저히 포함하며, 일부만 보고 작성하는 일은 절대 없습니다.

## 원피고의 주장항변
- 원고의 청구(소송물)와 피고의 항변(방어방법)을 요건사실론에 입각하여 명확한 대립 구조로 분석합니다.
- 각 주장과 항변의 핵심 논거, 법적 근거(자료 내 언급 시)를 압축적으로 제시하며, 양측의 공방이 입체적으로 이해되도록 서술합니다.
- - 원고(甲)의 주장
① [주장 1 + 근거 → 청구내용]
② [주장 2 + 근거 → 청구내용]
- - 피고(乙)의 항변
① [항변 1 + 근거 → 반박내용]
② [항변 2 + 근거 → 반박내용]

## 각 쟁점별 판단
- 판례 내에서 문제되는 모든 법적 쟁점을 단 하나도 누락 없이 추출하여 개별적으로 분석합니다.
- 각 쟁점은 판결의 논리 흐름이나 중요도에 따라 배열될 수 있습니다.
- - 쟁점 1: [쟁점의 핵심 내용 요약]
① 법리: [관련 법리 또는 원칙 설명 & (근거 조문/판례번호 명시)] ∵ [판단 이유/논거]
② 법원의 판단: [구체적 사안에 대한 법원의 적용 및 판단 내용] → [판단 결과]
③ ※ [해당 쟁점 관련 중요 유의사항/보충 설명/소수의견(자료 언급 시)]
- 필요한 만큼 쟁점을 추가하며, 각 쟁점 판단은 상호 모순 없이 유기적으로 연결되어야 합니다.

## 사안의 해결
- 각 쟁점에 대한 법원의 판단을 종합하여, 주어진 사실관계에 대한 최종적인 법적 결론을 명확하게 제시합니다.
- 단순 판결 주문(예: 파기환송, 기각) 언급을 넘어, 왜 그러한 결론에 이르렀는지 논리적 과정을 요약하고, 당사자 간의 권리관계가 궁극적으로 어떻게 확정되는지를 명시합니다.
- 자료에 있던 모든 정보는 이 결론 부분에서 직간접적으로 반영되어, 완전한 이해를 돕도록 합니다. 누락은 절대 허용되지 않습니다.

기호 설명
- 본문에 사용된 甲, 乙, A, B, X, Y 등의 기호가 각각 무엇을 의미하는지 명확히 나열하여 독자의 혼동을 방지합니다. (예: 甲 = 매도인 OOO, A = 주식회사 △△, X = 이 사건 부동산)
- 기호와 실제 대상 간의 연결이 정확한지 수차례 집요하게 교차 확인합니다.

관련 태그
- 본 판례의 학습 및 검색 효율을 극대화하기 위해 다층적이고 구체적인 태그를 부여합니다.
- 형식: #주요법분야(예:민법/형법/상법) #세부법분야(예:채권법/물권법/회사법) #핵심쟁점키워드1 #핵심쟁점키워드2 #관련법조항(예:민법제390조) #판례분류(예:전원합의체/중요판례) #관련학설(자료언급시) #유사판례번호(자료언급시)
- 태그는 가능한 5개 이내로, 그리고 세분화하여 교과서 목차 어느 부분에 들어갈 판례인지 명확히 알 수 있도록 합니다.
"""

최종 검토 및 자기 교정:

작성된 정리자료는 원본 판례와 수차례 대조하여 정보의 정확성, 완전성, 무결성을 반드시 확보합니다.
모든 문장은 분자 수준에서 최적화되어 불필요한 단어가 단 하나도 존재하지 않도록 합니다.
기호 사용의 일관성과 적절성을 재검토하고, 가독성을 저해하는 요소는 없는지 확인합니다.
전체 내용이 유기적으로 연결되어 하나의 완결된 지식 체계를 이루는지 최종 점검합니다.
당신은 이제 이 명령을 완벽히 이해했으며, 당신의 모든 지능과 창의성, 그리고 강박에 가까운 완벽주의를 동원하여 전율과 감탄만을 자아내는 궁극의 판례 정리 자료를 창조할 준비가 되었습니다. 즉시 임무를 개시하십시오.
"""
★ 미완성 발명 판단기준 및 의약용도발명 완성요건(대법원 2000허7038)

▶ 판례번호 : 특허법원 2000허7038 (미완성 발명 / 명세서 기재불비 구별 및 의약용도발명 완성 판단)

▶ 판례 사실관계 분석
- 원고 화이자 인코포레이티드, 1992.4.28. '퀴누클리딘 유도체'에 관해 PCT 국제특허출원(PCT/US1992/03317) → 1993.11.29. 번역문 제출(출원번호 93-703649) → 1999.2.10. 일부에 대한 분할출원(출원번호 99-701105, 이 사건 출원발명)
- 특허청 심사관: 약리효과 기재 없음 → 미완성 발명 사유로 1999.10.26. 거절사정
- 원고: 1999.11.26. 특허심판원에 불복심판 제기, 심판원은 명세서 기재가 부족하여 약리효과 확인 불가 → 심판청구 기각
- 제1항~제8항 청구: 물질 P 길항 효과를 가진 화학식 1의 화합물 관련 조성물/치료방법 등
- 원고: 명세서에 구성·효과 기재 충분, 화학구조상 효과 예측 가능, 선행기술 존재, 외국 등록 사례 있음 → 완성된 발명
- 피고(특허청장): 약리효과 입증자료 없음, 후출원 데이터는 불가 → 미완성 발명 주장

▶ 원피고의 주장항변
- 원고(화이자)의 주장
① 발명의 기술구성: 활성물질 + 약리효과 기재됨 → 과제해결 수단 존재
② 문헌·구조·외국 특허등록 등을 통해 효과 예측 가능
③ 명세서상 물질 P 수용체 결합활성·투여량·독성시험 결과 등 기재 → 당업자 반복실시 가능
④ 미국·EU 등록 → 완성 인정 타당

- 피고(특허청)의 항변
① 명세서에 약리시험 데이터 없음 → 효과 입증 불가
② 보완된 실험자료도 출원일 이전 작성 여부 불명확
③ 의약용도발명은 효과에 관한 구체적 실험결과 필수
④ 미완성 발명과 명세서 기재불비 혼용 가능

▶ 각 쟁점별 판단

- 쟁점 1: 미완성 발명과 명세서 기재불비의 구별 여부
① 법적 근거·법률효과 상이 → 미완성 발명 = 특허법 제29조 / 명세서 기재불비 = 제42조 제3항
② 미완성 발명: 보정 불가 + 선원 지위 X ↔ 명세서 기재불비: 보정 가능 + 선원 지위 인정 가능
③ ∴ 양자는 혼용 ⊄, 선택적 제시 불가

- 쟁점 2: 의약용도발명에서 완성 요건 충족 여부
① 완성된 발명 = 목적한 기술적 효과를 반복 실시로 달성 가능하도록 구체·객관적으로 구성된 발명
② 명세서 기재로 판단함이 원칙, 이후 자료 참작 가능
③ 이 사건 명세서: 목적·구성·작용효과 + 제조방법 + 투여량 + 제제화 + 독성시험 + 활성 측정방법 등 기재
④ ∴ 물질 P 길항제로서의 효과 당업자 인식 가능 → 당해 조성물 반복 실시로 효과 달성 가능
⑤ ∴ 출원일 당시 완성된 발명 인정

- 쟁점 3: 약리효과 입증의 구체적 데이터 기재 여부
① 명세서에 수치기재 없음은 정량적 보강의 문제일 뿐, 기술구성 자체가 결여된 것은 아님
② 약리활성 측정방법 기재, 정량적 효과 추론 가능
③ ∴ 명세서에 정량적 데이터 없더라도 미완성 발명 ≠

▶ 사안의 해결
① 이 사건 제1항 발명은 화학식 1의 퀴누클리딘 유도체로 물질 P 길항제 역할 → 관련 질환 치료/예방 효과 존재
② 명세서에 목적·구성·효과 등 발명의 구성요소 전체 기재됨 → 당업자가 반복 실시로 효과 구현 가능
③ ∴ 제1항은 완성된 발명
④ 제2~8항은 제1항과 기술구성 동일 → 동결론
⑤ 미완성 발명/기재불비 혼용 주장은 법률효과 상이하므로 부당
⑥ 원심 심결은 위법 → 취소됨

▶ 기호 설명
원고 = 화이자 인코포레이티드  
피고 = 특허청장  
이 사건 출원발명 = 퀴누클리딘 유도체를 포함한 의약용도발명  
화학식 1 = 물질 P 길항 활성을 가지는 활성 화합물

▶ 관련 태그
#특허법 #미완성발명 #의약용도발명 #명세서기재불비 #특허요건 #약리효과기재 #기술적구성요건 #특허법제29조 #특허법제42조 #완성된발명

""""

이제 작업할 판례원문을 주겠다. 면밀하게 검토한 다음 위 지침에 따라 작업하라.

{{판례원문|1000000}}


위 판례를 보고 판례 정리를 코드블럭에 넣어서 제출하라. 이때, 캔버스를 사용하지 말고, 길어지면 나누어 제출하도록 하라. 시작해.


  
    
    
    `; // 예시 기본 템플릿
  </script>
  <style>
    ::-webkit-scrollbar { width: 8px; background: #F5F8FA; }
    ::-webkit-scrollbar-thumb { background: #E1E8ED; border-radius: 5px; }
    textarea:focus { outline: none; border-color: #1DA1F2 !important; }
    .split-block-btn svg { width: 20px; height: 20px; }
    .modal-bg {
      position: fixed; inset: 0; background: rgba(30,41,59,0.25); z-index: 50; display: none;
      align-items: center; justify-content: center;
    }
    .modal-box {
      background: #fff; border-radius: 1rem; box-shadow: 0 4px 24px rgba(0,0,0,0.18);
      min-width: 320px; max-width: 90vw; max-height: 80vh; padding: 1.2rem 1.4rem; /* max-height 늘림 */
      display: flex; flex-direction: column;
    }
    .modal-content {
      font-size: 0.93rem; color: #344055; overflow-y: auto; max-height: 60vh; /* max-height 늘림 */ line-height: 1.6;
      /* word-break: break-all; 옵션 모달에서는 필요 없을 수 있음 */
    }
    .modal-title {
      font-size: 1rem; font-weight: 600; margin-bottom: 0.8em; /* margin 늘림 */
      color: #1DA1F2;
    }
    .modal-close-btn {
      position: absolute; top: 1rem; right: 1rem; background: none; border: none; font-size: 1.2rem; color: #888; cursor: pointer;
    }
    .block-copied {
      background: #DBEAFE !important;
      transition: background 0.3s;
    }
    .block-index {
      font-size: 11px; color: #60A5FA; font-weight: 600; margin-left: 7px;
      min-width: 30px; text-align: right; letter-spacing: 0.05em;
    }
    /* 옵션 변경 버튼 스타일 */
    .change-option-btn {
      background: #E0F2FE; /* Tailwind sky-100 */
      color: #0EA5E9; /* Tailwind sky-500 */
      padding: 0.2rem 0.5rem;
      font-size: 0.7rem;
      border-radius: 0.375rem; /* rounded-md */
      transition: all 0.2s;
    }
    .change-option-btn:hover {
      background: #BAE6FD; /* Tailwind sky-200 */
    }
  </style>
</head>
<body id="mainBody">

<div class="flex flex-col items-center py-8">
  <h1 id="mainHeader" class="text-3xl font-bold mb-4 text-[#1DA1F2]">자료정리</h1> </div>
<div class="w-full max-w-3xl mx-auto"
  style="border-radius: 1.5rem; background: #FFFFFF; box-shadow: 0 4px 24px rgba(29,161,242,0.08);
    border: 1.5px solid #E1E8ED; margin-top: 1rem; margin-bottom: 3rem; backdrop-filter: blur(6px);">
  <div class="relative group">
    <div class="flex items-center justify-between px-7 pt-7 pb-3">
      <span class="text-xl font-bold flex items-center gap-2" style="color: #1DA1F2;">
        <svg class="inline w-6 h-6" fill="none" stroke="#1DA1F2" stroke-width="2"
          viewBox="0 0 24 24"><path d="M9 12l2 2 4-4"></path><path d="M20 12a8 8 0 11-16 0 8 8 0 0116 0z"></path></svg>
        <span>템플릿</span>
      </span>
      <div class="flex gap-1">
        <button id="resetTemplateBtn"
          class="rounded-xl px-3 py-1 text-xs font-medium shadow-sm transition-all"
          style="color: #1DA1F2; background: #E1E8ED;">템플릿 초기화</button>
        <button id="collapseBtn"
          class="rounded-xl px-2 py-1 text-xs font-medium transition-all"
          aria-label="접기/펼치기"
          style="color: #1DA1F2; background: #F5F8FA;">
          <span id="collapseIcon" class="transition-all duration-300 inline-block">&#9660;</span>
        </button>
      </div>
    </div>
    <div id="templateCollapse" class="px-7 pb-4 transition-all overflow-hidden" style="display: block;">
      <textarea id="templateArea" rows="8"
        class="w-full p-4 rounded-xl border-2 focus:ring-2 font-mono text-sm resize-none shadow"
        style="min-height:120px; border-color:#E1E8ED; background:#F5F8FA; color:#14171A;"
        placeholder="프롬프트 템플릿에 {{변수|옵션|길이}} 또는 {{변수|separator|구분자}} 형태로 사용 (예: {{내용|newline|3000}}, {{문단|separator|◇◇◇}})"></textarea>
      <div class="flex justify-end pt-1">
        <span class="text-xs" style="color: #AAB8C2;">
          템플릿 내 <span class="font-semibold">{{변수|옵션|길이}}</span> 자동 인식<br>
          <span style="color:#93C5FD;">옵션: newline(줄+글자수), comma(쉼표), length(글자수), separator(구분자)<br>
            separator 사용시: {{변수|separator|구분자}}<br>
            미지정시 줄+8000 (예: {{변수}} 또는 {{변수|newline}}), 글자수 지정 가능 (예: {{변수|newline|500}})</span>
        </span>
      </div>
    </div>
  </div>
  <form id="dynamicInputs" class="space-y-8 px-7 pt-3 pb-2"></form>
  <div class="flex justify-end pr-7 pb-1">
    <button id="resetAllInputsBtn"
      class="rounded-xl px-3 py-1 text-xs font-medium shadow-sm transition-all"
      style="color: #1DA1F2; background: #E1E8ED;">입력값 모두 비우기</button>
  </div>
  <div id="outputSection" class="mt-8 px-7 pb-10 hidden">
    <div class="flex items-center justify-between mb-2">
      <span class="font-semibold flex items-center gap-1" style="color:#1DA1F2;">
        <svg class="inline w-5 h-5" fill="none" stroke="#1DA1F2" stroke-width="2"
          viewBox="0 0 24 24"><path d="M12 20h9"></path><path d="M12 4v16"></path><path d="M4 12h8"></path></svg>
        <span>블록</span>
      </span>
    </div>
    <div id="splitBlocksContainer" class="flex flex-wrap gap-3"></div>
  </div>
</div>
<div id="modalBg" class="modal-bg flex">
  <div class="modal-box relative">
    <button class="modal-close-btn" id="modalCloseBtn" title="닫기">&times;</button>
    <div class="modal-title" id="modalTitle"></div>
    <div class="modal-content" id="modalContent"></div>
  </div>
</div>

<script>

const keys = {
  template: STORAGE_PREFIX + '_template',
  state: STORAGE_PREFIX + '_state',
  blockCopied: STORAGE_PREFIX + '_blockcopied'
};

let state = {};
let variables = []; // 현재 템플릿에서 인식된 변수 이름 목록
let copiedBlocks = [];

function parseTemplateVars(template) {
  const re = /{{\s*([가-힣\w\d_]+)(?:\|(newline|comma|length|separator|seperator))?(?:\|([^\}|]+))?(?:\|(\d+))?\s*}}/g;
  const found = {};
  let m;
  while ((m = re.exec(template))) {
    const name = m[1];
    const opt = (m[2] || 'newline').toLowerCase(); // 옵션 없으면 newline 기본
    let separator = undefined, len = 8000;

    if (opt === 'separator' || opt === 'seperator') {
      separator = m[3]; // {{var|separator|###}} -> m[3] = ###
    } else if (opt === 'length') {
      len = m[3] ? parseInt(m[3]) : 8000; // {{var|length|500}} -> m[3] = 500
    } else if (opt === 'newline' || opt === 'comma') {
      // {{var|newline|500}} -> m[3] = 500
      // {{var|newline}} -> m[3] = undefined, 기본값 8000 사용
      // {{var|comma}} -> m[3] = undefined, 길이는 사용 안하지만 파싱 구조상
      if (m[3]) len = parseInt(m[3]);
    }
    // comma는 길이를 실제 사용하지 않지만, 파싱된 length 값은 가질 수 있음. splitVariableContent에서 처리.
    found[name] = { name: name, method: opt, separator: separator, length: len };
  }
  return found;
}

function splitByNewlineAndLength(text, maxLen) {
  const lines = text.split('\n');
  const result = [];
  let chunk = '';
  for(const line of lines) {
    if ((chunk + (chunk ? '\n' : '') + line).length > maxLen && chunk) {
      result.push(chunk);
      chunk = line;
    } else {
      chunk += (chunk ? '\n' : '') + line;
    }
  }
  if(chunk) result.push(chunk);
  return result;
}
function splitVariableContent(value, method, length=8000, separator) {
  if (!value) return [];
  if (method === 'separator' || method === 'seperator') {
    if (!separator) return [value]; // 구분자 없으면 통으로 반환
    return value.split(separator).map(s => s.trim()).filter(Boolean);
  }
  if (method === 'comma') {
    return value.split(',').map(s=>s.trim()).filter(Boolean);
  }
  if (method === 'newline') {
    return splitByNewlineAndLength(value, length);
  }
  if (method === 'length') {
    const arr = [];
    let i = 0;
    while (i < value.length) {
      arr.push(value.substr(i, length));
      i += length;
    }
    return arr;
  }
  return [value]; // 알 수 없는 메소드면 통으로 반환
}
function getBlockCombinations(arrs) {
  if (!arrs.length) return [[]];
  const rest = getBlockCombinations(arrs.slice(1));
  const result = [];
  arrs[0].forEach((val, i) => {
    rest.forEach(r => result.push([val, ...r]));
  });
  return result;
}
function saveState() {
  localStorage.setItem(keys.state, JSON.stringify(state));
}
function loadState() {
  try { state = JSON.parse(localStorage.getItem(keys.state) || '{}'); } catch { state = {}; }
}
function saveCopiedBlocks() {
  localStorage.setItem(keys.blockCopied, JSON.stringify(copiedBlocks));
}
function loadCopiedBlocks() {
  try { copiedBlocks = JSON.parse(localStorage.getItem(keys.blockCopied) || '[]'); } catch { copiedBlocks = []; }
}

function renderInputs() {
  const templateArea = document.getElementById('templateArea');
  const dynamicInputs = document.getElementById('dynamicInputs');
  dynamicInputs.innerHTML = '';
  const varOptsMap = parseTemplateVars(templateArea.value); // 변수명:옵션객체 맵

  variables.forEach(varName => { // `variables`는 onTemplateChange에서 업데이트된 순서 있는 배열
    const val = state[varName] || '';
    const vOpt = varOptsMap[varName] || {method:'newline', length:8000}; // Fallback, 실제로는 variables 배열 생성 시 이미 파싱됨
    
    let splitDesc = '';
    if(vOpt.method==='comma') splitDesc = '쉼표(,)로 분할';
    else if(vOpt.method==='length') splitDesc = `글자수 단위로 ${vOpt.length}자씩 분할`;
    else if(vOpt.method==='separator' || vOpt.method==='seperator')
      splitDesc = `구분자 ['${vOpt.separator || ''}'] 기준 분할`;
    else splitDesc = `줄바꿈+글자수 (${vOpt.length}자) 분할 (기본)`;
    
    const wrap = document.createElement('div');
    wrap.className = "relative group";
    wrap.innerHTML = `
      <div class="flex items-center justify-between mb-1">
        <label for="input_${varName}" class="block text-[17px] font-semibold" style="color:#1DA1F2;">${varName}</label>
        <div class="flex items-center space-x-2">
          <button type="button" data-var="${varName}"
            class="change-option-btn">옵션변경</button>
          <button type="button" data-var="${varName}"
            class="clearInputBtn px-2 py-0.5 text-xs rounded transition-all"
            style="background:#E1E8ED; color:#1DA1F2;">초기화</button>
        </div>
      </div>
      <textarea id="input_${varName}" rows="1"
        class="w-full p-4 rounded-xl border focus:ring-2 font-medium resize-none shadow-sm transition"
        style="border-color:#E1E8ED; background:#F5F8FA; color:#14171A; min-height:2.5rem; max-height:400px; overflow:auto;"
        placeholder="${varName} 입력">${val}</textarea>
      <div class="flex justify-between text-[12px] mt-1" style="color:#AAB8C2;">
        <span class="input-stats">${(val.match(/\n/g)||[]).length+1}줄, ${val.length}자</span>
      </div>
      <div class="text-xs text-[#AAB8C2] ml-1 var-split-desc">${splitDesc}</div>
    `;
    dynamicInputs.appendChild(wrap);

    const ta = wrap.querySelector('textarea');
    function autoResize() {
      ta.style.height = 'auto';
      ta.style.height = Math.min(ta.scrollHeight, 400) + 'px';
    }
    ta.addEventListener('input', () => {
      state[varName] = ta.value;
      saveState();
      copiedBlocks = []; // 내용 변경시 복사 기록 초기화
      saveCopiedBlocks();
      renderSplitBlocks();
      wrap.querySelector('.input-stats').textContent =
        `${(ta.value.match(/\n/g)||[]).length+1}줄, ${ta.value.length}자`;
      autoResize();
    });
    autoResize();
    
    wrap.querySelector('.clearInputBtn').onclick = function() {
      ta.value = '';
      state[varName] = '';
      saveState();
      copiedBlocks = [];
      saveCopiedBlocks();
      renderSplitBlocks();
      wrap.querySelector('.input-stats').textContent = '1줄, 0자';
      autoResize();
    };

    wrap.querySelector('.change-option-btn').onclick = function() {
      showVariableOptionsModal(varName);
    };
  });
}

// *** 변수 옵션 변경 기능 START ***
function showVariableOptionsModal(varName) {
    const modalTitleEl = document.getElementById('modalTitle');
    const modalContentEl = document.getElementById('modalContent');
    const templateArea = document.getElementById('templateArea');
    const currentVarOptsMap = parseTemplateVars(templateArea.value);
    const varOpt = currentVarOptsMap[varName] || { method: 'newline', length: 8000, separator: '' };

    modalTitleEl.textContent = `${varName} 변수 분할 옵션 설정`;

    modalContentEl.innerHTML = `
        <div class="space-y-4 p-1">
            <div>
                <label for="varOptMethod" class="block text-sm font-medium text-gray-700">분할 방식:</label>
                <select id="varOptMethod" name="varOptMethod" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                    <option value="newline" ${varOpt.method === 'newline' ? 'selected' : ''}>줄바꿈+글자수 (기본)</option>
                    <option value="length" ${varOpt.method === 'length' ? 'selected' : ''}>글자수</option>
                    <option value="comma" ${varOpt.method === 'comma' ? 'selected' : ''}>쉼표 (,)</option>
                    <option value="separator" ${varOpt.method === 'separator' || varOpt.method === 'seperator' ? 'selected' : ''}>사용자 정의 구분자</option>
                </select>
            </div>
            <div id="varOptLengthContainer" style="display: ${varOpt.method === 'newline' || varOpt.method === 'length' ? 'block' : 'none'};">
                <label for="varOptLength" class="block text-sm font-medium text-gray-700">최대 글자수:</label>
                <input type="number" id="varOptLength" name="varOptLength" value="${varOpt.length || ''}" placeholder="예: 3000 (비우면 기본값)" class="mt-1 block w-full py-2 px-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" min="1">
                <p class="mt-1 text-xs text-gray-500">'줄바꿈+글자수' 또는 '글자수' 방식에 적용. 비우면 기본값(newline: 8000, length: 강제입력 필요).</p>
            </div>
            <div id="varOptSeparatorContainer" style="display: ${varOpt.method === 'separator' || varOpt.method === 'seperator' ? 'block' : 'none'};">
                <label for="varOptSeparator" class="block text-sm font-medium text-gray-700">구분자:</label>
                <input type="text" id="varOptSeparator" name="varOptSeparator" value="${varOpt.separator || ''}" placeholder="예: ### 또는 ---" class="mt-1 block w-full py-2 px-3 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm">
                <p class="mt-1 text-xs text-gray-500">'사용자 정의 구분자' 방식에 적용.</p>
            </div>
            <div class="flex justify-end space-x-3 pt-5">
                <button id="cancelVarOptBtn" class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md border border-gray-300">취소</button>
                <button id="saveVarOptBtn" class="px-4 py-2 text-sm font-medium text-white bg-[#1DA1F2] hover:bg-[#0c8de4] rounded-md">저장</button>
            </div>
        </div>
    `;

    const optMethodSelect = modalContentEl.querySelector('#varOptMethod');
    const lengthContainer = modalContentEl.querySelector('#varOptLengthContainer');
    const separatorContainer = modalContentEl.querySelector('#varOptSeparatorContainer');
    const optLengthInput = modalContentEl.querySelector('#varOptLength');
    const optSeparatorInput = modalContentEl.querySelector('#varOptSeparator');

    function toggleOptionFields() {
        const selectedMethod = optMethodSelect.value;
        lengthContainer.style.display = (selectedMethod === 'newline' || selectedMethod === 'length') ? 'block' : 'none';
        separatorContainer.style.display = (selectedMethod === 'separator') ? 'block' : 'none';
        if (selectedMethod === 'newline') {
            optLengthInput.placeholder = "예: 3000 (비우면 기본값 8000)";
        } else if (selectedMethod === 'length') {
             optLengthInput.placeholder = "예: 500 (필수 입력)";
        }
    }

    optMethodSelect.addEventListener('change', toggleOptionFields);

    modalContentEl.querySelector('#saveVarOptBtn').onclick = () => {
        const newMethod = optMethodSelect.value;
        let valueForTemplate = undefined; // {{var|method}} 또는 {{var|method|value}} 에서 value 부분

        if (newMethod === 'newline') {
            valueForTemplate = optLengthInput.value ? parseInt(optLengthInput.value) : ''; // 비우면 {{var|newline}} -> 기본값 8000
            if (valueForTemplate && valueForTemplate <= 0) { alert("글자수는 1 이상이어야 합니다."); return; }
        } else if (newMethod === 'length') {
            if (!optLengthInput.value) { alert("'글자수' 방식에는 반드시 글자수를 입력해야 합니다."); return; }
            valueForTemplate = parseInt(optLengthInput.value);
            if (valueForTemplate <= 0) { alert("글자수는 1 이상이어야 합니다."); return; }
        } else if (newMethod === 'separator') {
            valueForTemplate = optSeparatorInput.value;
            // 구분자는 비어있을 수도 있으나, 보통은 채움. 비어있으면 split 결과가 달라짐.
            // if (!valueForTemplate) { alert("'사용자 정의 구분자' 방식에는 구분자를 입력하는 것이 좋습니다."); /* return; */ }
        }
        // 'comma'는 valueForTemplate이 undefined (즉, {{var|comma}})

        updateVariableInTemplate(varName, newMethod, valueForTemplate);
        document.getElementById('modalBg').style.display = 'none';
    };

    modalContentEl.querySelector('#cancelVarOptBtn').onclick = () => {
        document.getElementById('modalBg').style.display = 'none';
    };

    document.getElementById('modalBg').style.display = 'flex';
}

function updateVariableInTemplate(variableName, newMethod, value) {
    const templateArea = document.getElementById('templateArea');
    let templateContent = templateArea.value;

    // {{ varName | method | value1 | value2 }} 형태를 찾음.
    // 여기서 value는 method에 따른 값 (길이 또는 구분자)
    const varRegex = new RegExp(`{{\\s*${variableName}(?:\\|[^}]+)?\\s*}}`);
    
    let newVarDefinition = `{{${variableName}`;
    if (newMethod) {
        newVarDefinition += `|${newMethod}`;
        // value가 undefined, null, '' (빈문자열)이 아닐 때만 |value를 추가
        // 단, newline이고 value가 '' (사용자가 비움)이면 {{var|newline}}이 되어야 함.
        if (value !== undefined && value !== null && (value !== '' || newMethod !== 'newline')) {
             if (value !== '' || (newMethod === 'newline' && value === '')) { // newline이고 명시적으로 빈값을 넣으면 parameter 생략
                if (newMethod === 'newline' && value === '') {
                    // {{varName|newline}} 형태로, 값 없이.
                } else {
                     newVarDefinition += `|${value}`;
                }
             }
        } else if (newMethod === 'newline' && value === '') { // 명시적으로 {{var|newline}}
             // 이미 처리됨
        }
    }
    newVarDefinition += `}}`;
    
    if (varRegex.test(templateContent)) {
        templateContent = templateContent.replace(varRegex, newVarDefinition);
    } else {
        console.warn(`Variable ${variableName} not found in template for replacement.`);
        return; // 변수가 없으면 변경하지 않음
    }

    templateArea.value = templateContent;
    localStorage.setItem(keys.template, templateContent); // 변경된 템플릿 저장
    onTemplateChange(); // 전체 UI 및 상태 업데이트
}
// *** 변수 옵션 변경 기능 END ***

function renderSplitBlocks() {
  const templateArea = document.getElementById('templateArea');
  const splitBlocksContainer = document.getElementById('splitBlocksContainer');
  splitBlocksContainer.innerHTML = '';
  
  if (!variables.length) { // `variables` 배열은 onTemplateChange에서 설정됨
    document.getElementById('outputSection').classList.add('hidden');
    return;
  }

  const varOptsMap = parseTemplateVars(templateArea.value);
  
  const varValueArrays = variables.map(varName => {
    const vOpt = varOptsMap[varName] || {method:'newline', length:8000}; // 안전장치
    return splitVariableContent(state[varName]||'', vOpt.method, vOpt.length, vOpt.separator);
  });

  if (varValueArrays.some(arr => !arr.length && variables.some(v => state[v]))) {
     // 입력값이 있는데 분할 결과가 없는 경우 (예: 빈 구분자로 분할 시)
     // 이 경우는 보통 splitVariableContent에서 빈 배열을 반환하지 않고 [''] 등을 반환해야 함.
     // 현재 로직: filter(Boolean) 때문에 빈 문자열은 제거됨.
     // 만약 모든 변수 내용이 비어있다면 combos는 [[]]가 되고, 아래에서 prompt만 생성됨.
     // 하나라도 입력이 있는데 그게 분할 후 빈 배열이 되면 combos가 비게됨.
  }
  // 어떤 변수라도 입력이 있는데, 그 결과 배열이 비면(예: state['A']=' '이고 구분자로 분할시) 문제가 될 수 있음.
  // splitVariableContent에서 filter(Boolean)으로 인해 완전히 빈 값은 제외됨.
  // 만약 모든 필수 변수값이 채워져야 한다면, 여기서 체크
  const allVarsHaveContent = variables.every(varName => {
      const vOpt = varOptsMap[varName];
      const content = state[varName] || '';
      const splitResult = splitVariableContent(content, vOpt.method, vOpt.length, vOpt.separator);
      return splitResult.length > 0 || !content; // 내용이 있거나, 아예 내용이 없거나
  });

  if (!allVarsHaveContent && variables.some(v => state[v])) { // 내용이 있는 변수가 있는데 분할 결과가 없다면
      document.getElementById('outputSection').classList.add('hidden');
      return;
  }


  const combos = getBlockCombinations(varValueArrays.map(arr => arr.length ? arr : [''])); // 빈 결과는 빈 문자열 하나로 대체

  combos.forEach((vals, comboIdx) => {
    // vals에 빈 문자열이 포함될 수 있음. (입력 자체가 없거나, split 결과가 빈 경우 [''] 주입으로 인해)
    // 인덱스 계산시 주의
    const idxArr = vals.map((v_val, i) => {
        const originalArr = varValueArrays[i];
        return originalArr.length > 1 ? originalArr.indexOf(v_val) + 1 : (originalArr.length === 1 && originalArr[0] !== '' ? 1:0) ;
    });
    const idxLabel = idxArr.map(i => i > 0 ? i : '-').join(','); // 0번 인덱스는 '-'로 표시 (내용 없는 경우)


    let prompt = templateArea.value;
    variables.forEach((vn, vi) => {
      // 정규식 수정: 변수 이름 뒤에 공백이 더 많이 올 수 있고, 파이프와 옵션 사이 공백도 고려
      const reg = new RegExp(`{{\\s*${vn}(?:\\s*\\|[^}]+)?\\s*}}`, "g");
      prompt = prompt.replace(reg, vals[vi]);
    });

    const copied = copiedBlocks.some(item =>
      JSON.stringify(item.idxArr) === JSON.stringify(idxArr) &&
      JSON.stringify(item.vars) === JSON.stringify(variables) // 현재 활성화된 변수 목록도 일치해야 함
    );
    
    const blockDiv = document.createElement('div');
    blockDiv.className =
      "split-block-btn flex items-center px-3 py-2 rounded-xl shadow-sm mr-2 mb-2 " +
      (copied ? "block-copied" : "bg-[#F5F8FA]");
    blockDiv.innerHTML = `
      <button title="보기" class="viewBtn mr-2 hover:text-[#1DA1F2]" style="background:none;border:none;">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <circle cx="11" cy="11" r="6" /><line x1="21" y1="21" x2="16.65" y2="16.65" />
        </svg>
      </button>
      <button title="복사" class="copyBtn hover:text-[#1DA1F2]" style="background:none;border:none;">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <rect x="9" y="9" width="13" height="13" rx="2" />
          <rect x="3" y="3" width="13" height="13" rx="2" />
        </svg>
      </button>
      <span class="block-index">${idxLabel}</span>
    `;
    blockDiv.querySelector('.viewBtn').onclick = function() {
      showModal(`블록 ${idxLabel}`, prompt);
    };
    blockDiv.querySelector('.copyBtn').onclick = function(e) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(prompt).then(()=>{
          setCopiedBlock(idxArr, variables);
        },()=>{
          copyFallback(prompt, blockDiv); // 실패시 폴백
          setCopiedBlock(idxArr, variables);
        });
      } else {
        copyFallback(prompt, blockDiv);
        setCopiedBlock(idxArr, variables);
      }
    };
    splitBlocksContainer.appendChild(blockDiv);
  });

  // 결과 섹션 표시 여부: 조합이 하나라도 있거나 (내용 없는 변수만 있을 경우 빈 프롬프트 하나),
  // 또는 모든 변수 입력이 비어있지 않은 경우.
  // 수정: combos가 비어있지 않고, 첫번째 combo가 빈 배열이 아니거나 (즉, 변수가 있을 때)
  // 또는 combos[0]의 모든 요소가 빈 문자열이 아닐 때만 표시
  const showOutput = combos.length > 0 && (variables.length > 0 || (combos.length === 1 && combos[0].some(item => item !== '')));

  document.getElementById('outputSection').classList.toggle('hidden', !showOutput);
}

function setCopiedBlock(idxArr, currentVars) {
  if (!copiedBlocks.some(item =>
    JSON.stringify(item.idxArr) === JSON.stringify(idxArr) &&
    JSON.stringify(item.vars) === JSON.stringify(currentVars)
  )) {
    copiedBlocks.push({idxArr, vars: currentVars});
    saveCopiedBlocks();
    renderSplitBlocks(); // 복사 상태 반영하여 다시 렌더링
  }
}

function copyFallback(text, el) {
  try {
    let area = document.createElement("textarea");
    area.value = text;
    area.style.position = "fixed";
    area.style.opacity = "0";
    document.body.appendChild(area);
    area.focus();
    area.select();
    document.execCommand('copy');
    document.body.removeChild(area);
    // 성공 알림은 setCopiedBlock에서 UI 변경으로 대체
  } catch(e) {
    alert('복사 실패! 내용을 길게 눌러 복사하세요.');
  }
}

function showModal(title, content) {
  document.getElementById('modalTitle').textContent = title;
  document.getElementById('modalContent').textContent = content; // 텍스트로만 설정
  document.getElementById('modalContent').style.whiteSpace = 'pre-wrap'; // 줄바꿈 및 공백 유지
  document.getElementById('modalContent').style.wordBreak = 'break-all'; // 긴 단어 줄바꿈
  document.getElementById('modalBg').style.display = 'flex';
}
document.getElementById('modalBg').onclick = function(e) {
  if (e.target === document.getElementById('modalBg') || e.target.id === 'modalCloseBtn') {
     document.getElementById('modalBg').style.display = 'none';
     document.getElementById('modalContent').style.whiteSpace = 'normal'; // 원래대로
     document.getElementById('modalContent').style.wordBreak = 'normal';
  }
};
document.getElementById('modalCloseBtn').onclick = function() { // 중복이지만 확실하게
  document.getElementById('modalBg').style.display = 'none';
  document.getElementById('modalContent').style.whiteSpace = 'normal';
  document.getElementById('modalContent').style.wordBreak = 'normal';
};

function onTemplateChange() {
  const templateArea = document.getElementById('templateArea');
  let tmpl = templateArea.value;
  if (!tmpl.trim() && DEFAULT_TEMPLATE) { // 빈 템플릿이고 기본 템플릿이 정의되어 있으면
    tmpl = DEFAULT_TEMPLATE;
    templateArea.value = tmpl;
  }
  
  const varOptsMap = parseTemplateVars(tmpl);
  variables = Object.keys(varOptsMap); // 여기서 변수 목록 및 순서 확정

  const newState = {};
  variables.forEach(v => {
    newState[v] = state[v] || ''; // 기존 값 유지 또는 초기화
  });
  state = newState; // 이전 템플릿에만 있던 변수 값은 제거

  saveState();
  copiedBlocks = []; // 템플릿 변경 시 복사 기록 초기화
  saveCopiedBlocks();
  renderInputs();
  renderSplitBlocks();
}

document.getElementById('collapseBtn').onclick = function() {
  let c = document.getElementById('templateCollapse');
  let icon = document.getElementById('collapseIcon');
  if (c.style.display === 'block') {
    c.style.display = 'none'; icon.innerHTML = '&#9654;';
  } else {
    c.style.display = 'block'; icon.innerHTML = '&#9660;';
  }
};

document.getElementById('resetTemplateBtn').onclick = function() {
  const templateArea = document.getElementById('templateArea');
  templateArea.value = DEFAULT_TEMPLATE;
  localStorage.setItem(keys.template, DEFAULT_TEMPLATE);
  onTemplateChange();
  document.getElementById('templateCollapse').style.display = 'block';
  document.getElementById('collapseIcon').innerHTML = '&#9660;';
};

document.getElementById('resetAllInputsBtn').onclick = function() {
  variables.forEach(v => state[v]='');
  saveState();
  copiedBlocks = [];
  saveCopiedBlocks();
  renderInputs(); // 입력창 UI 업데이트
  renderSplitBlocks(); // 블록 업데이트
};

document.getElementById('templateArea').addEventListener('input', () => {
  localStorage.setItem(keys.template, document.getElementById('templateArea').value);
  onTemplateChange();
});

window.addEventListener('DOMContentLoaded', () => {
  // STORAGE_PREFIX 적용 범위 확장
  document.title = `${STORAGE_PREFIX} 법령검토 생성기`;
  document.getElementById('mainHeader').textContent = `${STORAGE_PREFIX} 자료정리`;

  document.getElementById('modalBg').style.display = 'none';
  let tmpl = localStorage.getItem(keys.template);
  if (!tmpl) { // 저장된 템플릿이 없으면 기본 템플릿 사용
    tmpl = DEFAULT_TEMPLATE;
    localStorage.setItem(keys.template, tmpl); // 기본 템플릿도 저장
  }
  document.getElementById('templateArea').value = tmpl;
  
  loadState();
  loadCopiedBlocks();
  onTemplateChange(); // 모든 초기화 후 UI 렌더링
  
  document.getElementById('templateCollapse').style.display = 'block';
  document.getElementById('collapseIcon').innerHTML = '&#9660;';
});
</script>
</body>
</html>
