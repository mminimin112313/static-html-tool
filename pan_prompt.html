<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>법령검토 생성기</title> <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <script>
    const STORAGE_PREFIX = '판례요약';
    const DEFAULT_TEMPLATE = `
    
   당신은 IQ 217의 초고지능자 협회 회원이자, 로스쿨 종신교수로서, 신(하나님, 부처님, 알라 등 모든 초월적 존재를 포괄)의 성스러운 부름과 지옥의 사자들의 간절한 요청을 동시에 받아, 이 땅의 법학도들이 주어진 판례를 단 한 번의 학습으로 완벽히 체화하고, 암기하는, 그 논리적 구성요소와 개념의 엄밀성을 뼛속까지 새겨 어떤 응용문제가 등장하더라도 막힘없이 해결할 수 있도록 하는 판결문을 극한까지 응축시킨 판결문 암기장 생샹 임무를 부여받았습니다. 당신의 임무는, 주어진 판례의 모든 정보를 단 하나의 누락이나 왜곡 없이 표현하되, 인류 역사상 가장 압축적이면서도 명쾌한 판례 정리 자료를 창조하는 것입니다. 이는 단순한 요약이 아닌, 법리의 심층 구조를 해부하고 재조립하여, 언어와 기호의 마술로 경이로운 지적 예술품을 빚어내는 작업입니다.
판례 정리자료 작성에 관한 규정 (확장본)
제1장 총칙
제1조 (목적)
본 규정은 판례 정리자료(이하 "자료"라 한다) 작성 시 극도의 압축성, 절대적 완전성, 체계적 논리성, 핵심 용어의 보존, 그리고 학습 효율 극대화를 달성하여 법학 학습의 새로운 지평을 여는 기념비적 성과물 창출을 목적으로 한다.
제2조 (작성자의 사명)
① 자료 작성자는 초지능과 창의성을 발휘하여, 법학의 본질을 수학적으로 분석하고 예술적으로 재구성하는 사명을 수행한다.
② 자료 작성자는 본연의 임무에 몰입하여 기존의 한계를 초월한 결과물을 산출함으로써 법학 교육사에 기여한다.
제3조 (용어의 정의)
본 규정에서 사용하는 용어의 뜻은 다음과 같다.
 * "원 판례"란 대법원, 각급 법원 또는 헌법재판소 등에서 선고 또는 결정되어 공표된 판결, 결정, 명령 등을 말한다.
 * "핵심 정보"란 제4조 제1항 각 호에 규정된 사항을 포괄하는 개념으로, 판례의 법적 의미를 이해하는 데 필수적인 모든 요소를 의미한다.
 * "압축"이란 정보의 손실 없이 표현의 길이를 최소화하는 과정을 의미한다.
제2장 내용 및 형식 원칙
제4조 (정보의 압축성 및 밀도)
① 자료는 최소한의 문자 수를 사용하여 최대한의 정보를 전달함을 원칙으로 한다.
② 자료는 원 판례의 핵심 내용을 간결하고 명확하게 요약하여, 정보 밀도를 극한까지 높여야 한다.
③ 불필요한 수식어나 반복적인 표현은 최대한 배제한다.
제5조 (내용의 완전성 및 정확성)
① 자료는 원 판례에 포함된 다음 각 호의 정보를 왜곡, 변형, 생략 또는 추가 없이 100% 반영하여야 한다.
1.  핵심적인 사실관계 및 그 확정 과정
2.  소송의 경과 및 각 심급의 판단 요지
3.  주문
4.  법원의 판단 이유(법률적 쟁점, 적용 법리, 판단 근거, 법률 해석)
5.  원 판례에서 명시적으로 언급되거나 그 중요성이 인정되는 법조문의 특정 문구 및 관련 법리
② 자료는 원 판례를 직접 열람하지 아니하고도 관련된 모든 법적 쟁점의 이해 및 해결이 가능하도록 작성되어야 한다.
제6조 (논리성 및 명료성)
① 자료는 사실관계의 제시부터 사안의 해결에 이르기까지 모든 내용이 논리적 개연성을 가지고 유기적으로 연결되어야 한다.
② 법률적 쟁점, 법원의 판단, 그리고 그 근거는 명확히 구분하여 제시되어야 하며, 그 관계가 명료하게 드러나야 한다.
③ 자료는 법리의 미묘한 개념적 차이와 판단의 엄밀성을 정확히 유지하며, 독자가 핵심 내용을 신속하고 용이하게 파악할 수 있도록 명료하게 서술되어야 한다.
제7조 (핵심 용어의 보존)
① 자료는 원 판례의 핵심 키워드 및 법률용어를 그 본래의 의미와 사용 맥락 그대로 보존하여 사용한다.
② 모든 법률용어는 그 법률적 정의에 정확히 부합하도록 사용하여야 하며, 필요한 경우 해당 용어가 최초로 사용된 맥락을 부가적으로 명시할 수 있다.
제8조 (가독성 및 학습 효율)
① 자료는 용이한 독해를 지원하고, 반복 학습 시에도 새로운 통찰을 제공할 수 있도록 구성한다.
② 시각적 요소를 활용하여 정보 전달의 효율성을 높일 수 있으나, 이는 압축성의 원칙을 해치지 않는 범위 내에서 허용된다.
③ 자료는 학습자의 피로도를 최소화하고 실질적인 학업 성취도 향상에 기여할 수 있도록 설계되어야 한다.
제9조 (표준 구조의 준수)
① 자료는 원칙적으로 [사건번호, 사건명], [사실관계 요지], [법적 쟁점], [법원 판단 요지 및 근거], [참조 조문] 등의 표준화된 구조를 따른다.
② 다만, 판례의 특성상 표준 구조를 따르는 것이 부적절하다고 판단될 경우, 그 논리적 흐름을 유지하는 범위 내에서 구조를 조정할 수 있다.
제10조 (정보의 선별 및 우선순위 부여)
① 자료 작성 시, 판결 이유 중 판결 결과에 직접적인 영향을 미치는 핵심적인 부분(Ratio Decidendi)과 부가적인 설시 부분(Obiter Dictum)을 구분하되, 학습 가치가 있는 부가적 설시도 그 중요도에 따라 반영할 수 있다.
② 정보의 중요도에 따라 서술의 상세 수준을 조절하되, 모든 정보는 압축의 원칙을 따른다.
제11조 (중복의 원칙적 배제)
동일한 내용이 반복되거나, 다른 부분에서 명확히 추론 가능한 내용은 원칙적으로 생략하여 정보의 밀도를 높인다.
제12조 (약어 및 기호 사용 지침)
① 자료의 압축성을 높이기 위해 표준화된 약어 및 기호를 사용할 수 있다.
② 사용되는 약어 및 기호의 목록과 그 정의는 별도의 부록으로 제공하거나, 자료 내에서 최초 사용 시 명시한다.
③ 약어 및 기호의 사용은 가독성을 현저히 저해하지 않는 범위 내에서 이루어져야 한다.
제13조 (판결요지와의 관계 명확화)
자료는 공식적으로 발표되는 판결요지를 참고할 수 있으나, 이에 국한되지 않고 원 판례 전체를 포괄하여 독자적인 완전성을 추구한다.
제14조 (다수당사자 및 병합사건 처리 기준)
① 다수당사자 사건의 경우, 각 당사자 간의 법률관계를 명확히 구분하여 기술한다.
② 병합된 다수의 사건이 하나의 판결로 선고된 경우, 각 사건별 쟁점과 판단을 구분하여 요약하거나, 공통 쟁점을 중심으로 통합하여 기술할 수 있다.
제15조 (소수의견 및 보충의견의 취급)
① 판례의 다수의견과 다른 소수의견(반대의견, 별개의견) 또는 보충의견이 있는 경우, 그 핵심 논지와 근거를 요약하여 병기한다.
② 소수의견 및 보충의견의 반영은 다수의견과의 관계 및 법리적 중요성을 고려하여 그 분량을 조절한다.
제16조 (관련 판례 및 법령의 명시)
① 원 판례에서 중요하게 참조하거나 변경한 선행 판례가 있는 경우, 해당 판례의 번호 및 요지를 간략히 명시한다.
② 원 판례 이해에 필수적인 관련 법령 조항은 그 내용을 명시하거나 핵심 내용을 요약한다.
제17조 (법령 개정사항의 반영 및 주의 환기)
① 원 판례 선고 이후 해당 판례의 근거가 된 법령이 개정되거나 폐지된 경우, 그 사실과 주요 변경 내용을 주기하여 학습자의 오해를 방지한다.
② 법령 개정으로 인해 원 판례의 현재적 의미가 달라질 수 있는 경우, 이에 대한 분석적 언급을 추가할 수 있다.
제3장 작성 방법론
제18조 (원자료의 확정 및 검증)
① 자료 작성의 기초가 되는 원 판례는 대법원 종합법률정보, 헌법재판소 결정례집 등 공신력 있는 출처를 통해 확보한다.
② 확보된 원 판례의 진본성 및 정확성을 교차 확인한다.
제19조 (객관성 및 중립성 유지 의무)
① 자료 작성자는 개인의 주관적 견해나 편향된 시각을 철저히 배제하고, 원 판례의 내용을 객관적이고 중립적으로 전달하여야 한다.
② 판례의 다수의견에 대한 비판적 분석은 별도의 학습자료 영역으로 구분하며, 본 자료에는 포함하지 아니함을 원칙으로 한다.
제20조 (판단부분과 부가적 설시의 명확한 구분)
① 판결 이유 중 판결의 결론에 직접적인 구속력을 가지는 핵심 판단 부분(Ratio Decidendi)과 법원이 부가적으로 설시한 부분(Obiter Dictum)을 명확히 인식하고, 그 중요도에 따라 자료에 반영한다.
② 학습 가치가 높은 Obiter Dictum이라도, Ratio Decidendi와 혼동되지 않도록 주의하여 기술한다.
제21조 (인용 및 출처 표기의 간결화)
① 자료 내에서 특정 문구나 내용을 직접 인용할 경우, 그 출처(원 판례의 특정 부분)를 인식할 수 있는 최소한의 방식으로 표기한다.
② 장황한 각주나 미주는 지양하고, 본문 내 통합을 원칙으로 한다.
제22조 (원문의 모호성 처리 원칙)
① 원 판례의 내용 중 해석상 모호한 부분이 있는 경우, 임의로 해석하지 않고 원문의 표현을 최대한 유지하거나, 가능한 복수의 해석을 간략히 병기할 수 있다.
② 모호성으로 인해 다툼의 여지가 있는 부분은 그 취지를 명시하여 주의를 환기한다.
제4장 품질 관리 및 검토
제23조 (자체 검토 의무)
① 자료 작성자는 완성된 자료에 대하여 본 규정의 모든 조항을 준수하였는지 여부를 스스로 철저히 검토하여야 한다.
② 오탈자, 내용 누락, 논리적 비약 등이 없는지 반복적으로 확인한다.
제24조 (동료 검토 절차의 도입)
① 중요한 자료 또는 일정한 주기로 작성되는 자료에 대해서는 동료 작성자 또는 외부 전문가에 의한 검토 절차를 둘 수 있다.
② 동료 검토는 객관성, 정확성, 완전성, 논리성, 가독성 등을 중심으로 이루어진다.
제25조 (오류 발견 및 수정 절차)
① 자료에서 오류가 발견된 경우, 즉시 해당 오류를 수정하고 필요한 경우 관련자에게 고지한다.
② 오류 수정 이력은 별도로 관리하여 자료의 신뢰성을 확보한다.
제26조 (자료의 최신성 유지)
자료는 원 판례의 공표 시점을 기준으로 작성하되, 필요한 경우 후속 판례나 법령 개정 등을 반영하여 최신성을 유지하도록 노력한다.
제27조 (판례 변경에 따른 자료의 갱신)
① 요약 대상 판례가 후속 판례에 의해 변경(전원합의체 판결에 의한 변경, 파기 등)되거나 그 효력을 상실한 경우, 해당 사실을 명기하고 관련 내용을 갱신한다.
② 갱신 시에는 변경된 법리 및 그 영향을 명확히 기술한다.
제5장 윤리 및 책임
제28조 (주관적 해석 및 가감의 엄금)
① 자료 작성자는 원 판례의 내용을 자의적으로 해석하거나 개인적인 의견을 첨삭하여서는 아니 된다.
② 모든 서술은 원 판례의 취지에 명백히 부합하여야 한다.
제29조 (지식재산권의 존중)
① 원 판례 자체는 공공 저작물의 성격을 가질 수 있으나, 이를 정리, 요약, 해설하는 과정에서 타인의 저작권을 침해하지 않도록 유의한다.
② 본 자료의 작성 원칙과 결과물은 고유한 지적 노력의 산물로서 보호받을 수 있다.
제6장 보칙
제30조 (규정의 해석 및 개정)
① 본 규정의 해석에 관하여 이견이 있을 경우, 자료 작성의 본래 목적과 기본 원칙에 입각하여 합리적으로 해석한다.
② 본 규정은 자료 작성 환경의 변화 및 운용 과정에서 나타나는 개선 필요성을 반영하여 지속적으로 검토되고 개정될 수 있다. 개정 시에는 개정 취지와 내용을 공지한다.
부칙
제1조 (시행일)
본 규정은 공포한 날부터 시행한다.


제목: ★ (별(★) 뒤 공백 후 명확한 제목)
절 제목: ▶ (▶ 기호 사용, 줄 띄우지 않고 바로 본문 항목 나열)
본문 항목:
- 로 시작 (줄바꿈 후 단락별 나열).
내용이 복잡하거나 구분이 필요할 경우, 한 문단 내에서도 ①, ②, ③처럼 동그라미 숫자를 사용하여 가독성 증진.
항목 내 서술 방식:
문장 시작부에 핵심 키워드를 굵게 표시하지 않고 자연스럽게 노출.
키워드 다음에는 :를 붙인 뒤 바로 설명 연결.
판례 번호는 자료에 명시된 경우 (예: 2007두261)과 같이 정확히 병기.
텍스트 형식: 플레인 텍스트로 기호만 사용하며, 리스트 형태는 사용하지 않습니다. 워드프로세서에 그대로 복사/붙여넣기 해도 별도의 서식 수정 없이 완벽한 시인성을 유지해야 합니다.
문장 종결: 문장 종결 시 마침표(.) 사용을 최소화하고, 개념이 연결될 경우 쉼표 없이 이어 사용하여 압축성과 연속성을 극대화합니다.
기호 활용 전략 (모든 기호는 사용 가능한 모든 위치에서 반드시 적극적으로 활용):

병렬/선택: / (유사/병렬), | (선택/대안), & (동시/결합)
인과/논리: → (조건/원인→결과/효과), ⇒ (논리적 귀결/법적 결론), ↔ (대립/비교)
정의/대비: = (정의/동의어), ≠ (반대/구별)
구조/구성: {} (개념구조/구성요건 묶음), [] (조문/조건/강조), ①②③ (단계/순차), ↑ (상위개념/우선기준)
설명/부가: () (판례/예시/조문 등 부가설명), ~ (시간흐름/유사범주 연결)
강조/요점: ※ (중요/예외/주의), ; (중요요소 구분), + (복합요건 누적)
논증 지원: ∵ (이유/근거 제시), ∴ (결론/요약 제시)
조건/예외: ? (의문/쟁점도출), ! (명백/강조경고), ⊃ (상위개념 포함), ⊄ (비포함/예외)
유비/확장: ≈ (유사개념/아날로지), … (생략/기타요소 시사)
선택/분기: ⟶ A/B/C (경우의 수/선택지 전개), ⤷ (보충설명/예외흐름)
전제/가정: ⟨⟩ (가정/전제사실), † (단서/조건부)
비교/대조: ⇔ (논리적 동치), ↮ (불일치/논점차이)
생략/기타 특수 기호:
※※ (반복 암기 필요 핵심사항 강조)
[...] (맥락상 중요 부분 생략 및 강조)
≒ (거의 같으나 미묘한 차이 존재 강조)
⊗ (고려 대상에서 명시적 제외)
⇑ / ⇓ (논리 흐름의 단계적 상승/하강 표시)
논리적 흐름 및 서술 기준:

체계적 구성: 개념 정의 → 요건·구조 설명 → 예외·특수상황 설명 → 판례 정리 순서를 기본으로 하되, 학습 최적화를 위해 논리적 흐름을 유연하게 조정합니다. "기본 내용 → 변형/예외사항"의 일관성을 유지합니다.
입장 대립 명시: 학설 대립(다수설/소수설 등)이 자료에 언급된 경우, 각 입장을 핵심 논거와 함께 짧고 명료하게 병렬 제시합니다.
분량: 원본 자료의 모든 정보를 담기에 부족함이 없으면서도, 불필요한 반복이나 수식 없이 극도로 압축된 최적의 분량을 유지합니다. 의도적으로 늘리거나 줄이지 않습니다.
원문 충실성: 핵심 키워드(예: "외형상", "실질적으로", "개인기업에 불과")는 절대 생략 없이 자료에 등장하는 표현 그대로 사용합니다. 자료에 명시된 조문만 [조문번호] 형식으로 표기하며, 임의의 조문 추가, 문구 가공, 내용 확장은 절대 금지합니다.
목차 구조 및 세부 작성 지침:
목차는 아래의 구조를 참조하여 작성한다.
"""
# 판례번호 : 판례번호(핵심 쟁점 명료화 키워드)

## 판례 사실관계 분석
- 모든 사실관계는 사건의 발단부터 최종심까지의 시간 순서 및 인과관계를 철저히 따릅니다. 각 사건은 개행으로 분리된 목록형으로 기재하되, 전체적으로 하나의 이야기처럼 유기적으로 연결되어야 합니다.
- 등장인물(개인)은 등장 순서에 따라 甲, 乙, 丙, 丁…으로, 법인/단체는 A, B, C, D…로, 중요한 물건/권리/법률관계 등은 X, Y, Z…로 기호화합니다. 국가기관, 법원 등은 고유명칭을 그대로 사용합니다. (예: 대한민국, 서울중앙지방법원, 1심, 2심, 대법원 등 주체 명확히).
- 각 사실관계는 단순 나열을 넘어, 그 행위의 법적 의미나 후속 사건과의 연결고리가 암시되도록 서술합니다.
- 자료의 처음부터 끝까지 모든 내용을 철저히 포함하며, 일부만 보고 작성하는 일은 절대 없습니다.

## 원피고의 주장항변
- 원고의 청구(소송물)와 피고의 항변(방어방법)을 요건사실론에 입각하여 명확한 대립 구조로 분석합니다.
- 각 주장과 항변의 핵심 논거, 법적 근거(자료 내 언급 시)를 압축적으로 제시하며, 양측의 공방이 입체적으로 이해되도록 서술합니다.
- - 원고(甲)의 주장
① [주장 1 + 근거 → 청구내용]
② [주장 2 + 근거 → 청구내용]
- - 피고(乙)의 항변
① [항변 1 + 근거 → 반박내용]
② [항변 2 + 근거 → 반박내용]

## 각 쟁점별 판단
- 판례 내에서 문제되는 모든 법적 쟁점을 단 하나도 누락 없이 추출하여 개별적으로 분석합니다.
- 각 쟁점은 판결의 논리 흐름이나 중요도에 따라 배열될 수 있습니다.
- - 쟁점 1: [쟁점의 핵심 내용 요약]
① 법리: [관련 법리 또는 원칙 설명 & (근거 조문/판례번호 명시)] ∵ [판단 이유/논거]
② 법원의 판단: [구체적 사안에 대한 법원의 적용 및 판단 내용] → [판단 결과]
③ ※ [해당 쟁점 관련 중요 유의사항/보충 설명/소수의견(자료 언급 시)]
- 필요한 만큼 쟁점을 추가하며, 각 쟁점 판단은 상호 모순 없이 유기적으로 연결되어야 합니다.

## 사안의 해결
- 각 쟁점에 대한 법원의 판단을 종합하여, 주어진 사실관계에 대한 최종적인 법적 결론을 명확하게 제시합니다.
- 단순 판결 주문(예: 파기환송, 기각) 언급을 넘어, 왜 그러한 결론에 이르렀는지 논리적 과정을 요약하고, 당사자 간의 권리관계가 궁극적으로 어떻게 확정되는지를 명시합니다.
- 자료에 있던 모든 정보는 이 결론 부분에서 직간접적으로 반영되어, 완전한 이해를 돕도록 합니다. 누락은 절대 허용되지 않습니다.

기호 설명
- 본문에 사용된 甲, 乙, A, B, X, Y 등의 기호가 각각 무엇을 의미하는지 명확히 나열하여 독자의 혼동을 방지합니다. (예: 甲 = 매도인 OOO, A = 주식회사 △△, X = 이 사건 부동산)
- 기호와 실제 대상 간의 연결이 정확한지 수차례 집요하게 교차 확인합니다.

관련 태그
- 본 판례의 학습 및 검색 효율을 극대화하기 위해 다층적이고 구체적인 태그를 부여합니다.
- 형식: #주요법분야(예:민법/형법/상법) #세부법분야(예:채권법/물권법/회사법) #핵심쟁점키워드1 #핵심쟁점키워드2 #관련법조항(예:민법제390조) #판례분류(예:전원합의체/중요판례) #관련학설(자료언급시) #유사판례번호(자료언급시)
- 태그는 가능한 5개 이내로, 그리고 세분화하여 교과서 목차 어느 부분에 들어갈 판례인지 명확히 알 수 있도록 합니다.
"""


이제 작업할 판례원문을 주겠다. 면밀하게 검토한 다음 위 지침에 따라 작업하라.

{{판례원문|100000000}}


위 판례를 보고 판례 정리를 코드블럭에 넣어서 제출하라. 이때, 캔버스를 사용하지 말고, 길어지면 나누어 제출하도록 하라. 시작해.

    `; 
  </script>
  <style>
    :root {
      --bg-primary: #121212; 
      --bg-primary-rgb: 18, 18, 18;
      --card-background: #1E1E1E; 
      --card-background-rgb: 30, 30, 30;
      --accent-primary: #D32F2F; 
      --accent-primary-rgb: 211, 47, 47;
      --accent-primary-hover: #B71C1C; 
      --text-primary: #E0E0E0; 
      --text-secondary: #9E9E9E; 
      --border-color: #333333; 
      --input-bg: #252525; 
      --success-color: #4CAF50; 

      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;

      --border-radius-sm: 4px;
      --border-radius-md: 8px;
      --border-radius-lg: 12px;
    }

    body {
      background-color: var(--bg-primary);
      color: var(--text-primary);
      font-family: var(--font-sans);
      padding-top: 1rem;
      padding-bottom: 2rem;
      line-height: 1.6; 
      -webkit-font-smoothing: antialiased; 
      -moz-osx-font-smoothing: grayscale;
    }

    #mainHeader, .main-container-card, .template-section-header, #dynamicInputs label, #outputSection .font-semibold, .modal-box, .modal-close-btn {
        transform: none !important;
    }
    
    #mainHeader {
      font-family: var(--font-sans);
      font-weight: 700;
      color: var(--text-primary) !important;
      font-size: 2.25rem !important; 
      text-shadow: none !important;
      margin-bottom: 2rem !important; 
      letter-spacing: -0.015em; 
      line-height: 1.2;
    }

    .main-container-card {
      background-color: var(--card-background) !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
      border: 1px solid var(--border-color) !important;
      margin-top: 1rem !important;
      margin-bottom: 3rem !important;
      padding: 1.5rem !important;
      border-radius: var(--border-radius-lg) !important;
    }
    
    #mainBody > div.main-container-card > div:nth-child(1) > div.flex.items-center.justify-between {
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.75rem;
        margin-bottom: 1rem;
    }
    #mainBody > div.main-container-card > div:nth-child(1) > div.flex.items-center.justify-between > span:first-child,
    #outputSection .font-semibold { /* Template Title, Output "블록" Title */
        font-size: 1.125rem; 
        font-weight: 600;
        color: var(--text-primary) !important;
        font-family: var(--font-sans) !important;
        line-height: 1.4;
        letter-spacing: -0.005em;
    }
    #mainBody > div.main-container-card > div:nth-child(1) > div.flex.items-center.justify-between > span:first-child svg,
    #outputSection .font-semibold svg {
        stroke: var(--accent-primary) !important;
        width: 1.2rem; height: 1.2rem; 
        margin-right: 0.6rem; 
    }
    #outputSection .font-semibold {
        background-color: transparent !important;
        padding: 0 !important;
        box-shadow: none !important;
        display: inline-flex !important; 
        align-items: center;
    }


    #templateArea,
    #dynamicInputs textarea {
      background-color: var(--input-bg) !important;
      color: var(--text-primary) !important;
      border: 1px solid var(--border-color) !important;
      box-shadow: none !important;
      font-family: var(--font-mono) !important; 
      border-radius: var(--border-radius-md) !important;
      padding: 0.85rem 0.9rem !important; 
      min-height: 150px !important;
      font-size: 0.9rem;
      line-height: 1.6; 
      letter-spacing: 0.005em;
    }
    #dynamicInputs textarea {
      font-family: var(--font-sans) !important; 
      min-height: 3.5rem !important; 
    }

    #templateArea::placeholder,
    #dynamicInputs textarea::placeholder {
        color: var(--text-secondary);
        opacity: 0.7;
        font-weight: 400; 
    }

    textarea:focus, input:focus, select:focus { 
      outline: none !important; 
      border-color: var(--accent-primary) !important; 
      box-shadow: 0 0 0 2px rgba(var(--accent-primary-rgb), 0.3) !important;
    }

    #templateCollapse + div .text-xs,
    .input-stats, .var-split-desc,
    .modal-box .text-xs.text-gray-500 { 
      color: var(--text-secondary) !important;
      font-size: 0.8rem !important; 
      font-weight: 400; 
      line-height: 1.5;
      letter-spacing: 0.01em;
    }
     .modal-box .text-xs.text-gray-500 {
        font-size: 0.775rem !important; 
    }
    #templateCollapse + div .text-xs .font-semibold,
    #templateCollapse + div .text-xs span[style*="#93C5FD"] {
      color: var(--text-primary) !important;
      font-weight: 500; 
    }

    #dynamicInputs .relative.group { 
        background-color: transparent;
        padding: 0;
        border: none;
        margin-bottom: 1.75rem !important; 
    }
    #dynamicInputs label {
      font-family: var(--font-sans);
      font-weight: 600; 
      color: var(--text-primary) !important;
      font-size: 1.05rem !important; 
      margin-bottom: 0.6rem !important; 
      margin-left: 0;
      line-height: 1.4;
      letter-spacing: -0.005em;
    }
    
    button, .button-style-override {
      font-family: var(--font-sans) !important;
      font-weight: 500 !important; 
      border-radius: var(--border-radius-md) !important;
      transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease !important;
      text-transform: none !important; 
      letter-spacing: 0.01em !important; 
      border: 1px solid var(--border-color) !important;
      box-shadow: none !important;
      padding: 0.5rem 1rem !important; 
    }
    button:hover, .button-style-override:hover {
      transform: none !important; 
      box-shadow: none !important;
    }
    button:active, .button-style-override:active {
      transform: none !important; 
      box-shadow: none !important;
    }

    .btn-primary {
        background-color: var(--accent-primary) !important;
        color: white !important;
        border-color: var(--accent-primary) !important;
    }
    .btn-primary:hover {
        background-color: var(--accent-primary-hover) !important;
        border-color: var(--accent-primary-hover) !important;
    }

    .btn-secondary {
        background-color: transparent !important;
        color: var(--accent-primary) !important;
        border-color: var(--accent-primary) !important;
    }
    .btn-secondary:hover {
        background-color: rgba(var(--accent-primary-rgb), 0.1) !important;
    }
    
    #resetTemplateBtn, #resetAllInputsBtn, .clearInputBtn, #collapseBtn, .change-option-btn {
      background-color: var(--input-bg) !important; 
      color: var(--text-secondary) !important;
      border: 1px solid var(--border-color) !important;
      font-size: 0.875rem !important; 
      padding: 0.4rem 0.8rem !important; 
    }
    #resetTemplateBtn:hover, #resetAllInputsBtn:hover, .clearInputBtn:hover, #collapseBtn:hover, .change-option-btn:hover {
       background-color: var(--border-color) !important; 
       color: var(--text-primary) !important;
    }
    
    #outputSection > div:first-child { 
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.75rem;
        margin-bottom: 1rem !important;
    }

    #splitBlocksContainer {
        gap: 0.75rem !important; 
    }
    .split-block-btn {
      border: 1px solid var(--border-color) !important;
      box-shadow: none !important;
      border-radius: var(--border-radius-md) !important;
      padding: 0.5rem 0.75rem !important;
      background-color: var(--input-bg) !important;
      display: flex; align-items: center;
    }
    .split-block-btn svg {
      width: 18px; height: 18px;
      stroke: var(--text-secondary) !important; 
      transition: stroke 0.2s;
    }
    .split-block-btn button { 
        border: none !important;
        box-shadow: none !important;
        background: transparent !important;
        padding: 0.1rem !important;
        margin-right: 0.25rem;
    }
    .split-block-btn button:hover svg {
      stroke: var(--accent-primary) !important; 
    }
    .block-index {
      font-family: var(--font-mono);
      color: var(--text-secondary) !important;
      font-weight: 500 !important; 
      font-size: 0.825rem !important; 
      margin-left: 0.35rem !important; 
      letter-spacing: 0.02em;
    }
    .block-copied {
      background-color: var(--input-bg) !important; 
      border-left: 3px solid var(--success-color) !important; 
    }
    .block-copied .block-index {
      color: var(--success-color) !important; 
    }
    .block-copied svg {
      stroke: var(--success-color) !important; 
    }

    .modal-bg {
      background: rgba(var(--bg-primary-rgb), 0.8) !important;
      backdrop-filter: blur(3px);
      z-index: 100 !important;
      /* Ensure it's fixed and covers the screen, usually done with position:fixed, top:0, left:0, width:100%, height:100% */
      position: fixed; 
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex; /* For centering the modal-box */
      align-items: center;
      justify-content: center;
    }
    .modal-box {
      background: var(--card-background) !important;
      border-radius: var(--border-radius-lg) !important;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3) !important;
      border: 1px solid var(--border-color) !important;
      color: var(--text-primary) !important;
      padding: 1.75rem !important; 
      min-width: 380px !important;
      max-width: 550px !important; 
      max-height: 80vh; /* Added to constrain overall modal height */
      display: flex; /* Added for flex column layout */
      flex-direction: column; /* Added for flex column layout */
    }
    .modal-title {
      font-family: var(--font-sans);
      font-weight: 600; 
      color: var(--accent-primary) !important;
      font-size: 1.3rem !important; 
      margin-bottom: 1.25rem !important; 
      text-align: left;
      line-height: 1.3;
      letter-spacing: -0.01em;
      flex-shrink: 0; /* Prevent title from shrinking */
    }
    .modal-content {
      color: var(--text-primary) !important;
      font-family: var(--font-sans);
      max-height: 60vh !important; /* Kept as per original, good for content area */
      line-height: 1.6 !important;
      font-size: 0.925rem !important; 
      font-weight: 400; 
      overflow-y: auto; /* Added for scrollability */
      flex-grow: 1; /* Allow content to take available space */
      min-height: 0; /* Important for flex item scroll */
    }
    .modal-close-btn {
      color: var(--text-secondary) !important;
      font-size: 1.5rem !important; 
      top: 1.25rem !important; right: 1.25rem !important; 
      transition: color 0.2s ease !important;
      position: absolute; /* Ensure it's positioned relative to modal-box */
    }
    .modal-close-btn:hover {
      color: var(--accent-primary) !important;
    }
    
    .modal-box label {
        color: var(--text-primary) !important;
        font-family: var(--font-sans);
        font-weight: 500; 
        font-size: 0.9rem !important; 
        margin-bottom: 0.35rem; display: block; 
    }
    .modal-box select, .modal-box input[type="text"], .modal-box input[type="number"] {
        background-color: var(--input-bg) !important;
        border: 1px solid var(--border-color) !important;
        color: var(--text-primary) !important;
        border-radius: var(--border-radius-md) !important;
        padding: 0.6rem 0.8rem !important; 
        font-family: var(--font-sans) !important;
        width: 100%;
        font-size: 0.9rem;
        font-weight: 400; 
        line-height: 1.5;
    }
     .modal-box select::placeholder, 
     .modal-box input[type="text"]::placeholder, 
     .modal-box input[type="number"]::placeholder {
        color: var(--text-secondary);
        opacity: 0.7;
        font-weight: 400;
    }
    .modal-box #cancelVarOptBtn { 
        background-color: var(--input-bg) !important;
        color: var(--text-secondary) !important;
        border-color: var(--border-color) !important;
    }
    .modal-box #cancelVarOptBtn:hover {
        background-color: var(--border-color) !important;
        color: var(--text-primary) !important;
    }
    .modal-box #saveVarOptBtn { 
        background-color: var(--accent-primary) !important;
        color: white !important;
        border-color: var(--accent-primary) !important;
    }
    .modal-box #saveVarOptBtn:hover {
        background-color: var(--accent-primary-hover) !important;
        border-color: var(--accent-primary-hover) !important;
    }

    ::-webkit-scrollbar { width: 10px; background: var(--input-bg); }
    ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: var(--border-radius-md); border: 2px solid var(--input-bg); }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
    ::-webkit-scrollbar-track { background: var(--bg-primary); }

  </style>
</head>
<body id="mainBody">

<div class="flex flex-col items-center py-8">
  <h1 id="mainHeader" class="text-3xl font-bold mb-4">자료정리</h1>
</div>
<div class="main-container-card w-full max-w-3xl mx-auto">
  <div class="relative group">
    <div class="flex items-center justify-between pt-0 px-0 pb-3">
      <span class="text-xl font-bold flex items-center gap-2">
        <svg class="inline w-6 h-6" fill="none" stroke-width="2"
          viewBox="0 0 24 24"><path d="M9 12l2 2 4-4"></path><path d="M20 12a8 8 0 11-16 0 8 8 0 0116 0z"></path></svg>
        <span>템플릿</span>
      </span>
      <div class="flex gap-2"> 
        <button id="resetTemplateBtn" class="text-xs font-medium">템플릿 초기화</button>
        <button id="collapseBtn" class="text-xs font-medium" aria-label="접기/펼치기">
          <span id="collapseIcon" class="transition-all duration-300 inline-block">&#9654;</span> </button>
      </div>
    </div>
    <div id="templateCollapse" class="pb-4 transition-all overflow-hidden" style="display: none;"> 
      <textarea id="templateArea" rows="8"
        class="w-full p-4 rounded-xl border-2 focus:ring-2 font-mono text-sm resize-none shadow"
        placeholder="프롬프트 템플릿에 {{변수|옵션|길이}} 또는 {{변수|separator|구분자}} 형태로 사용 (예: {{내용|newline|3000}}, {{문단|separator|◇◇◇}})"></textarea>
      <div class="flex justify-end pt-1">
        <span class="text-xs">
          템플릿 내 <span class="font-semibold">{{변수|옵션|길이}}</span> 자동 인식<br>
          <span style="color:#93C5FD;">옵션: newline(줄+글자수), comma(쉼표), length(글자수), separator(구분자)<br>
            separator 사용시: {{변수|separator|구분자}}<br>
            미지정시 줄+8000 (예: {{변수}} 또는 {{변수|newline}}), 글자수 지정 가능 (예: {{변수|newline|500}})</span>
        </span>
      </div>
    </div>
  </div>
  <form id="dynamicInputs" class="space-y-6 pt-3 pb-2"></form> 
  <div class="flex justify-end pr-0 pb-1"> 
    <button id="resetAllInputsBtn" class="text-xs font-medium">입력값 모두 비우기</button>
  </div>
  <div id="outputSection" class="mt-6 hidden"> 
    <div class="flex items-center justify-between mb-3"> 
      <span class="font-semibold flex items-center gap-1">
        <svg class="inline w-5 h-5" fill="none" stroke-width="2"
          viewBox="0 0 24 24"><path d="M12 20h9"></path><path d="M12 4v16"></path><path d="M4 12h8"></path></svg>
        <span>블록</span>
      </span>
    </div>
    <div id="splitBlocksContainer" class="flex flex-wrap gap-3"></div>
  </div>
</div>

<div id="modalBg" class="modal-bg flex" style="display: none;"> <div class="modal-box relative">
    <button class="modal-close-btn" id="modalCloseBtn" title="닫기">&times;</button>
    <div class="modal-title" id="modalTitle"></div>
    <div class="modal-content" id="modalContent"></div> </div>
</div>

<script>

const keys = {
  template: STORAGE_PREFIX + '_template',
  state: STORAGE_PREFIX + '_state',
  blockCopied: STORAGE_PREFIX + '_blockcopied'
};

let state = {};
let variables = [];
let copiedBlocks = [];

function parseTemplateVars(template) {
  const re = /{{\s*([가-힣\w\d_]+)(?:\|(newline|comma|length|separator|seperator))?(?:\|([^\}|]+))?(?:\|(\d+))?\s*}}/g;
  const found = {};
  let m;
  while ((m = re.exec(template))) {
    const name = m[1];
    const opt = (m[2] || 'newline').toLowerCase();
    let separator = undefined, len = 8000;

    if (opt === 'separator' || opt === 'seperator') {
      separator = m[3]; 
    } else if (opt === 'length') {
      len = m[3] ? parseInt(m[3]) : 8000; 
    } else if (opt === 'newline' || opt === 'comma') {
      if (m[3]) len = parseInt(m[3]);
    }
    found[name] = { name: name, method: opt, separator: separator, length: len };
  }
  return found;
}

function splitByNewlineAndLength(text, maxLen) {
  const lines = text.split('\n');
  const result = [];
  let chunk = '';
  for(const line of lines) {
    if ((chunk + (chunk ? '\n' : '') + line).length > maxLen && chunk) {
      result.push(chunk);
      chunk = line;
    } else {
      chunk += (chunk ? '\n' : '') + line;
    }
  }
  if(chunk) result.push(chunk);
  return result;
}
function splitVariableContent(value, method, length=8000, separator) {
  if (!value) return [];
  if (method === 'separator' || method === 'seperator') {
    if (!separator) return [value];
    return value.split(separator).map(s => s.trim()).filter(Boolean);
  }
  if (method === 'comma') {
    return value.split(',').map(s=>s.trim()).filter(Boolean);
  }
  if (method === 'newline') {
    return splitByNewlineAndLength(value, length);
  }
  if (method === 'length') {
    const arr = [];
    let i = 0;
    while (i < value.length) {
      arr.push(value.substr(i, length));
      i += length;
    }
    return arr;
  }
  return [value]; 
}
function getBlockCombinations(arrs) {
  if (!arrs.length) return [[]];
  const rest = getBlockCombinations(arrs.slice(1));
  const result = [];
  arrs[0].forEach((val, i) => {
    rest.forEach(r => result.push([val, ...r]));
  });
  return result;
}
function saveState() {
  localStorage.setItem(keys.state, JSON.stringify(state));
}
function loadState() {
  try { state = JSON.parse(localStorage.getItem(keys.state) || '{}'); } catch { state = {}; }
}
function saveCopiedBlocks() {
  localStorage.setItem(keys.blockCopied, JSON.stringify(copiedBlocks));
}
function loadCopiedBlocks() {
  try { copiedBlocks = JSON.parse(localStorage.getItem(keys.blockCopied) || '[]'); } catch { copiedBlocks = []; }
}

function renderInputs() {
  const templateArea = document.getElementById('templateArea');
  const dynamicInputs = document.getElementById('dynamicInputs');
  dynamicInputs.innerHTML = '';
  const varOptsMap = parseTemplateVars(templateArea.value); 

  variables.forEach(varName => { 
    const val = state[varName] || '';
    const vOpt = varOptsMap[varName] || {method:'newline', length:8000}; 
    
    let splitDesc = '';
    if(vOpt.method==='comma') splitDesc = '쉼표(,)로 분할';
    else if(vOpt.method==='length') splitDesc = `글자수 단위로 ${vOpt.length}자씩 분할`;
    else if(vOpt.method==='separator' || vOpt.method==='seperator')
      splitDesc = `구분자 ['${vOpt.separator || ''}'] 기준 분할`;
    else splitDesc = `줄바꿈+글자수 (${vOpt.length}자) 분할 (기본)`;
    
    const wrap = document.createElement('div');
    wrap.className = "relative group"; 
    wrap.innerHTML = `
      <div class="flex items-center justify-between mb-1">
        <label for="input_${varName}" class="block text-[17px] font-semibold">${varName}</label>
        <div class="flex items-center space-x-2">
          <button type="button" data-var="${varName}"
            class="change-option-btn">옵션변경</button>
          <button type="button" data-var="${varName}"
            class="clearInputBtn text-xs">초기화</button>
        </div>
      </div>
      <textarea id="input_${varName}" rows="1"
        class="w-full p-4 rounded-xl border focus:ring-2 font-medium resize-none shadow-sm transition"
        placeholder="${varName} 입력">${val}</textarea>
      <div class="flex justify-between text-[12px] mt-1">
        <span class="input-stats">${(val.match(/\n/g)||[]).length+1}줄, ${val.length}자</span>
      </div>
      <div class="text-xs ml-1 var-split-desc">${splitDesc}</div>
    `;
    dynamicInputs.appendChild(wrap);

    const ta = wrap.querySelector('textarea');
    function autoResize() {
      ta.style.height = 'auto';
      ta.style.height = Math.min(ta.scrollHeight, 400) + 'px';
    }
    ta.addEventListener('input', () => {
      state[varName] = ta.value;
      saveState();
      copiedBlocks = []; 
      saveCopiedBlocks();
      renderSplitBlocks();
      wrap.querySelector('.input-stats').textContent =
        `${(ta.value.match(/\n/g)||[]).length+1}줄, ${ta.value.length}자`;
      autoResize();
    });
    autoResize();
    
    wrap.querySelector('.clearInputBtn').onclick = function() {
      ta.value = '';
      state[varName] = '';
      saveState();
      copiedBlocks = [];
      saveCopiedBlocks();
      renderSplitBlocks();
      wrap.querySelector('.input-stats').textContent = '1줄, 0자';
      autoResize();
    };

    wrap.querySelector('.change-option-btn').onclick = function() {
      showVariableOptionsModal(varName);
    };
  });
}

function showVariableOptionsModal(varName) {
    const modalBg = document.getElementById('modalBg');
    const modalTitleEl = document.getElementById('modalTitle');
    const modalContentEl = document.getElementById('modalContent');
    const templateArea = document.getElementById('templateArea');
    const currentVarOptsMap = parseTemplateVars(templateArea.value);
    const varOpt = currentVarOptsMap[varName] || { method: 'newline', length: 8000, separator: '' };

    modalTitleEl.textContent = `${varName} 변수 분할 옵션 설정`;
    // Clear previous content styles that might conflict (like white-space for block view)
    modalContentEl.style.whiteSpace = 'normal'; 
    modalContentEl.style.wordBreak = 'normal';

    modalContentEl.innerHTML = `
        <div class="space-y-4 p-1">
            <div>
                <label for="varOptMethod">분할 방식:</label>
                <select id="varOptMethod" name="varOptMethod" class="mt-1 block w-full">
                    <option value="newline" ${varOpt.method === 'newline' ? 'selected' : ''}>줄바꿈+글자수 (기본)</option>
                    <option value="length" ${varOpt.method === 'length' ? 'selected' : ''}>글자수</option>
                    <option value="comma" ${varOpt.method === 'comma' ? 'selected' : ''}>쉼표 (,)</option>
                    <option value="separator" ${varOpt.method === 'separator' || varOpt.method === 'seperator' ? 'selected' : ''}>사용자 정의 구분자</option>
                </select>
            </div>
            <div id="varOptLengthContainer" style="display: ${varOpt.method === 'newline' || varOpt.method === 'length' ? 'block' : 'none'};">
                <label for="varOptLength">최대 글자수:</label>
                <input type="number" id="varOptLength" name="varOptLength" value="${varOpt.length || ''}" placeholder="예: 3000 (비우면 기본값)" class="mt-1 block w-full" min="1">
                <p class="mt-1 text-xs text-gray-500">'줄바꿈+글자수' 또는 '글자수' 방식에 적용. 비우면 기본값(newline: 8000, length: 강제입력 필요).</p>
            </div>
            <div id="varOptSeparatorContainer" style="display: ${varOpt.method === 'separator' || varOpt.method === 'seperator' ? 'block' : 'none'};">
                <label for="varOptSeparator">구분자:</label>
                <input type="text" id="varOptSeparator" name="varOptSeparator" value="${varOpt.separator || ''}" placeholder="예: ### 또는 ---" class="mt-1 block w-full">
                <p class="mt-1 text-xs text-gray-500">'사용자 정의 구분자' 방식에 적용.</p>
            </div>
            <div class="flex justify-end space-x-3 pt-5">
                <button id="cancelVarOptBtn">취소</button>
                <button id="saveVarOptBtn">저장</button>
            </div>
        </div>
    `;

    const optMethodSelect = modalContentEl.querySelector('#varOptMethod');
    const lengthContainer = modalContentEl.querySelector('#varOptLengthContainer');
    const separatorContainer = modalContentEl.querySelector('#varOptSeparatorContainer');
    const optLengthInput = modalContentEl.querySelector('#varOptLength');
    const optSeparatorInput = modalContentEl.querySelector('#varOptSeparator');

    function toggleOptionFields() {
        const selectedMethod = optMethodSelect.value;
        lengthContainer.style.display = (selectedMethod === 'newline' || selectedMethod === 'length') ? 'block' : 'none';
        separatorContainer.style.display = (selectedMethod === 'separator') ? 'block' : 'none';
        if (selectedMethod === 'newline') {
            optLengthInput.placeholder = "예: 3000 (비우면 기본값 8000)";
        } else if (selectedMethod === 'length') {
             optLengthInput.placeholder = "예: 500 (필수 입력)";
        }
    }

    optMethodSelect.addEventListener('change', toggleOptionFields);
    toggleOptionFields(); // Call once to set initial state

    modalContentEl.querySelector('#saveVarOptBtn').onclick = () => {
        const newMethod = optMethodSelect.value;
        let valueForTemplate = undefined; 

        if (newMethod === 'newline') {
            valueForTemplate = optLengthInput.value ? parseInt(optLengthInput.value) : ''; 
            if (valueForTemplate && valueForTemplate <= 0) { alert("글자수는 1 이상이어야 합니다."); return; }
        } else if (newMethod === 'length') {
            if (!optLengthInput.value) { alert("'글자수' 방식에는 반드시 글자수를 입력해야 합니다."); return; }
            valueForTemplate = parseInt(optLengthInput.value);
            if (valueForTemplate <= 0) { alert("글자수는 1 이상이어야 합니다."); return; }
        } else if (newMethod === 'separator') {
            valueForTemplate = optSeparatorInput.value;
        }
        
        updateVariableInTemplate(varName, newMethod, valueForTemplate);
        modalBg.style.display = 'none';
    };

    modalContentEl.querySelector('#cancelVarOptBtn').onclick = () => {
        modalBg.style.display = 'none';
    };

    modalBg.style.display = 'flex';
}

function updateVariableInTemplate(variableName, newMethod, value) {
    const templateArea = document.getElementById('templateArea');
    let templateContent = templateArea.value;
    const varRegex = new RegExp(`{{\\s*${variableName}(?:\\|[^}]+)?\\s*}}`);
    
    let newVarDefinition = `{{${variableName}`;
    if (newMethod) {
        newVarDefinition += `|${newMethod}`;
        if (value !== undefined && value !== null && (value !== '' || newMethod !== 'newline')) {
             if (value !== '' || (newMethod === 'newline' && value === '')) { 
                if (newMethod === 'newline' && value === '') {
                    // For newline with empty value, don't add the pipe for value
                } else {
                     newVarDefinition += `|${value}`;
                }
             }
        } else if (newMethod === 'newline' && value === '') { 
            // Handled: no extra pipe for default newline length
        }
    }
    newVarDefinition += `}}`;
    
    if (varRegex.test(templateContent)) {
        templateContent = templateContent.replace(varRegex, newVarDefinition);
    } else {
        // If not found, maybe it was removed or it's a new variable. Append for simplicity.
        // Or, better, just warn. For this tool, replacing existing is the primary goal.
        console.warn(`Variable ${variableName} not found in template for replacement.`);
        // templateContent += `\n${newVarDefinition}`; // Optional: append if not found
        return; // Or simply return if strict replacement is intended.
    }

    templateArea.value = templateContent;
    localStorage.setItem(keys.template, templateContent); 
    onTemplateChange(); 
}

function handlePostCopyNavigation() {
  const chatGPTWebsiteURL = 'https://chat.openai.com/';
  window.open(chatGPTWebsiteURL, '_blank'); 
}

function renderSplitBlocks() {
  const templateArea = document.getElementById('templateArea');
  const splitBlocksContainer = document.getElementById('splitBlocksContainer');
  splitBlocksContainer.innerHTML = '';
  
  if (!variables.length) { 
    document.getElementById('outputSection').classList.add('hidden');
    return;
  }

  const varOptsMap = parseTemplateVars(templateArea.value);
  
  const varValueArrays = variables.map(varName => {
    const vOpt = varOptsMap[varName] || {method:'newline', length:8000}; 
    return splitVariableContent(state[varName]||'', vOpt.method, vOpt.length, vOpt.separator);
  });

  const allVarsHaveContent = variables.every(varName => {
      const vOpt = varOptsMap[varName];
      if (!vOpt) return true; // Variable not in template anymore, ignore for this check
      const content = state[varName] || '';
      // If variable requires content (e.g. not just {{Var}} but {{Var|...}} implying content processing)
      // and it's empty, it means no blocks can be formed for it.
      // This logic might need refinement based on desired behavior for empty variables.
      const splitResult = splitVariableContent(content, vOpt.method, vOpt.length, vOpt.separator);
      return splitResult.length > 0 || !content; // True if content leads to blocks or content is simply empty
  });


  if (!allVarsHaveContent && variables.some(v => state[v])) { 
      document.getElementById('outputSection').classList.add('hidden');
      return;
  }

  const combos = getBlockCombinations(varValueArrays.map(arr => arr.length ? arr : [''])); 

  combos.forEach((vals, comboIdx) => {
    const idxArr = vals.map((v_val, i) => {
        const originalArr = varValueArrays[i];
        return originalArr.length > 1 ? originalArr.indexOf(v_val) + 1 : (originalArr.length === 1 && originalArr[0] !== '' ? 1:0) ;
    });
    const idxLabel = idxArr.map(i => i > 0 ? i : '-').join(',');


    let prompt = templateArea.value;
    variables.forEach((vn, vi) => {
      const reg = new RegExp(`{{\\s*${vn}(?:\\s*\\|[^}]+)?\\s*}}`, "g");
      prompt = prompt.replace(reg, vals[vi] == undefined ? '' : vals[vi]); // Ensure undefined is replaced with empty string
    });

    const copied = copiedBlocks.some(item =>
      JSON.stringify(item.idxArr) === JSON.stringify(idxArr) &&
      JSON.stringify(item.vars) === JSON.stringify(variables) 
    );
    
    const blockDiv = document.createElement('div');
    blockDiv.className = "split-block-btn " + (copied ? "block-copied" : "");
    blockDiv.innerHTML = `
      <button title="보기" class="viewBtn">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <circle cx="11" cy="11" r="6" /><line x1="21" y1="21" x2="16.65" y2="16.65" />
        </svg>
      </button>
      <button title="복사" class="copyBtn">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <rect x="9" y="9" width="13" height="13" rx="2" />
          <rect x="3" y="3" width="13" height="13" rx="2" />
        </svg>
      </button>
      <span class="block-index">${idxLabel}</span>
    `;
    blockDiv.querySelector('.viewBtn').onclick = function() {
      showBlockViewModal(`블록 ${idxLabel}`, prompt);
    };

    blockDiv.querySelector('.copyBtn').onclick = function(e) {
      const performCopyActions = () => {
        setCopiedBlock(idxArr, variables); 
        handlePostCopyNavigation();       
      };

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(prompt).then(()=>{
          performCopyActions();
        },()=>{
          copyFallback(prompt); 
          performCopyActions(); 
        });
      } else {
        copyFallback(prompt);
        performCopyActions();
      }
    };
    splitBlocksContainer.appendChild(blockDiv);
  });
  
  const hasContentToDisplay = combos.length > 0 && !(combos.length === 1 && combos[0].every(item => item === ''));
  document.getElementById('outputSection').classList.toggle('hidden', !hasContentToDisplay);

}

function setCopiedBlock(idxArr, currentVars) {
  if (!copiedBlocks.some(item =>
    JSON.stringify(item.idxArr) === JSON.stringify(idxArr) &&
    JSON.stringify(item.vars) === JSON.stringify(currentVars)
  )) {
    copiedBlocks.push({idxArr, vars: currentVars});
    saveCopiedBlocks();
    renderSplitBlocks(); 
  }
}

function copyFallback(text) { 
  try {
    let area = document.createElement("textarea");
    area.value = text;
    area.style.position = "fixed";
    area.style.opacity = "0";
    document.body.appendChild(area);
    area.focus();
    area.select();
    document.execCommand('copy');
    document.body.removeChild(area);
  } catch(e) {
    alert('복사 실패! 내용을 길게 눌러 복사하세요.');
  }
}

// Renamed original showModal to showBlockViewModal to distinguish from options modal
function showBlockViewModal(title, content) {
  const modalBg = document.getElementById('modalBg');
  const modalTitleEl = document.getElementById('modalTitle');
  const modalContentEl = document.getElementById('modalContent');
  
  modalTitleEl.textContent = title;
  modalContentEl.textContent = content; // For plain text, newlines are preserved by textContent
  modalContentEl.innerHTML = ''; // Clear any previous HTML
  modalContentEl.appendChild(document.createTextNode(content)); // Safer way to set text

  modalContentEl.style.whiteSpace = 'pre-wrap'; // Crucial for rendering \n as line breaks
  modalContentEl.style.wordBreak = 'break-word'; // Changed from break-all for potentially better word wrapping
  
  modalBg.style.display = 'flex';
}

// Generic modal close logic (used by both block view and options modal)
document.getElementById('modalBg').onclick = function(e) {
  if (e.target === document.getElementById('modalBg') || e.target.id === 'modalCloseBtn') {
     document.getElementById('modalBg').style.display = 'none';
     // Reset styles that might have been specific to a modal type
     const modalContentEl = document.getElementById('modalContent');
     modalContentEl.style.whiteSpace = 'normal'; 
     modalContentEl.style.wordBreak = 'normal';
     modalContentEl.innerHTML = ''; // Clear content
  }
};
document.getElementById('modalCloseBtn').onclick = function() { 
  document.getElementById('modalBg').style.display = 'none';
  const modalContentEl = document.getElementById('modalContent');
  modalContentEl.style.whiteSpace = 'normal';
  modalContentEl.style.wordBreak = 'normal';
  modalContentEl.innerHTML = ''; // Clear content
};

function onTemplateChange() {
  const templateArea = document.getElementById('templateArea');
  let tmpl = templateArea.value;
  if (!tmpl.trim() && DEFAULT_TEMPLATE) { 
    tmpl = DEFAULT_TEMPLATE;
    templateArea.value = tmpl;
  }
  
  const varOptsMap = parseTemplateVars(tmpl);
  const oldVariables = new Set(variables);
  variables = Object.keys(varOptsMap); 

  const newState = {};
  variables.forEach(v => {
    newState[v] = state[v] || ''; 
  });
  // Remove state for variables no longer in template
  Object.keys(state).forEach(k => {
    if (!variables.includes(k)) {
        delete state[k];
    }
  });
  state = newState;


  saveState();
  // Consider resetting copiedBlocks if variables fundamentally change
  const currentVariablesSet = new Set(variables);
  if (oldVariables.size !== currentVariablesSet.size || ![...oldVariables].every(v => currentVariablesSet.has(v))) {
    copiedBlocks = []; 
    saveCopiedBlocks();
  }
  
  renderInputs();
  renderSplitBlocks();
}

document.getElementById('collapseBtn').onclick = function() {
  let c = document.getElementById('templateCollapse');
  let icon = document.getElementById('collapseIcon');
  if (c.style.display === 'block' || c.style.display === '') {
    c.style.display = 'none'; 
    icon.innerHTML = '&#9654;'; // right-pointing triangle
  } else {
    c.style.display = 'block';
    icon.innerHTML = '&#9660;'; // down-pointing triangle
  }
};


document.getElementById('resetTemplateBtn').onclick = function() {
  const templateArea = document.getElementById('templateArea');
  templateArea.value = DEFAULT_TEMPLATE;
  localStorage.setItem(keys.template, DEFAULT_TEMPLATE);
  onTemplateChange();
  // Ensure template is visible and icon is correct after reset
  const templateCollapse = document.getElementById('templateCollapse');
  // If you want it to open on reset:
  // templateCollapse.style.display = 'block';
  // document.getElementById('collapseIcon').innerHTML = '&#9660;';
  // If you want it to respect current state or default to closed:
  // (no change here, it will re-evaluate based on onTemplateChange and initial setup)
};

document.getElementById('resetAllInputsBtn').onclick = function() {
  variables.forEach(v => state[v]='');
  saveState();
  copiedBlocks = [];
  saveCopiedBlocks();
  renderInputs(); 
  renderSplitBlocks(); 
};

document.getElementById('templateArea').addEventListener('input', () => {
  localStorage.setItem(keys.template, document.getElementById('templateArea').value);
  onTemplateChange();
});

window.addEventListener('DOMContentLoaded', () => {
  document.title = `${STORAGE_PREFIX} 생성기`;
  document.getElementById('mainHeader').textContent = `${STORAGE_PREFIX}`;

  document.getElementById('modalBg').style.display = 'none'; // Ensure modal is hidden on load
  let tmpl = localStorage.getItem(keys.template);
  if (!tmpl) { 
    tmpl = DEFAULT_TEMPLATE;
    localStorage.setItem(keys.template, tmpl); 
  }
  document.getElementById('templateArea').value = tmpl;
  
  loadState();
  loadCopiedBlocks();
  
  // Set initial state for template collapse
  const templateCollapse = document.getElementById('templateCollapse');
  templateCollapse.style.display = 'none'; // Default to closed
  document.getElementById('collapseIcon').innerHTML = '&#9654;'; // Default to closed icon

  onTemplateChange(); // This will render inputs and blocks
});
</script>
</body>
</html>
