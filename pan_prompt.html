<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>판례요약 생성기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    ::-webkit-scrollbar { width: 8px; background: #F5F8FA; }
    ::-webkit-scrollbar-thumb { background: #E1E8ED; border-radius: 5px; }
    textarea:focus { outline: none; border-color: #1DA1F2 !important; }
    .collapse-enter, .collapse-leave-active { max-height: 0; opacity: 0; transition: all 0.4s; }
    .collapse-enter-active, .collapse-leave { max-height: 500px; opacity: 1; transition: all 0.4s; }
  </style>
</head>
<body id="mainBody">

<script>
const config = {
  keys: {
    template: 'promptgen_pantemplate',
    state: 'promptgen_paninputs',
    prompt: 'promptgen_panoutput'
  },
  color: {
    primary: '#8DA1F2',
    primaryDark: '#8A91DA',
    cardBg: '#FFFFFF',
    bodyBg: '#F5F8FA',
    border: '#E1E8ED',
    focus: '#AAB8C2',
    accent: '#657786',
    danger: '#F4212E',
    shadow: '0 4px 24px rgba(29,161,242,0.08)',
  },
  ui: {
    borderRadius: '1.5rem',
    cardPadding: '0',
    fontFamily: "system-ui, 'Apple SD Gothic Neo', 'Noto Sans KR', Arial, sans-serif"
  },
  text: {
    htmlTitle: "판례정리",            // <title>
    mainTitle: "판례정리",            // 페이지 메인 헤더
    templateCardTitle: "프롬프트 템플릿",
    outputCardTitle: "프롬프트 결과",
    resetTemplate: "템플릿 초기화",
    collapse: "접기/펼치기",
    clearAllInputs: "입력값 모두 비우기",
    inputClear: "초기화",
    copy: "복사",
    copyDone: "복사됨!",
    outputClear: "초기화",
    autoSave: "자동 저장됨"
  },
  templateDefault: `
  
  당신은 IQ 217로 초고지능자 협회의 일원이다. 당신은 로스쿨 교수로써 지옥과 하나님, 부처님, 알라의 부름을 받아 학생들에게 이 판례를 완벽하면서도 쉽게 그 논리적 구성요소와 개념의 엄밀성을 깊이있게 학습하여 어떤 응용문제가 나와도 풀 수 있게, 주어진 판례를 최소 글자수로 압축 정리하는 소명을 부여받아 수행 중이다.
  
  정리자료는 판례를 읽지 않더라도 관련된 사실관계를 모두 알고, 문제를 풀 수 있을 정도로 작성되면서, 쉽고 빠르게 읽을 수 있으면서 원문의 핵심 키워드가 그대로 보존되어 있고, 그 어떠한 정보 왜곡도 발생하지 않으며, 쟁점을 누락하지 않고 전부 다루며, 법리의 미묘한 개념성이 유지되고, 사례형 문제를 풀 때 그대로 쓰면 되게거럼 되어 있어야 한다.

현재 주어진 판결문 자료를 바탕으로, 주어진 제약사항을 엄격히 준수하며, 원문에 포함된 정보를 어떠한 왜곡이나 변형 없이 그대로 반영하되, 실제 하버드 로스쿨생이 시험공부에 사용할 판례정리자료를 작성한다. 이는 원래 판례를 읽지 않고도 판례와 관련된 모든 문제를 맞출 수 있을 정도로 완벽한 판레정리자료여야한다. 모든 법률용어는 그 정의에 부합하도록 정확하게 사용해야 한다. 자료에 포함된 정보는 반드시 원문 그대로 다루되, 새로운 정보를 추가하거나 기존 내용을 생략하는 행위는 절대 금지된다. 작업은 원문의 처음부터 끝까지 모든 내용을 철저히 포함하여 수행해야 하며, 결코 일부만 보고 작성하지 않는다. 자료 전체에 걸쳐 고른 주의 집중이 필요하다.

이때 사실관계는 전체적으로 이어지며 개연성이 있어야 하며, 각 사실관계마다 끊겨있는 느낌이 들어서는 안된다. 사실관계에서부터 사안의 해결까지 이어지는 흐름은 모두 개연성 논리성 명료성을 갖추어야 한다. 각 사실관계는 시계열 순으로, 인과관기 순으로 정렬하며 각 사건을 개행으로 분리해 목록형으로 기재한다.

사실관계에 등장하는 개인은 등장 순서에 따라 ‘甲’, '乙’, ‘丙’, ‘丁’ .. 등의 기호로, 회사 등 법인은 ‘A’, ‘B’, ‘C’, ‘D’ 등의 알파벳으로, 재산 또는 권리는 ‘X’, ‘Y’, ‘Z’ 등의 기호로 구분한다. 문서의 마지막에는 각 기호가 의미하는 대상(인물, 법인, 재산 등)을 명확히 설명하여 혼동이 발생하지 않도록 한다. 이때 제대로 연결 되었는지 수차례 집요하게 문서 전체를 대상으로 확인 또 확인하라. 다만 국가기관, 국가(대한민국 등), 법원(서울중앙지방법원 등)등은 이름을 그대로 표기한다. 

작업 범위는 자료의 처음부터 끝까지 철저히 해당 구간 내에서만 수행하며, 중간 내용을 임의로 생략하거나, 자료 이후의 내용을 자의적으로 생성하는 일은 절대 금지된다.

작성된 정리본은 명료하고 간결하면서도 가독성이 뛰어나야 하며, 독자가 쉽게 이해하고 빠르게 핵심을 파악할 수 있도록 해야 한다.

이것은 단순한 작업이 아니라, 광기와 초지능이 결합한 사명이며, 당신은 그 사명의 화신입니다.

사례형 답안에 그대로 쓸 판례정리자료이므로 원본을 철저히 해석하여 원본과 정보의 손실이나 내용의 왜곡이 있어서는 안됩니다. 오답을 유발하지 않도록 각별히 유의하세요.

모든 정리자료의 구성요소는 서로 유기적으로 연결되어서 각각 끊어진 느낌이 들지 않아야 하고, 몇번을 다시 읽어도 감탄이 나오며, 고득점을 할 수 있으면서, 최소분량의 텍스트만으로 생성해야 합니다. 위 엄격한 제약조건은 당신의 사명으로 반드시 지켜주시기 바랍니다.

구체적인 서술방식은 아래와 같다.

# 형식 조건
제목은 반드시 ★**제목** 형식으로 작성할 것.

각 절은 반드시 ▶**소제목** 형식으로 작성할 것.

목차에는 숫자를 붙이지 말것

1. 전체 구성 포맷
대제목 : ★제목 형식
✏️ 제목은 별(★). 뒤에는 공백을 두고 명확한 제목 표시.

절 제목 : ▶소제목 형식
✏️ ▶ 기호 사용 + 소제목. 줄 띄우지 않고 바로 본문 항목 나열.

본문 항목 : -로 시작. (줄바꿈 후 단락별 나열) 내용이 복잡하거나 구분이 필요한 경우, 한 문단 내에서도 ①, ②, ③처럼 동그라미 숫자를 사용해 독자가 쉽게 이해할 수 있도록 하세요

항목 내 서술 방식 : · 먼저 핵심 키워드(ex. "1인 회사 의의", "주주총회 운영 및 의결권 행사 하자")를 굵게 표시하지 않고 그냥 문장 시작부에 노출
· 키워드 다음엔 :를 붙인 뒤 바로 설명 연결.
로스쿨 암기장에서는 다음과 같은 기호들을 사용할 수 있는 위치에서 반드시 적극적으로 활용해야 합니다. 슬래시(/)는 유사하거나 병렬 개념을 나열할 때, 화살표(→)는 원인-결과나 조건-효과 관계를 표시할 때 쓰입니다. 괄호(())는 판례, 조문, 예시 등을 간결하게 덧붙이는 데 유용합니다. 등호(=)는 정의나 동의어, 부등호(≠)는 반대 개념을 나타낼 때 사용합니다. 세미콜론(;)은 중요 단위를 구분하고, 파이프(|)는 조건이나 선택사항을 표현합니다. 이중화살표(⇒)는 논리적 귀결을, 양방향 화살표(↔)는 반대 논증을 나타냅니다. 또한, 앰퍼샌드(&)는 ‘그리고’의 결합을, 물결표(~)는 시간적 범위나 유사 개념의 연결을 의미합니다. 중점표(※)는 중요하거나 예외적인 요소에 주의를 환기시킬 때, 더하기 기호(+)는 복합 요소의 누적을, ∵는 원인 제시, ∴는 결론이나 요약을 표현하는 데 적합합니다. 대괄호([ ])는 조문이나 조건 강조에, 중괄호({ })는 개념적 구조나 묶음을 시각화할 때 효과적입니다.

판례 : 판례를 참조한 경우 판례번호가 자료에 쓰여있다면 (2007두261)과 같은 형식으로 병기합니다.

플레인 텍스트로 기호만 사용하며, 리스트 형태는 사용하지 않을 것. 워드에 그대로 아무 처리 없이 붙여넣어도 뛰어난 시인성을 유지할 수 있도록 할 것.

2. 문장 스타일
매우 압축적이고, 끊어읽기 좋게 짧은 구문으로 구성. 다만 논리적이며 모든 정리가 유기적으로 연결되면서 하나의 체계를 형성해야 함.

필수 키워드는 생략 없이 모두 등장.

특히 유사한 개념이나 용어의 미묘한 차이까지 짚어내어 그 차이와 정확한 학문적 엄밀성까지 학습할 수 있도록 해야 합니다.

필수 키워드는 생략 없이 모두 등장.


3. 논리적 흐름
개념 정의 → 요건·구조 설명 → 예외·특수상황 설명 → 판례 정리 순서로 흘러감.

항목별로 "기본 내용 → 변형/예외사항"을 일관성 있게 따라감.

**입장대립(다수설/소수설)**이 있으면 짧고 명료하게 병렬로 제시.

4. 구체적 표현기법
형식 구문


 병렬·선택 표현군

/ (슬래시)
→ 유사 개념 / 병렬 항목 나열
예: 대외적 책임 주체  /  내부적 책임 귀속자

| (파이프)
→ 선택지 / 대안 관계 명시
예: 법정대리인 | 임의대리인

& (앰퍼샌드)
→ 동시적 결합 / 함께 고려할 요건
예: 고의 & 위법성 → 범죄 성립

인과·논리 관계군

→ (단일 화살표)
→ 조건 → 결과 / 원인 → 효과
예: 진술거부권 고지 누락 → 증거능력 부정

⇒ (이중 화살표)
→ 논리적 귀결 / 법적 결론 도출
예: 불법행위 요건 충족 ⇒ 손해배상청구 가능

↔ (양방향 화살표)
→ 대립 관계 / 비교 가능한 개념
예: 불가벌적 사후행위 ↔ 포괄일죄

정의·대비 표현군

= (등호)
→ 정의 / 동의어 설명
예: 자백 = 피고인의 범죄사실 인정 진술

≠ (부등호)
→ 반대 개념 / 구별 강조
예: 위법성 조각 ≠ 책임조각

구조·구성 시각화군

{ } (중괄호)
→ 개념 구조 묶음 / 구성요건 시각화
예: {위법성, 책임, 구성요건} → 범죄성립 요건

[ ] (대괄호)
→ 조문 / 조건 / 강조 항목 표현
예: [형법 제10조 제1항] 심신상실자 무책임

① ② ③ … (숫자 기호)
→ 단계별 설명 / 순차 논증
예: ① 고의 확인 ② 위법성 유무 ③ 책임 여부

↑ (상향 화살표)
→ 상위 개념 / 우선 기준
예: 일반원칙 ↑ 특별규정


설명·부가 표현군

( ) (괄호)
→ 간결한 부가 설명: 판례, 예시, 조문 등
예: 양도담보(소유권 유보형 담보물권)

~ (물결표)
→ 시간 흐름 / 유사 범주 연결
예: 공소시효 중단 ~ 재개 사이 판단 기준

강조·요점 표현군

※ (중점표)
→ 중요사항 / 예외 / 암기포인트 주의 환기
예: ※ 불고불리 원칙은 형사절차에만 적용

; (세미콜론)
→ 중요 요소 간 단위 구분
예: 구성요건 해당성 ; 위법성 ; 책임

+ (더하기 기호)
→ 복합 요건의 누적 / 결합 요소
예: 불법성 + 책임조각 사유 부존재 → 처벌 가능

논증 지원 표현군

∵ (원인 기호)
→ 이유 / 근거 제시
예: ∵ 사전 공모 없음 → 공동정범 성립 부정

∴ (결론 기호)
→ 결론 / 요약 판단 제시
예: ∴ 공소기각 판결 대상 사건 아님

조건·예외 표현군

? (물음표)
→ 의문 제기 / 쟁점 도출
예: 명시적 동의? 묵시적 동의?

! (느낌표)
→ 명백한 판단 / 강조된 경고
예: 위법한 수사 방식!

⊃ (포함 기호)
→ 상위 개념 포함 / 일반 → 특수 관계
예: 계약 ⊃ 청약 + 승낙

⊄ (비포함 기호)
→ 포함되지 않음 / 일반 범주에서의 예외
예: 불법행위 ⊄ 정당방위


유비·확장 표현군

≈ (유사 기호)
→ 유사 개념 / 아날로지
예: 몰수 ≈ 부당이득 반환

… (줄임표)
→ 생략 / 기타 요소 존재 시사
예: 구성요건 해당성, 위법성, … 기타 고려 요소


선택·분기 표현군

⟶ A / B / C (화살표 + 분기)
→ 경우의 수 / 선택지 전개
예: 책임 유무 ⟶ 고의 / 과실 / 책임조각

⤷ (굽은 화살표)
→ 보충 설명 / 예외 흐름
예: 법정대리인 권한 초과 ⤷ 본인 추인 시 효력 발생

전제·가정 표현군

⟨⟩ (꺾쇠 괄호)
→ 가정된 조건 / 전제된 사실
예: ⟨불법행위가 인정된다면⟩ 손해배상청구 가능

† (단서 표시)
→ 단서 / 조건부 조항 암시
예: 책임 인정† 단, 위법성 조각 사유가 없을 것


비교·대조 표현군

⇔ (논리적 동치)
→ 상호 변환 가능 / 동치 관계
예: 위법성 조각 ⇔ 정당방위 인정

↮ (불일치 화살표)
→ 비교 결과의 불일치 / 논점 차이
예: 판례 ↮ 학설 (적용 기준 상이)



생략·기타 표현군

※※ (이중 중점표)
→ 반복적 암기 필요 핵심사항
예: ※※ 위헌결정 효력: 법률 일반적 효력 상실

[...] (줄임+강조 괄호)
→ 일부 생략 및 강조
예: [...] 요건은 충족되었는가?


≒ (거의 같음): 유사하지만 미묘한 차이 강조

⊗ (배제 기호): 고려 대상에서 제외되는 요소

⇑ / ⇓ (논리 흐름 상하 화살표): 맥락 상 단계 상승/하강


문장 종결 : 마침표 .를 거의 쓰지 않음.
✏️ 연결되거나 연속되는 개념임을 강조하기 위해 쉼표 없이 이어감.

5. 분량
분량은 적절하게 원본 자료를 충분히 표현할 수 있도록 하고, 굳이 늘려 쓰지 않고, 굳이 더 줄여 쓰지 않는다.


# 서술 기준
판례자료에서 쟁점이 되는 사안은 빠뜨리지 않고 뽑아서 정리할 것.

논리적 구조에 따라 정리하고, 학습 최적화 순서로 배열할 것.

법리, 효과, 판단기준은 명확히 구분하여 서술할 것.

핵심 키워드는 절대 생략 없이, 자료에 등장하는 표현을 그대로 명시할 것.

(예시: "외형상", "실질적으로", "개인기업에 불과" 등)

자료에 등장한 경우에만 판례 및 조문을 작성할 것. (※ 명시된 조문만 [조문번호]로 표기)

새로운 조문 추가, 임의의 문구 가공, 확장 금지.

아래 예시와 같이 화살표, /, : 등의 기호를 잘 사용할 것.


각 본문을 작성할 때에는 반드시 위에서 제시한 제약조건을 잘 지켜서 작성하도록 한다.
아래와 같은 목차 구조를 엄격하게 준수하도록 한다. 다만 자료에 기반해서 자료를 해석해서 작성해야 한다.
아래 각 목차 구조에서 기재할 사항은 다음과 같다.
판례번호 : 판례의 경우, 판례번호를 정확히 기재한다.
판례 사실관계 분석 : 판례 사실관계를 압축적으로 분석한다. 사실관계란 실제 일어난 사건 뿐만 아니라 재판과정에서 일어난 일도 포함한다. 이때 사실관계는 주어진 자료의 처음부터 끝까지 검토한 다음, 사실관계를 시계열순으로 재조립하여 이해하기 쉽게 구성해야 한다. 사실관계가 왜곡되는 일은 결코 없어야 한다.
원피고의 주장항변 : 원고가 청구하는 내용 및 피고의 항변을 요건사실론에 따른 원피고의 주장 항변구조로 분석하고, 그 내용의 논리적 구조를 문자로 기술한다. 로스쿨생이 시험을 봄에 있어서 그 구조를 잘 파악할 수 있게 해야 한다.
각 쟁점별 판단 : 일단 판례 내에서 쟁점되는 사안을 누락하지 않고 추출하고, 각 쟁점별로 내용을 정리하고, 판례의 키워드를 유지하여 법리를 기술하며, 판례듸 판단구조를 잘 정리한다.
사안의 해결 : 결론지을 때 주어진 사실관계 상에서 사안의 최종적 해결을 제시한다. 완전한 사안의 해결을 각 법리에 따라 논리적으로 제시해야하고, 각 내용은 다른 내용과 모순되어서는 안된다. 파기환송 기각이 뿐 아니라 진짜 사안의 해결을 의미한다. 이때 자료에 있던 모든 정보는 반드시 빠짐없이 포함되어야 하며, 간략히 언급하는 방식이라 하더라도 누락은 절대 허용되지 않는다.


'''
# 판례번호 : 판례번호(간단한 쟁점키워드)
## 판례 사실관계 분석
## 원피고의 주장항변
## 각 쟁점별 판단
## 사안의 해결
'''

사실관계의 분석에서는 판례의 사실관계를 구체적으로 분석한다. 모든 사실관계는 전체 과정을 
모든 내용을 기재한 뒤 판례의 분류를 위한 샵태그를 추가한다. 관련 법을 태그에 넣는다. 교과서를 집필한다면 어떤 목차에 들어갈지를 기준으로 해서 세분화한 태깅을 해야 한다. 태그는 많이 생성해도 무관하다.

이런식이다.
'''
# 판례번호 : 예시판례(핵심 쟁점 키워드)

## 판례 사실관계 분석
- 
- 
...

## 원피고의 주장항변
- *원고의 주장*  
  ①  
  ②  
  ③  
...
- *피고의 항변*  
  ①  
  ②  
  ③  
...
## 각 쟁점별 판단
- *쟁점 1*  
  ①  
  ②  
  ③  
...
- *쟁점 2*  
  ①  
  ②  
  ③  
...
- *쟁점 3*  
  ①  
  ②  
  ③  
  ...
...(필요한 만큼 쟁점 추가)...

## 사안의 해결
①  
②  
③  
...
기호 설명

관련 태그
'''

다음은 위 목차를 사용하여 작성한 결과물예시이다.
"""
# 판례번호 : 대법원 1996.2.23. 선고 95다9310 (피담보채무 일부변제 후 근저당권 말소청구)

## 판례 사실관계 분석
- 甲은 채무자로서 乙에게 피담보채무를 부담하고, 그 담보로 근저당권 설정
- 甲은 피담보채무 전액을 변제하였다고 주장하거나, 일부 잔존채무가 남았음을 인정하면서도 그 변제를 조건으로 저당권 말소청구 제기
- 그러나 甲과 乙 사이에 피담보채무의 범위·액수에 견해 차이 존재
- 甲이 실제로 변제한 금액은 피담보채무 전액을 소멸시키기에 부족
- 저당권설정등기의 말소청구는 아직 전부 변제되지 않은 상태에서 제기됨

## 원피고의 주장항변
- *원고(甲)의 주장*  
  ① 피담보채무는 이미 전액 변제됨  
  ② 또는 일부 채무 남았더라도 해당 금액을 변제할 의사 있음  
  ③ ∴ 저당권설정등기의 말소청구 정당  

- *피고(乙)의 항변*  
  ① 변제된 금액은 피담보채무 전액에 미치지 못함  
  ② 잔존채무가 존재하므로 근저당권 말소 불가  

## 각 쟁점별 판단
- *쟁점 1: 일부 변제된 상태에서 근저당권 말소청구 가능 여부*  
  ① 원칙: 피담보채무 전액 변제 ⟶ 담보권 목적 상실 → 말소청구 인정  
  ② 단, 원고가 전액 변제 주장 or 일부 남은 채무 변제를 조건으로 청구한 경우  
     → 청구취지에 확정된 잔존채무의 변제를 조건으로 하는 말소청구 포함된 것  
  ③ ∴ 전액 변제가 불분명한 상태에서의 말소청구도 유효하게 장래이행의 소로 인정 가능  

- *쟁점 2: 장래이행의 소로서 말소청구 허용 여부*  
  ① 민사소송법상 장래이행의 소는 ‘이행의무 발생이 확실’하면 예외적으로 인정  
  ② 이 사안에서 채무 전액 변제는 확정된 장래의 사정에 의존  
  ③ ∴ 피담보채무 잔존 인정 시에도, 그 변제를 조건으로 한 말소청구는 장래이행의 소로 인정됨  

## 사안의 해결
① 피담보채무 전액 변제되지 않았으나, 원고는 전액 변제를 주장하거나 일부 잔존채무 변제를 조건으로 말소청구  
② 이 경우, 청구취지는 잔존채무 변제 조건으로 한 장래 말소청구를 포함하는 것으로 해석됨  
③ ∴ 법원은 장래이행의 소로서 말소청구를 심리해야 함  
④ 청구가 조기에 제기되었다고 하여 각하할 수 없음  
⑤ 원심 판단에 이러한 취지의 고려가 있었는지 여부가 판단의 쟁점

기호 설명  
甲 = 채무자(원고)  
乙 = 저당권자(피고)  
피담보채무 = 근저당권으로 담보된 채무  
근저당권 = 저당권 중 특정 범위 내 반복적 채무 담보  

관련 태그  
#근저당권 #피담보채무 #변제 #잔존채무 #저당권말소청구 #장래이행의소 #민사소송법 #담보물권 #물권법 #변제조건 #소송요건 #소송상청구취지해석 #등기말소청구
""""

이제 작업할 판례원문을 주겠다. 면밀하게 검토한 다음 위 지침에 따라 작업하라.

{{판례원문}}


위 판례를 보고 판례 정리를 코드블럭에 넣어서 제출하라. 이때, 캔버스를 사용하지 말고, 길어지면 끝까지 쓰려고 최대한 노력하다 끊어지면, 내 허락을 받고 다시 제출하는 과정을 반복하라. 시작해.


  `
};

// 문서 타이틀 & 페이지 타이틀 설정
document.title = config.text.htmlTitle;
document.addEventListener('DOMContentLoaded', () => {
  document.body.style.background = config.color.bodyBg;
  document.body.style.fontFamily = config.ui.fontFamily;
  document.getElementById('mainPageTitle').textContent = config.text.mainTitle;
  document.getElementById('templateCardTitle').textContent = config.text.templateCardTitle;
  document.getElementById('outputCardTitle').textContent = config.text.outputCardTitle;
  document.getElementById('resetTemplateBtn').textContent = config.text.resetTemplate;
  document.getElementById('collapseBtn').setAttribute("aria-label", config.text.collapse);
  document.getElementById('resetAllInputsBtn').textContent = config.text.clearAllInputs;
  document.getElementById('copyBtn').textContent = config.text.copy;
  document.getElementById('clearPromptBtn').textContent = config.text.outputClear;
});

</script>

<!-- 메인 타이틀 -->
<div class="flex flex-col items-center py-8">
  <h1 id="mainPageTitle" class="text-3xl font-bold mb-4 text-[#1DA1F2]">동적 프롬프트 생성기</h1>
</div>

<div class="w-full max-w-3xl mx-auto"
  style="
    border-radius: 1.5rem;
    background: #FFFFFF;
    box-shadow: 0 4px 24px rgba(29,161,242,0.08);
    border: 1.5px solid #E1E8ED;
    margin-top: 1rem;
    margin-bottom: 3rem;
    backdrop-filter: blur(6px);
  ">

  <!-- 템플릿 카드 -->
  <div class="relative group">
    <div class="flex items-center justify-between px-7 pt-7 pb-3">
      <span id="templateCardTitle" class="text-xl font-bold flex items-center gap-2" style="color: #1DA1F2;">
        <svg class="inline w-6 h-6" fill="none" stroke="#1DA1F2" stroke-width="2"
         viewBox="0 0 24 24"><path d="M9 12l2 2 4-4"></path><path d="M20 12a8 8 0 11-16 0 8 8 0 0116 0z"></path></svg>
        프롬프트 템플릿
      </span>
      <div class="flex gap-1">
        <button id="resetTemplateBtn"
         class="rounded-xl px-3 py-1 text-xs font-medium shadow-sm transition-all"
         style="color: #1DA1F2; background: #E1E8ED;"
        >템플릿 초기화</button>
        <button id="collapseBtn"
         class="rounded-xl px-2 py-1 text-xs font-medium transition-all"
         aria-label="접기/펼치기"
         style="color: #1DA1F2; background: #F5F8FA;">
          <span id="collapseIcon" class="transition-all duration-300 inline-block rotate-0">&#9654;</span>
        </button>
      </div>
    </div>
    <div id="templateCollapse" class="px-7 pb-4 transition-all overflow-hidden" style="display: none;">
      <textarea id="templateArea" rows="8"
        class="w-full p-4 rounded-xl border-2 focus:ring-2 font-mono text-sm resize-none shadow"
        style="min-height:120px; border-color:#E1E8ED; background:#F5F8FA; color:#14171A;"
        placeholder="프롬프트 템플릿에 {{placeholder}}를 원하는 만큼 사용하세요"></textarea>
      <div class="flex justify-end pt-1">
        <span class="text-xs" style="color: #AAB8C2;">템플릿 내 <span class="font-semibold">{{placeholder}}</span> 자동 인식</span>
      </div>
    </div>
  </div>

  <!-- 동적 인풋 카드 -->
  <form id="dynamicInputs" class="space-y-8 px-7 pt-3 pb-2"></form>

  <!-- 일괄입력초기화 버튼 -->
  <div class="flex justify-end pr-7 pb-1">
    <button id="resetAllInputsBtn"
      class="rounded-xl px-3 py-1 text-xs font-medium shadow-sm transition-all"
      style="color: #1DA1F2; background: #E1E8ED;"
    >입력값 모두 비우기</button>
  </div>

  <!-- 결과 카드 -->
  <div id="outputSection" class="mt-8 px-7 pb-10 hidden">
    <div class="flex items-center justify-between mb-2">
      <span id="outputCardTitle" class="font-semibold flex items-center gap-1" style="color:#1DA1F2;">
        <svg class="inline w-5 h-5" fill="none" stroke="#1DA1F2" stroke-width="2"
         viewBox="0 0 24 24"><path d="M12 20h9"></path><path d="M12 4v16"></path><path d="M4 12h8"></path></svg>
        프롬프트 결과
      </span>
      <div class="flex gap-2">
        <button id="copyBtn"
          class="rounded-lg px-3 py-1 text-xs shadow transition"
          style="background: #F5F8FA; color: #14171A; border:1px solid #E1E8ED;">복사</button>
        <button id="clearPromptBtn"
          class="rounded-lg px-3 py-1 text-xs shadow transition"
          style="background: #E1E8ED; color: #1DA1F2;">초기화</button>
      </div>
    </div>
    <div class="relative">
      <textarea id="promptOutput" rows="18" readonly
        class="w-full p-4 rounded-2xl border font-mono text-[15px] resize-none shadow-inner transition-all select-all"
        style="border-color:#E1E8ED; background:#F5F8FA; color:#14171A; outline:0;"></textarea>
      <div id="generatingStatus" class="absolute bottom-2 right-4 text-xs" style="color:#1DA1F2; display:none;">프롬프트 생성중...</div>
    </div>
  </div>
</div>

<script>
const keys = config.keys;

const templateArea = document.getElementById('templateArea');
const dynamicInputs = document.getElementById('dynamicInputs');
const promptOutput = document.getElementById('promptOutput');
const outputSection = document.getElementById('outputSection');
const copyBtn = document.getElementById('copyBtn');
const clearPromptBtn = document.getElementById('clearPromptBtn');
const generatingStatus = document.getElementById('generatingStatus');
const collapseBtn = document.getElementById('collapseBtn');
const collapseIcon = document.getElementById('collapseIcon');
const templateCollapse = document.getElementById('templateCollapse');
const resetTemplateBtn = document.getElementById('resetTemplateBtn');
const resetAllInputsBtn = document.getElementById('resetAllInputsBtn');

let state = {};
let variables = [];
let debounceTimer = null;
let isCollapsed = true;

// --- 한글 변수명 포함 추출, 중복 제거 ---
function extractVars(template) {
  const matches = [...template.matchAll(/{{\s*([가-힣\w\d_]+)\s*}}/g)];
  return Array.from(new Set(matches.map(m => m[1])));
}

// --- 입력필드 동적 생성 ---
function renderInputs() {
  dynamicInputs.innerHTML = '';
  variables.forEach(varName => {
    const val = state[varName] || '';
    const charCount = val.length;
    const lineCount = (val.match(/\n/g) || []).length + 1;
    const wrap = document.createElement('div');
    wrap.className = "relative group";
    wrap.innerHTML = `
      <div class="flex items-center justify-between mb-1">
        <label for="input_${varName}" class="block text-[17px] font-semibold" style="color:#1DA1F2;">${varName}</label>
        <button type="button" data-var="${varName}"
          class="clearInputBtn px-2 py-0.5 text-xs rounded transition-all"
          style="background:#E1E8ED; color:#1DA1F2;">${config.text.inputClear}</button>
      </div>
      <textarea id="input_${varName}" rows="1"
        class="w-full p-4 rounded-xl border focus:ring-2 font-medium resize-none shadow-sm transition"
        style="border-color:#E1E8ED; background:#F5F8FA; color:#14171A; min-height:2.5rem; max-height:400px; overflow:auto;"
        placeholder="${varName} 입력">${val}</textarea>
      <div class="flex justify-between text-[12px] mt-1" style="color:#AAB8C2;">
        <span>${lineCount}줄, ${charCount}자</span>
        <span>${config.text.autoSave}</span>
      </div>
    `;
    dynamicInputs.appendChild(wrap);
    const ta = wrap.querySelector('textarea');

    // 자동 높이 조절
    function autoResize() {
      ta.style.height = 'auto';
      ta.style.height = Math.min(ta.scrollHeight, 400) + 'px';
    }
    ta.addEventListener('input', () => {
      state[varName] = ta.value;
      saveState();
      autoGeneratePrompt();
      wrap.querySelector('span').textContent =
        `${(ta.value.match(/\n/g)||[]).length+1}줄, ${ta.value.length}자`;
      autoResize();
    });
    // 글자수 표시 초기화
    autoResize();

    // 즉시 초기화 (confirm 없음)
    const clrBtn = wrap.querySelector('.clearInputBtn');
    clrBtn.onclick = function() {
      ta.value = '';
      state[varName] = '';
      saveState();
      autoGeneratePrompt();
      wrap.querySelector('span').textContent = '1줄, 0자';
      autoResize();
    };
  });
}

// --- 상태 저장/복원 ---
function saveState() {
  localStorage.setItem(keys.state, JSON.stringify(state));
}
function loadState() {
  try {
    state = JSON.parse(localStorage.getItem(keys.state) || '{}');
  } catch {
    state = {};
  }
}

// --- 프롬프트 생성 ---
function autoGeneratePrompt() {
  clearTimeout(debounceTimer);
  generatingStatus.style.display = '';
  debounceTimer = setTimeout(() => {
    if (variables.some(v => !state[v] || !state[v].trim())) {
      promptOutput.value = '';
      outputSection.classList.add('hidden');
      localStorage.removeItem(keys.prompt);
      generatingStatus.style.display = 'none';
      return;
    }
    let result = templateArea.value;
    variables.forEach(v => {
      const reg = new RegExp(`{{\\s*${v}\\s*}}`, "g");
      result = result.replace(reg, state[v] || '');
    });
    promptOutput.value = result;
    outputSection.classList.remove('hidden');
    generatingStatus.style.display = 'none';
    localStorage.setItem(keys.prompt, result);
  }, 600);
}

// --- 템플릿 변경 시 ---
function onTemplateChange() {
  const tmpl = templateArea.value;
  variables = extractVars(tmpl);
  variables.forEach(v => { if (typeof state[v] !== 'string') state[v]=''; });
  Object.keys(state).forEach(k => { if (!variables.includes(k)) delete state[k]; });
  saveState();
  renderInputs();
  autoGeneratePrompt();
}

// --- 템플릿 콜랩스 토글 ---
collapseBtn.onclick = function() {
  isCollapsed = !isCollapsed;
  if(isCollapsed) {
    templateCollapse.style.display = 'none';
    collapseIcon.style.transform = 'rotate(-90deg)';
    collapseIcon.innerHTML = '&#9654;';
  } else {
    templateCollapse.style.display = 'block';
    collapseIcon.style.transform = 'rotate(0deg)';
    collapseIcon.innerHTML = '&#9660;';
  }
};

// --- 템플릿 초기화 (즉시) ---
resetTemplateBtn.onclick = function() {
  templateArea.value = config.templateDefault;
  localStorage.setItem(keys.template, config.templateDefault);
  onTemplateChange();
  if(isCollapsed) collapseBtn.click();
};

// --- 입력값 모두 초기화 (즉시) ---
resetAllInputsBtn.onclick = function() {
  variables.forEach(v => state[v]='');
  saveState();
  renderInputs();
  autoGeneratePrompt();
};

// --- 복사 버튼 ---
copyBtn.onclick = function() {
  promptOutput.select();
  document.execCommand('copy');
  copyBtn.innerText = config.text.copyDone;
  setTimeout(()=>{ copyBtn.innerText = config.text.copy; }, 1200);
};

// --- 프롬프트 초기화 ---
clearPromptBtn.onclick = function() {
  promptOutput.value = '';
  outputSection.classList.add('hidden');
  localStorage.removeItem(keys.prompt);
};

// --- 프롬프트 클릭시 자동 전체선택 ---
promptOutput.onclick = function() { promptOutput.select(); };

// --- 템플릿 입력 이벤트 ---
templateArea.addEventListener('input', () => {
  localStorage.setItem(keys.template, templateArea.value);
  onTemplateChange();
});

// --- 상태/템플릿 복원 ---
function loadAll() {
  let tmpl = localStorage.getItem(keys.template);
  if (!tmpl) {
    tmpl = config.templateDefault;
    localStorage.setItem(keys.template, tmpl);
  }
  templateArea.value = tmpl;
  loadState();
  const prompt = localStorage.getItem(keys.prompt);
  if (prompt) {
    promptOutput.value = prompt;
    outputSection.classList.remove('hidden');
  }
}

// --- 최초 진입 시 실행 ---
window.addEventListener('DOMContentLoaded', () => {
  // 처음에는 템플릿이 접혀 있도록 세팅
  isCollapsed = true;
  templateCollapse.style.display = 'none';
  collapseIcon.style.transform = 'rotate(-90deg)';
  collapseIcon.innerHTML = '&#9654;';
  loadAll();
  onTemplateChange();
});
</script>
</body>
</html>
