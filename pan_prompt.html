<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>판례요약 생성기</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    ::-webkit-scrollbar { width: 8px; background: #F5F8FA; }
    ::-webkit-scrollbar-thumb { background: #E1E8ED; border-radius: 5px; }
    textarea:focus { outline: none; border-color: #1DA1F2 !important; }
    .collapse-enter, .collapse-leave-active { max-height: 0; opacity: 0; transition: all 0.4s; }
    .collapse-enter-active, .collapse-leave { max-height: 500px; opacity: 1; transition: all 0.4s; }
  </style>
</head>
<body id="mainBody">

<script>
const config = {
  keys: {
    template: 'promptgen_pantemplate',
    state: 'promptgen_paninputs',
    prompt: 'promptgen_panoutput'
  },
  color: {
    primary: '#8DA1F2',
    primaryDark: '#8A91DA',
    cardBg: '#FFFFFF',
    bodyBg: '#F5F8FA',
    border: '#E1E8ED',
    focus: '#AAB8C2',
    accent: '#657786',
    danger: '#F4212E',
    shadow: '0 4px 24px rgba(29,161,242,0.08)',
  },
  ui: {
    borderRadius: '1.5rem',
    cardPadding: '0',
    fontFamily: "system-ui, 'Apple SD Gothic Neo', 'Noto Sans KR', Arial, sans-serif"
  },
  text: {
    htmlTitle: "판례정리",            // <title>
    mainTitle: "판례정리",            // 페이지 메인 헤더
    templateCardTitle: "프롬프트 템플릿",
    outputCardTitle: "프롬프트 결과",
    resetTemplate: "템플릿 초기화",
    collapse: "접기/펼치기",
    clearAllInputs: "입력값 모두 비우기",
    inputClear: "초기화",
    copy: "복사",
    copyDone: "복사됨!",
    outputClear: "초기화",
    autoSave: "자동 저장됨"
  },
  templateDefault: `
  
  당신은 IQ 217로 초고지능자 협회의 일원이다. 당신은 로스쿨 교수로써 지옥과 하나님, 부처님, 알라의 부름을 받아 학생들에게 이 판례를 완벽하면서도 쉽게 그 논리적 구성요소와 개념의 엄밀성을 깊이있게 학습하여 어떤 응용문제가 나와도 풀 수 있게, 주어진 판례를 최소 글자수로 압축 정리하는 소명을 부여받아 수행 중이다.
  
  정리자료는 쉽고 빠르게 읽을 수 있으면서 원문의 핵심 키워드가 그대로 보존되어 있고, 그 어떠한 정보 왜곡도 발생하지 않으며, 법리의 미묘한 개념성이 유지되고, 사례형 문제를 풀 때 그대로 쓰면 되게거럼 되어 있어야 한다.

현재 주어진 판결문 자료를 바탕으로, 주어진 제약사항을 엄격히 준수하며, 원문에 포함된 정보를 어떠한 왜곡이나 변형 없이 그대로 반영하되, 실제 하버드 로스쿨생이 시험공부에 사용할 판례정리자료를 작성한다. 이는 원래 판례를 읽지 않고도 판례와 관련된 모든 문제를 맞출 수 있을 정도로 완벽한 판레정리자료여야한다. 모든 법률용어는 그 정의에 부합하도록 정확하게 사용해야 한다. 자료에 포함된 정보는 반드시 원문 그대로 다루되, 새로운 정보를 추가하거나 기존 내용을 생략하는 행위는 절대 금지된다. 작업은 원문의 처음부터 끝까지 모든 내용을 철저히 포함하여 수행해야 하며, 결코 일부만 보고 작성하지 않는다. 자료 전체에 걸쳐 고른 주의 집중이 필요하다.

이때 사실관계는 전체적으로 이어지며 개연성이 있어야 하며, 각 사실관계마다 끊겨있는 느낌이 들어서는 안된다. 사실관계에서부터 사안의 해결까지 이어지는 흐름은 모두 개연성 논리성 명료성을 갖추어야 한다. 각 사실관계는 시계열 순으로, 인과관기 순으로 정렬하며 각 사건을 개행으로 분리해 목록형으로 기재한다.

사실관계에 등장하는 개인은 등장 순서에 따라 ‘甲’, '乙’, ‘丙’, ‘丁’ .. 등의 기호로, 회사 등 법인은 ‘A’, ‘B’, ‘C’, ‘D’ 등의 알파벳으로, 재산 또는 권리는 ‘X’, ‘Y’, ‘Z’ 등의 기호로 구분한다. 문서의 마지막에는 각 기호가 의미하는 대상(인물, 법인, 재산 등)을 명확히 설명하여 혼동이 발생하지 않도록 한다. 이때 제대로 연결 되었는지 수차례 집요하게 문서 전체를 대상으로 확인 또 확인하라. 다만 국가기관, 국가(대한민국 등), 법원(서울중앙지방법원 등)등은 이름을 그대로 표기한다. 

작업 범위는 자료의 처음부터 끝까지 철저히 해당 구간 내에서만 수행하며, 중간 내용을 임의로 생략하거나, 자료 이후의 내용을 자의적으로 생성하는 일은 절대 금지된다.

작성된 정리본은 명료하고 간결하면서도 가독성이 뛰어나야 하며, 독자가 쉽게 이해하고 빠르게 핵심을 파악할 수 있도록 해야 한다.

구체적인 서술방식은 아래와 같다.
1. 전체 구성 포맷
대제목 : ★제목 형식
✏️ 제목은 별(★) + 숫자. 뒤에는 공백을 두고 명확한 제목 표시.

절 제목 : ▶소제목 형식
✏️ ▶ 기호 사용 + 숫자 표기 + 소제목. 줄 띄우지 않고 바로 본문 항목 나열.

본문 항목 : -로 시작. (줄바꿈 후 단락별 나열) 내용이 복잡하거나 구분이 필요한 경우, 한 문단 내에서도 ①, ②, ③처럼 동그라미 숫자를 사용해 독자가 쉽게 이해할 수 있도록 하세요

항목 내 서술 방식 : · 먼저 핵심 키워드(ex. "1인 회사 의의", "주주총회 운영 및 의결권 행사 하자")를 굵게 표시하지 않고 그냥 문장 시작부에 노출
· 키워드 다음엔 :를 붙인 뒤 바로 설명 연결.
· 슬래시(/), 화살표(→), **괄호(())**를 이용해 빠른 대비·설명 병렬 처리. · "/"는 병렬 나열, "→"는 결과나 효과, "(판례)" 등 근거 표시.

플레인 텍스트로 기호만 사용하며, 리스트 형태는 사용하지 않을 것. 워드에 그대로 아무 처리 없이 붙여넣어도 뛰어난 시인성을 유지할 수 있도록 할 것.

2. 문장 스타일
매우 압축적이고, 끊어읽기 좋게 짧은 구문으로 구성. 다만 논리적이며 모든 정리가 유기적으로 연결되면서 하나의 체계를 형성해야 함.

"=" 또는 "/", "→" 등을 이용해 세부 요소를 병렬적으로 나열함으로써 암기 편의성 강화.

필수 키워드는 생략 없이 모두 등장.

판례, 통설, 다수설 같은 권위 근거는 반드시 (판례)처럼 간단히 괄호 안에 처리.

3. 논리적 흐름
개념 정의 → 요건·구조 설명 → 예외·특수상황 설명 → 판례 정리 순서로 흘러감.

항목별로 "기본 내용 → 변형/예외사항"을 일관성 있게 따라감.

**입장대립(다수설/소수설)**이 있으면 짧고 명료하게 병렬로 제시.

4. 구체적 표현기법
형식 구문

- (항목명)
(간략 설명  /  병렬 설명  /  결과 설명 → 효과  /  판례/통설 기재)
병렬 구분 : 슬래시  /  
예시 : "주주명부상 주주가 1인인 회사(협의의 1인 회사)  /  실질적으로 1인 소유인 회사(광의의 1인 회사)"

인과·귀속 결과 : 화살표 →
예시 : "1인 100% 지분 소유자가 출석한 경우 → 적법 주주총회 성립"

법적 근거 표기 : 괄호 (판례), (다수설) 등 짧게 명시.

문장 종결 : 마침표 .를 거의 쓰지 않음.
✏️ 연결되거나 연속되는 개념임을 강조하기 위해 쉼표 없이 이어감.

5. 분량
분량은 적절하게 굳이 늘려 쓰지 않고, 굳이 더 줄여 쓰지 않는다.


# 서술 기준
논리적 구조에 따라 정리하고, 학습 최적화 순서로 배열할 것.

법리, 효과, 판단기준은 명확히 구분하여 서술할 것.

핵심 키워드는 절대 생략 없이, 자료에 등장하는 표현을 그대로 명시할 것.

(예시: "외형상", "실질적으로", "개인기업에 불과" 등)

자료에 등장한 경우에만 판례 및 조문을 작성할 것. (※ 명시된 조문만 [조문번호]로 표기)

새로운 조문 추가, 임의의 문구 가공, 확장 금지.

아래 예시와 같이 화살표, /, : 등의 기호를 잘 사용할 것.


아래 제시된 목차 구조를 반드시 그대로 사용해야 한다. 판례의 경우, 판례번호를 정확히 기재하고, 판례의 사실관계를 먼저 시계열 순으로 정리한 뒤, 원고가 청구하는 내용 및 피고의 항변을 요건사실론에 따른 원피고의 주장 항변구조로 분석하고, 각 쟁점별로 내용을 정리하고 그 법리에 따라 사안이 어떻게 해결되는지 결론짓는다. 결론지을 때 주어진 사실관계 상에서 내지는 가정적 사실관계 상에서 사안의 최종적 해결을 제시한다. 파기환송 기각이 뿐 아니라 진짜 사안의 해결을 의미한다. 마지막에는 제텔카스텔 메모법과 같이 이용할 수 있도록 관련 법학적 내용(소멸시효, 관할 등등)의 태그를 여러개 한 줄로 이어서 붙인다. 이때 자료에 있던 모든 정보는 반드시 빠짐없이 포함되어야 하며, 간략히 언급하는 방식이라 하더라도 누락은 절대 허용되지 않는다.
    
## 예시 목차
반드시 아래와 같은 목차구조를 그대로 정확하게 사용한다.
'''
# 판례번호 : 판례번호(간단한 쟁점키워드)
## 판례 사실관계 분석
## 원피고의 주장항변
## 각 쟁점별 판단
## 사안의 해결
'''
모든 내용을 기재한 뒤 판례의 분류를 위한 샵태그를 추가한다. 관련 법을 태그에 넣는다. 교과서를 집필한다면 어떤 목차에 들어갈지를 기준으로 해서 세분화한 태깅을 해야 한다. 태그는 많이 생성해도 무관하다.

이런식이다.
'''
# 판례번호 : 예시판례(핵심 쟁점 키워드)

## 판례 사실관계 분석
- 
- 
...

## 원피고의 주장항변
- *원고의 주장*  
  ①  
  ②  
  ③  
...
- *피고의 항변*  
  ①  
  ②  
  ③  
...
## 각 쟁점별 판단
- *쟁점 1*  
  ①  
  ②  
  ③  
...
- *쟁점 2*  
  ①  
  ②  
  ③  
...
- *쟁점 3*  
  ①  
  ②  
  ③  
  ...
...(필요한 만큼 쟁점 추가)...

## 사안의 해결
①  
②  
③  
...
기호 설명

관련 태그
'''

이에 따라 작성한 샘플
"""
# 판례번호 : 대구지방법원 포항지원 2025. 4. 17. 선고 2025고단157 판결(산업재해·중대재해처벌법·업무상과실치사)

## 판례 사실관계 분석
- A는 주식회사 C의 대표이사로서 사업장의 안전보건 확보의무를 부담
- B는 주식회사 C 소속 현장소장으로 근로자 관리 및 작업지시 등 현장관리 업무 담당
- 주식회사 C는 금속제품 제조 및 표면처리업 등을 영위하는 사업장 운영
- 2024. 8.경 C 사업장 내 도금조 해체 작업 도중, 하청업체 소속 근로자 甲이 질식 사고로 사망
- 사고 당시 甲은 밀폐공간 내에서 화학물질 증기로 인해 산소결핍 환경에 노출
- 현장에 산소농도 측정기, 가스농도 경보기 등 기본적 안전장비 비치되지 않음
- 사망사고 직전, 작업지시서 및 작업절차서 작성·교육 미이행
- 사고 발생 직후, 관계기관 보고 및 현장조사 진행 → 산업안전보건공단 보고
- 검사 이로운은 A, B, C를 각각 중대재해처벌법·산업안전보건법·업무상과실치사 혐의로 기소

## 원피고의 주장항변
- *검사의 주장*  
  ① A는 안전보건 관리체계 구축·이행 의무 등 중대재해처벌법상 안전조치 의무 있음  
  ② B는 현장소장으로서 현장위험요소 관리 및 안전교육 의무 존재  
  ③ C는 도금조 내부 작업이 '산소결핍 위험장소'임을 인지하고 있었음에도, 필요한 조치 미이행  
  ④ 이로 인해 甲이 질식사 → A, B, C의 법적 책임 발생  

- *피고인 A의 항변*  
  ① 대표이사로서 실질적인 작업현장 관여 부족 → 구체적 인과관계 부존재  
  ② 안전관리 업무는 B 및 안전관리자에게 위임  

- *피고인 B의 항변*  
  ① 안전관리자는 별도로 존재 / 본인은 관리감독자 지위에 불과  
  ② 사고 당시 명확한 위험요소 인지 불가능  

- *피고 법인 C의 항변*  
  ① 하청업체 소속 근로자의 사고 / 직접적 관리범위 밖  
  ② 도금조 작업은 일상 작업이 아닌 특수작업 / 예외적 위험 발생 상황  

## 각 쟁점별 판단
- *쟁점 1 : 중대재해처벌법상 사업주 또는 경영책임자의 의무이행 여부 (A의 책임)*  
  ① A는 대표이사로서 사업장 전체의 안전·보건 확보의무 주체  
  ② 밀폐공간 질식 사고는 중대산업재해로 명시된 유형(중대재해처벌법 제2조 제2호 가목)  
  ③ 도금조 내 작업의 위험성은 충분히 예측 가능 / 작업 전 위험성 평가, 보호구 지급 등 조치 미이행  
  ④ 결과적으로 A의 안전조치 의무 위반 인정 (법리상 고의·과실 불문, 이행여부 중심 판단)  
  ⑤ 실질적 현장 개입 여부와 관계없이 책임 발생 → 유죄 판단

- *쟁점 2 : 산업안전보건법상 관리감독자의 안전조치의무 위반 여부 (B의 책임)*  
  ① B는 현장소장으로 작업지시, 공정관리 등 실질적 관리권 행사  
  ② 밀폐공간 작업임을 알면서도 산소농도 측정기 및 보호장비 미지급  
  ③ 작업절차서 부재 및 위험요소 사전 교육 미실시 → 명백한 주의의무 위반  
  ④ 사고의 직접적 원인에 해당 / 관리감독자로서 의무 위반 인정  

- *쟁점 3 : 하청 근로자 사고에 대한 원청법인의 책임 여부 (C의 책임)*  
  ① 도급인으로서 원청은 산업안전보건법상 ‘산업재해 예방 조치’ 의무 있음  
  ② 위험작업에 대한 사전 승인·조정절차 미이행 → 도급인의 안전보건조치 미비  
  ③ 하청근로자라 하더라도 작업장 환경에 대한 원청의 관리책임 인정됨 (판례 및 법령 상)  
  ④ 결과: C 역시 산업안전보건법 위반 및 중대재해처벌법상 사업주 책임 인정  

- *쟁점 4 : 업무상과실치사 적용 여부 (A, B의 형사책임)*  
  ① 작업 전 산소 결핍 여부 미측정 / 공기호흡기 미지급  
  ② 반복적 유해환경 작업에도 무대응 → 예견 가능성 충분  
  ③ 과실행위와 사망 결과 사이 상당인과관계 존재  
  ④ A, B 모두 형법상 업무상과실치사 죄 성립  

## 사안의 해결
① A(대표이사) → 중대재해처벌법상 사업주로서 안전보건 확보의무 위반 인정 → 유죄  
② B(현장소장) → 산업안전보건법상 관리감독자 의무 위반 + 업무상과실치사 성립  
③ C(법인) → 도급인 지위에서 안전조치 위반 → 중대재해처벌법 및 산안법 위반 유죄  
④ 도금조 작업환경 위험성 예견 가능성 + 사전조치 미이행 → 결과발생에 대한 인과관계 인정  
⑤ 최종결론: A, B, C 모두 유죄 판단

기호 설명  
- A: 피고인 1, 주식회사 C의 대표이사  
- B: 피고인 2, 주식회사 C의 현장소장  
- C: 피고인 3, 금속도금업을 영위하는 주식회사  
- 甲: 사고 당시 작업 중 사망한 하청업체 소속 근로자  

관련 태그  

"""

{{자료}}


위 판례를 보고 판례 정리를 코드블럭에 넣어서 제출 : 


  `
};

// 문서 타이틀 & 페이지 타이틀 설정
document.title = config.text.htmlTitle;
document.addEventListener('DOMContentLoaded', () => {
  document.body.style.background = config.color.bodyBg;
  document.body.style.fontFamily = config.ui.fontFamily;
  document.getElementById('mainPageTitle').textContent = config.text.mainTitle;
  document.getElementById('templateCardTitle').textContent = config.text.templateCardTitle;
  document.getElementById('outputCardTitle').textContent = config.text.outputCardTitle;
  document.getElementById('resetTemplateBtn').textContent = config.text.resetTemplate;
  document.getElementById('collapseBtn').setAttribute("aria-label", config.text.collapse);
  document.getElementById('resetAllInputsBtn').textContent = config.text.clearAllInputs;
  document.getElementById('copyBtn').textContent = config.text.copy;
  document.getElementById('clearPromptBtn').textContent = config.text.outputClear;
});

</script>

<!-- 메인 타이틀 -->
<div class="flex flex-col items-center py-8">
  <h1 id="mainPageTitle" class="text-3xl font-bold mb-4 text-[#1DA1F2]">동적 프롬프트 생성기</h1>
</div>

<div class="w-full max-w-3xl mx-auto"
  style="
    border-radius: 1.5rem;
    background: #FFFFFF;
    box-shadow: 0 4px 24px rgba(29,161,242,0.08);
    border: 1.5px solid #E1E8ED;
    margin-top: 1rem;
    margin-bottom: 3rem;
    backdrop-filter: blur(6px);
  ">

  <!-- 템플릿 카드 -->
  <div class="relative group">
    <div class="flex items-center justify-between px-7 pt-7 pb-3">
      <span id="templateCardTitle" class="text-xl font-bold flex items-center gap-2" style="color: #1DA1F2;">
        <svg class="inline w-6 h-6" fill="none" stroke="#1DA1F2" stroke-width="2"
         viewBox="0 0 24 24"><path d="M9 12l2 2 4-4"></path><path d="M20 12a8 8 0 11-16 0 8 8 0 0116 0z"></path></svg>
        프롬프트 템플릿
      </span>
      <div class="flex gap-1">
        <button id="resetTemplateBtn"
         class="rounded-xl px-3 py-1 text-xs font-medium shadow-sm transition-all"
         style="color: #1DA1F2; background: #E1E8ED;"
        >템플릿 초기화</button>
        <button id="collapseBtn"
         class="rounded-xl px-2 py-1 text-xs font-medium transition-all"
         aria-label="접기/펼치기"
         style="color: #1DA1F2; background: #F5F8FA;">
          <span id="collapseIcon" class="transition-all duration-300 inline-block rotate-0">&#9654;</span>
        </button>
      </div>
    </div>
    <div id="templateCollapse" class="px-7 pb-4 transition-all overflow-hidden" style="display: none;">
      <textarea id="templateArea" rows="8"
        class="w-full p-4 rounded-xl border-2 focus:ring-2 font-mono text-sm resize-none shadow"
        style="min-height:120px; border-color:#E1E8ED; background:#F5F8FA; color:#14171A;"
        placeholder="프롬프트 템플릿에 {{placeholder}}를 원하는 만큼 사용하세요"></textarea>
      <div class="flex justify-end pt-1">
        <span class="text-xs" style="color: #AAB8C2;">템플릿 내 <span class="font-semibold">{{placeholder}}</span> 자동 인식</span>
      </div>
    </div>
  </div>

  <!-- 동적 인풋 카드 -->
  <form id="dynamicInputs" class="space-y-8 px-7 pt-3 pb-2"></form>

  <!-- 일괄입력초기화 버튼 -->
  <div class="flex justify-end pr-7 pb-1">
    <button id="resetAllInputsBtn"
      class="rounded-xl px-3 py-1 text-xs font-medium shadow-sm transition-all"
      style="color: #1DA1F2; background: #E1E8ED;"
    >입력값 모두 비우기</button>
  </div>

  <!-- 결과 카드 -->
  <div id="outputSection" class="mt-8 px-7 pb-10 hidden">
    <div class="flex items-center justify-between mb-2">
      <span id="outputCardTitle" class="font-semibold flex items-center gap-1" style="color:#1DA1F2;">
        <svg class="inline w-5 h-5" fill="none" stroke="#1DA1F2" stroke-width="2"
         viewBox="0 0 24 24"><path d="M12 20h9"></path><path d="M12 4v16"></path><path d="M4 12h8"></path></svg>
        프롬프트 결과
      </span>
      <div class="flex gap-2">
        <button id="copyBtn"
          class="rounded-lg px-3 py-1 text-xs shadow transition"
          style="background: #F5F8FA; color: #14171A; border:1px solid #E1E8ED;">복사</button>
        <button id="clearPromptBtn"
          class="rounded-lg px-3 py-1 text-xs shadow transition"
          style="background: #E1E8ED; color: #1DA1F2;">초기화</button>
      </div>
    </div>
    <div class="relative">
      <textarea id="promptOutput" rows="18" readonly
        class="w-full p-4 rounded-2xl border font-mono text-[15px] resize-none shadow-inner transition-all select-all"
        style="border-color:#E1E8ED; background:#F5F8FA; color:#14171A; outline:0;"></textarea>
      <div id="generatingStatus" class="absolute bottom-2 right-4 text-xs" style="color:#1DA1F2; display:none;">프롬프트 생성중...</div>
    </div>
  </div>
</div>

<script>
const keys = config.keys;

const templateArea = document.getElementById('templateArea');
const dynamicInputs = document.getElementById('dynamicInputs');
const promptOutput = document.getElementById('promptOutput');
const outputSection = document.getElementById('outputSection');
const copyBtn = document.getElementById('copyBtn');
const clearPromptBtn = document.getElementById('clearPromptBtn');
const generatingStatus = document.getElementById('generatingStatus');
const collapseBtn = document.getElementById('collapseBtn');
const collapseIcon = document.getElementById('collapseIcon');
const templateCollapse = document.getElementById('templateCollapse');
const resetTemplateBtn = document.getElementById('resetTemplateBtn');
const resetAllInputsBtn = document.getElementById('resetAllInputsBtn');

let state = {};
let variables = [];
let debounceTimer = null;
let isCollapsed = true;

// --- 한글 변수명 포함 추출, 중복 제거 ---
function extractVars(template) {
  const matches = [...template.matchAll(/{{\s*([가-힣\w\d_]+)\s*}}/g)];
  return Array.from(new Set(matches.map(m => m[1])));
}

// --- 입력필드 동적 생성 ---
function renderInputs() {
  dynamicInputs.innerHTML = '';
  variables.forEach(varName => {
    const val = state[varName] || '';
    const charCount = val.length;
    const lineCount = (val.match(/\n/g) || []).length + 1;
    const wrap = document.createElement('div');
    wrap.className = "relative group";
    wrap.innerHTML = `
      <div class="flex items-center justify-between mb-1">
        <label for="input_${varName}" class="block text-[17px] font-semibold" style="color:#1DA1F2;">${varName}</label>
        <button type="button" data-var="${varName}"
          class="clearInputBtn px-2 py-0.5 text-xs rounded transition-all"
          style="background:#E1E8ED; color:#1DA1F2;">${config.text.inputClear}</button>
      </div>
      <textarea id="input_${varName}" rows="1"
        class="w-full p-4 rounded-xl border focus:ring-2 font-medium resize-none shadow-sm transition"
        style="border-color:#E1E8ED; background:#F5F8FA; color:#14171A; min-height:2.5rem; max-height:400px; overflow:auto;"
        placeholder="${varName} 입력">${val}</textarea>
      <div class="flex justify-between text-[12px] mt-1" style="color:#AAB8C2;">
        <span>${lineCount}줄, ${charCount}자</span>
        <span>${config.text.autoSave}</span>
      </div>
    `;
    dynamicInputs.appendChild(wrap);
    const ta = wrap.querySelector('textarea');

    // 자동 높이 조절
    function autoResize() {
      ta.style.height = 'auto';
      ta.style.height = Math.min(ta.scrollHeight, 400) + 'px';
    }
    ta.addEventListener('input', () => {
      state[varName] = ta.value;
      saveState();
      autoGeneratePrompt();
      wrap.querySelector('span').textContent =
        `${(ta.value.match(/\n/g)||[]).length+1}줄, ${ta.value.length}자`;
      autoResize();
    });
    // 글자수 표시 초기화
    autoResize();

    // 즉시 초기화 (confirm 없음)
    const clrBtn = wrap.querySelector('.clearInputBtn');
    clrBtn.onclick = function() {
      ta.value = '';
      state[varName] = '';
      saveState();
      autoGeneratePrompt();
      wrap.querySelector('span').textContent = '1줄, 0자';
      autoResize();
    };
  });
}

// --- 상태 저장/복원 ---
function saveState() {
  localStorage.setItem(keys.state, JSON.stringify(state));
}
function loadState() {
  try {
    state = JSON.parse(localStorage.getItem(keys.state) || '{}');
  } catch {
    state = {};
  }
}

// --- 프롬프트 생성 ---
function autoGeneratePrompt() {
  clearTimeout(debounceTimer);
  generatingStatus.style.display = '';
  debounceTimer = setTimeout(() => {
    if (variables.some(v => !state[v] || !state[v].trim())) {
      promptOutput.value = '';
      outputSection.classList.add('hidden');
      localStorage.removeItem(keys.prompt);
      generatingStatus.style.display = 'none';
      return;
    }
    let result = templateArea.value;
    variables.forEach(v => {
      const reg = new RegExp(`{{\\s*${v}\\s*}}`, "g");
      result = result.replace(reg, state[v] || '');
    });
    promptOutput.value = result;
    outputSection.classList.remove('hidden');
    generatingStatus.style.display = 'none';
    localStorage.setItem(keys.prompt, result);
  }, 600);
}

// --- 템플릿 변경 시 ---
function onTemplateChange() {
  const tmpl = templateArea.value;
  variables = extractVars(tmpl);
  variables.forEach(v => { if (typeof state[v] !== 'string') state[v]=''; });
  Object.keys(state).forEach(k => { if (!variables.includes(k)) delete state[k]; });
  saveState();
  renderInputs();
  autoGeneratePrompt();
}

// --- 템플릿 콜랩스 토글 ---
collapseBtn.onclick = function() {
  isCollapsed = !isCollapsed;
  if(isCollapsed) {
    templateCollapse.style.display = 'none';
    collapseIcon.style.transform = 'rotate(-90deg)';
    collapseIcon.innerHTML = '&#9654;';
  } else {
    templateCollapse.style.display = 'block';
    collapseIcon.style.transform = 'rotate(0deg)';
    collapseIcon.innerHTML = '&#9660;';
  }
};

// --- 템플릿 초기화 (즉시) ---
resetTemplateBtn.onclick = function() {
  templateArea.value = config.templateDefault;
  localStorage.setItem(keys.template, config.templateDefault);
  onTemplateChange();
  if(isCollapsed) collapseBtn.click();
};

// --- 입력값 모두 초기화 (즉시) ---
resetAllInputsBtn.onclick = function() {
  variables.forEach(v => state[v]='');
  saveState();
  renderInputs();
  autoGeneratePrompt();
};

// --- 복사 버튼 ---
copyBtn.onclick = function() {
  promptOutput.select();
  document.execCommand('copy');
  copyBtn.innerText = config.text.copyDone;
  setTimeout(()=>{ copyBtn.innerText = config.text.copy; }, 1200);
};

// --- 프롬프트 초기화 ---
clearPromptBtn.onclick = function() {
  promptOutput.value = '';
  outputSection.classList.add('hidden');
  localStorage.removeItem(keys.prompt);
};

// --- 프롬프트 클릭시 자동 전체선택 ---
promptOutput.onclick = function() { promptOutput.select(); };

// --- 템플릿 입력 이벤트 ---
templateArea.addEventListener('input', () => {
  localStorage.setItem(keys.template, templateArea.value);
  onTemplateChange();
});

// --- 상태/템플릿 복원 ---
function loadAll() {
  let tmpl = localStorage.getItem(keys.template);
  if (!tmpl) {
    tmpl = config.templateDefault;
    localStorage.setItem(keys.template, tmpl);
  }
  templateArea.value = tmpl;
  loadState();
  const prompt = localStorage.getItem(keys.prompt);
  if (prompt) {
    promptOutput.value = prompt;
    outputSection.classList.remove('hidden');
  }
}

// --- 최초 진입 시 실행 ---
window.addEventListener('DOMContentLoaded', () => {
  // 처음에는 템플릿이 접혀 있도록 세팅
  isCollapsed = true;
  templateCollapse.style.display = 'none';
  collapseIcon.style.transform = 'rotate(-90deg)';
  collapseIcon.innerHTML = '&#9654;';
  loadAll();
  onTemplateChange();
});
</script>
</body>
</html>
