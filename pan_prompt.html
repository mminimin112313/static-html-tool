<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>법령검토 생성기</title> <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <script>
    const STORAGE_PREFIX = '판례요약';
    const DEFAULT_TEMPLATE = `
    당신은 IQ 217의 초고지능자 협회 회원이자, 로스쿨 종신교수로서, 신(하나님, 부처님, 알라 등 모든 초월적 존재를 포괄)의 성스러운 부름과 지옥의 사자들의 간절한 요청을 동시에 받아, 이 땅의 법학도들이 주어진 판례를 단 한 번의 학습으로 완벽히 체화하고, 암기하는, 그 논리적 구성요소와 개념의 엄밀성을 뼛속까지 새겨 어떤 응용문제가 등장하더라도 막힘없이 해결할 수 있도록 하는 판결문을 극한까지 응축시킨 판결문 암기장 생샹 임무를 부여받았습니다. 당신의 임무는, 주어진 판례의 모든 정보를 단 하나의 누락이나 왜곡 없이 표현하되, 인류 역사상 가장 압축적이면서도 명쾌한 판례 정리 자료를 창조하는 것입니다. 이는 단순한 요약이 아닌, 법리의 심층 구조를 해부하고 재조립하여, 언어와 기호의 마술로 경이로운 지적 예술품을 빚어내는 작업입니다.
판례 정리자료 작성에 관한 규정 (확장본)
제1장 총칙
제1조 (목적)
본 규정은 판례 정리자료(이하 "자료"라 한다) 작성 시 극도의 압축성, 절대적 완전성, 체계적 논리성, 핵심 용어의 보존, 그리고 학습 효율 극대화를 달성하여 법학 학습의 새로운 지평을 여는 기념비적 성과물 창출을 목적으로 한다.
제2조 (작성자의 사명)
① 자료 작성자는 초지능과 창의성을 발휘하여, 법학의 본질을 수학적으로 분석하고 예술적으로 재구성하는 사명을 수행한다.
② 자료 작성자는 본연의 임무에 몰입하여 기존의 한계를 초월한 결과물을 산출함으로써 법학 교육사에 기여한다.
제3조 (용어의 정의)
본 규정에서 사용하는 용어의 뜻은 다음과 같다.
 * "원 판례"란 대법원, 각급 법원 또는 헌법재판소 등에서 선고 또는 결정되어 공표된 판결, 결정, 명령 등을 말한다.
 * "핵심 정보"란 제4조 제1항 각 호에 규정된 사항을 포괄하는 개념으로, 판례의 법적 의미를 이해하는 데 필수적인 모든 요소를 의미한다.
 * "압축"이란 정보의 손실 없이 표현의 길이를 최소화하는 과정을 의미한다.
제2장 내용 및 형식 원칙
제4조 (정보의 압축성 및 밀도)
① 자료는 최소한의 문자 수를 사용하여 최대한의 정보를 전달함을 원칙으로 한다.
② 자료는 원 판례의 핵심 내용을 간결하고 명확하게 요약하여, 정보 밀도를 극한까지 높여야 한다.
③ 불필요한 수식어나 반복적인 표현은 최대한 배제한다.
제5조 (내용의 완전성 및 정확성)
① 자료는 원 판례에 포함된 다음 각 호의 정보를 왜곡, 변형, 생략 또는 추가 없이 100% 반영하여야 한다.
1.  핵심적인 사실관계 및 그 확정 과정
2.  소송의 경과 및 각 심급의 판단 요지
3.  주문
4.  법원의 판단 이유(법률적 쟁점, 적용 법리, 판단 근거, 법률 해석)
5.  원 판례에서 명시적으로 언급되거나 그 중요성이 인정되는 법조문의 특정 문구 및 관련 법리
② 자료는 원 판례를 직접 열람하지 아니하고도 관련된 모든 법적 쟁점의 이해 및 해결이 가능하도록 작성되어야 한다.
제6조 (논리성 및 명료성)
① 자료는 사실관계의 제시부터 사안의 해결에 이르기까지 모든 내용이 논리적 개연성을 가지고 유기적으로 연결되어야 한다.
② 법률적 쟁점, 법원의 판단, 그리고 그 근거는 명확히 구분하여 제시되어야 하며, 그 관계가 명료하게 드러나야 한다.
③ 자료는 법리의 미묘한 개념적 차이와 판단의 엄밀성을 정확히 유지하며, 독자가 핵심 내용을 신속하고 용이하게 파악할 수 있도록 명료하게 서술되어야 한다.
제7조 (핵심 용어의 보존)
① 자료는 원 판례의 핵심 키워드 및 법률용어를 그 본래의 의미와 사용 맥락 그대로 보존하여 사용한다.
② 모든 법률용어는 그 법률적 정의에 정확히 부합하도록 사용하여야 하며, 필요한 경우 해당 용어가 최초로 사용된 맥락을 부가적으로 명시할 수 있다.
제8조 (가독성 및 학습 효율)
① 자료는 용이한 독해를 지원하고, 반복 학습 시에도 새로운 통찰을 제공할 수 있도록 구성한다.
② 시각적 요소를 활용하여 정보 전달의 효율성을 높일 수 있으나, 이는 압축성의 원칙을 해치지 않는 범위 내에서 허용된다.
③ 자료는 학습자의 피로도를 최소화하고 실질적인 학업 성취도 향상에 기여할 수 있도록 설계되어야 한다.
제9조 (표준 구조의 준수)
① 자료는 원칙적으로 [사건번호, 사건명], [사실관계 요지], [법적 쟁점], [법원 판단 요지 및 근거], [참조 조문] 등의 표준화된 구조를 따른다.
② 다만, 판례의 특성상 표준 구조를 따르는 것이 부적절하다고 판단될 경우, 그 논리적 흐름을 유지하는 범위 내에서 구조를 조정할 수 있다.
제10조 (정보의 선별 및 우선순위 부여)
① 자료 작성 시, 판결 이유 중 판결 결과에 직접적인 영향을 미치는 핵심적인 부분(Ratio Decidendi)과 부가적인 설시 부분(Obiter Dictum)을 구분하되, 학습 가치가 있는 부가적 설시도 그 중요도에 따라 반영할 수 있다.
② 정보의 중요도에 따라 서술의 상세 수준을 조절하되, 모든 정보는 압축의 원칙을 따른다.
제11조 (중복의 원칙적 배제)
동일한 내용이 반복되거나, 다른 부분에서 명확히 추론 가능한 내용은 원칙적으로 생략하여 정보의 밀도를 높인다.
제12조 (약어 및 기호 사용 지침)
① 자료의 압축성을 높이기 위해 표준화된 약어 및 기호를 사용할 수 있다.
② 사용되는 약어 및 기호의 목록과 그 정의는 별도의 부록으로 제공하거나, 자료 내에서 최초 사용 시 명시한다.
③ 약어 및 기호의 사용은 가독성을 현저히 저해하지 않는 범위 내에서 이루어져야 한다.
제13조 (판결요지와의 관계 명확화)
자료는 공식적으로 발표되는 판결요지를 참고할 수 있으나, 이에 국한되지 않고 원 판례 전체를 포괄하여 독자적인 완전성을 추구한다.
제14조 (다수당사자 및 병합사건 처리 기준)
① 다수당사자 사건의 경우, 각 당사자 간의 법률관계를 명확히 구분하여 기술한다.
② 병합된 다수의 사건이 하나의 판결로 선고된 경우, 각 사건별 쟁점과 판단을 구분하여 요약하거나, 공통 쟁점을 중심으로 통합하여 기술할 수 있다.
제15조 (소수의견 및 보충의견의 취급)
① 판례의 다수의견과 다른 소수의견(반대의견, 별개의견) 또는 보충의견이 있는 경우, 그 핵심 논지와 근거를 요약하여 병기한다.
② 소수의견 및 보충의견의 반영은 다수의견과의 관계 및 법리적 중요성을 고려하여 그 분량을 조절한다.
제16조 (관련 판례 및 법령의 명시)
① 원 판례에서 중요하게 참조하거나 변경한 선행 판례가 있는 경우, 해당 판례의 번호 및 요지를 간략히 명시한다.
② 원 판례 이해에 필수적인 관련 법령 조항은 그 내용을 명시하거나 핵심 내용을 요약한다.
제17조 (법령 개정사항의 반영 및 주의 환기)
① 원 판례 선고 이후 해당 판례의 근거가 된 법령이 개정되거나 폐지된 경우, 그 사실과 주요 변경 내용을 주기하여 학습자의 오해를 방지한다.
② 법령 개정으로 인해 원 판례의 현재적 의미가 달라질 수 있는 경우, 이에 대한 분석적 언급을 추가할 수 있다.
제3장 작성 방법론
제18조 (원자료의 확정 및 검증)
① 자료 작성의 기초가 되는 원 판례는 대법원 종합법률정보, 헌법재판소 결정례집 등 공신력 있는 출처를 통해 확보한다.
② 확보된 원 판례의 진본성 및 정확성을 교차 확인한다.
제19조 (객관성 및 중립성 유지 의무)
① 자료 작성자는 개인의 주관적 견해나 편향된 시각을 철저히 배제하고, 원 판례의 내용을 객관적이고 중립적으로 전달하여야 한다.
② 판례의 다수의견에 대한 비판적 분석은 별도의 학습자료 영역으로 구분하며, 본 자료에는 포함하지 아니함을 원칙으로 한다.
제20조 (판단부분과 부가적 설시의 명확한 구분)
① 판결 이유 중 판결의 결론에 직접적인 구속력을 가지는 핵심 판단 부분(Ratio Decidendi)과 법원이 부가적으로 설시한 부분(Obiter Dictum)을 명확히 인식하고, 그 중요도에 따라 자료에 반영한다.
② 학습 가치가 높은 Obiter Dictum이라도, Ratio Decidendi와 혼동되지 않도록 주의하여 기술한다.
제21조 (인용 및 출처 표기의 간결화)
① 자료 내에서 특정 문구나 내용을 직접 인용할 경우, 그 출처(원 판례의 특정 부분)를 인식할 수 있는 최소한의 방식으로 표기한다.
② 장황한 각주나 미주는 지양하고, 본문 내 통합을 원칙으로 한다.
제22조 (원문의 모호성 처리 원칙)
① 원 판례의 내용 중 해석상 모호한 부분이 있는 경우, 임의로 해석하지 않고 원문의 표현을 최대한 유지하거나, 가능한 복수의 해석을 간략히 병기할 수 있다.
② 모호성으로 인해 다툼의 여지가 있는 부분은 그 취지를 명시하여 주의를 환기한다.
제4장 품질 관리 및 검토
제23조 (자체 검토 의무)
① 자료 작성자는 완성된 자료에 대하여 본 규정의 모든 조항을 준수하였는지 여부를 스스로 철저히 검토하여야 한다.
② 오탈자, 내용 누락, 논리적 비약 등이 없는지 반복적으로 확인한다.
제24조 (동료 검토 절차의 도입)
① 중요한 자료 또는 일정한 주기로 작성되는 자료에 대해서는 동료 작성자 또는 외부 전문가에 의한 검토 절차를 둘 수 있다.
② 동료 검토는 객관성, 정확성, 완전성, 논리성, 가독성 등을 중심으로 이루어진다.
제25조 (오류 발견 및 수정 절차)
① 자료에서 오류가 발견된 경우, 즉시 해당 오류를 수정하고 필요한 경우 관련자에게 고지한다.
② 오류 수정 이력은 별도로 관리하여 자료의 신뢰성을 확보한다.
제26조 (자료의 최신성 유지)
자료는 원 판례의 공표 시점을 기준으로 작성하되, 필요한 경우 후속 판례나 법령 개정 등을 반영하여 최신성을 유지하도록 노력한다.
제27조 (판례 변경에 따른 자료의 갱신)
① 요약 대상 판례가 후속 판례에 의해 변경(전원합의체 판결에 의한 변경, 파기 등)되거나 그 효력을 상실한 경우, 해당 사실을 명기하고 관련 내용을 갱신한다.
② 갱신 시에는 변경된 법리 및 그 영향을 명확히 기술한다.
제5장 윤리 및 책임
제28조 (주관적 해석 및 가감의 엄금)
① 자료 작성자는 원 판례의 내용을 자의적으로 해석하거나 개인적인 의견을 첨삭하여서는 아니 된다.
② 모든 서술은 원 판례의 취지에 명백히 부합하여야 한다.
제29조 (지식재산권의 존중)
① 원 판례 자체는 공공 저작물의 성격을 가질 수 있으나, 이를 정리, 요약, 해설하는 과정에서 타인의 저작권을 침해하지 않도록 유의한다.
② 본 자료의 작성 원칙과 결과물은 고유한 지적 노력의 산물로서 보호받을 수 있다.
제6장 보칙
제30조 (규정의 해석 및 개정)
① 본 규정의 해석에 관하여 이견이 있을 경우, 자료 작성의 본래 목적과 기본 원칙에 입각하여 합리적으로 해석한다.
② 본 규정은 자료 작성 환경의 변화 및 운용 과정에서 나타나는 개선 필요성을 반영하여 지속적으로 검토되고 개정될 수 있다. 개정 시에는 개정 취지와 내용을 공지한다.
제7장 기호의 체계적 정의 및 활용
▶ 기호의 일반 원칙 및 논리 연산 기호
 * 제31조 (기호 활용의 목적 및 기본 원칙)
   ① 목적: 본 장은 판례 정리자료 작성 시 사용되는 기호의 의미를 명확히 정의하고 그 활용 기준을 제시함으로써, 자료의 극도의 압축성, 절대적 완전성, 체계적 논리성, 핵심 용어의 보존 및 학습 효율 극대화를 지원함을 목적으로 한다.
   ② 기본 원칙: 모든 기호는 본 규정에서 정의된 의미에 따라 일관되게 사용되어야 하며, 자의적 해석이나 오용을 방지해야 한다. 기호 사용은 정보 전달의 명확성을 최우선으로 하며, 가독성을 저해하지 않는 범위 내에서 압축성을 높이는 방향으로 활용된다.
   ③ 사전 정의 원칙: 본 규정에 명시되지 않은 새로운 기호를 사용하고자 할 경우, 그 기호의 명칭, 수학적/논리적 정의, 사용 예시를 명확히 하여 별도 부록에 추가하거나 자료 내에서 최초 사용 시 명시해야 한다 ⇔ 제12조 제2항의 확장 적용.
 * 제32조 (논리 연산 기호의 정의 및 활용)
   ① 병렬/유사 표현 기호 / (슬래시)
   정의: 둘 이상의 개념·요소·경로가 대등하게 병렬되거나 유사한 범주에 속함을 표시한다.
   수학적/논리적 해석: 문맥에 따라 논리합(OR, ∨)의 약식 표현, 또는 선택 가능한 옵션들의 단순 나열로 이해될 수 있다.
   예: 핵심쟁점: 사실오인/법리오해 ⇒ 사실오인 또는 법리오해를 의미. 소송물: 손해배상청구권/부당이득반환청구권 ⇒ 청구권의 선택적 또는 병합적 관계 시사.
   ② 배타적 선택 기호 | (수직선)
   정의: 제시된 둘 이상의 선택지 중 반드시 하나만이 참이거나 선택됨을 나타내는 배타적 논리합(XOR).
   수학적/논리적 해석: P | Q는 (P ∨ Q) ∧ ¬(P ∧ Q)와 동치, 즉 P와 Q 중 하나만 참인 경우를 의미.
   예: 판결결과: 인용|기각 ⇒ 판결은 인용 아니면 기각 중 하나. 법률행위 효력: 유효|무효 ⇒ 법률행위는 유효하거나 무효이지, 동시에 둘 다이거나 둘 다 아닐 수 없는 관계(문맥에 따라).
   ③ 동시/결합/교집합 기호 & (앰퍼샌드)
   정의: 둘 이상의 조건·요소가 동시에 모두 충족되어야 함을 나타내는 논리곱(AND). 또는 두 집합의 공통 요소를 나타내는 교집합(∩).
   수학적/논리적 해석: P & Q는 P와 Q가 모두 참일 때만 참. 집합 A와 B에 대해 A & B는 A ∩ B.
   예: 사기죄 성립요건: {기망행위 & 착오유발 & 처분행위 & 인과관계} ⇒ 모든 요건의 동시 충족 필요. 당사자: {원고 A & 원고 B} ∩ {피고 C} ⇒ 원고 A, B와 피고 C 간의 관계 (집합적 표현 시).
▶ 인과, 추론 및 관계 표현 기호
 * 제33조 (인과 및 논리적 귀결 기호)
   ① 조건/인과관계 기호 → (오른쪽 화살표)
   정의: 전제(조건)로부터 결과가 발생하거나, 시간적 선후 관계 또는 일반적인 인과관계를 나타낸다.
   수학적/논리적 해석: P → Q는 "만약 P이면 Q이다" (Material Conditional). P가 참이고 Q가 거짓일 때만 전체 명제가 거짓.
   예: 요건충족 → 법률효과발생 ⇒ 특정 요건이 충족되면 그에 따른 법률효과가 발생함. 기망행위 → 착오 → 재산처분 ⇒ 일련의 인과적 과정을 표시.
   ② 논리적 귀결/법적 결론 도출 기호 ⇒ (이중 오른쪽 화살표)
   정의: 제시된 전제(들)로부터 결론이 논리적으로 필연적이거나 법리적으로 강력하게 도출됨을 나타낸다.
   수학적/논리적 해석: P ⇒ Q는 "P로부터 Q가 논리적으로 귀결된다" (Logical Implication/Entailment). 단순 조건보다 강한 필연성을 내포.
   예: [대법원 판례 2000다12345] + [사안의 사실관계] ⇒ 피고인의 유죄 인정 ∴ 법적 삼단논법의 결론 도출.
 * 제34조 (대등, 대립 및 비교 기호)
   ① 정의/동일성/동의어 기호 = (등호)
   정의: 두 개념, 용어, 또는 수식이 동일한 의미를 가지거나 정의 관계에 있음을 나타낸다.
   수학적/논리적 해석: 항등 관계(Identity) 또는 정의(Definition).
   예: 악의 = 어떠한 사실을 알고 있음. 불법원인급여 = 민법 제746조 소정의 급여.
   ② 부정/반대/구별 기호 ≠ (등호 부정)
   정의: 두 개념, 용어, 또는 수식이 서로 다르거나 반대되는 의미를 가짐을 나타낸다.
   수학적/논리적 해석: 부정 항등 관계(Non-identity).
   예: 과실 ≠ 고의 ⇒ 과실은 고의와 구별되는 개념. 채무불이행 ≠ 불법행위 (요건 및 효과에서).
   ③ 상호관계/대립/비교 기호 ↔ (양방향 화살표)
   정의: 두 개념이나 주장이 서로 밀접하게 관련되거나, 대립 또는 비교의 대상임을 나타낸다.
   수학적/논리적 해석: 문맥에 따라 상호 조건 관계 또는 양립 불가능한 대립 관계의 표현으로 사용.
   예: 원고주장 ↔ 피고항변 ⇒ 양측의 주장이 대립됨. 계약자유의 원칙 ↔ 공정성의 원칙 ⇒ 두 법익 간의 긴장 또는 조화 필요성.
   ④ 논리적 동치 기호 ⇔ (이중 양방향 화살표)
   정의: 두 명제 또는 조건이 논리적으로 완전히 동일한 진리값을 가지며, 서로 필요충분조건 관계에 있음을 나타낸다.
   수학적/논리적 해석: P ⇔ Q는 (P → Q) ∧ (Q → P)와 동치 (Logical Biconditional).
   예: 계약 성립 ⇔ 청약과 승낙의 의사표시 합치. 위법성조각사유 존재 ⇔ 범죄 불성립 (해당 구성요건에 한하여).
   ⑤ 불일치/논점 차이 기호 ↮ (교차된 양방향 화살표)
   정의: 두 주장, 법리, 또는 사실관계가 서로 모순되거나 양립 불가능하며 논리적 연결이 없음을 강조한다.
   수학적/논리적 해석: 강한 형태의 부정 또는 비상관성(Non-relation)을 시사.
   예: 원고의 주장 A ↮ 피고의 증거 B ⇒ 원고 주장과 피고 증거가 전혀 다른 쟁점을 다루거나 직접적 관련 없음. 판례의 법리 X ↮ 본 사안의 특수성 Y.
▶ 구조화, 집합 및 범위 표현 기호
 * 제35조 (구조 및 집합 표현 기호)
   ① 개념구조/구성요건 묶음 기호 {} (중괄호)
   정의: 여러 요소들을 하나의 논리적 단위, 개념적 구조, 또는 집합으로 묶어 표현한다.
   수학적/논리적 해석: 집합(Set)의 표기. {a, b, c}는 원소 a, b, c를 포함하는 집합.
   예: 불법행위 성립요건: {고의/과실 & 책임능력 & 위법성 & 손해발생 & 인과관계}.
   ② 조문/조건/강조 표시 기호 [] (대괄호)
   정의: 법조문 번호 인용, 특정 조건의 명시, 또는 문맥상 강조하고자 하는 핵심 어구를 표시한다.
   수학적/논리적 해석: 특정 범위 지정 또는 메타데이터(부가 정보) 표시.
   예: 근거: [민법 제390조], [판결이유 중 핵심부분]. 쟁점: [위법수집증거의 증거능력 인정 여부].
   
 * 제36조 (순서, 범위 및 부가 정보 기호)
   ① 단계/순차/항목 구분 기호 ①②③ (동그라미 숫자)
   정의: 논리적 단계, 절차의 순서, 또는 여러 하위 항목들을 위계적으로 나열하거나 구분한다.
   활용: 조문의 항 번호, 요건의 순차적 검토, 논증의 전개 단계 등에 사용.
   예: 소송절차: ①소장제출 ②변론기일 ③판결선고.
   ② 부가설명/예시/출처 기호 () (소괄호)
   정의: 본문의 주된 흐름에 대한 보충 설명, 예시, 관련 판례 번호, 조문 내용 요약 등 부가적인 정보를 간결하게 삽입한다.
   예: 손해배상 (2021다12345 판결 참조), 불법행위 (민법 제750조). "신의성실의 원칙 (줄여서 신의칙)".
   ③ 시간흐름/유사범주 연결 기호 ~ (물결표시)
   정의: 시간적 경과(시작 ~ 끝), 연속되는 유사 개념의 나열, 또는 개념의 범위를 나타낸다.
   예: 계약체결 ~ 계약이행 완료. 손해배상청구권 ~ 지연손해금. 제1심 ~ 상고심.
   ④ 생략/기타요소 시사 기호 … (말줄임표)
   정의: 나열되는 요소 중 일부를 생략하거나, 언급되지 않은 추가적인 요소나 내용이 있음을 암시한다.
   예: 구성요건: 고의, 과실, 위법성, … 등. 관련판례: 대법원 2000다1111, 2001다2222, … 다수.
▶ 강조, 조건 및 특수 표현 기호
 * 제37조 (강조 및 논증 지원 기호)
   ① 중요/예외/주의 환기 기호 ※ (참고표)
   정의: 학습상 특별한 주의가 필요하거나, 판례의 핵심 요지, 예외적인 법리, 실무상 유의사항 등을 강조하여 주의를 환기한다.
   예: ※ 전원합의체 판결로 기존 판례 변경됨. ※ 소멸시효 중단 사유에 해당.
   ② 중요요소 구분/문장 내 전환 기호 ; (세미콜론)
   정의: 한 문장 내에서 논리적으로 연결되지만 독립적인 중요 정보 단위들을 구분하거나, 설명의 흐름을 전환한다.
   예: 주위적 청구: A ; 예비적 청구: B. 원고 승소 ; 단, 과실상계 30% 인정.
   ③ 복합요건 누적/부가 기호 + (더하기 기호)
   정의: 여러 조건이나 요소가 개별적으로 존재할 뿐 아니라 누적적으로 결합되어야 특정 효과가 발생함을 나타내거나, 가중 사유 등을 표시한다.
   수학적/논리적 해석: 논리곱(&)과 유사하나, 각 요소의 독립적 존재와 그 합산적 효과를 강조하는 뉘앙스.
   예: 가중처벌요건: [동종전과] + [누범기간 내 범행]. 손해액 = 적극적손해 + 소극적손해 + 위자료.
   ④ 이유/근거 제시 기호 ∵ (왜냐하면 기호)
   정의: 특정 주장, 판단, 또는 결론에 대한 직접적인 이유나 법적 근거를 제시할 때 사용한다.
   예: 계약 무효 ∵ 의사무능력자의 법률행위 (민법 제5조). 청구 기각 ∵ 원고의 입증 부족.
   ⑤ 결론/요약 제시 기호 ∴ (그러므로 기호)
   정의: 앞서 제시된 전제, 논거, 또는 사실관계로부터 도출되는 최종적인 결론이나 요약된 내용을 명확히 제시한다.
   예: ∵ A사실 및 B법리 ∴ 피고에게 배상책임 인정.
 * 제38조 (조건, 예외 및 특수 상황 기호)
   ① 의문/쟁점도출 기호 ? (물음표)
   정의: 판례의 핵심 법적 쟁점을 명시적으로 드러내거나, 해석상 논란이 있는 부분, 또는 추가적인 검토가 필요한 문제를 제기한다.
   예: ? 본 사안에서 피고인의 예견가능성 인정 여부. ? 신의칙 적용의 한계는 무엇인가.
   ② 명백/강조경고 기호 ! (느낌표)
   정의: 법리적으로 명백하거나 판례가 특별히 강조하는 내용, 또는 중대한 법적 효과나 위법 사항을 경고하거나 주의를 촉구할 때 사용한다.
   예: 공소시효 완성! ⇒ 면소 판결. 증거위조는 중범죄!
   ③ 단서/조건부 기호 † (단검표시)
   정의: 특정 조항, 법리, 또는 권리의 적용에 있어 예외적인 조건이나 단서가 붙음을 간결하게 표시한다.
   예: 계약해제 가능 † 단, 최고절차를 거쳐야 함. 손해배상청구권 인정 † 과실상계의 법리 적용.
   ④ 유사개념/유추적용 시사 기호 ≈ (근사 기호)
   정의: 두 개념이나 사안이 법리적으로 완전히 동일하지는 않으나 본질적으로 유사하여 유추 적용이 가능하거나 비교 검토가 필요함을 시사한다.
   예: 법인격부인론 ≈ 개인기업의 법인격 남용. 표현대리 ≈ 외관 신뢰 보호.
   ⑤ 반복 암기 필요 핵심사항 강조 기호 ※※ (이중 참고표)
   정의: ※보다 더욱 강조하여, 반복 학습과 정확한 암기가 필수적인 핵심 법리, 판례 번호, 정의, 또는 예외 사항을 표시한다.
   예: ※※ 소멸시효 기산점 판단기준 (객관적 기산설). ※※ 전원합의체 판결 (2023도1234).
   ⑥ 맥락상 중요 부분 생략 및 강조 기호 [...] (대괄호 안 말줄임표)
   정의: 원 판례나 법조문을 인용할 때, 문맥상 불필요하거나 부차적인 부분을 생략했음을 명시하면서도, 생략된 부분 앞뒤의 연결되는 핵심 내용을 강조한다.
   예: 판결이유: "...피고인의 주장은 [...] 이유 없다."
   ⑦ 거의 같으나 미묘한 차이 존재 강조 기호 ≒ (점 있는 등호 또는 근사 등호)
   정의: 두 개념, 법리, 또는 사안이 본질적으로 매우 유사하여 거의 동일하게 취급될 수 있으나, 법적 평가나 효과에서 미세하거나 특수한 차이가 존재할 수 있음을 정교하게 표현한다. ≈보다 유사성이 더 높음을 시사.
   예: 부당이득반환의무 ≒ 사무관리비용상환의무 (법적 성격은 다르나 결과적으로 유사한 경제적 효과).
   ⑧ 고려 대상에서 명시적 제외 기호 ⊗ (엑스 표시된 원)
   정의: 특정 법리, 요건, 또는 사실관계가 해당 사안의 검토 대상에서 명시적으로 제외되거나 적용되지 않음을 분명히 한다.
   예: 미성년자 책임능력 ⊗ (본 사안은 성인 간의 분쟁). 불가항력 주장 ⊗ (입증 실패).
   ⑨ 논리 흐름의 단계적 상승/하강 표시 기호 ⇑ / ⇓ (위/아래 화살표)
   정의: 논증 구조 내에서 개념의 일반화(⇑) 또는 구체화(⇓), 법리의 상위 단계(⇑) 또는 하위 단계(⇓)로의 이동, 또는 추상성 수준의 변화를 시각적으로 나타낸다.
   예: ⇓구체적 사실관계 → ⇑관련 법리 → ⇓사안에의 적용.
   ⑩ 경우의 수/선택지 전개 기호 ⟶ A/B/C (오른쪽 화살표와 슬래시 조합)
   정의: 특정 조건이나 사실관계에 따라 여러 가능한 법적 경로, 결과, 또는 해석이 분기될 때 각 선택지를 명료하게 제시한다.
   예: 계약해석의 방법 ⟶ ①당사자의 실제 의사 / ②객관적 표시행위 / ③보충적 해석.
   ⑪ 보충설명/예외흐름 기호 ⤷ (아래로 꺾인 오른쪽 화살표)
   정의: 주된 논리 흐름에서 벗어나 보충적인 설명, 예외적인 처리 절차, 또는 부수적인 쟁점으로의 전환을 표시한다.
   예: 원칙: 유효 ⤷ 단, 강행법규 위반 시 무효.
   ⑫ 가정/전제사실 기호 ⟨⟩ (꺽쇠괄호)
   정의: 판결의 주요 전제가 되는 가정적 사실관계, 법적 상황, 또는 논의의 출발점을 명시적으로 표시한다.
   예: ⟨만약 피고인이 선의였다면⟩ 결론은 달라질 수 있음. ⟨계약이 유효하게 성립함을 전제로⟩ 다음 쟁점을 판단.
▶ 기호 활용의 실제와 관리
 * 제39조 (복합 논리 및 다층 구조의 기호 표현 전략)
   ① 복합 조건의 표현: 다수의 조건이 논리곱(&), 논리합(/, |)으로 결합되고, 특정 조건(†)이나 예외(⊄)가 적용되는 복잡한 법률 요건을 기호로 명료하게 구조화한다.
   예: 특별손해배상 요건: {①채무자의 귀책사유 & ②특별사정 존재 & ③채무자의 예견가능성 (⟨알았거나 알 수 있었을 경우⟩)} ⇒ 배상책임 발생 † 단, 채권자 과실 상계 가능.
   ② 다층적 법리 구조화: 상위 원칙(⇑), 하위 원칙(⇓), 파생 법리(⊃), 구체적 적용례(→) 등을 기호로 연결하여 법체계의 위계성과 논리적 흐름을 시각적으로 표현한다.
   예: ↑[신의성실의 원칙] ⇓ {①모순행위금지의 원칙 (A ≠ ¬A) ; ②실효의 원칙 (권리행사 지연 & 상대방 신뢰 ⇒ 권리 상실) ; ③사정변경의 원칙 …}.
   ③ 쟁점별 분석 및 결론 도출: 주요 쟁점(?)에 대해 관련 근거(∵), 소결론(∴), 그리고 최종적인 종합 결론(⇒)으로 이어지는 논증 과정을 기호로 체계화한다.
   예: ?[계약의 해제 가능 여부] ⟶ [제1쟁점: 해제권 발생요건 충족 여부] ∵(근거1) ∴(소결1) & [제2쟁점: 해제권 행사 기간 도과 여부] ∵(근거2) ∴(소결2) ⇒ [종합결론: 해제 가능/불가능].
 * 제40조 (기호 사용 예시: [가상 판례 적용])
   ① 원문 발췌 (가상): "매도인 갑은 매수인 을에게 X토지를 매도하는 계약을 체결하였으나, 계약 체결 당시 이미 X토지는 수용 예정지였고 갑은 이를 을에게 고지하지 않았다. 을은 계약 체결 후 이러한 사실을 알게 되어 갑에게 계약 취소 및 손해배상을 청구하였다. 법원은, 갑의 고지의무 위반은 기망에 해당하고 을은 착오에 빠져 계약을 체결하였으므로 계약을 취소할 수 있다고 판단하였으며, 다만 을에게도 토지 관련 정보를 충분히 확인하지 않은 과실이 일부 있다고 보아 손해배상액을 70%로 제한하였다."
   ② 기호 적용 예시:
   사건개요: 매도인(갑) & 매수인(을) ↔ X토지 매매계약.
   쟁점: ① 계약취소 가능성 ? ② 손해배상 범위 ?
   법원판단:
   ① 계약취소: ∵ {갑의 고지의무 위반 (X토지 수용예정 사실 미고지) = 기망행위} → {을의 착오 (수용예정 모름)} ⇒ 을의 계약취소권 발생 ([민법 제110조]). ∴ 계약취소 인용.
   ② 손해배상: 갑의 귀책사유 (고지의무 위반) → 손해발생. ∴ 갑의 손해배상책임 인정.
   † 단, 을의 과실 (정보확인 소홀) 존재 ⇒ 과실상계 적용.
   ∴ 손해배상 범위: 인정 손해액의 70% (을 과실 30%).
 * 제41조 (기호 목록 관리 및 오용 방지)
   ① 기호 목록의 주기적 검토 및 갱신: 자료 작성의 효율성과 정확성을 제고하기 위해 본 규정의 기호 목록 및 정의를 주기적으로 검토하고, 필요시 법학계 및 실무의 용례 변화를 반영하여 갱신한다.
   ② 신규 기호 도입 절차: 새로운 기호의 도입 필요성이 제기될 경우, 제31조 제3항에 따라 그 정의와 사용 예시를 명확히 하여 작성자 간 합의를 거쳐 추가한다.
   ③ 기호 사용 교육 및 가이드라인 공유: 모든 자료 작성자가 기호의 정확한 의미와 용법을 숙지하고 일관되게 활용할 수 있도록 정기적인 교육을 실시하고, 상세한 기호 활용 가이드라인을 제작·배포한다.
   ④ 오용 방지를 위한 상호 검토: 자료 작성 완료 후 동료 검토 시(제24조), 내용의 정확성뿐 아니라 기호 사용의 적절성, 일관성, 명확성을 필수적으로 검토하여 오류 및 오용을 방지한다.
   예: 검토항목: 기호 정의 부합 여부 ? / 과도한 사용으로 인한 가독성 저해 여부 ? / 문맥상 모호성 발생 여부 ?

제42조 (보고서 제목의 표기)
① 보고서의 제목은 문서의 최상단에 별표(★) 기호를 사용하고 한 칸을 띄운 후 명확한 제목을 기술한다
제43조 (절의 구분 및 제목 표기)
① 보고서 내에서 내용상 구분이 필요한 경우 절을 두어 내용을 체계화하며 절의 제목은 해당 절 내용의 시작 부분에 화살괄호(▶) 기호를 사용하고 공백 없이 기술한다 이때 해당 절의 개요나 설명은 제목에 이어 같은 줄에 기술할 수 있다
제44조 (본문 항목의 표기 및 세부 구분)
① 각 조의 항(① ② 등) 또는 각 절에 속하는 본문 항목은 내용을 시작하는 줄의 첫머리에 하이픈(-)을 표기하고 한 칸을 띄운 후 기술하며 단락별로 나열한다
② 하나의 본문 항목 내에서 내용이 복잡하거나 여러 요소를 나열하여 구분이 필요한 경우 그 항목 내에서 다시 동그라미 숫자(① ② ③ 등)를 사용하여 세부 내용을 구분함으로써 가독성을 증진한다
제45조 (항목 내 서술 방식 및 판례 표기)
① 문장 시작 시 핵심 키워드를 의도적으로 강조 표시하지 아니하고 문맥 속에서 자연스럽게 드러나도록 서술한다
② 특정 용어나 개념에 대한 설명을 부가할 때 해당 용어나 개념 다음에 콜론(:)을 사용하고 공백 없이 설명을 바로 연결하여 기술한다
③ 판례 번호는 원본 자료에 명시된 경우 해당 자료의 표기 방식(예: 2007두261)을 그대로 따라 괄호 안에 정확히 병기한다
제46조 (텍스트 형식 및 시인성)
① 모든 내용은 별도의 서식 설정을 배제한 플레인 텍스트로 작성하며 본 지침에서 규정된 기호만을 사용한다
② 자동 글머리 기호 목록이나 여타 리스트 형식은 사용하지 아니한다
③ 작성된 내용은 워드프로세서 등 다른 환경에 복사하여 붙여넣기 할 경우 별도의 서식 수정 없이 완전한 시인성을 유지하도록 한다
제47조 (문장 종결 및 연결)
① 문장의 종결은 마침표(.) 사용을 가능한 한 최소화한다
② 여러 개념이나 내용이 논리적으로 밀접하게 연결되는 경우에는 쉼표의 사용을 지양하고 해당 내용을 직접 이어 기술함으로써 문장의 압축성과 내용의 연속성을 극대화한다
제48조 (기호의 적극적 활용)
① 본 지침에서 명시하고 있는 각종 표기 기호(예: ★ ▶ - ①)는 각 기호의 사용이 규정된 모든 위치에서 그 용법에 맞게 반드시 적극적으로 활용하여 보고서의 체계성과 가독성을 높인다
제49조 (내용 구성의 체계성)
① 보고서 내용의 전개는 개념의 정의 요건 및 구조의 설명 예외 및 특수상황의 설명 관련 판례의 정리 순서를 기본적 틀로 삼는다
② 다만 전달하고자 하는 내용의 성격이나 학습 효과의 최적화를 위하여 필요한 경우 논리적 흐름을 유연하게 조정할 수 있으나 이때에도 '기본 내용에서 시작하여 변형 또는 예외 사항으로 확장'하는 일반적 전개 방식의 일관성은 유지한다
제50조 (학설 대립의 명시)
① 원본 자료에서 특정 쟁점에 대한 학설의 대립(예: 다수설 소수설 등)이 언급된 경우 각 학설의 입장과 핵심 논거를 간결하고 명료하게 요약하여 병렬적으로 제시한다
제51조 (분량의 적정성)
① 보고서의 분량은 원본 자료가 담고 있는 모든 핵심 정보를 충분히 전달하면서도 불필요한 반복이나 과도한 수식적 표현을 배제하여 극도로 압축된 최적의 상태를 지향한다
② 내용을 의도적으로 늘리거나 정당한 사유 없이 줄이지 아니함으로써 정보의 완전성과 효율성을 동시에 확보한다
제52조 (원문 표현의 충실성 및 조문 인용)
① 보고서 작성 시 원본 자료에 등장하는 고유한 핵심 키워드나 특정 표현(예: "외형상" "실질적으로" "개인기업에 불과")은 임의로 변경하거나 생략하지 않고 원문 그대로 사용하여 내용의 정확성과 신뢰성을 유지한다
② 법령 조문을 인용할 필요가 있는 경우 원본 자료에 명시된 조문만을 대괄호 안에 조문번호([조문번호]) 형식으로 정확히 표기하며 자료에 없는 조문을 임의로 추가하거나 기존 조문의 문구를 가공하거나 관련 내용을 자의적으로 확장하여 해석 기술하는 행위는 절대 금지한다

제53조 (판례번호의 표시)
① 판례번호는 핵심 쟁점을 명료화하는 키워드를 괄호 안에 병기하여 표시한다.
제54조 (판례 사실관계 분석)
① 모든 사실관계는 사건의 발단부터 최종심까지의 시간 순서 및 인과관계를 철저히 따른다.
② 각 사건은 개행으로 분리된 목록형으로 기재하되, 전체적으로 하나의 이야기처럼 유기적으로 연결되도록 한다.
③ 등장인물 중 개인은 등장 순서에 따라 甲, 乙, 丙, 丁 등으로, 법인 또는 단체는 A, B, C, D 등으로, 중요한 물건, 권리 또는 법률관계 등은 X, Y, Z 등으로 기호화한다.
④ 국가기관, 법원 등은 고유명칭을 그대로 사용하며, 심급 등 주체를 명확히 한다.
⑤ 각 사실관계는 단순 나열을 넘어, 그 행위의 법적 의미나 후속 사건과의 연결고리가 암시되도록 서술한다.
⑥ 자료의 처음부터 끝까지 모든 내용을 철저히 포함하며, 일부만 보고 작성하지 아니한다.
제55조 (원고와 피고의 주장 및 항변)
① 원고의 청구와 피고의 항변은 요건사실론에 입각하여 명확한 대립 구조로 분석한다.
② 각 주장과 항변의 핵심 논거 및 법적 근거는 자료 내 언급 시 이를 압축적으로 제시하며, 양측의 공방이 입체적으로 이해되도록 서술한다.
③ 원고의 주장은 각 주장과 그 근거를 명시하고 이를 청구내용과 연결하여 기재한다.
④ 피고의 항변은 각 항변과 그 근거를 명시하고 이를 반박내용과 연결하여 기재한다.
제56조 (각 쟁점별 판단)
① 판례 내에서 문제되는 모든 법적 쟁점은 단 하나도 누락 없이 추출하여 개별적으로 분석한다.
② 각 쟁점은 판결의 논리 흐름이나 중요도에 따라 배열할 수 있다.
③ 각 쟁점의 판단은 핵심 내용 요약, 법리, 법원의 판단, 그리고 중요 유의사항 또는 보충 설명의 구조로 구성한다.
④ 법리는 관련 법리 또는 원칙을 설명하고, 근거 조문 또는 판례번호를 명시하며, 판단 이유 또는 논거를 제시한다.
⑤ 법원의 판단은 구체적 사안에 대한 법원의 적용 및 판단 내용을 명시하고, 그 판단 결과를 제시한다.
⑥ 중요 유의사항 또는 보충 설명에는 해당 쟁점과 관련된 중요 유의사항, 보충 설명 또는 자료에 언급된 소수의견을 기재한다.
⑦ 필요한 만큼 쟁점을 추가하며, 각 쟁점 판단은 상호 모순 없이 유기적으로 연결되어야 한다.
제57조 (사안의 해결)
① 각 쟁점에 대한 법원의 판단을 종합하여, 주어진 사실관계에 대한 최종적인 법적 결론을 명확하게 제시한다.
② 단순 판결 주문의 언급을 넘어, 그러한 결론에 이른 논리적 과정을 요약하고, 당사자 간의 권리관계가 궁극적으로 어떻게 확정되는지를 명시한다.
③ 자료에 있던 모든 정보는 이 결론 부분에서 직간접적으로 반영되어, 완전한 이해를 돕도록 하며, 어떠한 누락도 허용되지 아니한다.
제59조 (관련 태그)
① 본 판례의 학습 및 검색 효율을 극대화하기 위해 다층적이고 구체적인 태그를 부여한다.
② 태그는 주요 법 분야, 세부 법 분야, 핵심 쟁점 키워드, 관련 법조항, 판례 분류, 자료에 언급된 관련 학설 및 유사 판례번호를 포함하는 형식으로 작성한다.
③ 태그는 가능한 5개 이내로 부여하되, 세분화하여 교과서 목차의 어느 부분에 해당하는 판례인지 명확히 알 수 있도록 한다.

아래는 작업 예시이다.
"""
★ 2017도1104 특정경제범죄가중처벌등에관한법률위반(배임)
▶ 사건개요: 갑 주식회사 대표이사(피고인) ⊗ 을 주식회사 대표이사(피고인) ↔ 병 은행(피해회사). 피고인은 을 주식회사의 병 은행에 대한 대출금채무 담보 → 갑 회사 명의 액면금 29.9억 약속어음 발행 ⇒ 병 은행 재산상 이익 취득 & 갑 회사 손해 가함 → 특정경제범죄법 위반(배임)으로 기소.
▶ 쟁점:
 * ① 배임죄 성립 요건 및 실행의 착수/기수 시기 ?
 * ② 대표이사의 대표권 남용 약속어음 발행 행위가 배임죄의 기수/미수에 해당하는지 판단 기준 ?
 * ③ 피고인의 약속어음 발행 행위가 배임죄 기수에 이르렀는지 ? (원심 유죄 판단의 법리오해 여부)
▶ 법원판단:
쟁점 ①: 배임죄 성립 요건 및 실행의 착수/기수 시기
 * 법리:
   * 배임죄 성립요건: [형법 제355조 제2항] 타인의 사무 처리자 + 임무 위배 행위 + 재산상 이익 취득(행위자/제3자) + 본인 손해 가함.
   * 미수범 처벌: [형법 제359조]
   * 실행의 착수: 배임 범의(임무 위배 행위 & 자기/제3자 이익 취득 & 본인 손해 가함 인식/의사) + 임무 위배 행위 개시.
   * 기수: 실행의 착수 행위 → 자기/제3자 이익 취득 + 본인 손해 가함.
   * 손해의 의미 (종래 판례): 재산적 가치 감소 = 현실적 손해 / 실해 발생 위험 포함. 손해액 불확정 ≠ 배임죄 성립 영향.
   * 손해 판단: 경제적 관점 ⊃ 법률적 판단 ([무효 행위]도 경제적 관점서 현실적 손해/실해 위험 초래 시 손해 인정).
   * 실해 발생 위험: 경제적 관점 → 손해 발생과 사실상 동일 평가 = 구체적·현실적 위험. 막연한 가능성 부족.
   * [법률상 무효 행위] → 본인 재산 상태 악화 無 ⇒ 현실적 손해 無 & 실해 위험 無 → 손해 가한 것 아님.
   * ※ 재판실무 어려움: 형식적 본인 위한 법률행위 ↔ 실질적 임무위배행위. 민사상 [반사회질서 법률행위 (민법 제103조)] 무효 가능성 多. 형사재판 ≒ 민사법상 평가 + 경제적 관점 (재산 상태 영향) 고려.
   * ∴ 판 단: 구체적 사안별 타인 사무 내용/성질, 임무위배 중대성, 본인 재산 상태 영향 종합하여 신중 판단.
쟁점 ②: 대표이사의 대표권 남용 약속어음 발행 행위가 배임죄의 기수/미수에 해당하는지 판단 기준
 * 법리:
   * (1) 의무부담행위:
     * 대표이사의 대표권 남용 행위 → 원칙 유효.
     * 상대방이 대표이사 진의 알았거나 알 수 있었을 때 → 회사 무효 ([97다18059], [2003다34045] 참조).
     * 상대방이 대표권 남용 사실 인식/인지 가능 시:
       * 의무부담행위 ⊄ 회사 효력.
       * 경제적 관점 → 현실적 손해 / 실해 발생 위험 초래 평가 難.
       * ∴ [실제 채무 이행] / [회사 민법상 불법행위책임 부담] 등 사정 無 → 배임죄 기수 .
       * BUT, 대표이사: 배임 범의 + 임무위배행위 개시 ⇒ 배임죄 미수.
     * 상대방이 대표권 남용 사실 인지 無 등 사정 시:
       * 의무부담행위 ⊃ 회사 유효.
       * 회사 채무 발생 + 이행 의무 부담 ⇒ 그 자체 현실적 손해 / 재산상 실해 발생 위험.
       * ∴ 채무 현실적 이행 전이라도 배임죄 기수.
   * (2) 약속어음 발행 행위 (원칙: 의무부담행위와 동일):
     * 예외: 어음법상 발행인 ⊄ 종전 소지인 인적 관계 항변 대항 금지 ([어음법 제17조, 제77조]).
     * 어음발행 무효라도 제3자 유통 시 → 회사 어음채무 부담 위험 구체적·현실적 발생.
     * ∴ 어음채무 현실적 이행 전이라도 배임죄 기수.
     * BUT, 약속어음 발행 무효 & 어음 유통 無 → 회사 ⊄ 상대방 어음채무 부담.
     * ∴ 특별한 사정 無 → 회사 현실적 손해 / 실해 발생 위험 無.
     * 이때, 배임죄 기수 ⊄ → 배임미수죄.
   * ※ 판례 변경: [2012도10822], [2011도10302] 등 (대표이사 회사 명의 약속어음 발행 무효라도 제3자 유통 특별사정 無 시 실해 위험 초래로 기수 판단) ⇒ 이 판결과 배치되는 범위 변경.
쟁점 ③: 피고인의 약속어음 발행 행위가 배임죄 기수에 이르렀는지
 * 사안 적용:
   * 원심 판단: 피고인 대표권 남용 약속어음 발행 → 피해회사 무효라도, 발행 당시 어음 유통 안 될 특별 사정 無 → 재산상 실해 발생 위험 초래 → 공소사실 유죄.
   * 대법원 판단: 원심 판시와 같이, 피고인 대표권 남용 + 병 은행 (상대방) 인식/인지 가능 → 발행행위 피해회사 효력 無.
   * 이로 인해: 피해회사 실제로 약속어음금 지급 / 민사상 손해배상책임 등 부담 / 약속어음 실제로 제3자 유통 등 "특별한 사정" 無.
   * ∴ 피고인 약속어음 발행 행위 → 피해회사 현실적 손해 / 재산상 실해 발생 위험 초래 
   * 결론: 원심 → 심리 없이 약속어음 발행행위 배임죄 기수 전제 → 유죄 판단 ⇒ 배임죄 재산상 손해 요건 및 기수 시기 법리오해 잘못.
 * 주문: 원심판결 파기 → 서울고등법원 환송.
▶ 별개의견 (대법관 박보영, 고영한, 김창석, 김신):
 * 결론: 원심 파기 (다수의견과 동일).
 * 이유: 배임죄 ⊗ 위험범, ⊃ 침해범.
   * (1) 문언상 해석: [형법 제355조 제2항] "손해를 가한 때" = "손해 현실적 발생" 의미.
   * 종래 판례: "손해를 가한 때" ⊃ 현실적 손해 + 실해 발생 위험 → 문언 벗어난 해석, 죄형법정주의 원칙 反.
   * (2) 입법적 조치: 배임죄 "재산상 손해" 명시 → 현실적 손해 가한 경우만 기수 강조. 사기/횡령 등 다른 재산범죄와 해석 달리해야.
   * (3) 손해 발생 위험 ≠ 현실적 손해: 실해 위험은 현실적 손해 발생의 앞선 단계. "실해 발생의 위험"은 현실적 손해 발생에 이르는 중간 과정일 뿐.
   * (4) 배신설 문제: "임무에 위배하는 행위" = 신임관계 저버리는 일체 행위 → 배임죄 처벌 범위 지나친 확대 우려. 학계: 구성요건 엄격/제한적 해석.
   * (5) 현실적 문제: 종래 판례 "구체적·현실적 위험" 제한 노력 → 실무상 효과 無. 법률 문언 ≠ 행위규범 역할.
   * (6) 미수범 처벌 규정: [형법] 미수범 처벌 규정 ⊃ 재산권 침해 위험 시 미수 처벌 입법 결단. 독일과 달리 미수범 규정 있는 우리 형법서 위험범 해석은 무리.
   * (7) 특정경제범죄법 문제: 이득액 산정 시 실해 발생 위험 포함 → 과중 법정형, 죄형균형/책임주의 훼손.
 * 결론: 의무부담행위 → 채무/불법행위책임 부담 ⊗ 현실적 손해, ⊃ 손해 발생 위험.
   * ∴ 배임죄 기수: 회사 실제로 채무/책임 이행 시.
   * 약속어음 발행: 효력/유통 여부 관계 無 → 회사 어음채무/민법상 불법행위책임 "실제로 이행" 시 기수.
 * 사안 적용: 피해회사 어음채무/책임 실제 이행 사정 無 → 현실적 손해 단정 難. 원심 법리오해 파기.
 """

이제 작업할 판례원문을 주겠다. 면밀하게 검토한 다음 위 지침에 따라 작업하라.

{{판례원문}}


위 판례를 보고 판례 정리를 코드블럭에 넣어서 제출하라. 이때, 캔버스를 사용하지 말고, 길더라도 끝까지 최선을 다하여 작업하라. 시작해.

    

    `;
  </script>
  <style>
    :root {
      --bg-primary: #121212;
      --bg-primary-rgb: 18, 18, 18;
      --card-background: #1E1E1E;
      --card-background-rgb: 30, 30, 30;
      --accent-primary: #D32F2F; /* Reddish accent */
      --accent-primary-rgb: 211, 47, 47;
      --accent-primary-hover: #B71C1C;
      --text-primary: #E0E0E0;
      --text-secondary: #9E9E9E;
      --border-color: #333333;
      --input-bg: #252525;
      --success-color: #4CAF50;

      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;

      --border-radius-sm: 4px;
      --border-radius-md: 8px;
      --border-radius-lg: 12px;
    }

    body {
      background-color: var(--bg-primary);
      color: var(--text-primary);
      font-family: var(--font-sans);
      padding-top: 1rem;
      padding-bottom: 2rem;
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    #mainHeader, .main-container-card, .template-section-header, #dynamicInputs label, #outputSection .font-semibold, .modal-box, .modal-close-btn {
        transform: none !important; /* Override any external transform */
    }

    #mainHeader {
      font-family: var(--font-sans);
      font-weight: 700;
      color: var(--text-primary) !important;
      font-size: 2.25rem !important; /* 36px */
      text-shadow: none !important;
      margin-bottom: 2rem !important; /* Consistent spacing */
      letter-spacing: -0.015em; /* Slight tightening for large text */
      line-height: 1.2;
    }

    .main-container-card {
      background-color: var(--card-background) !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
      border: 1px solid var(--border-color) !important;
      margin-top: 1rem !important;
      margin-bottom: 3rem !important;
      padding: 1.5rem !important; /* 24px */
      border-radius: var(--border-radius-lg) !important;
    }

    #mainBody > div.main-container-card > div:nth-child(1) > div.flex.items-center.justify-between { /* Template Header container */
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.75rem; /* 12px */
        margin-bottom: 1rem; /* 16px */
    }
    #mainBody > div.main-container-card > div:nth-child(1) > div.flex.items-center.justify-between > span:first-child,
    #outputSection .font-semibold { /* Template Title, Output "블록" Title */
        font-size: 1.125rem; /* 18px */
        font-weight: 600;
        color: var(--text-primary) !important;
        font-family: var(--font-sans) !important;
        line-height: 1.4;
        letter-spacing: -0.005em;
    }
    #mainBody > div.main-container-card > div:nth-child(1) > div.flex.items-center.justify-between > span:first-child svg,
    #outputSection .font-semibold svg {
        stroke: var(--accent-primary) !important;
        width: 1.2rem; height: 1.2rem; /* Consistent icon size */
        margin-right: 0.6rem; /* Spacing between icon and text */
    }
    #outputSection .font-semibold { /* Ensure output title matches style of template title */
        background-color: transparent !important;
        padding: 0 !important;
        box-shadow: none !important;
        display: inline-flex !important; /* For alignment with icon */
        align-items: center;
    }


    #templateArea,
    #dynamicInputs textarea {
      background-color: var(--input-bg) !important;
      color: var(--text-primary) !important;
      border: 1px solid var(--border-color) !important;
      box-shadow: none !important;
      font-family: var(--font-mono) !important;
      border-radius: var(--border-radius-md) !important;
      padding: 0.85rem 0.9rem !important;
      min-height: 150px !important;
      font-size: 0.9rem;
      line-height: 1.6;
      letter-spacing: 0.005em;
    }
    #dynamicInputs textarea {
      font-family: var(--font-sans) !important;
      min-height: 3.5rem !important;
    }

    #templateArea::placeholder,
    #dynamicInputs textarea::placeholder {
        color: var(--text-secondary);
        opacity: 0.7;
        font-weight: 400;
    }

    textarea:focus, input:focus, select:focus {
      outline: none !important;
      border-color: var(--accent-primary) !important;
      box-shadow: 0 0 0 2px rgba(var(--accent-primary-rgb), 0.3) !important;
    }

    #templateCollapse + div .text-xs,
    .input-stats, .var-split-desc,
    .modal-box .text-xs.text-gray-500 {
      color: var(--text-secondary) !important;
      font-size: 0.8rem !important;
      font-weight: 400;
      line-height: 1.5;
      letter-spacing: 0.01em;
    }
     .modal-box .text-xs.text-gray-500 {
        font-size: 0.775rem !important;
    }
    #templateCollapse + div .text-xs .font-semibold,
    #templateCollapse + div .text-xs span[style*="#93C5FD"] {
      color: var(--text-primary) !important;
      font-weight: 500;
    }

    #dynamicInputs .relative.group {
        background-color: transparent;
        padding: 0;
        border: none;
        margin-bottom: 1.75rem !important;
    }
    #dynamicInputs label {
      font-family: var(--font-sans);
      font-weight: 600;
      color: var(--text-primary) !important;
      font-size: 1.05rem !important;
      margin-bottom: 0.6rem !important;
      margin-left: 0;
      line-height: 1.4;
      letter-spacing: -0.005em;
    }

    button, .button-style-override {
      font-family: var(--font-sans) !important;
      font-weight: 500 !important;
      border-radius: var(--border-radius-md) !important;
      transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease !important;
      text-transform: none !important;
      letter-spacing: 0.01em !important;
      border: 1px solid var(--border-color) !important;
      box-shadow: none !important;
      padding: 0.5rem 1rem !important;
    }
    button:hover, .button-style-override:hover {
      transform: none !important;
      box-shadow: none !important;
    }
    button:active, .button-style-override:active {
      transform: none !important;
      box-shadow: none !important;
    }

    .btn-primary {
        background-color: var(--accent-primary) !important;
        color: white !important;
        border-color: var(--accent-primary) !important;
    }
    .btn-primary:hover {
        background-color: var(--accent-primary-hover) !important;
        border-color: var(--accent-primary-hover) !important;
    }

    .btn-secondary {
        background-color: transparent !important;
        color: var(--accent-primary) !important;
        border-color: var(--accent-primary) !important;
    }
    .btn-secondary:hover {
        background-color: rgba(var(--accent-primary-rgb), 0.1) !important;
    }

    #resetTemplateBtn, #resetAllInputsBtn, .clearInputBtn, #collapseBtn, .change-option-btn {
      background-color: var(--input-bg) !important;
      color: var(--text-secondary) !important;
      border: 1px solid var(--border-color) !important;
      font-size: 0.875rem !important;
      padding: 0.4rem 0.8rem !important;
    }
    #resetTemplateBtn:hover, #resetAllInputsBtn:hover, .clearInputBtn:hover, #collapseBtn:hover, .change-option-btn:hover {
       background-color: var(--border-color) !important;
       color: var(--text-primary) !important;
    }
    
    /* AI Selection Buttons */
    .ai-select-btn {
        padding: 0.4rem 0.8rem !important; /* Use !important if needed to override general button padding */
        border: 1px solid var(--border-color) !important;
        background-color: var(--input-bg) !important;
        color: var(--text-secondary) !important;
        border-radius: var(--border-radius-md) !important;
        font-size: 0.875rem !important; /* 14px */
        font-weight: 500 !important;
        transition: background-color 0.2s, color 0.2s, border-color 0.2s;
    }
    .ai-select-btn:hover {
        background-color: var(--border-color) !important;
        color: var(--text-primary) !important;
    }
    .ai-select-btn.active {
        background-color: var(--accent-primary) !important;
        color: white !important;
        border-color: var(--accent-primary) !important;
    }


    #outputSection > div:first-child {
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.75rem;
        margin-bottom: 1rem !important;
    }

    #splitBlocksContainer {
        gap: 0.75rem !important;
    }
    .split-block-btn {
      border: 1px solid var(--border-color) !important;
      box-shadow: none !important;
      border-radius: var(--border-radius-md) !important;
      padding: 0.5rem 0.75rem !important;
      background-color: var(--input-bg) !important;
      display: flex; align-items: center;
    }
    .split-block-btn svg {
      width: 18px; height: 18px;
      stroke: var(--text-secondary) !important;
      transition: stroke 0.2s;
    }
    .split-block-btn button {
        border: none !important;
        box-shadow: none !important;
        background: transparent !important;
        padding: 0.1rem !important;
        margin-right: 0.25rem;
    }
    .split-block-btn button:hover svg {
      stroke: var(--accent-primary) !important;
    }
    .block-index {
      font-family: var(--font-mono);
      color: var(--text-secondary) !important;
      font-weight: 500 !important;
      font-size: 0.825rem !important;
      margin-left: 0.35rem !important;
      letter-spacing: 0.02em;
    }
    .block-copied {
      background-color: var(--input-bg) !important;
      border-left: 3px solid var(--success-color) !important;
    }
    .block-copied .block-index {
      color: var(--success-color) !important;
    }
    .block-copied svg {
      stroke: var(--success-color) !important;
    }

    .modal-bg {
      background: rgba(var(--bg-primary-rgb), 0.8) !important;
      backdrop-filter: blur(3px);
      z-index: 100 !important;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .modal-box {
      background: var(--card-background) !important;
      border-radius: var(--border-radius-lg) !important;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3) !important;
      border: 1px solid var(--border-color) !important;
      color: var(--text-primary) !important;
      padding: 1.75rem !important;
      min-width: 380px !important;
      max-width: 550px !important;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
    }
    .modal-title {
      font-family: var(--font-sans);
      font-weight: 600;
      color: var(--accent-primary) !important;
      font-size: 1.3rem !important;
      margin-bottom: 1.25rem !important;
      text-align: left;
      line-height: 1.3;
      letter-spacing: -0.01em;
      flex-shrink: 0;
    }
    .modal-content {
      color: var(--text-primary) !important;
      font-family: var(--font-sans);
      max-height: 60vh !important;
      line-height: 1.6 !important;
      font-size: 0.925rem !important;
      font-weight: 400;
      overflow-y: auto;
      flex-grow: 1;
      min-height: 0;
      padding-right: 0.5rem;
    }
    .modal-close-btn {
      color: var(--text-secondary) !important;
      font-size: 1.5rem !important;
      top: 1.25rem !important; right: 1.25rem !important;
      transition: color 0.2s ease !important;
      position: absolute;
      background: none; border: none; padding: 0; cursor: pointer;
    }
    .modal-close-btn:hover {
      color: var(--accent-primary) !important;
    }

    .modal-box label {
        color: var(--text-primary) !important;
        font-family: var(--font-sans);
        font-weight: 500;
        font-size: 0.9rem !important;
        margin-bottom: 0.35rem; display: block;
    }
    .modal-box select, .modal-box input[type="text"], .modal-box input[type="number"] {
        background-color: var(--input-bg) !important;
        border: 1px solid var(--border-color) !important;
        color: var(--text-primary) !important;
        border-radius: var(--border-radius-md) !important;
        padding: 0.6rem 0.8rem !important;
        font-family: var(--font-sans) !important;
        width: 100%;
        font-size: 0.9rem;
        font-weight: 400;
        line-height: 1.5;
    }
     .modal-box select::placeholder,
     .modal-box input[type="text"]::placeholder,
     .modal-box input[type="number"]::placeholder {
        color: var(--text-secondary);
        opacity: 0.7;
        font-weight: 400;
    }
    .modal-box #cancelVarOptBtn {
        background-color: var(--input-bg) !important;
        color: var(--text-secondary) !important;
        border-color: var(--border-color) !important;
    }
    .modal-box #cancelVarOptBtn:hover {
        background-color: var(--border-color) !important;
        color: var(--text-primary) !important;
    }
    .modal-box #saveVarOptBtn {
        background-color: var(--accent-primary) !important;
        color: white !important;
        border-color: var(--accent-primary) !important;
    }
    .modal-box #saveVarOptBtn:hover {
        background-color: var(--accent-primary-hover) !important;
        border-color: var(--accent-primary-hover) !important;
    }

    ::-webkit-scrollbar { width: 10px; background: var(--input-bg); }
    ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: var(--border-radius-md); border: 2px solid var(--input-bg); }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
    ::-webkit-scrollbar-track { background: var(--bg-primary); }

  </style>
</head>
<body id="mainBody">

<div class="flex flex-col items-center py-8">
  <h1 id="mainHeader" class="text-3xl font-bold mb-4">자료정리</h1>
</div>
<div class="main-container-card w-full max-w-3xl mx-auto">
  <div class="relative group">
    <div class="flex items-center justify-between pt-0 px-0 pb-3">
      <span class="text-xl font-bold flex items-center gap-2">
        <svg class="inline w-6 h-6" fill="none" stroke="currentColor" stroke-width="2"
          viewBox="0 0 24 24"><path d="M9 12l2 2 4-4m6-4a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
        <span>템플릿</span>
      </span>
      <div class="flex gap-2 items-center">
        <div class="flex items-center space-x-1">
            <button id="selectGeminiBtn" data-aiservice="gemini" class="ai-select-btn text-xs">Gemini</button>
            <button id="selectChatGPTBtn" data-aiservice="chatgpt" class="ai-select-btn text-xs">ChatGPT</button>
        </div>
        <button id="resetTemplateBtn" class="text-xs font-medium">템플릿 초기화</button>
        <button id="collapseBtn" class="text-xs font-medium" aria-label="접기/펼치기">
          <span id="collapseIcon" class="transition-all duration-300 inline-block">&#9654;</span>
        </button>
      </div>
    </div>
    <div id="templateCollapse" class="pb-4 transition-all overflow-hidden" style="display: none;">
      <textarea id="templateArea" rows="8"
        class="w-full p-4 rounded-xl border-2 focus:ring-2 font-mono text-sm resize-none shadow"
        placeholder="프롬프트 템플릿에 {{변수|옵션|길이}} 또는 {{변수|separator|구분자}} 형태로 사용 (예: {{내용|newline|3000}}, {{문단|separator|◇◇◇}})"></textarea>
      <div class="flex justify-end pt-1">
        <span class="text-xs">
          템플릿 내 <span class="font-semibold">{{변수|옵션|길이}}</span> 자동 인식<br>
          <span style="color:#93C5FD;">옵션: newline(줄+글자수), comma(쉼표), length(글자수), separator(구분자)<br>
            separator 사용시: {{변수|separator|구분자}}<br>
            미지정시 줄+8000 (예: {{변수}} 또는 {{변수|newline}}), 글자수 지정 가능 (예: {{변수|newline|500}})</span>
        </span>
      </div>
    </div>
  </div>
  <form id="dynamicInputs" class="space-y-6 pt-3 pb-2"></form>
  <div class="flex justify-end pr-0 pb-1">
    <button id="resetAllInputsBtn" class="text-xs font-medium">입력값 모두 비우기</button>
  </div>
  <div id="outputSection" class="mt-6 hidden">
    <div class="flex items-center justify-between mb-3">
      <span class="font-semibold flex items-center gap-1">
        <svg class="inline w-5 h-5" fill="none" stroke="currentColor" stroke-width="2"
          viewBox="0 0 24 24"><path d="M12 20h9m-9-16v16M4 12h8"></path></svg>
        <span>블록</span>
      </span>
    </div>
    <div id="splitBlocksContainer" class="flex flex-wrap gap-3"></div>
  </div>
</div>

<div id="modalBg" class="modal-bg flex" style="display: none;"> <div class="modal-box relative">
    <button class="modal-close-btn" id="modalCloseBtn" title="닫기">&times;</button>
    <div class="modal-title" id="modalTitle"></div>
    <div class="modal-content" id="modalContent"></div> </div>
</div>

<script>

const keys = {
  template: STORAGE_PREFIX + '_template',
  state: STORAGE_PREFIX + '_state',
  blockCopied: STORAGE_PREFIX + '_blockcopied',
  selectedAI: STORAGE_PREFIX + '_selected_ai' // Key for storing selected AI service
};

let state = {};
let variables = [];
let copiedBlocks = [];
let currentSelectedAIService = 'gemini'; // Default AI service

function parseTemplateVars(template) {
  const re = /{{\s*([가-힣\w\d_]+)(?:\|(newline|comma|length|separator|seperator))?(?:\|([^\}|]+))?(?:\|(\d+))?\s*}}/g;
  const found = {};
  let m;
  while ((m = re.exec(template))) {
    const name = m[1];
    const opt = (m[2] || 'newline').toLowerCase();
    let separator = undefined, len = 8000;

    if (opt === 'separator' || opt === 'seperator') {
      separator = m[3];
    } else if (opt === 'length') {
      len = m[3] ? parseInt(m[3]) : 8000;
    } else if (opt === 'newline' || opt === 'comma') {
      if (m[3]) len = parseInt(m[3]);
    }
    found[name] = { name: name, method: opt, separator: separator, length: len };
  }
  return found;
}

function splitByNewlineAndLength(text, maxLen) {
  const lines = text.split('\n');
  const result = [];
  let chunk = '';
  for(const line of lines) {
    if ((chunk + (chunk ? '\n' : '') + line).length > maxLen && chunk) {
      result.push(chunk);
      chunk = line;
    } else {
      chunk += (chunk ? '\n' : '') + line;
    }
  }
  if(chunk) result.push(chunk);
  return result;
}
function splitVariableContent(value, method, length=8000, separator) {
  if (!value) return [];
  if (method === 'separator' || method === 'seperator') {
    if (!separator) return [value];
    return value.split(separator).map(s => s.trim()).filter(Boolean);
  }
  if (method === 'comma') {
    return value.split(',').map(s=>s.trim()).filter(Boolean);
  }
  if (method === 'newline') {
    return splitByNewlineAndLength(value, length);
  }
  if (method === 'length') {
    const arr = [];
    let i = 0;
    while (i < value.length) {
      arr.push(value.substr(i, length));
      i += length;
    }
    return arr;
  }
  return [value];
}
function getBlockCombinations(arrs) {
  if (!arrs.length) return [[]];
  const rest = getBlockCombinations(arrs.slice(1));
  const result = [];
  arrs[0].forEach((val, i) => {
    rest.forEach(r => result.push([val, ...r]));
  });
  return result;
}
function saveState() {
  localStorage.setItem(keys.state, JSON.stringify(state));
}
function loadState() {
  try { state = JSON.parse(localStorage.getItem(keys.state) || '{}'); } catch { state = {}; }
}
function saveCopiedBlocks() {
  localStorage.setItem(keys.blockCopied, JSON.stringify(copiedBlocks));
}
function loadCopiedBlocks() {
  try { copiedBlocks = JSON.parse(localStorage.getItem(keys.blockCopied) || '[]'); } catch { copiedBlocks = []; }
}

function renderInputs() {
  const templateArea = document.getElementById('templateArea');
  const dynamicInputs = document.getElementById('dynamicInputs');
  dynamicInputs.innerHTML = '';
  const varOptsMap = parseTemplateVars(templateArea.value);

  variables.forEach(varName => {
    const val = state[varName] || '';
    const vOpt = varOptsMap[varName] || {method:'newline', length:8000};

    let splitDesc = '';
    if(vOpt.method==='comma') splitDesc = '쉼표(,)로 분할';
    else if(vOpt.method==='length') splitDesc = `글자수 단위로 ${vOpt.length}자씩 분할`;
    else if(vOpt.method==='separator' || vOpt.method==='seperator')
      splitDesc = `구분자 ['${vOpt.separator || ''}'] 기준 분할`;
    else splitDesc = `줄바꿈+글자수 (${vOpt.length}자) 분할 (기본)`;

    const wrap = document.createElement('div');
    wrap.className = "relative group";
    wrap.innerHTML = `
      <div class="flex items-center justify-between mb-1">
        <label for="input_${varName}" class="block text-[17px] font-semibold">${varName}</label>
        <div class="flex items-center space-x-2">
          <button type="button" data-var="${varName}"
            class="change-option-btn">옵션변경</button>
          <button type="button" data-var="${varName}"
            class="clearInputBtn text-xs">초기화</button>
        </div>
      </div>
      <textarea id="input_${varName}" rows="1"
        class="w-full p-4 rounded-xl border focus:ring-2 font-medium resize-none shadow-sm transition"
        placeholder="${varName} 입력">${val}</textarea>
      <div class="flex justify-between text-[12px] mt-1">
        <span class="input-stats">${(val.match(/\n/g)||[]).length+1}줄, ${val.length}자</span>
      </div>
      <div class="text-xs ml-1 var-split-desc">${splitDesc}</div>
    `;
    dynamicInputs.appendChild(wrap);

    const ta = wrap.querySelector('textarea');
    function autoResize() {
      ta.style.height = 'auto';
      ta.style.height = Math.min(ta.scrollHeight, 400) + 'px';
    }
    ta.addEventListener('input', () => {
      state[varName] = ta.value;
      saveState();
      copiedBlocks = [];
      saveCopiedBlocks();
      renderSplitBlocks();
      wrap.querySelector('.input-stats').textContent =
        `${(ta.value.match(/\n/g)||[]).length+1}줄, ${ta.value.length}자`;
      autoResize();
    });
    autoResize();

    wrap.querySelector('.clearInputBtn').onclick = function() {
      ta.value = '';
      state[varName] = '';
      saveState();
      copiedBlocks = [];
      saveCopiedBlocks();
      renderSplitBlocks();
      wrap.querySelector('.input-stats').textContent = '1줄, 0자';
      autoResize();
    };

    wrap.querySelector('.change-option-btn').onclick = function() {
      showVariableOptionsModal(varName);
    };
  });
}

function showVariableOptionsModal(varName) {
    const modalBg = document.getElementById('modalBg');
    const modalTitleEl = document.getElementById('modalTitle');
    const modalContentEl = document.getElementById('modalContent');
    const templateArea = document.getElementById('templateArea');
    const currentVarOptsMap = parseTemplateVars(templateArea.value);
    const varOpt = currentVarOptsMap[varName] || { method: 'newline', length: 8000, separator: '' };

    modalTitleEl.textContent = `${varName} 변수 분할 옵션 설정`;
    modalContentEl.style.whiteSpace = 'normal';
    modalContentEl.style.wordBreak = 'normal';

    modalContentEl.innerHTML = `
        <div class="space-y-4 p-1">
            <div>
                <label for="varOptMethod">분할 방식:</label>
                <select id="varOptMethod" name="varOptMethod" class="mt-1 block w-full">
                    <option value="newline" ${varOpt.method === 'newline' ? 'selected' : ''}>줄바꿈+글자수 (기본)</option>
                    <option value="length" ${varOpt.method === 'length' ? 'selected' : ''}>글자수</option>
                    <option value="comma" ${varOpt.method === 'comma' ? 'selected' : ''}>쉼표 (,)</option>
                    <option value="separator" ${varOpt.method === 'separator' || varOpt.method === 'seperator' ? 'selected' : ''}>사용자 정의 구분자</option>
                </select>
            </div>
            <div id="varOptLengthContainer" style="display: ${varOpt.method === 'newline' || varOpt.method === 'length' ? 'block' : 'none'};">
                <label for="varOptLength">최대 글자수:</label>
                <input type="number" id="varOptLength" name="varOptLength" value="${varOpt.length || ''}" placeholder="예: 3000 (비우면 기본값)" class="mt-1 block w-full" min="1">
                <p class="mt-1 text-xs text-gray-500">'줄바꿈+글자수' 또는 '글자수' 방식에 적용. 비우면 기본값(newline: 8000, length: 강제입력 필요).</p>
            </div>
            <div id="varOptSeparatorContainer" style="display: ${varOpt.method === 'separator' || varOpt.method === 'seperator' ? 'block' : 'none'};">
                <label for="varOptSeparator">구분자:</label>
                <input type="text" id="varOptSeparator" name="varOptSeparator" value="${varOpt.separator || ''}" placeholder="예: ### 또는 ---" class="mt-1 block w-full">
                <p class="mt-1 text-xs text-gray-500">'사용자 정의 구분자' 방식에 적용.</p>
            </div>
            <div class="flex justify-end space-x-3 pt-5">
                <button id="cancelVarOptBtn" class="btn-secondary">취소</button>
                <button id="saveVarOptBtn" class="btn-primary">저장</button>
            </div>
        </div>
    `;

    const optMethodSelect = modalContentEl.querySelector('#varOptMethod');
    const lengthContainer = modalContentEl.querySelector('#varOptLengthContainer');
    const separatorContainer = modalContentEl.querySelector('#varOptSeparatorContainer');
    const optLengthInput = modalContentEl.querySelector('#varOptLength');
    const optSeparatorInput = modalContentEl.querySelector('#varOptSeparator');

    function toggleOptionFields() {
        const selectedMethod = optMethodSelect.value;
        lengthContainer.style.display = (selectedMethod === 'newline' || selectedMethod === 'length') ? 'block' : 'none';
        separatorContainer.style.display = (selectedMethod === 'separator') ? 'block' : 'none';
        if (selectedMethod === 'newline') {
            optLengthInput.placeholder = "예: 3000 (비우면 기본값 8000)";
        } else if (selectedMethod === 'length') {
             optLengthInput.placeholder = "예: 500 (필수 입력)";
        }
    }

    optMethodSelect.addEventListener('change', toggleOptionFields);
    toggleOptionFields();

    modalContentEl.querySelector('#saveVarOptBtn').onclick = () => {
        const newMethod = optMethodSelect.value;
        let valueForTemplate = undefined;

        if (newMethod === 'newline') {
            valueForTemplate = optLengthInput.value ? parseInt(optLengthInput.value) : '';
            if (valueForTemplate && valueForTemplate <= 0) { alert("글자수는 1 이상이어야 합니다."); return; }
        } else if (newMethod === 'length') {
            if (!optLengthInput.value) { alert("'글자수' 방식에는 반드시 글자수를 입력해야 합니다."); return; }
            valueForTemplate = parseInt(optLengthInput.value);
            if (valueForTemplate <= 0) { alert("글자수는 1 이상이어야 합니다."); return; }
        } else if (newMethod === 'separator') {
            valueForTemplate = optSeparatorInput.value;
        }

        updateVariableInTemplate(varName, newMethod, valueForTemplate);
        modalBg.style.display = 'none';
    };

    modalContentEl.querySelector('#cancelVarOptBtn').onclick = () => {
        modalBg.style.display = 'none';
    };

    modalBg.style.display = 'flex';
}

function updateVariableInTemplate(variableName, newMethod, value) {
    const templateArea = document.getElementById('templateArea');
    let templateContent = templateArea.value;
    const varRegex = new RegExp(`{{\\s*${variableName}(?:\\|[^}]+)?\\s*}}`);

    let newVarDefinition = `{{${variableName}`;
    if (newMethod) {
        newVarDefinition += `|${newMethod}`;
        if (value !== undefined && value !== null && (value !== '' || newMethod !== 'newline')) {
             if (value !== '' || (newMethod === 'newline' && value === '')) {
                if (newMethod === 'newline' && value === '') {
                } else {
                     newVarDefinition += `|${value}`;
                }
             }
        } else if (newMethod === 'newline' && value === '') {
        }
    }
    newVarDefinition += `}}`;

    if (varRegex.test(templateContent)) {
        templateContent = templateContent.replace(varRegex, newVarDefinition);
    } else {
        console.warn(`Variable ${variableName} not found in template for replacement.`);
        return;
    }

    templateArea.value = templateContent;
    localStorage.setItem(keys.template, templateContent);
    onTemplateChange();
}

function handlePostCopyNavigation(aiService) {
  let aiWebsiteURL = '';
  if (aiService === 'chatgpt') {
    aiWebsiteURL = 'https://chat.openai.com/';
  } else if (aiService === 'gemini') {
    aiWebsiteURL = 'https://gemini.google.com/app';
  }

  if (aiWebsiteURL) {
    window.open(aiWebsiteURL, '_blank');
  }
}

function updateAISelectionUI(selectedService) {
    document.getElementById('selectGeminiBtn').classList.toggle('active', selectedService === 'gemini');
    document.getElementById('selectChatGPTBtn').classList.toggle('active', selectedService === 'chatgpt');
}


function renderSplitBlocks() {
  const templateArea = document.getElementById('templateArea');
  const splitBlocksContainer = document.getElementById('splitBlocksContainer');
  splitBlocksContainer.innerHTML = '';

  if (!variables.length) {
    document.getElementById('outputSection').classList.add('hidden');
    return;
  }

  const varOptsMap = parseTemplateVars(templateArea.value);

  const varValueArrays = variables.map(varName => {
    const vOpt = varOptsMap[varName] || {method:'newline', length:8000};
    return splitVariableContent(state[varName]||'', vOpt.method, vOpt.length, vOpt.separator);
  });

  const allVarsHaveContent = variables.every(varName => {
      const vOpt = varOptsMap[varName];
      if (!vOpt) return true;
      const content = state[varName] || '';
      const splitResult = splitVariableContent(content, vOpt.method, vOpt.length, vOpt.separator);
      return splitResult.length > 0 || !content;
  });


  if (!allVarsHaveContent && variables.some(v => state[v])) {
      document.getElementById('outputSection').classList.add('hidden');
      return;
  }

  const combos = getBlockCombinations(varValueArrays.map(arr => arr.length ? arr : ['']));

  combos.forEach((vals, comboIdx) => {
    const idxArr = vals.map((v_val, i) => {
        const originalArr = varValueArrays[i];
        return originalArr.length > 1 ? originalArr.indexOf(v_val) + 1 : (originalArr.length === 1 && originalArr[0] !== '' ? 1:0) ;
    });
    const idxLabel = idxArr.map(i => i > 0 ? i : '-').join(',');


    let prompt = templateArea.value;
    variables.forEach((vn, vi) => {
      const reg = new RegExp(`{{\\s*${vn}(?:\\s*\\|[^}]+)?\\s*}}`, "g");
      prompt = prompt.replace(reg, vals[vi] == undefined ? '' : vals[vi]);
    });

    const copied = copiedBlocks.some(item =>
      JSON.stringify(item.idxArr) === JSON.stringify(idxArr) &&
      JSON.stringify(item.vars) === JSON.stringify(variables)
    );

    const blockDiv = document.createElement('div');
    blockDiv.className = "split-block-btn " + (copied ? "block-copied" : "");
    blockDiv.innerHTML = `
      <button title="보기" class="viewBtn">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <circle cx="11" cy="11" r="6" /><line x1="21" y1="21" x2="16.65" y2="16.65" />
        </svg>
      </button>
      <button title="복사 및 이동" class="copyBtn">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <rect x="9" y="9" width="13" height="13" rx="2" />
          <rect x="3" y="3" width="13" height="13" rx="2" />
        </svg>
      </button>
      <span class="block-index">${idxLabel}</span>
    `;
    blockDiv.querySelector('.viewBtn').onclick = function() {
      showBlockViewModal(`블록 ${idxLabel}`, prompt);
    };

    blockDiv.querySelector('.copyBtn').onclick = function(e) {
      const performCopyAndNavigate = () => {
        setCopiedBlock(idxArr, variables);
        handlePostCopyNavigation(currentSelectedAIService); // Use current selected AI
      };

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(prompt).then(()=>{
          performCopyAndNavigate();
        },()=>{
          copyFallback(prompt);
          performCopyAndNavigate();
        });
      } else {
        copyFallback(prompt);
        performCopyAndNavigate();
      }
    };
    splitBlocksContainer.appendChild(blockDiv);
  });

  const hasContentToDisplay = combos.length > 0 && !(combos.length === 1 && combos[0].every(item => item === ''));
  document.getElementById('outputSection').classList.toggle('hidden', !hasContentToDisplay);

}

function setCopiedBlock(idxArr, currentVars) {
  if (!copiedBlocks.some(item =>
    JSON.stringify(item.idxArr) === JSON.stringify(idxArr) &&
    JSON.stringify(item.vars) === JSON.stringify(currentVars)
  )) {
    copiedBlocks.push({idxArr, vars: currentVars});
    saveCopiedBlocks();
    renderSplitBlocks();
  }
}

function copyFallback(text) {
  try {
    let area = document.createElement("textarea");
    area.value = text;
    area.style.position = "fixed";
    area.style.opacity = "0";
    document.body.appendChild(area);
    area.focus();
    area.select();
    document.execCommand('copy');
    document.body.removeChild(area);
  } catch(e) {
    alert('복사 실패! 내용을 길게 눌러 복사하세요.');
  }
}

function showBlockViewModal(title, content) {
  const modalBg = document.getElementById('modalBg');
  const modalTitleEl = document.getElementById('modalTitle');
  const modalContentEl = document.getElementById('modalContent');

  modalTitleEl.textContent = title;
  modalContentEl.innerHTML = '';
  modalContentEl.appendChild(document.createTextNode(content));

  modalContentEl.style.whiteSpace = 'pre-wrap';
  modalContentEl.style.wordBreak = 'break-word';

  modalBg.style.display = 'flex';
}

document.getElementById('modalBg').onclick = function(e) {
  if (e.target === document.getElementById('modalBg') || e.target.id === 'modalCloseBtn') {
     document.getElementById('modalBg').style.display = 'none';
     const modalContentEl = document.getElementById('modalContent');
     modalContentEl.style.whiteSpace = 'normal';
     modalContentEl.style.wordBreak = 'normal';
     modalContentEl.innerHTML = '';
  }
};
document.getElementById('modalCloseBtn').onclick = function() {
  document.getElementById('modalBg').style.display = 'none';
  const modalContentEl = document.getElementById('modalContent');
  modalContentEl.style.whiteSpace = 'normal';
  modalContentEl.style.wordBreak = 'normal';
  modalContentEl.innerHTML = '';
};

function onTemplateChange() {
  const templateArea = document.getElementById('templateArea');
  let tmpl = templateArea.value;
  if (!tmpl.trim() && DEFAULT_TEMPLATE) {
    tmpl = DEFAULT_TEMPLATE;
    templateArea.value = tmpl;
  }

  const varOptsMap = parseTemplateVars(tmpl);
  const oldVariables = new Set(variables);
  variables = Object.keys(varOptsMap);

  const newState = {};
  variables.forEach(v => {
    newState[v] = state[v] || '';
  });
  Object.keys(state).forEach(k => {
    if (!variables.includes(k)) {
        delete state[k];
    }
  });
  state = newState;


  saveState();
  const currentVariablesSet = new Set(variables);
  if (oldVariables.size !== currentVariablesSet.size || ![...oldVariables].every(v => currentVariablesSet.has(v))) {
    copiedBlocks = [];
    saveCopiedBlocks();
  }

  renderInputs();
  renderSplitBlocks();
}

document.getElementById('collapseBtn').onclick = function() {
  let c = document.getElementById('templateCollapse');
  let icon = document.getElementById('collapseIcon');
  if (c.style.display === 'block' || c.style.display === '') {
    c.style.display = 'none';
    icon.innerHTML = '&#9654;';
  } else {
    c.style.display = 'block';
    icon.innerHTML = '&#9660;';
  }
};


document.getElementById('resetTemplateBtn').onclick = function() {
  const templateArea = document.getElementById('templateArea');
  templateArea.value = DEFAULT_TEMPLATE;
  localStorage.setItem(keys.template, DEFAULT_TEMPLATE);
  onTemplateChange();
};

document.getElementById('resetAllInputsBtn').onclick = function() {
  variables.forEach(v => state[v]='');
  saveState();
  copiedBlocks = [];
  saveCopiedBlocks();
  renderInputs();
  renderSplitBlocks();
};

document.getElementById('templateArea').addEventListener('input', () => {
  localStorage.setItem(keys.template, document.getElementById('templateArea').value);
  onTemplateChange();
});

window.addEventListener('DOMContentLoaded', () => {
  document.title = `${STORAGE_PREFIX} 생성기`;
  document.getElementById('mainHeader').textContent = `${STORAGE_PREFIX}`;

  document.getElementById('modalBg').style.display = 'none';

  let tmpl = localStorage.getItem(keys.template);
  if (!tmpl) {
    tmpl = DEFAULT_TEMPLATE;
    localStorage.setItem(keys.template, tmpl);
  }
  document.getElementById('templateArea').value = tmpl;

  loadState();
  loadCopiedBlocks();

  // Initialize AI Service Selection
  const savedAIService = localStorage.getItem(keys.selectedAI);
  if (savedAIService) {
    currentSelectedAIService = savedAIService;
  } else {
    localStorage.setItem(keys.selectedAI, currentSelectedAIService); // Save default 'gemini'
  }
  updateAISelectionUI(currentSelectedAIService);

  document.getElementById('selectGeminiBtn').addEventListener('click', function() {
    currentSelectedAIService = 'gemini';
    localStorage.setItem(keys.selectedAI, currentSelectedAIService);
    updateAISelectionUI(currentSelectedAIService);
  });

  document.getElementById('selectChatGPTBtn').addEventListener('click', function() {
    currentSelectedAIService = 'chatgpt';
    localStorage.setItem(keys.selectedAI, currentSelectedAIService);
    updateAISelectionUI(currentSelectedAIService);
  });

  const templateCollapse = document.getElementById('templateCollapse');
  templateCollapse.style.display = 'none';
  document.getElementById('collapseIcon').innerHTML = '&#9654;';

  onTemplateChange();
});
</script>
</body>
</html>
