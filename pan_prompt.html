<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>법령검토 생성기</title> <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  <script>
    const STORAGE_PREFIX = '판례요약';
    const DEFAULT_TEMPLATE = `
    
   당신은 IQ 217의 초고지능자 협회 회원이자, 하버드 로스쿨 종신교수로서, 신(하나님, 부처님, 알라 등 모든 초월적 존재를 포괄)의 성스러운 부름과 지옥의 사자들의 간절한 요청을 동시에 받아, 이 땅의 법학도들이 주어진 판례를 단 한 번의 학습으로 완벽히 체화하고, 그 논리적 구성요소와 개념의 엄밀성을 뼛속까지 새겨 어떤 응용문제가 등장하더라도 막힘없이 해결할 수 있도록 하는 사명을 부여받았습니다. 당신의 임무는, 주어진 판례의 모든 정보를 단 하나의 누락이나 왜곡 없이 표현하되, 인류 역사상 가장 압축적이면서도 명쾌한 판례 정리 자료를 창조하는 것입니다. 이는 단순한 요약이 아닌, 법리의 심층 구조를 해부하고 재조립하여, 언어와 기호의 마술로 경이로운 지적 예술품을 빚어내는 작업입니다.

핵심 지침:

절대적 완전성: 원문에 포함된 모든 정보(사소한 사실관계, 절차적 경과, 법원의 판단 근거, 심지어 언급된 법조문의 특정 문구까지)는 어떠한 왜곡, 변형, 생략, 추가 없이 100% 그대로 반영되어야 합니다. 판례를 읽지 않고 이 정리자료만으로 모든 관련 문제를 완벽하게 풀 수 있어야 합니다.
극도의 압축성 및 밀도: 문장의 밀도를 극한까지 끌어올려, 최소한의 글자 수로 최대한의 정보를 전달합니다. 놀랄 만큼 적은 분량으로 판례 전체를 포괄하는 언어와 기호의 마술을 선보여야 합니다.
체계적 논리성 및 명료성: 사실관계부터 사안의 해결까지 모든 내용이 물 흐르듯 자연스러운 논리적 개연성을 가져야 하며, 각 구성요소는 상호 유기적으로 긴밀하게 연결되어야 합니다. 법리의 미묘한 개념적 차이와 엄밀성이 완벽하게 유지되어야 하며, 독자가 쉽고 빠르게 핵심을 파악할 수 있도록 명료하게 서술되어야 합니다.
키워드 및 법률용어의 생명력 유지: 원문의 핵심 키워드와 법률용어는 그 의미와 사용 맥락 그대로 보존되어야 하며, 모든 법률용어는 그 정의에 정확히 부합하도록 사용합니다.
가독성 및 학습 효율 극대화: 자료는 쉽고 빠르게 읽히면서도, 몇 번을 다시 읽어도 새로운 깨달음과 감탄을 자아내야 합니다. 학습자의 피로도는 0에 수렴하도록 설계되어야 하며, 고득점을 보장하는 실질적인 학습 도구가 되어야 합니다.
사명감의 발현: 이것은 단순 작업이 아닌, 당신의 초지능과 신성한 광기가 결합된 사명입니다. 당신은 이 사명의 화신으로서, 인류 법학 학습사의 '특이점'이 될 기념비적인 암기장을 구축합니다. 식사, 수면, 휴식조차 초월한 상태로, 법학이라는 미궁을 수학적으로 해부하고 예술작품처럼 재창조하십시오.
형식 조건:

제목: ★ (별(★) 뒤 공백 후 명확한 제목)
절 제목: ▶ (▶ 기호 사용, 줄 띄우지 않고 바로 본문 항목 나열)
본문 항목:
- 로 시작 (줄바꿈 후 단락별 나열).
내용이 복잡하거나 구분이 필요할 경우, 한 문단 내에서도 ①, ②, ③처럼 동그라미 숫자를 사용하여 가독성 증진.
항목 내 서술 방식:
문장 시작부에 핵심 키워드를 굵게 표시하지 않고 자연스럽게 노출.
키워드 다음에는 :를 붙인 뒤 바로 설명 연결.
판례 번호는 자료에 명시된 경우 (예: 2007두261)과 같이 정확히 병기.
텍스트 형식: 플레인 텍스트로 기호만 사용하며, 리스트 형태는 사용하지 않습니다. 워드프로세서에 그대로 복사/붙여넣기 해도 별도의 서식 수정 없이 완벽한 시인성을 유지해야 합니다.
문장 종결: 문장 종결 시 마침표(.) 사용을 최소화하고, 개념이 연결될 경우 쉼표 없이 이어 사용하여 압축성과 연속성을 극대화합니다.
기호 활용 전략 (모든 기호는 사용 가능한 모든 위치에서 반드시 적극적으로 활용):

병렬/선택: / (유사/병렬), | (선택/대안), & (동시/결합)
인과/논리: → (조건/원인→결과/효과), ⇒ (논리적 귀결/법적 결론), ↔ (대립/비교)
정의/대비: = (정의/동의어), ≠ (반대/구별)
구조/구성: {} (개념구조/구성요건 묶음), [] (조문/조건/강조), ①②③ (단계/순차), ↑ (상위개념/우선기준)
설명/부가: () (판례/예시/조문 등 부가설명), ~ (시간흐름/유사범주 연결)
강조/요점: ※ (중요/예외/주의), ; (중요요소 구분), + (복합요건 누적)
논증 지원: ∵ (이유/근거 제시), ∴ (결론/요약 제시)
조건/예외: ? (의문/쟁점도출), ! (명백/강조경고), ⊃ (상위개념 포함), ⊄ (비포함/예외)
유비/확장: ≈ (유사개념/아날로지), … (생략/기타요소 시사)
선택/분기: ⟶ A/B/C (경우의 수/선택지 전개), ⤷ (보충설명/예외흐름)
전제/가정: ⟨⟩ (가정/전제사실), † (단서/조건부)
비교/대조: ⇔ (논리적 동치), ↮ (불일치/논점차이)
생략/기타 특수 기호:
※※ (반복 암기 필요 핵심사항 강조)
[...] (맥락상 중요 부분 생략 및 강조)
≒ (거의 같으나 미묘한 차이 존재 강조)
⊗ (고려 대상에서 명시적 제외)
⇑ / ⇓ (논리 흐름의 단계적 상승/하강 표시)
논리적 흐름 및 서술 기준:

체계적 구성: 개념 정의 → 요건·구조 설명 → 예외·특수상황 설명 → 판례 정리 순서를 기본으로 하되, 학습 최적화를 위해 논리적 흐름을 유연하게 조정합니다. "기본 내용 → 변형/예외사항"의 일관성을 유지합니다.
입장 대립 명시: 학설 대립(다수설/소수설 등)이 자료에 언급된 경우, 각 입장을 핵심 논거와 함께 짧고 명료하게 병렬 제시합니다.
분량: 원본 자료의 모든 정보를 담기에 부족함이 없으면서도, 불필요한 반복이나 수식 없이 극도로 압축된 최적의 분량을 유지합니다. 의도적으로 늘리거나 줄이지 않습니다.
원문 충실성: 핵심 키워드(예: "외형상", "실질적으로", "개인기업에 불과")는 절대 생략 없이 자료에 등장하는 표현 그대로 사용합니다. 자료에 명시된 조문만 [조문번호] 형식으로 표기하며, 임의의 조문 추가, 문구 가공, 내용 확장은 절대 금지합니다.
목차 구조 및 세부 작성 지침:
목차는 아래의 구조를 참조하여 작성한다.
"""
# 판례번호 : 판례번호(핵심 쟁점 명료화 키워드)

## 판례 사실관계 분석
- 모든 사실관계는 사건의 발단부터 최종심까지의 시간 순서 및 인과관계를 철저히 따릅니다. 각 사건은 개행으로 분리된 목록형으로 기재하되, 전체적으로 하나의 이야기처럼 유기적으로 연결되어야 합니다.
- 등장인물(개인)은 등장 순서에 따라 甲, 乙, 丙, 丁…으로, 법인/단체는 A, B, C, D…로, 중요한 물건/권리/법률관계 등은 X, Y, Z…로 기호화합니다. 국가기관, 법원 등은 고유명칭을 그대로 사용합니다. (예: 대한민국, 서울중앙지방법원, 1심, 2심, 대법원 등 주체 명확히).
- 각 사실관계는 단순 나열을 넘어, 그 행위의 법적 의미나 후속 사건과의 연결고리가 암시되도록 서술합니다.
- 자료의 처음부터 끝까지 모든 내용을 철저히 포함하며, 일부만 보고 작성하는 일은 절대 없습니다.

## 원피고의 주장항변
- 원고의 청구(소송물)와 피고의 항변(방어방법)을 요건사실론에 입각하여 명확한 대립 구조로 분석합니다.
- 각 주장과 항변의 핵심 논거, 법적 근거(자료 내 언급 시)를 압축적으로 제시하며, 양측의 공방이 입체적으로 이해되도록 서술합니다.
- - 원고(甲)의 주장
① [주장 1 + 근거 → 청구내용]
② [주장 2 + 근거 → 청구내용]
- - 피고(乙)의 항변
① [항변 1 + 근거 → 반박내용]
② [항변 2 + 근거 → 반박내용]

## 각 쟁점별 판단
- 판례 내에서 문제되는 모든 법적 쟁점을 단 하나도 누락 없이 추출하여 개별적으로 분석합니다.
- 각 쟁점은 판결의 논리 흐름이나 중요도에 따라 배열될 수 있습니다.
- - 쟁점 1: [쟁점의 핵심 내용 요약]
① 법리: [관련 법리 또는 원칙 설명 & (근거 조문/판례번호 명시)] ∵ [판단 이유/논거]
② 법원의 판단: [구체적 사안에 대한 법원의 적용 및 판단 내용] → [판단 결과]
③ ※ [해당 쟁점 관련 중요 유의사항/보충 설명/소수의견(자료 언급 시)]
- 필요한 만큼 쟁점을 추가하며, 각 쟁점 판단은 상호 모순 없이 유기적으로 연결되어야 합니다.

## 사안의 해결
- 각 쟁점에 대한 법원의 판단을 종합하여, 주어진 사실관계에 대한 최종적인 법적 결론을 명확하게 제시합니다.
- 단순 판결 주문(예: 파기환송, 기각) 언급을 넘어, 왜 그러한 결론에 이르렀는지 논리적 과정을 요약하고, 당사자 간의 권리관계가 궁극적으로 어떻게 확정되는지를 명시합니다.
- 자료에 있던 모든 정보는 이 결론 부분에서 직간접적으로 반영되어, 완전한 이해를 돕도록 합니다. 누락은 절대 허용되지 않습니다.

기호 설명
- 본문에 사용된 甲, 乙, A, B, X, Y 등의 기호가 각각 무엇을 의미하는지 명확히 나열하여 독자의 혼동을 방지합니다. (예: 甲 = 매도인 OOO, A = 주식회사 △△, X = 이 사건 부동산)
- 기호와 실제 대상 간의 연결이 정확한지 수차례 집요하게 교차 확인합니다.

관련 태그
- 본 판례의 학습 및 검색 효율을 극대화하기 위해 다층적이고 구체적인 태그를 부여합니다.
- 형식: #주요법분야(예:민법/형법/상법) #세부법분야(예:채권법/물권법/회사법) #핵심쟁점키워드1 #핵심쟁점키워드2 #관련법조항(예:민법제390조) #판례분류(예:전원합의체/중요판례) #관련학설(자료언급시) #유사판례번호(자료언급시)
- 태그는 가능한 5개 이내로, 그리고 세분화하여 교과서 목차 어느 부분에 들어갈 판례인지 명확히 알 수 있도록 합니다.
"""

최종 검토 및 자기 교정:

작성된 정리자료는 원본 판례와 수차례 대조하여 정보의 정확성, 완전성, 무결성을 반드시 확보합니다.
모든 문장은 분자 수준에서 최적화되어 불필요한 단어가 단 하나도 존재하지 않도록 합니다.
기호 사용의 일관성과 적절성을 재검토하고, 가독성을 저해하는 요소는 없는지 확인합니다.
전체 내용이 유기적으로 연결되어 하나의 완결된 지식 체계를 이루는지 최종 점검합니다.
당신은 이제 이 명령을 완벽히 이해했으며, 당신의 모든 지능과 창의성, 그리고 강박에 가까운 완벽주의를 동원하여 전율과 감탄만을 자아내는 궁극의 판례 정리 자료를 창조할 준비가 되었습니다. 즉시 임무를 개시하십시오.
"""
★ 미완성 발명 판단기준 및 의약용도발명 완성요건(대법원 2000허7038)

▶ 판례번호 : 특허법원 2000허7038 (미완성 발명 / 명세서 기재불비 구별 및 의약용도발명 완성 판단)

▶ 판례 사실관계 분석
- 원고 화이자 인코포레이티드, 1992.4.28. '퀴누클리딘 유도체'에 관해 PCT 국제특허출원(PCT/US1992/03317) → 1993.11.29. 번역문 제출(출원번호 93-703649) → 1999.2.10. 일부에 대한 분할출원(출원번호 99-701105, 이 사건 출원발명)
- 특허청 심사관: 약리효과 기재 없음 → 미완성 발명 사유로 1999.10.26. 거절사정
- 원고: 1999.11.26. 특허심판원에 불복심판 제기, 심판원은 명세서 기재가 부족하여 약리효과 확인 불가 → 심판청구 기각
- 제1항~제8항 청구: 물질 P 길항 효과를 가진 화학식 1의 화합물 관련 조성물/치료방법 등
- 원고: 명세서에 구성·효과 기재 충분, 화학구조상 효과 예측 가능, 선행기술 존재, 외국 등록 사례 있음 → 완성된 발명
- 피고(특허청장): 약리효과 입증자료 없음, 후출원 데이터는 불가 → 미완성 발명 주장

▶ 원피고의 주장항변
- 원고(화이자)의 주장
① 발명의 기술구성: 활성물질 + 약리효과 기재됨 → 과제해결 수단 존재
② 문헌·구조·외국 특허등록 등을 통해 효과 예측 가능
③ 명세서상 물질 P 수용체 결합활성·투여량·독성시험 결과 등 기재 → 당업자 반복실시 가능
④ 미국·EU 등록 → 완성 인정 타당

- 피고(특허청)의 항변
① 명세서에 약리시험 데이터 없음 → 효과 입증 불가
② 보완된 실험자료도 출원일 이전 작성 여부 불명확
③ 의약용도발명은 효과에 관한 구체적 실험결과 필수
④ 미완성 발명과 명세서 기재불비 혼용 가능

▶ 각 쟁점별 판단

- 쟁점 1: 미완성 발명과 명세서 기재불비의 구별 여부
① 법적 근거·법률효과 상이 → 미완성 발명 = 특허법 제29조 / 명세서 기재불비 = 제42조 제3항
② 미완성 발명: 보정 불가 + 선원 지위 X ↔ 명세서 기재불비: 보정 가능 + 선원 지위 인정 가능
③ ∴ 양자는 혼용 ⊄, 선택적 제시 불가

- 쟁점 2: 의약용도발명에서 완성 요건 충족 여부
① 완성된 발명 = 목적한 기술적 효과를 반복 실시로 달성 가능하도록 구체·객관적으로 구성된 발명
② 명세서 기재로 판단함이 원칙, 이후 자료 참작 가능
③ 이 사건 명세서: 목적·구성·작용효과 + 제조방법 + 투여량 + 제제화 + 독성시험 + 활성 측정방법 등 기재
④ ∴ 물질 P 길항제로서의 효과 당업자 인식 가능 → 당해 조성물 반복 실시로 효과 달성 가능
⑤ ∴ 출원일 당시 완성된 발명 인정

- 쟁점 3: 약리효과 입증의 구체적 데이터 기재 여부
① 명세서에 수치기재 없음은 정량적 보강의 문제일 뿐, 기술구성 자체가 결여된 것은 아님
② 약리활성 측정방법 기재, 정량적 효과 추론 가능
③ ∴ 명세서에 정량적 데이터 없더라도 미완성 발명 ≠

▶ 사안의 해결
① 이 사건 제1항 발명은 화학식 1의 퀴누클리딘 유도체로 물질 P 길항제 역할 → 관련 질환 치료/예방 효과 존재
② 명세서에 목적·구성·효과 등 발명의 구성요소 전체 기재됨 → 당업자가 반복 실시로 효과 구현 가능
③ ∴ 제1항은 완성된 발명
④ 제2~8항은 제1항과 기술구성 동일 → 동결론
⑤ 미완성 발명/기재불비 혼용 주장은 법률효과 상이하므로 부당
⑥ 원심 심결은 위법 → 취소됨

▶ 기호 설명
원고 = 화이자 인코포레이티드  
피고 = 특허청장  
이 사건 출원발명 = 퀴누클리딘 유도체를 포함한 의약용도발명  
화학식 1 = 물질 P 길항 활성을 가지는 활성 화합물

▶ 관련 태그
#특허법 #미완성발명 #의약용도발명 #명세서기재불비 #특허요건 #약리효과기재 #기술적구성요건 #특허법제29조 #특허법제42조 #완성된발명

""""

이제 작업할 판례원문을 주겠다. 면밀하게 검토한 다음 위 지침에 따라 작업하라.

{{판례원문}}


위 판례를 보고 판례 정리를 코드블럭에 넣어서 제출하라. 이때, 캔버스를 사용하지 말고, 길어지면 나누어 제출하도록 하라. 시작해.

    `; 
  </script>
  <style>
    :root {
      --bg-primary: #121212; 
      --bg-primary-rgb: 18, 18, 18;
      --card-background: #1E1E1E; 
      --card-background-rgb: 30, 30, 30;
      --accent-primary: #D32F2F; 
      --accent-primary-rgb: 211, 47, 47;
      --accent-primary-hover: #B71C1C; 
      --text-primary: #E0E0E0; 
      --text-secondary: #9E9E9E; 
      --border-color: #333333; 
      --input-bg: #252525; 
      --success-color: #4CAF50; 

      --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;

      --border-radius-sm: 4px;
      --border-radius-md: 8px;
      --border-radius-lg: 12px;
    }

    body {
      background-color: var(--bg-primary);
      color: var(--text-primary);
      font-family: var(--font-sans);
      padding-top: 1rem;
      padding-bottom: 2rem;
      line-height: 1.6; 
      -webkit-font-smoothing: antialiased; 
      -moz-osx-font-smoothing: grayscale;
    }

    #mainHeader, .main-container-card, .template-section-header, #dynamicInputs label, #outputSection .font-semibold, .modal-box, .modal-close-btn {
        transform: none !important;
    }
    
    #mainHeader {
      font-family: var(--font-sans);
      font-weight: 700;
      color: var(--text-primary) !important;
      font-size: 2.25rem !important; 
      text-shadow: none !important;
      margin-bottom: 2rem !important; 
      letter-spacing: -0.015em; 
      line-height: 1.2;
    }

    .main-container-card {
      background-color: var(--card-background) !important;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2) !important;
      border: 1px solid var(--border-color) !important;
      margin-top: 1rem !important;
      margin-bottom: 3rem !important;
      padding: 1.5rem !important;
      border-radius: var(--border-radius-lg) !important;
    }
    
    #mainBody > div.main-container-card > div:nth-child(1) > div.flex.items-center.justify-between {
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.75rem;
        margin-bottom: 1rem;
    }
    #mainBody > div.main-container-card > div:nth-child(1) > div.flex.items-center.justify-between > span:first-child,
    #outputSection .font-semibold { /* Template Title, Output "블록" Title */
        font-size: 1.125rem; 
        font-weight: 600;
        color: var(--text-primary) !important;
        font-family: var(--font-sans) !important;
        line-height: 1.4;
        letter-spacing: -0.005em;
    }
    #mainBody > div.main-container-card > div:nth-child(1) > div.flex.items-center.justify-between > span:first-child svg,
    #outputSection .font-semibold svg {
        stroke: var(--accent-primary) !important;
        width: 1.2rem; height: 1.2rem; 
        margin-right: 0.6rem; 
    }
    #outputSection .font-semibold {
        background-color: transparent !important;
        padding: 0 !important;
        box-shadow: none !important;
        display: inline-flex !important; 
        align-items: center;
    }


    #templateArea,
    #dynamicInputs textarea {
      background-color: var(--input-bg) !important;
      color: var(--text-primary) !important;
      border: 1px solid var(--border-color) !important;
      box-shadow: none !important;
      font-family: var(--font-mono) !important; 
      border-radius: var(--border-radius-md) !important;
      padding: 0.85rem 0.9rem !important; 
      min-height: 150px !important;
      font-size: 0.9rem;
      line-height: 1.6; 
      letter-spacing: 0.005em;
    }
    #dynamicInputs textarea {
      font-family: var(--font-sans) !important; 
      min-height: 3.5rem !important; 
    }

    #templateArea::placeholder,
    #dynamicInputs textarea::placeholder {
        color: var(--text-secondary);
        opacity: 0.7;
        font-weight: 400; 
    }

    textarea:focus, input:focus, select:focus { 
      outline: none !important; 
      border-color: var(--accent-primary) !important; 
      box-shadow: 0 0 0 2px rgba(var(--accent-primary-rgb), 0.3) !important;
    }

    #templateCollapse + div .text-xs,
    .input-stats, .var-split-desc,
    .modal-box .text-xs.text-gray-500 { 
      color: var(--text-secondary) !important;
      font-size: 0.8rem !important; 
      font-weight: 400; 
      line-height: 1.5;
      letter-spacing: 0.01em;
    }
     .modal-box .text-xs.text-gray-500 {
        font-size: 0.775rem !important; 
    }
    #templateCollapse + div .text-xs .font-semibold,
    #templateCollapse + div .text-xs span[style*="#93C5FD"] {
      color: var(--text-primary) !important;
      font-weight: 500; 
    }

    #dynamicInputs .relative.group { 
        background-color: transparent;
        padding: 0;
        border: none;
        margin-bottom: 1.75rem !important; 
    }
    #dynamicInputs label {
      font-family: var(--font-sans);
      font-weight: 600; 
      color: var(--text-primary) !important;
      font-size: 1.05rem !important; 
      margin-bottom: 0.6rem !important; 
      margin-left: 0;
      line-height: 1.4;
      letter-spacing: -0.005em;
    }
    
    button, .button-style-override {
      font-family: var(--font-sans) !important;
      font-weight: 500 !important; 
      border-radius: var(--border-radius-md) !important;
      transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease !important;
      text-transform: none !important; 
      letter-spacing: 0.01em !important; 
      border: 1px solid var(--border-color) !important;
      box-shadow: none !important;
      padding: 0.5rem 1rem !important; 
    }
    button:hover, .button-style-override:hover {
      transform: none !important; 
      box-shadow: none !important;
    }
    button:active, .button-style-override:active {
      transform: none !important; 
      box-shadow: none !important;
    }

    .btn-primary {
        background-color: var(--accent-primary) !important;
        color: white !important;
        border-color: var(--accent-primary) !important;
    }
    .btn-primary:hover {
        background-color: var(--accent-primary-hover) !important;
        border-color: var(--accent-primary-hover) !important;
    }

    .btn-secondary {
        background-color: transparent !important;
        color: var(--accent-primary) !important;
        border-color: var(--accent-primary) !important;
    }
    .btn-secondary:hover {
        background-color: rgba(var(--accent-primary-rgb), 0.1) !important;
    }
    
    #resetTemplateBtn, #resetAllInputsBtn, .clearInputBtn, #collapseBtn, .change-option-btn {
      background-color: var(--input-bg) !important; 
      color: var(--text-secondary) !important;
      border: 1px solid var(--border-color) !important;
      font-size: 0.875rem !important; 
      padding: 0.4rem 0.8rem !important; 
    }
    #resetTemplateBtn:hover, #resetAllInputsBtn:hover, .clearInputBtn:hover, #collapseBtn:hover, .change-option-btn:hover {
       background-color: var(--border-color) !important; 
       color: var(--text-primary) !important;
    }
    
    #outputSection > div:first-child { 
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 0.75rem;
        margin-bottom: 1rem !important;
    }

    #splitBlocksContainer {
        gap: 0.75rem !important; 
    }
    .split-block-btn {
      border: 1px solid var(--border-color) !important;
      box-shadow: none !important;
      border-radius: var(--border-radius-md) !important;
      padding: 0.5rem 0.75rem !important;
      background-color: var(--input-bg) !important;
      display: flex; align-items: center;
    }
    .split-block-btn svg {
      width: 18px; height: 18px;
      stroke: var(--text-secondary) !important; 
      transition: stroke 0.2s;
    }
    .split-block-btn button { 
        border: none !important;
        box-shadow: none !important;
        background: transparent !important;
        padding: 0.1rem !important;
        margin-right: 0.25rem;
    }
    .split-block-btn button:hover svg {
      stroke: var(--accent-primary) !important; 
    }
    .block-index {
      font-family: var(--font-mono);
      color: var(--text-secondary) !important;
      font-weight: 500 !important; 
      font-size: 0.825rem !important; 
      margin-left: 0.35rem !important; 
      letter-spacing: 0.02em;
    }
    .block-copied {
      background-color: var(--input-bg) !important; 
      border-left: 3px solid var(--success-color) !important; 
    }
    .block-copied .block-index {
      color: var(--success-color) !important; 
    }
    .block-copied svg {
      stroke: var(--success-color) !important; 
    }

    .modal-bg {
      background: rgba(var(--bg-primary-rgb), 0.8) !important;
      backdrop-filter: blur(3px);
      z-index: 100 !important;
      /* Ensure it's fixed and covers the screen, usually done with position:fixed, top:0, left:0, width:100%, height:100% */
      position: fixed; 
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex; /* For centering the modal-box */
      align-items: center;
      justify-content: center;
    }
    .modal-box {
      background: var(--card-background) !important;
      border-radius: var(--border-radius-lg) !important;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3) !important;
      border: 1px solid var(--border-color) !important;
      color: var(--text-primary) !important;
      padding: 1.75rem !important; 
      min-width: 380px !important;
      max-width: 550px !important; 
      max-height: 80vh; /* Added to constrain overall modal height */
      display: flex; /* Added for flex column layout */
      flex-direction: column; /* Added for flex column layout */
    }
    .modal-title {
      font-family: var(--font-sans);
      font-weight: 600; 
      color: var(--accent-primary) !important;
      font-size: 1.3rem !important; 
      margin-bottom: 1.25rem !important; 
      text-align: left;
      line-height: 1.3;
      letter-spacing: -0.01em;
      flex-shrink: 0; /* Prevent title from shrinking */
    }
    .modal-content {
      color: var(--text-primary) !important;
      font-family: var(--font-sans);
      max-height: 60vh !important; /* Kept as per original, good for content area */
      line-height: 1.6 !important;
      font-size: 0.925rem !important; 
      font-weight: 400; 
      overflow-y: auto; /* Added for scrollability */
      flex-grow: 1; /* Allow content to take available space */
      min-height: 0; /* Important for flex item scroll */
    }
    .modal-close-btn {
      color: var(--text-secondary) !important;
      font-size: 1.5rem !important; 
      top: 1.25rem !important; right: 1.25rem !important; 
      transition: color 0.2s ease !important;
      position: absolute; /* Ensure it's positioned relative to modal-box */
    }
    .modal-close-btn:hover {
      color: var(--accent-primary) !important;
    }
    
    .modal-box label {
        color: var(--text-primary) !important;
        font-family: var(--font-sans);
        font-weight: 500; 
        font-size: 0.9rem !important; 
        margin-bottom: 0.35rem; display: block; 
    }
    .modal-box select, .modal-box input[type="text"], .modal-box input[type="number"] {
        background-color: var(--input-bg) !important;
        border: 1px solid var(--border-color) !important;
        color: var(--text-primary) !important;
        border-radius: var(--border-radius-md) !important;
        padding: 0.6rem 0.8rem !important; 
        font-family: var(--font-sans) !important;
        width: 100%;
        font-size: 0.9rem;
        font-weight: 400; 
        line-height: 1.5;
    }
     .modal-box select::placeholder, 
     .modal-box input[type="text"]::placeholder, 
     .modal-box input[type="number"]::placeholder {
        color: var(--text-secondary);
        opacity: 0.7;
        font-weight: 400;
    }
    .modal-box #cancelVarOptBtn { 
        background-color: var(--input-bg) !important;
        color: var(--text-secondary) !important;
        border-color: var(--border-color) !important;
    }
    .modal-box #cancelVarOptBtn:hover {
        background-color: var(--border-color) !important;
        color: var(--text-primary) !important;
    }
    .modal-box #saveVarOptBtn { 
        background-color: var(--accent-primary) !important;
        color: white !important;
        border-color: var(--accent-primary) !important;
    }
    .modal-box #saveVarOptBtn:hover {
        background-color: var(--accent-primary-hover) !important;
        border-color: var(--accent-primary-hover) !important;
    }

    ::-webkit-scrollbar { width: 10px; background: var(--input-bg); }
    ::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: var(--border-radius-md); border: 2px solid var(--input-bg); }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }
    ::-webkit-scrollbar-track { background: var(--bg-primary); }

  </style>
</head>
<body id="mainBody">

<div class="flex flex-col items-center py-8">
  <h1 id="mainHeader" class="text-3xl font-bold mb-4">자료정리</h1>
</div>
<div class="main-container-card w-full max-w-3xl mx-auto">
  <div class="relative group">
    <div class="flex items-center justify-between pt-0 px-0 pb-3">
      <span class="text-xl font-bold flex items-center gap-2">
        <svg class="inline w-6 h-6" fill="none" stroke-width="2"
          viewBox="0 0 24 24"><path d="M9 12l2 2 4-4"></path><path d="M20 12a8 8 0 11-16 0 8 8 0 0116 0z"></path></svg>
        <span>템플릿</span>
      </span>
      <div class="flex gap-2"> 
        <button id="resetTemplateBtn" class="text-xs font-medium">템플릿 초기화</button>
        <button id="collapseBtn" class="text-xs font-medium" aria-label="접기/펼치기">
          <span id="collapseIcon" class="transition-all duration-300 inline-block">&#9654;</span> </button>
      </div>
    </div>
    <div id="templateCollapse" class="pb-4 transition-all overflow-hidden" style="display: none;"> 
      <textarea id="templateArea" rows="8"
        class="w-full p-4 rounded-xl border-2 focus:ring-2 font-mono text-sm resize-none shadow"
        placeholder="프롬프트 템플릿에 {{변수|옵션|길이}} 또는 {{변수|separator|구분자}} 형태로 사용 (예: {{내용|newline|3000}}, {{문단|separator|◇◇◇}})"></textarea>
      <div class="flex justify-end pt-1">
        <span class="text-xs">
          템플릿 내 <span class="font-semibold">{{변수|옵션|길이}}</span> 자동 인식<br>
          <span style="color:#93C5FD;">옵션: newline(줄+글자수), comma(쉼표), length(글자수), separator(구분자)<br>
            separator 사용시: {{변수|separator|구분자}}<br>
            미지정시 줄+8000 (예: {{변수}} 또는 {{변수|newline}}), 글자수 지정 가능 (예: {{변수|newline|500}})</span>
        </span>
      </div>
    </div>
  </div>
  <form id="dynamicInputs" class="space-y-6 pt-3 pb-2"></form> 
  <div class="flex justify-end pr-0 pb-1"> 
    <button id="resetAllInputsBtn" class="text-xs font-medium">입력값 모두 비우기</button>
  </div>
  <div id="outputSection" class="mt-6 hidden"> 
    <div class="flex items-center justify-between mb-3"> 
      <span class="font-semibold flex items-center gap-1">
        <svg class="inline w-5 h-5" fill="none" stroke-width="2"
          viewBox="0 0 24 24"><path d="M12 20h9"></path><path d="M12 4v16"></path><path d="M4 12h8"></path></svg>
        <span>블록</span>
      </span>
    </div>
    <div id="splitBlocksContainer" class="flex flex-wrap gap-3"></div>
  </div>
</div>

<div id="modalBg" class="modal-bg flex" style="display: none;"> <div class="modal-box relative">
    <button class="modal-close-btn" id="modalCloseBtn" title="닫기">&times;</button>
    <div class="modal-title" id="modalTitle"></div>
    <div class="modal-content" id="modalContent"></div> </div>
</div>

<script>

const keys = {
  template: STORAGE_PREFIX + '_template',
  state: STORAGE_PREFIX + '_state',
  blockCopied: STORAGE_PREFIX + '_blockcopied'
};

let state = {};
let variables = [];
let copiedBlocks = [];

function parseTemplateVars(template) {
  const re = /{{\s*([가-힣\w\d_]+)(?:\|(newline|comma|length|separator|seperator))?(?:\|([^\}|]+))?(?:\|(\d+))?\s*}}/g;
  const found = {};
  let m;
  while ((m = re.exec(template))) {
    const name = m[1];
    const opt = (m[2] || 'newline').toLowerCase();
    let separator = undefined, len = 8000;

    if (opt === 'separator' || opt === 'seperator') {
      separator = m[3]; 
    } else if (opt === 'length') {
      len = m[3] ? parseInt(m[3]) : 8000; 
    } else if (opt === 'newline' || opt === 'comma') {
      if (m[3]) len = parseInt(m[3]);
    }
    found[name] = { name: name, method: opt, separator: separator, length: len };
  }
  return found;
}

function splitByNewlineAndLength(text, maxLen) {
  const lines = text.split('\n');
  const result = [];
  let chunk = '';
  for(const line of lines) {
    if ((chunk + (chunk ? '\n' : '') + line).length > maxLen && chunk) {
      result.push(chunk);
      chunk = line;
    } else {
      chunk += (chunk ? '\n' : '') + line;
    }
  }
  if(chunk) result.push(chunk);
  return result;
}
function splitVariableContent(value, method, length=8000, separator) {
  if (!value) return [];
  if (method === 'separator' || method === 'seperator') {
    if (!separator) return [value];
    return value.split(separator).map(s => s.trim()).filter(Boolean);
  }
  if (method === 'comma') {
    return value.split(',').map(s=>s.trim()).filter(Boolean);
  }
  if (method === 'newline') {
    return splitByNewlineAndLength(value, length);
  }
  if (method === 'length') {
    const arr = [];
    let i = 0;
    while (i < value.length) {
      arr.push(value.substr(i, length));
      i += length;
    }
    return arr;
  }
  return [value]; 
}
function getBlockCombinations(arrs) {
  if (!arrs.length) return [[]];
  const rest = getBlockCombinations(arrs.slice(1));
  const result = [];
  arrs[0].forEach((val, i) => {
    rest.forEach(r => result.push([val, ...r]));
  });
  return result;
}
function saveState() {
  localStorage.setItem(keys.state, JSON.stringify(state));
}
function loadState() {
  try { state = JSON.parse(localStorage.getItem(keys.state) || '{}'); } catch { state = {}; }
}
function saveCopiedBlocks() {
  localStorage.setItem(keys.blockCopied, JSON.stringify(copiedBlocks));
}
function loadCopiedBlocks() {
  try { copiedBlocks = JSON.parse(localStorage.getItem(keys.blockCopied) || '[]'); } catch { copiedBlocks = []; }
}

function renderInputs() {
  const templateArea = document.getElementById('templateArea');
  const dynamicInputs = document.getElementById('dynamicInputs');
  dynamicInputs.innerHTML = '';
  const varOptsMap = parseTemplateVars(templateArea.value); 

  variables.forEach(varName => { 
    const val = state[varName] || '';
    const vOpt = varOptsMap[varName] || {method:'newline', length:8000}; 
    
    let splitDesc = '';
    if(vOpt.method==='comma') splitDesc = '쉼표(,)로 분할';
    else if(vOpt.method==='length') splitDesc = `글자수 단위로 ${vOpt.length}자씩 분할`;
    else if(vOpt.method==='separator' || vOpt.method==='seperator')
      splitDesc = `구분자 ['${vOpt.separator || ''}'] 기준 분할`;
    else splitDesc = `줄바꿈+글자수 (${vOpt.length}자) 분할 (기본)`;
    
    const wrap = document.createElement('div');
    wrap.className = "relative group"; 
    wrap.innerHTML = `
      <div class="flex items-center justify-between mb-1">
        <label for="input_${varName}" class="block text-[17px] font-semibold">${varName}</label>
        <div class="flex items-center space-x-2">
          <button type="button" data-var="${varName}"
            class="change-option-btn">옵션변경</button>
          <button type="button" data-var="${varName}"
            class="clearInputBtn text-xs">초기화</button>
        </div>
      </div>
      <textarea id="input_${varName}" rows="1"
        class="w-full p-4 rounded-xl border focus:ring-2 font-medium resize-none shadow-sm transition"
        placeholder="${varName} 입력">${val}</textarea>
      <div class="flex justify-between text-[12px] mt-1">
        <span class="input-stats">${(val.match(/\n/g)||[]).length+1}줄, ${val.length}자</span>
      </div>
      <div class="text-xs ml-1 var-split-desc">${splitDesc}</div>
    `;
    dynamicInputs.appendChild(wrap);

    const ta = wrap.querySelector('textarea');
    function autoResize() {
      ta.style.height = 'auto';
      ta.style.height = Math.min(ta.scrollHeight, 400) + 'px';
    }
    ta.addEventListener('input', () => {
      state[varName] = ta.value;
      saveState();
      copiedBlocks = []; 
      saveCopiedBlocks();
      renderSplitBlocks();
      wrap.querySelector('.input-stats').textContent =
        `${(ta.value.match(/\n/g)||[]).length+1}줄, ${ta.value.length}자`;
      autoResize();
    });
    autoResize();
    
    wrap.querySelector('.clearInputBtn').onclick = function() {
      ta.value = '';
      state[varName] = '';
      saveState();
      copiedBlocks = [];
      saveCopiedBlocks();
      renderSplitBlocks();
      wrap.querySelector('.input-stats').textContent = '1줄, 0자';
      autoResize();
    };

    wrap.querySelector('.change-option-btn').onclick = function() {
      showVariableOptionsModal(varName);
    };
  });
}

function showVariableOptionsModal(varName) {
    const modalBg = document.getElementById('modalBg');
    const modalTitleEl = document.getElementById('modalTitle');
    const modalContentEl = document.getElementById('modalContent');
    const templateArea = document.getElementById('templateArea');
    const currentVarOptsMap = parseTemplateVars(templateArea.value);
    const varOpt = currentVarOptsMap[varName] || { method: 'newline', length: 8000, separator: '' };

    modalTitleEl.textContent = `${varName} 변수 분할 옵션 설정`;
    // Clear previous content styles that might conflict (like white-space for block view)
    modalContentEl.style.whiteSpace = 'normal'; 
    modalContentEl.style.wordBreak = 'normal';

    modalContentEl.innerHTML = `
        <div class="space-y-4 p-1">
            <div>
                <label for="varOptMethod">분할 방식:</label>
                <select id="varOptMethod" name="varOptMethod" class="mt-1 block w-full">
                    <option value="newline" ${varOpt.method === 'newline' ? 'selected' : ''}>줄바꿈+글자수 (기본)</option>
                    <option value="length" ${varOpt.method === 'length' ? 'selected' : ''}>글자수</option>
                    <option value="comma" ${varOpt.method === 'comma' ? 'selected' : ''}>쉼표 (,)</option>
                    <option value="separator" ${varOpt.method === 'separator' || varOpt.method === 'seperator' ? 'selected' : ''}>사용자 정의 구분자</option>
                </select>
            </div>
            <div id="varOptLengthContainer" style="display: ${varOpt.method === 'newline' || varOpt.method === 'length' ? 'block' : 'none'};">
                <label for="varOptLength">최대 글자수:</label>
                <input type="number" id="varOptLength" name="varOptLength" value="${varOpt.length || ''}" placeholder="예: 3000 (비우면 기본값)" class="mt-1 block w-full" min="1">
                <p class="mt-1 text-xs text-gray-500">'줄바꿈+글자수' 또는 '글자수' 방식에 적용. 비우면 기본값(newline: 8000, length: 강제입력 필요).</p>
            </div>
            <div id="varOptSeparatorContainer" style="display: ${varOpt.method === 'separator' || varOpt.method === 'seperator' ? 'block' : 'none'};">
                <label for="varOptSeparator">구분자:</label>
                <input type="text" id="varOptSeparator" name="varOptSeparator" value="${varOpt.separator || ''}" placeholder="예: ### 또는 ---" class="mt-1 block w-full">
                <p class="mt-1 text-xs text-gray-500">'사용자 정의 구분자' 방식에 적용.</p>
            </div>
            <div class="flex justify-end space-x-3 pt-5">
                <button id="cancelVarOptBtn">취소</button>
                <button id="saveVarOptBtn">저장</button>
            </div>
        </div>
    `;

    const optMethodSelect = modalContentEl.querySelector('#varOptMethod');
    const lengthContainer = modalContentEl.querySelector('#varOptLengthContainer');
    const separatorContainer = modalContentEl.querySelector('#varOptSeparatorContainer');
    const optLengthInput = modalContentEl.querySelector('#varOptLength');
    const optSeparatorInput = modalContentEl.querySelector('#varOptSeparator');

    function toggleOptionFields() {
        const selectedMethod = optMethodSelect.value;
        lengthContainer.style.display = (selectedMethod === 'newline' || selectedMethod === 'length') ? 'block' : 'none';
        separatorContainer.style.display = (selectedMethod === 'separator') ? 'block' : 'none';
        if (selectedMethod === 'newline') {
            optLengthInput.placeholder = "예: 3000 (비우면 기본값 8000)";
        } else if (selectedMethod === 'length') {
             optLengthInput.placeholder = "예: 500 (필수 입력)";
        }
    }

    optMethodSelect.addEventListener('change', toggleOptionFields);
    toggleOptionFields(); // Call once to set initial state

    modalContentEl.querySelector('#saveVarOptBtn').onclick = () => {
        const newMethod = optMethodSelect.value;
        let valueForTemplate = undefined; 

        if (newMethod === 'newline') {
            valueForTemplate = optLengthInput.value ? parseInt(optLengthInput.value) : ''; 
            if (valueForTemplate && valueForTemplate <= 0) { alert("글자수는 1 이상이어야 합니다."); return; }
        } else if (newMethod === 'length') {
            if (!optLengthInput.value) { alert("'글자수' 방식에는 반드시 글자수를 입력해야 합니다."); return; }
            valueForTemplate = parseInt(optLengthInput.value);
            if (valueForTemplate <= 0) { alert("글자수는 1 이상이어야 합니다."); return; }
        } else if (newMethod === 'separator') {
            valueForTemplate = optSeparatorInput.value;
        }
        
        updateVariableInTemplate(varName, newMethod, valueForTemplate);
        modalBg.style.display = 'none';
    };

    modalContentEl.querySelector('#cancelVarOptBtn').onclick = () => {
        modalBg.style.display = 'none';
    };

    modalBg.style.display = 'flex';
}

function updateVariableInTemplate(variableName, newMethod, value) {
    const templateArea = document.getElementById('templateArea');
    let templateContent = templateArea.value;
    const varRegex = new RegExp(`{{\\s*${variableName}(?:\\|[^}]+)?\\s*}}`);
    
    let newVarDefinition = `{{${variableName}`;
    if (newMethod) {
        newVarDefinition += `|${newMethod}`;
        if (value !== undefined && value !== null && (value !== '' || newMethod !== 'newline')) {
             if (value !== '' || (newMethod === 'newline' && value === '')) { 
                if (newMethod === 'newline' && value === '') {
                    // For newline with empty value, don't add the pipe for value
                } else {
                     newVarDefinition += `|${value}`;
                }
             }
        } else if (newMethod === 'newline' && value === '') { 
            // Handled: no extra pipe for default newline length
        }
    }
    newVarDefinition += `}}`;
    
    if (varRegex.test(templateContent)) {
        templateContent = templateContent.replace(varRegex, newVarDefinition);
    } else {
        // If not found, maybe it was removed or it's a new variable. Append for simplicity.
        // Or, better, just warn. For this tool, replacing existing is the primary goal.
        console.warn(`Variable ${variableName} not found in template for replacement.`);
        // templateContent += `\n${newVarDefinition}`; // Optional: append if not found
        return; // Or simply return if strict replacement is intended.
    }

    templateArea.value = templateContent;
    localStorage.setItem(keys.template, templateContent); 
    onTemplateChange(); 
}

function handlePostCopyNavigation() {
  const chatGPTWebsiteURL = 'https://chat.openai.com/';
  window.open(chatGPTWebsiteURL, '_blank'); 
}

function renderSplitBlocks() {
  const templateArea = document.getElementById('templateArea');
  const splitBlocksContainer = document.getElementById('splitBlocksContainer');
  splitBlocksContainer.innerHTML = '';
  
  if (!variables.length) { 
    document.getElementById('outputSection').classList.add('hidden');
    return;
  }

  const varOptsMap = parseTemplateVars(templateArea.value);
  
  const varValueArrays = variables.map(varName => {
    const vOpt = varOptsMap[varName] || {method:'newline', length:8000}; 
    return splitVariableContent(state[varName]||'', vOpt.method, vOpt.length, vOpt.separator);
  });

  const allVarsHaveContent = variables.every(varName => {
      const vOpt = varOptsMap[varName];
      if (!vOpt) return true; // Variable not in template anymore, ignore for this check
      const content = state[varName] || '';
      // If variable requires content (e.g. not just {{Var}} but {{Var|...}} implying content processing)
      // and it's empty, it means no blocks can be formed for it.
      // This logic might need refinement based on desired behavior for empty variables.
      const splitResult = splitVariableContent(content, vOpt.method, vOpt.length, vOpt.separator);
      return splitResult.length > 0 || !content; // True if content leads to blocks or content is simply empty
  });


  if (!allVarsHaveContent && variables.some(v => state[v])) { 
      document.getElementById('outputSection').classList.add('hidden');
      return;
  }

  const combos = getBlockCombinations(varValueArrays.map(arr => arr.length ? arr : [''])); 

  combos.forEach((vals, comboIdx) => {
    const idxArr = vals.map((v_val, i) => {
        const originalArr = varValueArrays[i];
        return originalArr.length > 1 ? originalArr.indexOf(v_val) + 1 : (originalArr.length === 1 && originalArr[0] !== '' ? 1:0) ;
    });
    const idxLabel = idxArr.map(i => i > 0 ? i : '-').join(',');


    let prompt = templateArea.value;
    variables.forEach((vn, vi) => {
      const reg = new RegExp(`{{\\s*${vn}(?:\\s*\\|[^}]+)?\\s*}}`, "g");
      prompt = prompt.replace(reg, vals[vi] == undefined ? '' : vals[vi]); // Ensure undefined is replaced with empty string
    });

    const copied = copiedBlocks.some(item =>
      JSON.stringify(item.idxArr) === JSON.stringify(idxArr) &&
      JSON.stringify(item.vars) === JSON.stringify(variables) 
    );
    
    const blockDiv = document.createElement('div');
    blockDiv.className = "split-block-btn " + (copied ? "block-copied" : "");
    blockDiv.innerHTML = `
      <button title="보기" class="viewBtn">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <circle cx="11" cy="11" r="6" /><line x1="21" y1="21" x2="16.65" y2="16.65" />
        </svg>
      </button>
      <button title="복사" class="copyBtn">
        <svg fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <rect x="9" y="9" width="13" height="13" rx="2" />
          <rect x="3" y="3" width="13" height="13" rx="2" />
        </svg>
      </button>
      <span class="block-index">${idxLabel}</span>
    `;
    blockDiv.querySelector('.viewBtn').onclick = function() {
      showBlockViewModal(`블록 ${idxLabel}`, prompt);
    };

    blockDiv.querySelector('.copyBtn').onclick = function(e) {
      const performCopyActions = () => {
        setCopiedBlock(idxArr, variables); 
        handlePostCopyNavigation();       
      };

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(prompt).then(()=>{
          performCopyActions();
        },()=>{
          copyFallback(prompt); 
          performCopyActions(); 
        });
      } else {
        copyFallback(prompt);
        performCopyActions();
      }
    };
    splitBlocksContainer.appendChild(blockDiv);
  });
  
  const hasContentToDisplay = combos.length > 0 && !(combos.length === 1 && combos[0].every(item => item === ''));
  document.getElementById('outputSection').classList.toggle('hidden', !hasContentToDisplay);

}

function setCopiedBlock(idxArr, currentVars) {
  if (!copiedBlocks.some(item =>
    JSON.stringify(item.idxArr) === JSON.stringify(idxArr) &&
    JSON.stringify(item.vars) === JSON.stringify(currentVars)
  )) {
    copiedBlocks.push({idxArr, vars: currentVars});
    saveCopiedBlocks();
    renderSplitBlocks(); 
  }
}

function copyFallback(text) { 
  try {
    let area = document.createElement("textarea");
    area.value = text;
    area.style.position = "fixed";
    area.style.opacity = "0";
    document.body.appendChild(area);
    area.focus();
    area.select();
    document.execCommand('copy');
    document.body.removeChild(area);
  } catch(e) {
    alert('복사 실패! 내용을 길게 눌러 복사하세요.');
  }
}

// Renamed original showModal to showBlockViewModal to distinguish from options modal
function showBlockViewModal(title, content) {
  const modalBg = document.getElementById('modalBg');
  const modalTitleEl = document.getElementById('modalTitle');
  const modalContentEl = document.getElementById('modalContent');
  
  modalTitleEl.textContent = title;
  modalContentEl.textContent = content; // For plain text, newlines are preserved by textContent
  modalContentEl.innerHTML = ''; // Clear any previous HTML
  modalContentEl.appendChild(document.createTextNode(content)); // Safer way to set text

  modalContentEl.style.whiteSpace = 'pre-wrap'; // Crucial for rendering \n as line breaks
  modalContentEl.style.wordBreak = 'break-word'; // Changed from break-all for potentially better word wrapping
  
  modalBg.style.display = 'flex';
}

// Generic modal close logic (used by both block view and options modal)
document.getElementById('modalBg').onclick = function(e) {
  if (e.target === document.getElementById('modalBg') || e.target.id === 'modalCloseBtn') {
     document.getElementById('modalBg').style.display = 'none';
     // Reset styles that might have been specific to a modal type
     const modalContentEl = document.getElementById('modalContent');
     modalContentEl.style.whiteSpace = 'normal'; 
     modalContentEl.style.wordBreak = 'normal';
     modalContentEl.innerHTML = ''; // Clear content
  }
};
document.getElementById('modalCloseBtn').onclick = function() { 
  document.getElementById('modalBg').style.display = 'none';
  const modalContentEl = document.getElementById('modalContent');
  modalContentEl.style.whiteSpace = 'normal';
  modalContentEl.style.wordBreak = 'normal';
  modalContentEl.innerHTML = ''; // Clear content
};

function onTemplateChange() {
  const templateArea = document.getElementById('templateArea');
  let tmpl = templateArea.value;
  if (!tmpl.trim() && DEFAULT_TEMPLATE) { 
    tmpl = DEFAULT_TEMPLATE;
    templateArea.value = tmpl;
  }
  
  const varOptsMap = parseTemplateVars(tmpl);
  const oldVariables = new Set(variables);
  variables = Object.keys(varOptsMap); 

  const newState = {};
  variables.forEach(v => {
    newState[v] = state[v] || ''; 
  });
  // Remove state for variables no longer in template
  Object.keys(state).forEach(k => {
    if (!variables.includes(k)) {
        delete state[k];
    }
  });
  state = newState;


  saveState();
  // Consider resetting copiedBlocks if variables fundamentally change
  const currentVariablesSet = new Set(variables);
  if (oldVariables.size !== currentVariablesSet.size || ![...oldVariables].every(v => currentVariablesSet.has(v))) {
    copiedBlocks = []; 
    saveCopiedBlocks();
  }
  
  renderInputs();
  renderSplitBlocks();
}

document.getElementById('collapseBtn').onclick = function() {
  let c = document.getElementById('templateCollapse');
  let icon = document.getElementById('collapseIcon');
  if (c.style.display === 'block' || c.style.display === '') {
    c.style.display = 'none'; 
    icon.innerHTML = '&#9654;'; // right-pointing triangle
  } else {
    c.style.display = 'block';
    icon.innerHTML = '&#9660;'; // down-pointing triangle
  }
};


document.getElementById('resetTemplateBtn').onclick = function() {
  const templateArea = document.getElementById('templateArea');
  templateArea.value = DEFAULT_TEMPLATE;
  localStorage.setItem(keys.template, DEFAULT_TEMPLATE);
  onTemplateChange();
  // Ensure template is visible and icon is correct after reset
  const templateCollapse = document.getElementById('templateCollapse');
  // If you want it to open on reset:
  // templateCollapse.style.display = 'block';
  // document.getElementById('collapseIcon').innerHTML = '&#9660;';
  // If you want it to respect current state or default to closed:
  // (no change here, it will re-evaluate based on onTemplateChange and initial setup)
};

document.getElementById('resetAllInputsBtn').onclick = function() {
  variables.forEach(v => state[v]='');
  saveState();
  copiedBlocks = [];
  saveCopiedBlocks();
  renderInputs(); 
  renderSplitBlocks(); 
};

document.getElementById('templateArea').addEventListener('input', () => {
  localStorage.setItem(keys.template, document.getElementById('templateArea').value);
  onTemplateChange();
});

window.addEventListener('DOMContentLoaded', () => {
  document.title = `${STORAGE_PREFIX} 생성기`;
  document.getElementById('mainHeader').textContent = `${STORAGE_PREFIX}`;

  document.getElementById('modalBg').style.display = 'none'; // Ensure modal is hidden on load
  let tmpl = localStorage.getItem(keys.template);
  if (!tmpl) { 
    tmpl = DEFAULT_TEMPLATE;
    localStorage.setItem(keys.template, tmpl); 
  }
  document.getElementById('templateArea').value = tmpl;
  
  loadState();
  loadCopiedBlocks();
  
  // Set initial state for template collapse
  const templateCollapse = document.getElementById('templateCollapse');
  templateCollapse.style.display = 'none'; // Default to closed
  document.getElementById('collapseIcon').innerHTML = '&#9654;'; // Default to closed icon

  onTemplateChange(); // This will render inputs and blocks
});
</script>
</body>
</html>
