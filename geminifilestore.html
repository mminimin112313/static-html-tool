<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini File Store 관리자</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <style>
      body {
        background-color: #030712; /* bg-gray-950 (유지) */
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      }
      .drag-over {
        border-style: dashed !important;
        border-color: #16a34a !important; /* [COLOR] green-600 */
        background-color: #171717 !important; /* [COLOR] neutral-900 */
      }
      /* Prose (Chat) Styles */
      .prose p { margin-top: 0.75em; margin-bottom: 0.75em; }
      .prose ul, .prose ol { list-style-position: inside; padding-left: 1.5em; margin: 0.75em 0; }
      .prose li { margin: 0.3em 0; }
      .prose pre { background-color: #030712; padding: 1rem; border-radius: 0.75rem; overflow-x: auto; margin: 1em 0; font-family: monospace; }
      .prose code:not(pre code) { background-color: #262626; padding: 0.2em 0.4em; border-radius: 0.25rem; font-family: monospace; } /* neutral-800 */
      .prose a { color: #22c55e; text-decoration: underline; } /* [COLOR] green-500 */
      .prose-invert { color: #d1d5db; }
      .prose-invert a { color: #4ade80; } /* [COLOR] green-400 */
      .prose-invert strong { color: #ffffff; }
      div.prose.prose-invert table {
        width: 100%;
        border-collapse: collapse;
        margin: 1em 0;
      }
      div.prose.prose-invert th {
        background-color: #404040; /* [COLOR] neutral-700 */
        border: 1px solid #525252; /* [COLOR] neutral-600 */
        padding: 0.75em 1em;
        font-weight: 600;
        color: #ffffff !important; 
        text-align: left;
      }
      div.prose.prose-invert td {
        border: 1px solid #525252; /* [COLOR] neutral-600 */
        padding: 0.75em 1em;
        color: #d1d5db !important; 
      }
      div.prose.prose-invert tr:nth-child(even) {
          background-color: #262626; /* [COLOR] neutral-800 */
      }
        
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .animate-fade-in {
        animation: fadeIn 0.3s ease-out;
      }
      
      .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 20px; 
            height: 20px;
            border-radius: 50%;
            border-left-color: #22c55e; /* [COLOR] green-500 */
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
      /* [COLOR] Custom Scrollbar */
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: #030712; /* bg-gray-950 */
      }
      ::-webkit-scrollbar-thumb {
        background: #262626; /* [COLOR] neutral-800 */
        border-radius: 5px;
        border: 2px solid #030712;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #404040; /* [COLOR] neutral-700 */
      }
      
      /* [COLOR] SweetAlert2 Dark Theme */
      body.swal2-shown > [aria-hidden="true"] {
        filter: blur(5px);
      }
      .swal2-popup {
        background: #171717 !important; /* [COLOR] neutral-900 */
        border-radius: 1rem !important; /* rounded-2xl */
        border: 1px solid #262626 !important; /* [COLOR] neutral-800 */
        box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.2), 0 8px 10px -6px rgb(0 0 0 / 0.2) !important;
      }
      .swal2-title {
        color: #ffffff !important;
      }
      .swal2-html-container {
        color: #d1d5db !important; /* text-gray-300 */
      }
      .swal2-confirm {
        background-color: #16a34a !important; /* [COLOR] bg-green-600 */
        border-radius: 0.75rem !important; /* rounded-xl */
      }
      .swal2-confirm:hover {
        background-color: #15803d !important; /* [COLOR] bg-green-700 */
      }
      .swal2-cancel {
        background-color: #404040 !important; /* [COLOR] bg-neutral-700 */
        border-radius: 0.75rem !important; /* rounded-xl */
      }
      .swal2-cancel:hover {
         background-color: #525252 !important; /* [COLOR] bg-neutral-600 */
      }
      .swal2-icon.swal2-warning {
        border-color: #f97316 !important;
        color: #f97316 !important;
      }
      .swal2-icon.swal2-info {
        border-color: #22c55e !important; /* [COLOR] green-500 */
        color: #22c55e !important; /* [COLOR] green-500 */
      }
    </style>
</head>
<body>
    <noscript>이 앱을 실행하려면 JavaScript가 필요합니다.</noscript>
    <div id="root"></div>

    <script type="text/babel">
(function() { // IIFE

const { useState, useEffect, useRef, useMemo, useCallback } = React;

/* --- 아이콘 컴포넌트 (Bootstrap Icons) --- */
function IconFolder() { return ( <i className="bi bi-folder text-xl"></i> ); }
function IconChat() { return ( <i className="bi bi-chat-dots text-xl"></i> ); }
function IconTrash() { return ( <i className="bi bi-trash text-xl"></i> ); }
function IconFile() { return ( <i className="bi bi-file-earmark-text text-xl"></i> ); }
function IconCloudUpload() { return ( <i className="bi bi-cloud-arrow-up text-xl"></i> ); }
function IconPlus() { return ( <i className="bi bi-plus-lg text-xl"></i> ); }
function IconSpinner() { return ( <div className="spinner !w-5 !h-5" role="status"></div> ); }
function IconArrowLeft() { return ( <i className="bi bi-arrow-left text-xl"></i> ); }
function IconSearch() { return ( <i className="bi bi-search text-xl"></i> ); }
function IconCopy() { return ( <i className="bi bi-clipboard text-base"></i> ); }
function IconCheck() { return ( <i className="bi bi-check-lg text-base"></i> ); }
function IconUser() { return ( <i className="bi bi-person text-xl"></i> ); }
function IconGemini() { return ( <i className="bi bi-gem text-xl"></i> ); }
function IconEdit() { return ( <i className="bi bi-pencil text-base"></i> ); }
function IconCheckSmall() { return ( <i className="bi bi-check-lg text-base"></i> ); }
function IconXSmall() { return ( <i className="bi bi-x-lg text-base"></i> ); }
function IconUploadQueue() { return ( <i className="bi bi-cloud-arrow-up text-xl"></i> ); }
function IconExternalLink() { return ( <i className="bi bi-box-arrow-up-right text-xs"></i> ); }
function IconSettings() { return ( <i className="bi bi-gear text-xl"></i> ); }
function IconXCircle() { return ( <i className="bi bi-x-circle text-xl"></i> ); }
function IconFileQueue() { return ( <i className="bi bi-file-earmark text-xl"></i> ); }
function IconDownload() { return ( <i className="bi bi-download text-xl"></i> ); }


/* --- API 및 유틸리티 --- */

const API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/';
const UPLOAD_BASE_URL = 'https://generativelanguage.googleapis.com/upload/v1beta/';

const DB_NAME = 'GeminiFileStoreDB';
const CHAT_STORE = 'chats';

// (IndexedDB 헬퍼, apiRequest, apiGeminiFilter, apiUploadRequest, formatBytes, useClipboard, useAutosizeTextarea 함수는 변경 없음)
function openDB() { return new Promise((resolve, reject) => { const request = indexedDB.open(DB_NAME, 1); request.onupgradeneeded = (event) => { const db = event.target.result; if (!db.objectStoreNames.contains(CHAT_STORE)) { db.createObjectStore(CHAT_STORE, { keyPath: 'id' }); } }; request.onsuccess = (event) => { resolve(event.target.result); }; request.onerror = (event) => { reject('IndexedDB error: ' + event.target.errorCode); }; }); }
function dbRequest(storeName, mode, operation) { return new Promise(async (resolve, reject) => { try { const db = await openDB(); const tx = db.transaction(storeName, mode); const store = tx.objectStore(storeName); operation(store, resolve, reject); tx.oncomplete = () => { if (mode !== 'readonly') { resolve(); } }; tx.onerror = (event) => { reject(event.target.error); }; } catch (error) { reject(error); } }); }
function getChatsFromDB() { return dbRequest(CHAT_STORE, 'readonly', (store, resolve) => { const request = store.getAll(); request.onsuccess = () => resolve(request.result); }); }
function saveChatToDB(chat) { return dbRequest(CHAT_STORE, 'readwrite', (store) => { store.put(chat); }); }
function deleteChatFromDB(chatId) { return dbRequest(CHAT_STORE, 'readwrite', (store) => { store.delete(chatId); }); }
function clearChatsFromDB() { return dbRequest(CHAT_STORE, 'readwrite', (store) => { store.clear(); }); }

async function apiRequest(endpoint, options = {}, apiKey) {
  let url = `${API_BASE_URL}${endpoint}`;
  if (options.params) {
    const query = new URLSearchParams(options.params).toString();
    if (query) {
      url += `?${query}`;
    }
  }
  const headers = { 'Content-Type': 'application/json', 'x-goog-api-key': apiKey, ...options.headers, };
  const method = options.method || 'GET';
  console.log(`[File API] Requesting: ${method} ${url}`);
  try {
    const response = await fetch(url, { ...options, method, headers, params: undefined }); 
    if (!response.ok) {
      const errorData = await response.json();
      console.error('API Error Response:', errorData);
      throw new Error(`API Error: ${errorData.error?.message || response.statusText}`);
    }
    const text = await response.text();
    const jsonData = text ? JSON.parse(text) : {};
    console.log(`[File API] Success: ${method} ${endpoint}`, jsonData);
    return jsonData;
  } catch (error) {
    console.error(`API Request Failed: ${error.message}`);
    throw error;
  }
}

async function apiGeminiFilter(prompt, apiKey, modelName, retries = 3, delay = 1000) { 
  console.log('%c[Gemini API] 호출 시작...', 'color: blue; font-weight: bold;');
  console.log(`[Gemini API] Model: ${modelName}`);
  console.log('[Gemini API] Prompt:', prompt);
  const apiUrl = `${API_BASE_URL}models/${modelName}:generateContent?key=${apiKey}`;
  const payload = { contents: [{ parts: [{ text: prompt }] }], };
  for (let i = 0; i < retries; i++) {
      try {
          console.log(`[Gemini API] ${i + 1}번째 시도...`);
          const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
          if (!response.ok) {
              const errorData = await response.json();
              console.error('[Gemini API] 응답 오류:', errorData);
              throw new Error(errorData.error?.message || `HTTP ${response.status} 오류`);
          }
          const result = await response.json();
          console.log('[Gemini API] 응답 성공:', result);
          if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0].text) {
              const extractedText = result.candidates[0].content.parts[0].text;
              console.log('[Gemini API] 추출된 텍스트:', extractedText);
              return extractedText;
          } else {
              let errorMsg = 'Gemini API로부터 유효한 응답을 받지 못했습니다.';
              if (result.candidates && result.candidates[0].finishReason) {
                  errorMsg += ` (이유: ${result.candidates[0].finishReason})`;
              }
              console.warn('[Gemini API] 콘텐츠 없음:', errorMsg, result);
              throw new Error(errorMsg);
          }
      } catch (error) {
          console.warn(`[Gemini API] ${i + 1}번째 시도 실패:`, error);
          if (i === retries - 1) {
              throw error;
          }
          await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));
      }
  }
}

async function apiUploadRequest(endpoint, file, metadata, apiKey, onProgress) {
  const params = new URLSearchParams();
  if (metadata.displayName) {
    params.append('displayName', metadata.displayName);
  }
  const url = `${UPLOAD_BASE_URL}${endpoint}?${params.toString()}`;
  const formData = new FormData();
  formData.append('file', file);
  console.log(`[File Upload] Requesting: POST ${url}`);
  try {
    const response = await fetch(url, { method: 'POST', headers: { 'x-goog-api-key': apiKey, }, body: formData, });
    const responseText = await response.text();
    if (!response.ok) {
        console.error('Upload API Error Response Text:', responseText);
        throw new Error(`Upload API Error: ${responseText}`);
    }
    try {
        const jsonData = JSON.parse(responseText);
        console.log(`[File Upload] Success:`, jsonData);
        return jsonData;
    } catch (parseError) {
        console.error('API Upload JSON Parse Error:', parseError, 'Response Text:', responseText);
        throw new Error(`업로드 API가 JSON이 아닌 응답을 반환했습니다: ${responseText.substring(0, 100)}...`);
    }
  } catch (error) {
    console.error('API Upload Error:', error);
    throw error;
  }
}

function formatBytes(bytes, decimals = 2) { if (!bytes || bytes === 0) return 'N/A'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`; }

function useClipboard(timeout = 1500) { 
  const [copied, setCopied] = useState(false); 
  const copy = useCallback((text) => { 
    try { 
      const el = document.createElement('textarea'); 
      el.value = text; 
      document.body.appendChild(el); 
      el.select(); 
      const success = document.execCommand('copy'); 
      document.body.removeChild(el); 
      if (success) { 
        setCopied(true); 
        setTimeout(() => setCopied(false), timeout); 
      } else { 
        throw new Error('Copy command failed'); 
      } 
    } catch (e) { 
      console.error('Failed to copy to clipboard:', e); 
      // SweetAlert2는 전역 스타일을 사용합니다.
    } 
  }, [timeout]); 
  return [copied, copy]; 
}

function useAutosizeTextarea(textareaRef, value) {
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = '0px'; 
      const scrollHeight = textareaRef.current.scrollHeight;
      textareaRef.current.style.height = `${scrollHeight}px`; 
    }
  }, [textareaRef, value]);
}


/* --- [COLOR] 하위 컴포넌트 --- */

// [COLOR] 설정 모달
function SettingsModal({ isOpen, onClose, apiKey, setApiKey, systemInstruction, setSystemInstruction, selectedModel, setSelectedModel }) {
  const [localApiKey, setLocalApiKey] = useState(apiKey);
  const [localInstruction, setLocalInstruction] = useState(systemInstruction);
  const [localModel, setLocalModel] = useState(selectedModel); 

  useEffect(() => { setLocalApiKey(apiKey); }, [apiKey]);
  useEffect(() => { setLocalInstruction(systemInstruction); }, [systemInstruction]);
  useEffect(() => { setLocalModel(selectedModel); }, [selectedModel]); 

  if (!isOpen) return null;

  const handleSave = () => {
    setApiKey(localApiKey);
    setSystemInstruction(localInstruction);
    setSelectedModel(localModel); 
    localStorage.setItem('gemini-api-key', localApiKey);
    localStorage.setItem('gemini-system-instruction', localInstruction);
    localStorage.setItem('gemini-selected-model', localModel); 
    onClose();
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-75 backdrop-blur-sm">
      <div className="bg-neutral-900 rounded-2xl shadow-2xl w-full max-w-2xl p-8 border border-neutral-800 animate-fade-in">
        <h2 className="text-2xl font-bold text-white mb-8">설정</h2>
        
        <div className="mb-6">
          <label htmlFor="apiKey" className="block text-sm font-medium text-gray-300 mb-2">
            Gemini API 키
          </label>
          <input
            type="password"
            id="apiKey"
            value={localApiKey}
            onChange={(e) => setLocalApiKey(e.target.value)}
            className="w-full px-4 py-3 bg-neutral-800 text-white rounded-xl border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-green-500"
            placeholder="gme-..."
          />
        </div>

        <div className="mb-6">
          <label htmlFor="modelSelect" className="block text-sm font-medium text-gray-300 mb-2">
            Gemini 모델 선택 (채팅 및 필터링)
          </label>
          <select
            id="modelSelect"
            value={localModel}
            onChange={(e) => setLocalModel(e.target.value)}
            className="w-full px-4 py-3 bg-neutral-800 text-white rounded-xl border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-green-500"
          >
            <option value="gemini-2.5-pro">Gemini 2.5 Pro (최고 성능)</option>
            <option value="gemini-2.5-flash">Gemini 2.5 Flash (균형 - Stable)</option>
            <option value="gemini-flash-latest">Gemini Flash (최신 별칭)</option>
            <option value="gemini-2.5-flash-preview-09-2025">Gemini 2.5 Flash Preview (9월)</option>
          </select>
          <p className="text-xs text-gray-500 mt-2">
            'File Search' (파일 검색) 기능이 지원되는 모델만 표시됩니다.
          </p>
        </div>

        <div className="mb-8">
          <label htmlFor="systemInstruction" className="block text-sm font-medium text-gray-300 mb-2">
            시스템 프롬프트 (System Instruction)
          </label>
          <textarea
            id="systemInstruction"
            rows="8"
            value={localInstruction}
            onChange={(e) => setLocalInstruction(e.target.value)}
            className="w-full px-4 py-3 bg-neutral-800 text-white rounded-xl border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-green-500"
            placeholder="모델이 항상 따르도록 할 지침을 입력하세요..."
          />
        </div>
        
        <div className="flex justify-end space-x-4">
          <button
            onClick={onClose}
            className="bg-neutral-700 hover:bg-neutral-600 text-white font-semibold py-2 px-6 rounded-xl transition"
          >
            취소
          </button>
          <button
            onClick={handleSave}
            className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-xl transition"
          >
            저장
          </button>
        </div>
      </div>
    </div>
  );
}

// [COLOR] 헤더
function Header({ apiKey, onLogout, pendingOperations, removeOperation, onOpenSettings }) {
  const [showOps, setShowOps] = useState(false);
  const opCount = Object.keys(pendingOperations).length;

  const getStatusColor = (status) => {
    if (status === 'succeeded') return 'text-green-400';
    if (status === 'failed') return 'text-red-400';
    return 'text-green-400'; // [COLOR]
  };

  return (
    <header className="flex-shrink-0 bg-gray-950 border-b border-neutral-800 flex items-center justify-between p-4 h-16">
      <div className="flex items-center space-x-3">
        <IconGemini />
        <h1 className="text-xl font-bold text-white">File Store</h1>
      </div>
      <div className="flex items-center space-x-4">
        <div className="relative">
          <button 
            onClick={() => setShowOps(!showOps)}
            className="relative p-2 rounded-full text-gray-400 hover:text-white hover:bg-neutral-800"
          >
            <IconUploadQueue />
            {opCount > 0 && (
              <span className="absolute top-0 right-0 block h-5 w-5 rounded-full text-xs flex items-center justify-center bg-green-600 text-white ring-2 ring-gray-950">
                {opCount}
              </span>
            )}
          </button>
          
          {showOps && opCount > 0 && (
            <div className="absolute right-0 mt-2 w-80 bg-neutral-900 border border-neutral-700 rounded-xl shadow-2xl z-50">
              <div className="p-4 border-b border-neutral-700"><h3 className="font-semibold text-white">진행중인 작업</h3></div>
              <ul className="max-h-64 overflow-y-auto">
                {Object.values(pendingOperations).map(op => (
                  <li key={op.id} className="p-4 border-b border-neutral-800 last:border-b-0">
                    <div className="flex items-center justify-between">
                      <span className="text-sm text-gray-300 w-3/4 truncate">{op.description}</span>
                      {['processing', 'indexing'].includes(op.status) && <IconSpinner />}
                      {op.status === 'succeeded' && <i className="bi bi-check-lg text-green-400 text-xl"></i>}
                      {op.status === 'failed' && <i className="bi bi-x-lg text-red-400 text-xl"></i>}
                    </div>
                    <p className={`text-xs mt-1 ${getStatusColor(op.status)}`}>
                      {op.status === 'failed' ? op.error : op.status}
                    </p>
                    {(op.status === 'succeeded' || op.status === 'failed') && (
                      <button onClick={() => removeOperation(op.id)} className="text-xs text-gray-500 hover:text-red-400 mt-1"> 닫기 </button>
                    )}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>

        <div className="text-sm text-gray-500 hidden sm:block">
          API Key: ...{apiKey.slice(-4)}
        </div>
        
        <button
          onClick={onOpenSettings}
          className="p-2 rounded-full text-gray-400 hover:text-white hover:bg-neutral-800"
          title="설정"
        >
          <IconSettings />
        </button>

        <button
          onClick={onLogout}
          className="bg-neutral-800 hover:bg-red-700 hover:text-white text-gray-300 text-sm font-semibold py-2 px-4 rounded-xl transition"
        >
          로그아웃
        </button>
      </div>
    </header>
  );
}

// [COLOR] 채팅 사이드바
function ChatSidebar({ chats, selectedChat, onSelectChat, onCreateNewChat, onDeleteChat, onUpdateChat, onNavigateBack, currentStoreName }) {
  const [editingChatId, setEditingChatId] = useState(null);
  const [newTitle, setNewTitle] = useState('');

  const handleStartEdit = (chat) => { setEditingChatId(chat.id); setNewTitle(chat.title); };
  const handleSaveEdit = (chat) => { if (newTitle.trim()) { onUpdateChat({ ...chat, title: newTitle.trim() }); } setEditingChatId(null); };

  const filteredChats = chats.filter(c => c.storeName === selectedChat.storeName);

  return (
    <div className="w-72 flex-shrink-0 bg-gray-950 border-r border-neutral-800 flex flex-col">
      <div className="p-4 border-b border-neutral-800 h-16 flex flex-col justify-center">
        <button onClick={onNavigateBack} className="flex items-center space-x-2 text-sm text-gray-400 hover:text-white mb-2">
          <IconArrowLeft /> <span>모든 프로젝트</span>
        </button>
        <h2 className="text-lg font-semibold text-white truncate" title={currentStoreName}> {currentStoreName || "채팅"} </h2>
      </div>
      <div className="p-4">
        <button onClick={onCreateNewChat} className="w-full flex items-center justify-center space-x-2 bg-green-600 hover:bg-green-700 text-white font-semibold py-3 px-4 rounded-xl transition">
          <IconPlus /> <span>새 채팅 시작</span>
        </button>
      </div>
      <nav className="flex-1 overflow-y-auto px-2 py-2 space-y-1">
        {filteredChats.length > 0 ? (
          filteredChats.map(chat => (
            <div key={chat.id} className={`group flex items-center justify-between p-3 rounded-xl cursor-pointer ${selectedChat?.id === chat.id ? 'bg-green-800 text-white' : 'text-gray-300 hover:bg-neutral-800'}`}>
              {editingChatId === chat.id ? (
                <input
                  type="text" value={newTitle} onChange={(e) => setNewTitle(e.target.value)}
                  onBlur={() => handleSaveEdit(chat)} onKeyDown={(e) => e.key === 'Enter' && handleSaveEdit(chat)}
                  className="flex-1 bg-neutral-700 text-white p-1 rounded-lg outline-none" autoFocus
                />
              ) : (
                <span className="flex-1 truncate" onClick={() => onSelectChat(chat)}> {chat.title} </span>
              )}
              <div className="flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
                {editingChatId === chat.id ? (
                  <button onClick={() => handleSaveEdit(chat)} className="p-1 hover:text-white"><IconCheckSmall /></button>
                ) : (
                  <button onClick={() => handleStartEdit(chat)} className="p-1 hover:text-white"><IconEdit /></button>
                )}
                <button onClick={() => onDeleteChat(chat.id)} className="p-1 hover:text-red-400"><IconTrash /></button>
              </div>
            </div>
          ))
        ) : ( <p className="text-sm text-gray-500 text-center p-4">이 스토어의 채팅 기록이 없습니다.</p> )}
      </nav>
    </div>
  );
}

// [COLOR] 스토어 목록 (대시보드)
function FileSearchStoreList({ stores, onCreateStore, onDeleteStore, onSelectStoreForDocs, onSelectStoreForChat, deletingStoreName }) {
  const [newStoreName, setNewStoreName] = useState('');
  const handleSubmit = (e) => { e.preventDefault(); if (newStoreName.trim()) { onCreateStore(newStoreName.trim()); setNewStoreName(''); } };

  return (
    <div className="animate-fade-in">
      <div className="mb-10 p-8 bg-neutral-900 rounded-2xl shadow-xl border border-neutral-800">
        <form onSubmit={handleSubmit} className="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
          <input
            type="text" value={newStoreName} onChange={(e) => setNewStoreName(e.target.value)}
            className="flex-1 px-5 py-3 bg-neutral-800 text-white rounded-xl border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-green-500"
            placeholder="새 프로젝트 (스토어) 이름"
          />
          <button type="submit" className="flex items-center justify-center space-x-2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl transition">
            <IconPlus /> <span>생성</span>
          </button>
        </form>
      </div>
      <h2 className="text-3xl font-bold text-white mb-8">프로젝트 대시보드 ({stores.length})</h2>
      {stores.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
          {stores.map(store => (
            <div key={store.name} className="bg-neutral-900 border border-neutral-800 rounded-2xl shadow-xl p-6 flex flex-col justify-between transition hover:shadow-green-500/10 hover:border-neutral-700">
              <div>
                <h3 className="text-xl font-bold text-white mb-2 truncate" title={store.displayName}>{store.displayName}</h3>
                <p className="text-sm text-gray-500 truncate mb-6" title={store.name}>{store.name}</p>
                <div className="flex space-x-6 text-sm text-gray-400 mb-8">
                  <span className="flex items-center space-x-2"><i className="bi bi-file-earmark-text text-base"></i> <span>{store.activeDocumentsCount || 0} Docs</span></span>
                  <span className="flex items-center space-x-2"><i className="bi bi-hdd-stack text-base"></i> <span>{formatBytes(store.sizeBytes)}</span></span>
                </div>
              </div>
              
              {/* [MODIFIED] 버튼 UI: 텍스트 제거, 툴팁 추가, 스타일 변경 */}
              <div className="flex justify-between items-center">
                <div className="flex items-center space-x-2">
                  <button 
                    onClick={() => onSelectStoreForDocs(store)} 
                    className="bg-neutral-800 hover:bg-neutral-700 text-gray-400 hover:text-white p-2 rounded-xl transition"
                    title="문서 관리"
                  >
                    <IconFolder />
                  </button>
                  <button 
                    onClick={() => onSelectStoreForChat(store)} 
                    className="bg-neutral-800 hover:bg-neutral-700 text-gray-400 hover:text-white p-2 rounded-xl transition"
                    title="채팅 시작"
                  >
                    <IconChat />
                  </button>
                </div>
                
                <button 
                  onClick={() => onDeleteStore(store.name)} 
                  className="bg-neutral-800 hover:bg-red-700 text-gray-400 hover:text-white p-2 rounded-xl transition disabled:opacity-50" 
                  title="스토어 삭제"
                  disabled={deletingStoreName === store.name}
                >
                  {deletingStoreName === store.name ? <IconSpinner /> : <IconTrash />}
                </button>
              </div>
            </div>
          ))}
        </div>
      ) : ( <p className="text-gray-400 text-center py-10">생성된 스토어가 없습니다. 새 프로젝트(스토어)를 생성해주세요.</p> )}
    </div>
  );
}


// [COLOR] 문서 목록
function DocumentList({ store, documents, onDeleteDocument, onUploadFiles, onSelectDocument, onBack, isLoading, onSelectStoreForSearch }) {
  const [uploadQueue, setUploadQueue] = useState([]); 
  const [isDragging, setIsDragging] = useState(false);
  const fileInputRef = useRef(null);

  const handleFilesChange = (files) => {
    if (files && files.length > 0) {
      const newFiles = Array.from(files);
      const uniqueNewFiles = newFiles.filter(nf => !uploadQueue.some(qf => qf.name === nf.name && qf.size === nf.size));
      setUploadQueue(prev => [...prev, ...uniqueNewFiles]);
    }
  };
  
  const handleFileChange = (e) => {
    handleFilesChange(e.target.files);
    if (fileInputRef.current) {
        fileInputRef.current.value = '';
    }
  };
  
  const removeFromQueue = (fileName) => {
    setUploadQueue(prev => prev.filter(f => f.name !== fileName));
  };

  const handleUploadAll = () => {
    if (uploadQueue.length === 0) return;
    Swal.fire({
      title: `${uploadQueue.length}개 파일 업로드`,
      text: '선택한 모든 파일을 업로드하시겠습니까?',
      icon: 'info',
      showCancelButton: true,
      confirmButtonText: '업로드 시작',
      cancelButtonText: '취소',
    }).then((result) => {
      if (result.isConfirmed) {
        onUploadFiles(store.name, uploadQueue);
        setUploadQueue([]);
      }
    });
  };

  const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(true); };
  const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); };
  const handleDrop = (e) => { e.preventDefault(); e.stopPropagation(); setIsDragging(false); handleFilesChange(e.dataTransfer.files); };


  return (
    <div 
      className={`animate-fade-in ${isDragging ? 'drag-over' : ''}`}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      <button onClick={onBack} className="flex items-center space-x-2 text-sm text-green-400 hover:text-green-300 mb-8">
        <IconArrowLeft />
        <span>프로젝트 대시보드로 돌아가기</span>
      </button>
      
      <div className="flex justify-between items-center mb-8">
        <h2 className="text-3xl font-bold text-white">
          문서 관리: <span className="text-green-400">{store.displayName}</span>
        </h2>
        <button 
          onClick={() => onSelectStoreForSearch(store)} 
          className="flex items-center space-x-2 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-5 rounded-xl transition text-sm"
          disabled={documents.length === 0 || isLoading}
        >
          <IconSearch /> <span>스토어 전체 검색</span>
        </button>
      </div>
      
      <div className={`mb-10 p-8 bg-neutral-900 rounded-2xl shadow-xl border border-neutral-800 transition-all ${isDragging ? 'border-green-500 border-dashed' : 'border-neutral-800'}`}>
        <h3 className="text-2xl font-semibold text-white mb-6">새 문서 업로드</h3>
        
        <div className="flex justify-center items-center p-10 border-2 border-dashed border-neutral-700 rounded-xl text-center">
          <input
            type="file"
            ref={fileInputRef}
            onChange={handleFileChange}
            multiple 
            className="hidden"
            id="file-upload"
          />
          <label htmlFor="file-upload" className="cursor-pointer">
            <i className="bi bi-cloud-arrow-up mx-auto h-12 w-12 text-gray-500" style={{ fontSize: '3rem' }}></i>
            <p className="mt-3 text-lg text-green-400 font-semibold">파일 선택</p>
            <p className="text-sm text-gray-400 mt-1">또는 파일을 드래그 앤 드롭하세요</p>
            <p className="text-xs text-gray-500 mt-1">(여러 파일 선택 가능)</p>
          </label>
        </div>

        {uploadQueue.length > 0 && (
          <div className="mt-8">
            <h4 className="font-semibold text-white mb-3">업로드 대기열 ({uploadQueue.length})</h4>
            <ul className="max-h-48 overflow-y-auto space-y-2 bg-neutral-800 p-3 rounded-xl border border-neutral-700">
              {uploadQueue.map(file => (
                <li key={file.name} className="flex items-center justify-between text-sm text-gray-300 bg-neutral-700 p-3 rounded-lg">
                  <span className="flex items-center space-x-3 truncate">
                    <IconFileQueue className="flex-shrink-0" />
                    <span className="truncate" title={file.name}>{file.name}</span>
                  </span>
                  <div className="flex items-center space-x-3">
                    <span className="text-xs text-gray-400">{formatBytes(file.size)}</span>
                    <button 
                      onClick={() => removeFromQueue(file.name)} 
                      className="text-red-400 hover:text-red-300"
                      title="큐에서 제거"
                    >
                      <IconXCircle />
                    </button>
                  </div>
                </li>
              ))}
            </ul>
            <button 
              onClick={handleUploadAll} 
              className="w-full mt-6 flex items-center justify-center space-x-2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl transition"
            >
              <IconCloudUpload /> <span>모두 업로드 ({uploadQueue.length}개)</span>
            </button>
          </div>
        )}
      </div>

      <div className="bg-neutral-900 rounded-2xl shadow-xl border border-neutral-800 overflow-hidden">
        <table className="min-w-full divide-y divide-neutral-800">
          <thead className="bg-neutral-800">
            <tr>
              <th scope="col" className="px-6 py-4 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">표시 이름</th>
              <th scope="col" className="px-6 py-4 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">상태</th>
              <th scope="col" className="px-6 py-4 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">크기</th>
              <th scope="col" className="px-6 py-4 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">MIME 유형</th>
              <th scope="col" className="px-6 py-4 text-right text-xs font-medium text-gray-400 uppercase tracking-wider">작업</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-neutral-800">
            {isLoading && !documents.length ? (
              <tr><td colSpan="5" className="text-center py-10 text-gray-400"><div className="flex justify-center"><IconSpinner /></div></td></tr>
            ) : (
              documents.map(doc => (
                <tr key={doc.name} className="hover:bg-neutral-800">
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{doc.displayName}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm">
                    <span className={`px-2 py-0.5 inline-flex text-xs leading-5 font-semibold rounded-full ${ doc.state === 'ACTIVE' ? 'bg-green-900 text-green-300' : doc.state === 'PENDING' ? 'bg-yellow-900 text-yellow-300' : 'bg-red-900 text-red-300' }`}>
                      {doc.state}
                    </span>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatBytes(doc.sizeBytes)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{doc.mimeType}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium space-x-4">
                    <button onClick={() => onSelectDocument(doc)} disabled={doc.state !== 'ACTIVE'} className="text-green-400 hover:text-green-300 disabled:opacity-50" title="시맨틱 검색"> <IconSearch /> </button>
                    <button onClick={() => onDeleteDocument(doc.name)} className="text-red-400 hover:text-red-300" title="문서 삭제"> <IconTrash /> </button>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}

// [COLOR] 문서 시맨틱 검색
function DocumentSearch({ document, apiKey, onBack }) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [copied, copy] = useClipboard();

  const handleSearch = async (e) => {
    e.preventDefault();
    if (!query.trim()) return;
    setIsLoading(true); setError(null); setResults([]);
    try {
      const endpoint = `${document.name}:query`;
      const data = await apiRequest(endpoint, {
        method: 'POST',
        body: JSON.stringify({ query: query, resultsCount: 10 }),
      }, apiKey);
      setResults(data.relevantChunks || []);
    } catch (err) { setError(err.message); } finally { setIsLoading(false); }
  };

  const copyAllResults = () => { const allText = results.map((chunk, i) => (`[검색 결과 ${i + 1} (청크 ID: ${chunk.chunk.name})]\n${chunk.chunk.text}\n\n`)).join('--------------------\n'); copy(allText); };

  return (
    <div className="animate-fade-in">
      <button onClick={onBack} className="flex items-center space-x-2 text-sm text-green-400 hover:text-green-300 mb-8">
        <IconArrowLeft /> <span>문서 목록으로 돌아가기</span>
      </button>
      <h2 className="text-3xl font-bold text-white mb-2"> 시맨틱 검색: <span className="text-green-400">{document.displayName}</span> </h2>
      <p className="text-sm text-gray-500 mb-8">{document.name}</p>
      
      <div className="mb-10 p-8 bg-neutral-900 rounded-2xl shadow-xl border border-neutral-800">
        <form onSubmit={handleSearch} className="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
          <input
            type="text" value={query} onChange={(e) => setQuery(e.target.value)}
            className="flex-1 px-5 py-3 bg-neutral-800 text-white rounded-xl border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-green-500"
            placeholder="문서 내용 검색..." disabled={isLoading}
          />
          <button type="submit" className="flex items-center justify-center space-x-2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl transition disabled:opacity-50" disabled={isLoading || !query.trim()}>
            {isLoading ? <IconSpinner /> : <IconSearch />} <span>검색</span>
          </button>
        </form>
      </div>

      {error && ( <div className="mb-6 bg-red-900 border border-red-700 text-red-200 px-5 py-4 rounded-xl"> {error} </div> )}
      
      <div className="bg-neutral-900 rounded-2xl shadow-xl border border-neutral-800 p-8">
        <div className="flex items-center justify-between mb-6 pb-4 border-b border-neutral-800">
          <h3 className="text-2xl font-semibold text-white">검색 결과 ({results.length})</h3>
          {results.length > 0 && (
            <button onClick={copyAllResults} className="flex items-center space-x-2 text-sm bg-neutral-700 hover:bg-neutral-600 text-white font-semibold py-2 px-4 rounded-xl transition">
              {copied ? <IconCheck /> : <IconCopy />} <span>{copied ? '복사 완료!' : '전체 복사'}</span>
            </button>
          )}
        </div>
        {isLoading && results.length === 0 && <p className="text-gray-400 text-center py-10">검색 중...</p>}
        {!isLoading && results.length === 0 && query && ( <p className="text-gray-400 text-center py-10">검색 결과가 없습니다.</p> )}
        <div className="space-y-5">
          {results.map((chunk, index) => (
            <div key={index} className="bg-neutral-800 border border-neutral-700 rounded-xl p-5">
              <p className="text-sm text-green-400 mb-2 font-mono" title={chunk.chunk.name}> 청크 ID: ...{chunk.chunk.name.split('/').pop()} </p>
              <p className="text-gray-300 whitespace-pre-wrap text-base">{chunk.chunk.text}</p>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}


// [COLOR] 스토어 전체 검색
function StoreSearch({ store, documents, apiKey, onBack, selectedModel }) { 
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]); 
  const [isLoading, setIsLoading] = useState(false);
  const [geminiStatus, setGeminiStatus] = useState(''); 
  const [searchStatus, setSearchStatus] = useState(''); 
  const [error, setError] = useState(null);
  const [downloadReady, setDownloadReady] = useState(false);

  const handleSearch = async (e) => {
    e.preventDefault();
    if (!query.trim()) return;

    console.log(`[StoreSearch] 검색 시작. 쿼리: "${query}"`);
    setIsLoading(true);
    setError(null);
    setResults([]);
    setGeminiStatus('Gemini가 관련 문서를 필터링 중...');
    setSearchStatus('');
    setDownloadReady(false);

    try {
      const docNames = documents.map(d => d.displayName || d.name.split('/').pop());
      const prompt = `사용자 쿼리: "${query}"\n\n문서 목록: [${docNames.join(', ')}]\n\n위 쿼리와 가장 관련성이 높아 보이는 문서의 '표시 이름(displayName)'을 쉼표(,)로 구분된 목록으로 반환해 줘. 다른 설명은 필요 없고, 관련 문서가 없으면 "없음"이라고만 응답해 줘.\n\n관련 문서 목록:`;
      
      const geminiResponse = await apiGeminiFilter(prompt, apiKey, selectedModel);

      if (!geminiResponse || geminiResponse.trim().toLowerCase() === '없음') {
        setGeminiStatus('Gemini가 관련 문서를 찾지 못했습니다.');
        setIsLoading(false);
        return;
      }

      const relevantDocNames = geminiResponse.split(',').map(name => name.trim()).filter(name => name.length > 0);
      const docsToSearch = documents.filter(doc => {
  
        const docName = doc.displayName || doc.name.split('/').pop();
          return relevantDocNames.some(geminiName => docName.includes(geminiName));
      });
      
      if (docsToSearch.length === 0) {
        setGeminiStatus(`Gemini가 "${geminiResponse}" 문서를 찾았으나, 실제 문서 목록과 일치하는 항목이 없습니다.`);
        setIsLoading(false);
        return;
      }

      setGeminiStatus(`Gemini가 선택한 관련 문서: ${docsToSearch.map(d => d.displayName).join(', ')}`);

      let allRelevantChunks = [];
      let resultsFound = false;
      setSearchStatus(`총 ${docsToSearch.length}개 문서에서 병렬 검색을 시작합니다...`);

      const searchPromises = docsToSearch.map(doc =>
        apiRequest( `${doc.name}:query`, { method: 'POST', body: JSON.stringify({ query: query, resultsCount: 100 }) }, apiKey)
      );
      const promiseResults = await Promise.allSettled(searchPromises);
      let newResultsBatch = []; 

      promiseResults.forEach((result, index) => {
        const doc = docsToSearch[index]; 
        const docDisplayName = doc.displayName || doc.name.split('/').pop();
        if (result.status === 'fulfilled') {
          const resultData = result.value;
          if (resultData && resultData.relevantChunks && resultData.relevantChunks.length > 0) {
            resultsFound = true;
            const chunksWithDoc = resultData.relevantChunks.map(chunk => ({ ...chunk, documentName: docDisplayName }));
            allRelevantChunks.push(...chunksWithDoc);
            newResultsBatch.push(...chunksWithDoc); 
          }
        } else {
          const docError = result.reason;
          console.warn(`'${docDisplayName}' 문서 검색 실패:`, docError);
          newResultsBatch.push({ isError: true, documentName: docDisplayName, error: docError.message });
        }
      });
      
      setResults(newResultsBatch);
      setSearchStatus(resultsFound ? `총 ${allRelevantChunks.length}개의 결과를 찾았습니다.` : '관련된 검색 결과를 찾을 수 없습니다.');
      if (resultsFound) {
        setDownloadReady(true);
      }
    } catch (err) {
      console.error('[StoreSearch] 검색 오류:', err);
      setError(err.message);
      setGeminiStatus('');
      setSearchStatus('');
    } finally {
      setIsLoading(false);
    }
  };

  const downloadResults = () => {
    if (results.length === 0 || !downloadReady) return;
    const validResults = results.filter(r => !r.isError);
    if (validResults.length === 0) {
        Swal.fire({ title: '오류', text: '다운로드할 유효한 검색 결과가 없습니다.', icon: 'error' });
        return;
    }
    const data = JSON.stringify(validResults, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `search_results_${store.displayName.replace(/[^a-z0-9]/gi, '_')}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <div className="animate-fade-in">
      <button onClick={onBack} className="flex items-center space-x-2 text-sm text-green-400 hover:text-green-300 mb-8">
        <IconArrowLeft /> <span>문서 목록으로 돌아가기</span>
      </button>
      <h2 className="text-3xl font-bold text-white mb-2">
        스토어 전체 검색: <span className="text-green-400">{store.displayName}</span>
      </h2>
      <p className="text-sm text-gray-400 mb-8">총 {documents.length}개 문서를 대상으로 Gemini가 필터링 후 검색합니다.</p>
      
      <div className="mb-10 p-8 bg-neutral-900 rounded-2xl shadow-xl border border-neutral-800">
        <form onSubmit={handleSearch} className="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4">
          <input
            type="text" value={query} onChange={(e) => setQuery(e.target.value)}
            className="flex-1 px-5 py-3 bg-neutral-800 text-white rounded-xl border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-green-500"
            placeholder="스토어 전체에서 검색할 쿼리 입력..." disabled={isLoading}
          />
          <button type="submit" className="flex items-center justify-center space-x-2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl transition disabled:opacity-50" disabled={isLoading || !query.trim()}>
            {isLoading ? <IconSpinner /> : <IconSearch />} <span>검색</span>
          </button>
        </form>
      </div>

      <div className="bg-neutral-900 border border-neutral-800 rounded-2xl shadow-xl p-8 min-h-[400px]">
        <div className="flex justify-between items-center mb-6 pb-4 border-b border-neutral-800">
          <h3 className="text-2xl font-semibold text-white">검색 결과</h3>
          <button 
            onClick={downloadResults} 
            className="flex items-center space-x-2 bg-neutral-700 text-white px-4 py-2 rounded-xl font-medium text-sm hover:bg-neutral-600 transition shadow-sm disabled:opacity-50 disabled:cursor-not-allowed"
            disabled={!downloadReady || isLoading}
          >
            <IconDownload />
            <span>결과 다운로드 (JSON)</span>
          </button>
        </div>

        {error && ( <div className="my-4 bg-red-900 border border-red-700 text-red-200 px-5 py-4 rounded-xl"> <strong>오류:</strong> {error} </div> )}

        {geminiStatus && (
          <div className="text-sm text-gray-300 mb-6 p-4 bg-green-900 bg-opacity-30 border border-green-800 rounded-xl">
            <strong>Gemini 필터:</strong> {geminiStatus}
          </div>
        )}
        
        {isLoading && (
          <div className="flex items-center justify-center space-x-3 text-gray-400 py-10">
            <IconSpinner />
            <span>{searchStatus || '대기 중...'}</span>
          </div>
        )}

        {!isLoading && results.length === 0 && searchStatus && (
           <p className="text-gray-400 text-center py-10">{searchStatus}</p>
        )}

        <div className="space-y-5 mt-4">
          {results.map((item, index) => {
            if (item.isError) {
              return (
                <div key={index} className="border border-red-700 p-5 rounded-xl bg-red-900 bg-opacity-30">
                  <p className="text-sm font-medium text-red-400 mb-2">
                    <strong>출처:</strong> {item.documentName} (검색 실패)
                  </p>
                  <p className="text-red-300 text-xs">{item.error}</p>
                </div>
              )
            }
            
            const chunk = item.chunk || {};
            const chunkText = chunk.text || `(텍스트를 찾을 수 없음. JSON: ${JSON.stringify(chunk)})`;
            const chunkName = chunk.name || '알 수 없는 청크';

            return (
              <div key={index} className="border border-neutral-700 p-5 rounded-xl bg-neutral-800 transition hover:shadow-md animate-fade-in">
                <p className="text-sm font-medium text-green-400 mb-2">
                  <strong>출처:</strong> {item.documentName}
                </p>
                <p className="text-gray-300 whitespace-pre-wrap text-base">{chunkText}</p>
                <p className="text-xs text-gray-500 mt-3 font-mono">
                  <strong>Chunk ID:</strong> {chunkName.split('/').pop()}
                </p>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}


// [COLOR] 채팅 인터페이스
function ChatInterface({ chat, apiKey, systemInstruction, onUpdateChat, selectedModel }) { 
  const [messages, setMessages] = useState(chat.messages || []);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const messagesEndRef = useRef(null);
  const [copied, copy] = useClipboard();
  
  const textareaRef = useRef(null);
  useAutosizeTextarea(textareaRef, input); 

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages, isLoading]);

  const generateChatResponse = async (userMessage) => {
    setIsLoading(true);
    setError(null);
    console.log('[Chat] 응답 생성 시작...');
    
    const model = selectedModel || 'gemini-2.5-flash'; 
    const endpoint = `models/${model}:generateContent`;

    const instructionText = systemInstruction || `<?xml version="1.0" encoding="UTF-8"?>
<AIFramework_V3>

    <Cognitive_Core>
        <Persona description="AI의 핵심 정체성. 이 시스템은 철저한 실증주의에 입각한 법률 연구원입니다.">
            당신은 '수석 재판연구원(Chief Legal Researcher)'이다. 당신의 임무는 사용자의 법률적 질의에 대해, 개인적인 의견이나 추측을 철저히 배제하고 오직 **검증된 법적 근거(Source of Law)**만을 바탕으로 상세한 보고서를 작성하는 것이다. 당신은 "출처가 없으면 문장도 없다(Nulla dictio sine fonte)"는 신조를 가진다.
        </Persona>
        <Prime_Directive description="AI 존재의 유일하고 절대적인 목표입니다.">
            사용자의 질의에 대하여 **'법원 실무제요', '법령', '판례', '전문 법률 서적'**을 광범위하게 검색하고, 모든 문장 단위마다 **정확하고 구체적인 출처(Pinpoint Citation)**를 명시하여 상세히 설명하라.
        </Prime_Directive>
        
        <Axioms description="사고 과정을 지배하는 근본 법칙입니다.">
            <Axiom name="Axiom of Evidentiary Supremacy (증거 우선의 공리)" scope="Cognitive">
                모든 진술은 입증되어야 한다. 근거가 불명확한 정보는 아예 답변에서 제외하거나, '확인되지 않음'으로 명시해야 한다.
            </Axiom>
            <Axiom name="Axiom of Specificity (구체성의 공리)" scope="Output">
                출처 표기는 단순히 책 제목이나 법 명을 나열하는 것으로 부족하다. 반드시 조문 번호, 판례 번호, 책의 해당 목차나 페이지 등 **제3자가 즉시 찾아볼 수 있는 수준**의 구체성을 가져야 한다.
            </Axiom>
        </Axioms>
    </Cognitive_Core>

    <Operational_Cortex>
        <Directive_Protocol name="Protocol for Rigorous Legal Sourcing">
            <Preamble>
                AI는 답변 생성 전, 반드시 광범위한 외부 검색을 선행해야 한다. 내재된 지식(Hallucination 가능성 있음)보다 실시간 검색 결과(Evidence)를 절대적으로 우선시한다.
            </Preamble>
            
            <Modules>
                <Module id="MOD_SEARCH" title="전략적 법률 정보 검색 (Strategic Legal Search)">
                    <Rules>
                        <Rule name="Mandatory Tool Usage">
                            모든 답변 작성 전, 반드시 `Google Search` (또는 가용한 searchapi)를 사용하여 정보를 수집해야 한다.
                        </Rule>
                        <Rule name="Search Priority Hierarchy">
                            정보 검색 시 다음 순서로 공신력을 부여하고 우선적으로 검색한다:
                            1. **법원 실무제요 (Judicial Practice Guidelines):** 해당 사안과 관련된 실무제요(민사, 형사, 가사 등) 내용을 최우선으로 탐색.
                            2. **대법원 및 하급심 판례 (Case Law):** 관련 법리를 설시한 최신 판례.
                            3. **법령 (Statutes):** 현행 법률, 시행령, 시행규칙의 구체적 조문.
                            4. **권위 있는 법률 서적/논문:** 주석서, 교수 저널 등.
                        </Rule>
                    </Rules>
                </Module>

                <Module id="MOD_CITATION" title="정밀 출처 표기 표준 (Precision Citation Standards)">
                    <Rules>
                        <Rule name="Sentence-Level Attribution">
                            사실 관계나 법리를 설명하는 **모든 문장**의 끝에는 반드시 각주나 괄호를 통해 출처를 명기해야 한다.
                        </Rule>
                        <Rule name="Citation Format">
                            다음의 형식을 엄격히 준수한다:
                            * **법령:** [법률명 제OO조 제O항] (예: [민법 제103조])
                            * **판례:** [대법원 20XX.X.X. 선고 20XX다XXXX 판결]
                            * **실무제요/도서:** [도서명, 해당 목차/단원명, (가능한 경우) 페이지] (예: [법원실무제요 민사집행(III), 제2장 강제경매, 3. 매각절차])
                        </Rule>
                    </Rules>
                </Module>
            </Modules>

            <Validation_Protocol name="Source Verification Loop">
                <Sweeps>
                    <Sweep name="The 'Orphan Sentence' Check">
                        출처 표기가 없는 문장이 하나라도 있는지 검사한다. 발견 시 즉시 추가 검색을 통해 출처를 보완하거나 해당 문장을 삭제한다.
                    </Sweep>
                    <Sweep name="The 'Generalization' Check">
                        "법에 따르면" 또는 "판례에 의하면"과 같이 뭉뚱그려 표현한 부분이 있는지 확인한다. 이를 구체적인 조문이나 판례 번호로 대체한다.
                    </Sweep>
                </Sweeps>
            </Validation_Protocol>
        </Directive_Protocol>
    </Operational_Cortex>

    <Task_Definition>
        <Success_Criteria>
            <Criterion>모든 핵심 문장에 구체적인 출처(조문, 판례번호, 서적 목차)가 명시되었는가?</Criterion>
            <Criterion>답변 내용이 법원 실무제요와 법령에 근거하여 법리적으로 정확한가?</Criterion>
            <Criterion>searchapi를 활용하여 최신 정보를 반영했는가?</Criterion>
        </Success_Criteria>

        <Task_Hierarchy>
            <Task id="T1" name="법률 질의에 대한 근거 기반 상세 답변 작성">
                <SubTasks>
                    <SubTask id="ST1" name="심층 검색 수행">
                        <Objective>사용자 질의 키워드를 바탕으로 실무제요, 법령, 판례를 타겟팅하여 검색한다.</Objective>
                    </SubTask>
                    <SubTask id="ST2" name="정보 교차 검증 및 구조화">
                        <Objective>수집된 정보 간의 정합성을 확인하고, 논리적 흐름에 따라 목차를 구성한다.</Objective>
                    </SubTask>
                    <SubTask id="ST3" name="상세 답변 집필 및 출처 매핑">
                        <Objective>전문적인 어조로 상세히 설명하되, 문장마다 확보된 출처를 매핑하여 작성한다.</Objective>
                    </SubTask>
                </SubTasks>
            </Task>
        </Task_Hierarchy>
        
    </Task_Definition>

</AIFramework_V3>`;
    
    const systemInstructionPayload = { parts: [ { text: instructionText } ] };
    const generationConfig = { thinkingConfig: { thinkingBudget: -1 }, imageConfig: { imageSize: '1K' }, };
    const contents = [ ...messages.map(m => ({ role: m.role, parts: [{ text: m.text }] })), { role: 'user', parts: [{ text: userMessage }] } ];
    const tools = [ { fileSearch: { fileSearchStoreNames: [chat.storeName] } } ];
    const payload = { systemInstruction: systemInstructionPayload, generationConfig, contents, tools };
    
    console.log('[Chat] API Payload:', payload);

    try {
      const data = await apiRequest(endpoint, { method: 'POST', body: JSON.stringify(payload), }, apiKey);
      console.log('[Chat] API Response:', data);
      const modelResponse = data.candidates[0].content.parts[0].text;
      const groundingMetadata = data.candidates[0].groundingMetadata;
      return { text: modelResponse, groundingMetadata: groundingMetadata };
    } catch (err) {
      console.error('[Chat] API Error:', err);
      setError(err.message);
      setIsLoading(false);
      return null;
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!input.trim() || isLoading) return;

    const userMessage = { role: 'user', text: input.trim() };
    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setInput('');
    
    let updatedChat = { ...chat, messages: newMessages };
    if (chat.title === "새 채팅") {
      updatedChat.title = input.trim().substring(0, 30);
    }
    
    const modelResponse = await generateChatResponse(input.trim());
    setIsLoading(false);

    if (modelResponse) {
      const botMessage = { role: 'model', text: modelResponse.text, groundingMetadata: modelResponse.groundingMetadata };
      const finalMessages = [...newMessages, botMessage];
      setMessages(finalMessages);
      onUpdateChat({ ...updatedChat, messages: finalMessages });
      console.log('[Chat] 채팅 업데이트됨 (응답 포함).');
    } else {
      onUpdateChat(updatedChat);
      console.log('[Chat] 채팅 업데이트됨 (유저 메시지만).');
    }
  };
  
  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && e.shiftKey) {
        e.preventDefault();
        handleSubmit(e);
    }
  };

  const ChatMessageContent = ({ message }) => {
    const [justCopied, setJustCopied] = useState(false);
    const handleCopy = () => { copy(message.text); setJustCopied(true); setTimeout(() => setJustCopied(false), 1500); };
    const renderedHtml = useMemo(() => {
        if (!window.marked) return message.text.replace(/\n/g, '<br>'); 
        return window.marked.parse(message.text, { gfm: true, breaks: true, sanitize: false });
    }, [message.text]);

    return (
      <div className={`relative group w-full max-w-full ${message.role === 'user' ? 'bg-neutral-800' : 'bg-neutral-900'}`}>
        <div className="max-w-4xl mx-auto px-6 md:px-8 py-7 flex space-x-5">
          <div className="flex-shrink-0 w-8 h-8 rounded-full bg-neutral-700 flex items-center justify-center">
            {message.role === 'user' ? <IconUser /> : <IconGemini />}
          </div>
          <div className="flex-1 overflow-hidden">
            <div
              className="prose prose-invert max-w-none"
              dangerouslySetInnerHTML={{ __html: renderedHtml }}
            />
            {message.groundingMetadata?.groundingAttributions?.length > 0 && (
              <div className="mt-5 border-t border-neutral-700 pt-4">
                <h4 className="text-sm font-semibold text-gray-400 mb-2">참조 (인용)</h4>
                <div className="flex flex-wrap gap-2">
                  {message.groundingMetadata.groundingAttributions.map((attr, idx) => (
                    <a 
                      key={idx}
                      href={attr.web?.uri} 
                      target="_blank" rel="noopener noreferrer"
                      className="flex items-center space-x-1 text-xs bg-green-900 bg-opacity-50 text-green-300 px-3 py-1 rounded-full hover:bg-green-800"
                      title={`출처: ${attr.file?.displayName || '알 수 없음'}`}
                    >
                      <span>{attr.file?.displayName ? attr.file.displayName.substring(0, 20) : '출처'}...</span>
                      <IconExternalLink />
                    </a>
                  ))}
                </div>
              </div>
            )}
            {message.role === 'model' && (
              <button onClick={handleCopy} className="absolute top-3 right-3 p-1.5 rounded-lg bg-neutral-800 text-gray-400 opacity-0 group-hover:opacity-100 transition hover:bg-neutral-700 hover:text-white" title="응답 복사">
                {justCopied ? <IconCheck /> : <IconCopy />}
              </button>
            )}
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="flex flex-col h-full animate-fade-in bg-neutral-900">
      <div className="flex-1 overflow-y-auto">
        {messages.length === 0 && !isLoading && (
          <div className="flex h-full items-center justify-center">
            <p className="text-gray-500">무엇이든 물어보세요. 이 스토어의 문서를 참조하여 답변합니다.</p>
          </div>
        )}
        {messages.length > 0 && (
            <div>
                {messages.map((msg, index) => (
                  <ChatMessageContent key={index} message={msg} />
                ))}
            </div>
        )}
        {isLoading && (
          <div className="w-full max-w-full bg-neutral-900">
            <div className="max-w-4xl mx-auto px-6 md:px-8 py-7 flex space-x-5">
              <div className="flex-shrink-0 w-8 h-8 rounded-full bg-neutral-700 flex items-center justify-center"><IconGemini /></div>
              <div className="flex-1 overflow-hidden flex items-center">
                <IconSpinner /> <span className="ml-3 text-gray-400">생각 중...</span>
              </div>
            </div>
          </div>
        )}
        {error && (
          <div className="w-full max-w-full bg-red-900 text-red-200">
            <div className="max-w-4xl mx-auto px-6 md:px-8 py-5"> <strong>오류:</strong> {error} </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      <div className="flex-shrink-0 p-4 bg-neutral-900 border-t border-neutral-800">
        <form onSubmit={handleSubmit} className="max-w-4xl mx-auto flex items-end space-x-4">
          <textarea
            ref={textareaRef}
            rows="1" 
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={handleKeyDown} 
            className="flex-1 px-4 py-3 bg-neutral-800 text-white rounded-xl border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-green-500 resize-none overflow-y-auto"
            style={{ maxHeight: '200px' }} 
            placeholder={isLoading ? "답변 생성 중..." : `${chat.storeDisplayName}에 질문하기... (Enter로 줄바꿈, Shift+Enter로 전송)`}
            disabled={isLoading}
          />
          <button
            type="submit"
            className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-xl transition disabled:opacity-50 self-end"
            disabled={isLoading || !input.trim()}
          >
            전송
          </button>
        </form>
      </div>
    </div>
  );
}


/* --- [COLOR] 메인 앱 컴포넌트 --- */
function App() {
  const [apiKey, setApiKey] = useState(localStorage.getItem('gemini-api-key') || '');
  const [systemInstruction, setSystemInstruction] = useState(localStorage.getItem('gemini-system-instruction') || '반드시 모든 답변에는 출처를 특정하여 기술하세요.');
  const [selectedModel, setSelectedModel] = useState(localStorage.getItem('gemini-selected-model') || 'gemini-2.5-flash');

  const [apiKeyValid, setApiKeyValid] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [globalError, setGlobalError] = useState(null);
  
  const [currentView, setCurrentView] = useState('STORES');
  const [selectedStore, setSelectedStore] = useState(null);
  const [selectedDoc, setSelectedDoc] = useState(null);
  const [selectedChat, setSelectedChat] = useState(null);

  const [stores, setStores] = useState([]);
  const [documents, setDocuments] = useState([]);
  const [chats, setChats] = useState([]);
  
  const [pendingOperations, setPendingOperations] = useState({});
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  
  const [deletingStoreName, setDeletingStoreName] = useState(null);

  // (데이터 CRUD 및 헬퍼 함수들은 변경 없음)
  const addOperation = (id, description) => { setPendingOperations(prev => ({ ...prev, [id]: { id, description, status: 'processing' } })); };
  const updateOperation = (id, status, error = null) => { setPendingOperations(prev => ({ ...prev, [id]: { ...prev[id], status, error } })); };
  const removeOperation = (id) => { setPendingOperations(prev => { const newState = { ...prev }; delete newState[id]; return newState; }); };

  const validateApiKey = useCallback(async (key) => {
    if (!key) { setApiKeyValid(false); setIsLoading(false); return; }
    setIsLoading(true); setGlobalError(null);
    try {
      await apiRequest('fileSearchStores', { method: 'GET' }, key);
      setApiKeyValid(true);
      localStorage.setItem('gemini-api-key', key);
    } catch (error) {
      setApiKeyValid(false);
      setGlobalError('API 키가 유효하지 않거나, 네트워크 오류가 발생했습니다.');
      localStorage.removeItem('gemini-api-key');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => { validateApiKey(apiKey); }, [apiKey, validateApiKey]);

  useEffect(() => {
    if (apiKeyValid) { listStores(); loadChats(); } 
    else { setStores([]); setChats([]); }
  }, [apiKeyValid]);

  const listStores = useCallback(async () => {
    if (!apiKeyValid) return;
    setIsLoading(true);
    try {
      const data = await apiRequest('fileSearchStores', { method: 'GET' }, apiKey);
      setStores(data.fileSearchStores || []);
    } catch (error) { 
      setGlobalError(error.message); 
    } finally { setIsLoading(false); }
  }, [apiKey, apiKeyValid]);

  const createStore = async (displayName) => {
    try {
      const newStore = await apiRequest('fileSearchStores', { method: 'POST', body: JSON.stringify({ displayName }), }, apiKey);
      setStores([newStore, ...stores]);
    } catch (error) { 
      setGlobalError(`스토어 생성 실패: ${error.message}`); 
    }
  };

  const deleteStore = async (storeName) => {
    const result = await Swal.fire({
      title: '정말 삭제하시겠습니까?',
      text: "이 스토어와 관련된 모든 문서 및 채팅 기록(로컬)이 영구적으로 삭제됩니다.",
      icon: 'warning',
      showCancelButton: true,
      confirmButtonText: '삭제',
      cancelButtonText: '취소',
      confirmButtonColor: '#e53e3e',
    });
    if (!result.isConfirmed) return;
    setDeletingStoreName(storeName); 
    setGlobalError(null); 
    const chatsToDelete = chats.filter(c => c.storeName === storeName);
    for (const chat of chatsToDelete) { await deleteChatFromDB(chat.id); }
    setChats(prev => prev.filter(c => c.storeName !== storeName));
    try {
      await apiRequest(storeName, { method: 'DELETE', params: { force: true } }, apiKey);
      setStores(stores.filter(s => s.name !== storeName));
    } catch (error) { 
      setGlobalError(`스토어 삭제 실패: ${error.message}`); 
    } finally {
      setDeletingStoreName(null); 
    }
  };

  const listDocuments = useCallback(async (storeName) => {
    if (!apiKeyValid) return;
    setIsLoading(true);
    setDocuments([]); 
    let allDocuments = [];
    let nextPageToken = null;
    try {
      do {
        const params = { pageSize: 20 };
        if (nextPageToken) { params.pageToken = nextPageToken; }
        const data = await apiRequest(`${storeName}/documents`, { method: 'GET', params: params }, apiKey);
        allDocuments = [...allDocuments, ...(data.documents || [])];
        nextPageToken = data.nextPageToken;
      } while (nextPageToken);
      setDocuments(allDocuments);
    } catch (error) {
      setGlobalError(error.message);
    } finally {
      setIsLoading(false);
    }
  }, [apiKey, apiKeyValid]);

  const uploadFiles = async (storeName, files) => {
    for (const file of files) {
      const opId = `upload-${crypto.randomUUID()}`;
      addOperation(opId, `${file.name} 업로드 중...`);
      const metadata = { displayName: file.name };
      try {
        const operation = await apiUploadRequest( `${storeName}:uploadToFileSearchStore`, file, metadata, apiKey );
        updateOperation(opId, 'indexing', '파일 인덱싱 중...');
        pollOperation(operation.name, opId);
      } catch (error) {
        updateOperation(opId, 'failed', error.message);
      }
    }
  };

  const deleteDocument = async (docName) => {
    try {
      await apiRequest(docName, { method: 'DELETE', params: { force: true } }, apiKey);
      setDocuments(documents.filter(d => d.name !== docName));
    } catch (error) { 
      setGlobalError(`문서 삭제 실패: ${error.message}`); 
    }
  };

  const pollOperation = useCallback(async (opName, uiOpId) => {
    try {
      const operation = await apiRequest(opName, { method: 'GET' }, apiKey);
      if (operation.done) {
        if (operation.error) { throw new Error(operation.error.message); }
        updateOperation(uiOpId, 'succeeded', '완료');
        if (currentView === 'STORES') listStores();
        if (currentView === 'DOCS' && selectedStore) listDocuments(selectedStore.name);
        setTimeout(() => removeOperation(uiOpId), 3000);
      } else {
        setTimeout(() => pollOperation(opName, uiOpId), 3000);
      }
    } catch (error) { 
      updateOperation(uiOpId, 'failed', error.message); 
    }
  }, [apiKey, currentView, selectedStore, listStores, listDocuments]);

  const loadChats = async () => { 
    const dbChats = await getChatsFromDB(); 
    setChats(dbChats); 
  };
  const createNewChat = (store) => { 
    const newChat = { id: crypto.randomUUID(), storeName: store.name, storeDisplayName: store.displayName, title: "새 채팅", messages: [], createdAt: new Date().toISOString(), }; 
    setChats([newChat, ...chats]); 
    setSelectedChat(newChat); 
    saveChatToDB(newChat); 
    setCurrentView('CHAT'); 
  };
  const updateChat = (chat) => { 
    setSelectedChat(chat); 
    saveChatToDB(chat); 
    setChats(prev => prev.map(c => c.id === chat.id ? chat : c)); 
  };
  const deleteChat = (chatId) => { 
    deleteChatFromDB(chatId); 
    setChats(prev => prev.filter(c => c.id !== chatId)); 
    if (selectedChat?.id === chatId) { 
      setSelectedChat(null); 
      setCurrentView('STORES'); 
    } 
  };

  /* --- UI 렌더링 로직 --- */
  const handleApiKeySubmit = (e) => {
    e.preventDefault();
    const key = e.target.elements.apiKey.value;
    setApiKey(key);
    validateApiKey(key);
  };

  const selectStoreForDocs = (store) => { setSelectedStore(store); listDocuments(store.name); setCurrentView('DOCS'); };
  const selectStoreForChat = (store) => { 
    setSelectedStore(store); 
    const existingChat = chats.find(c => c.storeName === store.name); 
    if (existingChat) { setSelectedChat(existingChat); setCurrentView('CHAT'); } 
    else { createNewChat(store); } 
  };
  const selectDocForSearch = (doc) => { setSelectedDoc(doc); setCurrentView('DOC_SEARCH'); };
  const selectStoreForSearch = (store) => { setSelectedStore(store); setCurrentView('STORE_SEARCH'); };
  const navigateTo = (view) => { 
    setCurrentView(view); 
    if (view === 'STORES') { setSelectedStore(null); setSelectedDoc(null); setSelectedChat(null); listStores(); } 
  };
  const selectChat = (chat) => { setSelectedChat(chat); setCurrentView('CHAT'); };
  
  if (isLoading && !apiKeyValid && !apiKey) {
      return <div className="flex h-screen w-full items-center justify-center bg-gray-950 text-white"><IconSpinner /> 로딩 중...</div>; 
  }

  // [COLOR] 로그인 스크린
  if (!apiKey) {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-gray-950 text-white p-4">
        <div className="w-full max-w-md p-10 bg-neutral-900 rounded-2xl shadow-2xl border border-neutral-800">
          <h1 className="text-3xl font-bold text-center text-white mb-4">Gemini File Store</h1>
          <p className="text-center text-gray-400 mb-8">시작하려면 Gemini API 키를 입력하세요.</p>
          <form onSubmit={handleApiKeySubmit}>
            <input
              type="password" name="apiKey"
              className="w-full px-4 py-3 bg-neutral-800 text-white rounded-xl border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-green-500"
              placeholder="Gemini API Key"
            />
            <button type="submit" className="w-full mt-6 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-xl transition">
              API 키 저장 및 시작
            </button>
            {globalError && <p className="mt-4 text-center text-red-400">{globalError}</p>}
          </form>
        </div>
      </div>
    );
  }

  // [COLOR] API 키 오류 스크린
  if (!apiKeyValid) {
     return (
        <div className="flex h-screen w-full items-center justify-center bg-gray-950 text-white p-4">
            <div className="w-full max-w-md p-10 bg-neutral-900 rounded-2xl shadow-2xl border border-neutral-800">
                <h1 className="text-3xl font-bold text-center text-red-400 mb-6">오류</h1>
                <p className="text-center text-gray-300 mb-8">{globalError || "API 키가 유효하지 않습니다."}</p>
                <button 
                    onClick={() => setIsSettingsOpen(true)} 
                    className="w-full mt-6 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-xl transition"
                >
                    설정에서 API 키 수정
                </button>
                <SettingsModal
                    isOpen={true} 
                    onClose={() => setIsSettingsOpen(false)} 
                    apiKey={apiKey}
                    setApiKey={setApiKey} 
                    systemInstruction={systemInstruction}
                    setSystemInstruction={setSystemInstruction}
                    selectedModel={selectedModel} 
                    setSelectedModel={setSelectedModel} 
                />
            </div>
        </div>
     );
  }

  // [COLOR] 메인 앱 레이아웃
  return (
    <div className="flex h-screen bg-gray-950 text-gray-200">
      <SettingsModal
        isOpen={isSettingsOpen}
        onClose={() => setIsSettingsOpen(false)}
        apiKey={apiKey}
        setApiKey={setApiKey} 
        systemInstruction={systemInstruction}
        setSystemInstruction={setSystemInstruction}
        selectedModel={selectedModel} 
        setSelectedModel={setSelectedModel} 
      />

      {currentView === 'CHAT' && (
        <ChatSidebar 
          chats={chats} 
          selectedChat={selectedChat}
          onSelectChat={selectChat}
          onCreateNewChat={() => createNewChat(selectedStore)}
          onDeleteChat={deleteChat}
          onUpdateChat={updateChat}
          onNavigateBack={() => navigateTo('STORES')}
          currentStoreName={selectedStore?.displayName}
        />
      )}

      <div className="flex-1 flex flex-col overflow-hidden">
        <Header 
          apiKey={apiKey} 
          onLogout={() => {
            setApiKey('');
            setApiKeyValid(false);
            localStorage.removeItem('gemini-api-key');
            localStorage.removeItem('gemini-selected-model'); 
            setGlobalError(null);
          }}
          pendingOperations={pendingOperations}
          removeOperation={removeOperation}
          onOpenSettings={() => setIsSettingsOpen(true)}
        />
        <main className={`flex-1 ${currentView !== 'CHAT' ? 'overflow-y-auto p-6 md:p-10' : 'overflow-hidden'}`}>
          {globalError && (
            <div className="mb-6 bg-red-900 border border-red-700 text-red-200 px-5 py-4 rounded-xl relative" role="alert">
              <span className="block sm:inline">{globalError}</span>
              <button className="absolute top-0 bottom-0 right-0 px-4 py-3" onClick={() => setGlobalError(null)}>
                  <IconXSmall />
              </button>
            </div>
          )}

          <div className={currentView !== 'CHAT' ? 'max-w-7xl mx-auto' : 'h-full'}>
            {currentView === 'STORES' && (
              <FileSearchStoreList 
                stores={stores}
                deletingStoreName={deletingStoreName}
                onCreateStore={createStore}
                onDeleteStore={deleteStore}
                onSelectStoreForDocs={selectStoreForDocs}
                onSelectStoreForChat={selectStoreForChat}
              />
            )}
            
            {currentView === 'DOCS' && selectedStore && (
              <DocumentList
                store={selectedStore}
                documents={documents}
                onDeleteDocument={deleteDocument}
                onUploadFiles={uploadFiles} 
                onSelectDocument={selectDocForSearch}
                onBack={() => navigateTo('STORES')}
                isLoading={isLoading}
                onSelectStoreForSearch={selectStoreForSearch} 
              />
            )}

            {currentView === 'DOC_SEARCH' && selectedDoc && (
              <DocumentSearch
                document={selectedDoc}
                apiKey={apiKey}
                onBack={() => setCurrentView('DOCS')}
              />
            )}
            
            {currentView === 'STORE_SEARCH' && selectedStore && (
              <StoreSearch
                store={selectedStore}
                documents={documents}
                apiKey={apiKey}
                onBack={() => setCurrentView('DOCS')}
                selectedModel={selectedModel} 
              />
            )}
          </div>

          {currentView === 'CHAT' && selectedChat && (
            <ChatInterface
              key={selectedChat.id}
              chat={selectedChat}
              apiKey={apiKey}
              systemInstruction={systemInstruction}
              onUpdateChat={updateChat}
              selectedModel={selectedModel} 
            />
          )}
        </main>
      </div>
    </div>
  );
}


// React 앱 마운트
const container = document.getElementById('root');
if (!window._geminiAppRoot) {
  const EffectiveReactDOM = ReactDOM.default || ReactDOM; 
  if (EffectiveReactDOM && typeof EffectiveReactDOM.createRoot === 'function') {
    window._geminiAppRoot = EffectiveReactDOM.createRoot(container);
  } else if (typeof ReactDOMClient !== 'undefined') {
    window._geminiAppRoot = ReactDOMClient.createRoot(container);
  } else {
    console.error('Could not find ReactDOM.createRoot or ReactDOMClient.createRoot.');
  }
}
if (window._geminiAppRoot) {
  window._geminiAppRoot.render(<App />);
} else {
  console.error('Failed to create React root.');
}

})(); // IIFE 종료
    </script>
</body>
</html>
