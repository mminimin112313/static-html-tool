<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini File Store 관리자</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel (JSX Transpiler) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Marked.js (Markdown Renderer) -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <style>
      body {
        background-color: #030712; /* bg-gray-950 */
      }
      /* marked.js로 생성된 HTML을 스타일링하기 위한 CSS입니다. */
      .prose p {
        margin-top: 0.5em;
        margin-bottom: 0.5em;
      }
      .prose ul, .prose ol {
        list-style-position: inside;
        padding-left: 1.5em;
        margin-top: 0.5em;
        margin-bottom: 0.5em;
      }
      .prose li {
        margin-top: 0.25em;
        margin-bottom: 0.25em;
      }
      .prose pre {
        background-color: #030712; /* bg-gray-950 */
        padding: 0.75rem;
        border-radius: 0.375rem;
        overflow-x: auto;
        margin-top: 1em;
        margin-bottom: 1em;
        font-family: monospace;
      }
      .prose code:not(pre code) {
         background-color: #1f2937; /* bg-gray-700 */
         padding: 0.2em 0.4em;
         border-radius: 0.25rem;
         font-family: monospace;
      }
      .prose a {
        color: #60a5fa; /* text-blue-400 */
        text-decoration: underline;
      }
      .prose-invert {
        color: #d1d5db; /* text-gray-300 */
      }
      .prose-invert a {
        color: #93c5fd; /* text-blue-300 */
      }
      .prose-invert strong {
        color: #ffffff;
      }
      /* 애니메이션 */
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .animate-fade-in {
        animation: fadeIn 0.3s ease-out;
      }
    </style>
</head>
<body>
    <noscript>이 앱을 실행하려면 JavaScript가 필요합니다.</noscript>
    <div id="root"></div>

    <!-- React/JSX Code -->
    <script type="text/babel">
(function() { // 전체 코드를 IIFE로 감싸서 변수 충돌을 방지합니다.

const { useState, useEffect, useRef, useMemo, useCallback } = React;

/* --- 아이콘 컴포넌트 --- */
function IconFolder() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
      <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 12.75V12A2.25 2.25 0 014.5 9.75h15A2.25 2.25 0 0121.75 12v.75m-8.69-6.44l-2.12-2.12a1.5 1.5 0 00-1.061-.44H4.5A2.25 2.25 0 002.25 6v12a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9a2.25 2.25 0 00-2.25-2.25h-5.379a1.5 1.5 0 01-1.06-.44z" />
    </svg>
  );
}
function IconChat() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
      <path strokeLinecap="round" strokeLinejoin="round" d="M8.625 12a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H8.25m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0H12m4.125 0a.375.375 0 11-.75 0 .375.375 0 01.75 0zm0 0h-.375M21 12c0 4.556-3.86 8.25-8.625 8.25a8.61 8.61 0 01-1.631-.203l-4.055 2.026a.75.75 0 01-.913-.913l2.026-4.055a8.61 8.61 0 01-.203-1.631c0-4.556 3.86-8.25 8.625-8.25s8.625 3.694 8.625 8.25z" />
    </svg>
  );
}
function IconTrash() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
      <path strokeLinecap="round" strokeLinejoin="round" d="M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.084a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12.502 0v-.001c0-.104.012-.207.035-.308.31-.994 1.29-1.75 2.433-1.75h3.164a2.25 2.25 0 012.23 1.973c.043.372.079.75.12 1.139m-14.456 0c.342.052.682.107 1.022.166" />
    </svg>
  );
}
function IconFile() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
      <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 00-3.375-3.375h-1.5A1.125 1.125 0 0113.5 7.125v-1.5a3.375 3.375 0 00-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 00-9-9z" />
    </svg>
  );
}
function IconCloudUpload() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
      <path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75m-7.5 3C4.5 16.5 3 15 3 13.125c0-1.77 1.19-3.214 2.754-3.571.324-.058.65-.098 1.002-.122a3.75 3.75 0 013.48-3.316.75.75 0 01.62.375 3.75 3.75 0 013.48 3.316.75.75 0 01.62-.375 3.75 3.75 0 013.48 3.316c.353.024.678.064 1.002.122C20.81 9.91 22 11.355 22 13.125c0 1.875-1.5 3.375-3.375 3.375M12 16.5h-1.5" />
    </svg>
  );
}
function IconPlus() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
      <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
    </svg>
  );
}
function IconSpinner() {
  return (
    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
    </svg>
  );
}
function IconArrowLeft() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
      <path strokeLinecap="round" strokeLinejoin="round" d="M10.5 19.5L3 12m0 0l7.5-7.5M3 12h18" />
    </svg>
  );
}
function IconSearch() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
      <path strokeLinecap="round" strokeLinejoin="round" d="M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607z" />
    </svg>
  );
}
function IconCopy() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4">
      <path strokeLinecap="round" strokeLinejoin="round" d="M15.666 3.888A2.25 2.25 0 0013.5 2.25h-3c-1.03 0-1.9.693-2.166 1.638m7.332 0c.055.194.084.4.084.612v0a.75.75 0 01-.75.75H9a.75.75 0 01-.75-.75v0c0-.212.03-.418.084-.612m7.332 0c.646.049 1.288.11 1.927.184 1.1.128 1.907 1.077 1.907 2.185V19.5a2.25 2.25 0 01-2.25 2.25H6.75A2.25 2.25 0 014.5 19.5V6.257c0-1.108.806-2.057 1.907-2.185a48.208 48.208 0 011.927-.184" />
    </svg>
  );
}
function IconCheck() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4">
      <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 12.75l6 6 9-13.5" />
    </svg>
  );
}
function IconUser() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
      <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z" />
    </svg>
  );
}
function IconGemini() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" className="w-5 h-5">
      <path d="M12 10.454c-1.28 0-2.318 1.038-2.318 2.318s1.038 2.318 2.318 2.318 2.318-1.038 2.318-2.318-1.038-2.318-2.318-2.318zm0 3.136c-.451 0-.818-.367-.818-.818s.367-.818.818-.818.818.367.818.818-.367.818-.818.818zm6.545-3.136c-1.28 0-2.318 1.038-2.318 2.318s1.038 2.318 2.318 2.318 2.318-1.038 2.318-2.318-1.038-2.318-2.318-2.318zm0 3.136c-.451 0-.818-.367-.818-.818s.367-.818.818-.818.818.367.818.818-.367.818-.818.818zM5.455 10.454c-1.28 0-2.318 1.038-2.318 2.318s1.038 2.318 2.318 2.318 2.318-1.038 2.318-2.318-1.038-2.318-2.318-2.318zm0 3.136c-.451 0-.818-.367-.818-.818s.367-.818.818-.818.818.367.818.818-.367.818-.818.818zM12 3.273c-1.28 0-2.318 1.038-2.318 2.318s1.038 2.318 2.318 2.318 2.318-1.038 2.318-2.318S13.28 3.273 12 3.273zm0 3.136c-.451 0-.818-.367-.818-.818s.367-.818.818-.818.818.367.818.818-.367.818-.818.818zm6.545-3.136c-1.28 0-2.318 1.038-2.318 2.318s1.038 2.318 2.318 2.318 2.318-1.038 2.318-2.318-1.038-2.318-2.318-2.318zm0 3.136c-.451 0-.818-.367-.818-.818s.367-.818.818-.818.818.367.818.818-.367.818-.818.818zM5.455 3.273c-1.28 0-2.318 1.038-2.318 2.318s1.038 2.318 2.318 2.318 2.318-1.038 2.318-2.318S6.735 3.273 5.455 3.273zm0 3.136c-.451 0-.818-.367-.818-.818s.367-.818.818-.818.818.367.818.818-.367.818-.818.818zM12 17.636c-1.28 0-2.318 1.038-2.318 2.318s1.038 2.318 2.318 2.318 2.318-1.038 2.318-2.318-1.038-2.318-2.318-2.318zm0 3.136c-.451 0-.818-.367-.818-.818s.367-.818.818-.818.818.367.818.818-.367.818-.818.818zm6.545-3.136c-1.28 0-2.318 1.038-2.318 2.318s1.038 2.318 2.318 2.318 2.318-1.038 2.318-2.318-1.038-2.318-2.318-2.318zm0 3.136c-.451 0-.818-.367-.818-.818s.367-.818.818-.818.818.367.818.818-.367.818-.818.818zM5.455 17.636c-1.28 0-2.318 1.038-2.318 2.318s1.038 2.318 2.318 2.318 2.318-1.038 2.318-2.318-1.038-2.318-2.318-2.318zm0 3.136c-.451 0-.818-.367-.818-.818s.367-.818.818-.818.818.367.818.818-.367.818-.818.818z" />
    </svg>
  );
}
function IconEdit() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4">
      <path strokeLinecap="round" strokeLinejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 112.652 2.652L10.582 16.07a4.5 4.5 0 01-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 011.13-1.897l8.932-8.931zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0115.75 21H5.25A2.25 2.25 0 013 18.75V8.25A2.25 2.25 0 015.25 6H10" />
    </svg>
  );
}
function IconCheckSmall() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4">
      <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 12.75l6 6 9-13.5" />
    </svg>
  );
}
function IconXSmall() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4">
      <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
    </svg>
  );
}
function IconUploadQueue() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-5 h-5">
      <path strokeLinecap="round" strokeLinejoin="round" d="M12 16.5V9.75m0 0l-3.75 3.75M12 9.75l3.75 3.75m-7.5 3C4.5 16.5 3 15 3 13.125c0-1.77 1.19-3.214 2.754-3.571.324-.058.65-.098 1.002-.122a3.75 3.75 0 013.48-3.316.75.75 0 01.62.375 3.75 3.75 0 013.48 3.316.75.75 0 01.62-.375 3.75 3.75 0 013.48 3.316c.353.024.678.064 1.002.122C20.81 9.91 22 11.355 22 13.125c0 1.875-1.5 3.375-3.375 3.375M12 16.5h-1.5" />
    </svg>
  );
}
function IconChevronDown() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4">
      <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 8.25l-7.5 7.5-7.5-7.5" />
    </svg>
  );
}
function IconChevronRight() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4">
      <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
    </svg>
  );
}
function IconExternalLink() {
  return (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-4 h-4">
      <path strokeLinecap="round" strokeLinejoin="round" d="M13.5 6H5.25A2.25 2.25 0 003 8.25v10.5A2.25 2.25 0 005.25 21h10.5A2.25 2.25 0 0018 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25" />
    </svg>
  );
}


/* --- API 및 유틸리티 --- */

const API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/';
const UPLOAD_BASE_URL = 'https://generativelanguage.googleapis.com/upload/v1beta/';

const DB_NAME = 'GeminiFileStoreDB';
const CHAT_STORE = 'chats';

// IndexedDB 헬퍼
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(CHAT_STORE)) {
        db.createObjectStore(CHAT_STORE, { keyPath: 'id' });
      }
    };
    request.onsuccess = (event) => {
      resolve(event.target.result);
    };
    request.onerror = (event) => {
      reject('IndexedDB error: ' + event.target.errorCode);
    };
  });
}

function dbRequest(storeName, mode, operation) {
  return new Promise(async (resolve, reject) => {
    try {
      const db = await openDB();
      const tx = db.transaction(storeName, mode);
      const store = tx.objectStore(storeName);
      operation(store, resolve, reject);
      tx.oncomplete = () => {
        if (mode !== 'readonly') {
          resolve(); // CUD 작업은 oncomplete에서 resolve
        }
      };
      tx.onerror = (event) => {
        reject(event.target.error);
      };
    } catch (error) {
      reject(error);
    }
  });
}

function getChatsFromDB() {
  return dbRequest(CHAT_STORE, 'readonly', (store, resolve) => {
    const request = store.getAll();
    request.onsuccess = () => resolve(request.result);
  });
}

function saveChatToDB(chat) {
  return dbRequest(CHAT_STORE, 'readwrite', (store) => {
    store.put(chat);
  });
}

function deleteChatFromDB(chatId) {
  return dbRequest(CHAT_STORE, 'readwrite', (store) => {
    store.delete(chatId);
  });
}

function clearChatsFromDB() {
  return dbRequest(CHAT_STORE, 'readwrite', (store) => {
    store.clear(); // objectStore에서 clear 호출
  });
}


// 일반 API 요청
async function apiRequest(endpoint, options = {}, apiKey) {
  const url = `${API_BASE_URL}${endpoint}`;
  const headers = {
    'Content-Type': 'application/json',
    'x-goog-api-key': apiKey,
    ...options.headers,
  };

  try {
    const response = await fetch(url, { ...options, headers });
    if (!response.ok) {
      const errorData = await response.json();
      console.error('API Error Response:', errorData);
      throw new Error(`API Error: ${errorData.error?.message || response.statusText}`);
    }
    // (수정) 내용이 없는 응답(e.g. DELETE)을 위해 .json() 대신 .text() 사용
    const text = await response.text();
    return text ? JSON.parse(text) : {}; // 비어있으면 빈 객체 반환
  } catch (error) {
    console.error(`API Request Failed: ${error.message}`);
    throw error;
  }
}

// (수정) 파일 업로드 요청 - FormData 사용
async function apiUploadRequest(endpoint, file, metadata, apiKey, onProgress) {
  
  // (수정) 메타데이터를 쿼리 파라미터로 구축합니다.
  const params = new URLSearchParams();
  if (metadata.displayName) {
    params.append('displayName', metadata.displayName);
  }
  // (향후 확장) customMetadata 등 다른 메타데이터도 쿼리 파라미터로 추가할 수 있습니다.
  // if (metadata.customMetadata) { ... }

  const url = `${UPLOAD_BASE_URL}${endpoint}?${params.toString()}`;

  // (수정) FormData에는 *오직* 파일만 포함합니다.
  const formData = new FormData();
  formData.append('file', file); // API가 'file'이라는 키를 기대한다고 가정합니다.

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'x-goog-api-key': apiKey,
        // (중요) 'Content-Type'을 명시하지 않습니다.
        // 브라우저가 FormData로부터 자동으로 multipart/form-data와 boundary를 생성하도록 합니다.
      },
      body: formData, // 파일만 담긴 FormData 객체를 본문으로 전달
    });

    const responseText = await response.text();

    if (!response.ok) {
        console.error('Upload API Error Response Text:', responseText);
        throw new Error(`Upload API Error: ${responseText}`);
    }

    try {
        // 응답이 성공적일 때만 JSON 파싱 시도
        return JSON.parse(responseText);
    } catch (parseError) {
        console.error('API Upload JSON Parse Error:', parseError, 'Response Text:', responseText);
        throw new Error(`업로드 API가 JSON이 아닌 응답을 반환했습니다: ${responseText.substring(0, 100)}...`);
    }

  } catch (error) {
    console.error('API Upload Error:', error);
    throw error;
  }
}

// 파일 크기 포맷터
function formatBytes(bytes, decimals = 2) {
  if (!bytes || bytes === 0) return 'N/A';
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}

// 커스텀 훅: 복사 버튼용
function useClipboard(timeout = 1500) {
  const [copied, setCopied] = useState(false);

  const copy = useCallback((text) => {
    try {
      const el = document.createElement('textarea');
      el.value = text;
      document.body.appendChild(el);
      el.select();
      const success = document.execCommand('copy');
      document.body.removeChild(el);
      
      if (success) {
        setCopied(true);
        setTimeout(() => setCopied(false), timeout);
      } else {
        throw new Error('Copy command failed');
      }
    } catch (e) {
      console.error('Failed to copy to clipboard:', e);
      alert('클립보드 복사에 실패했습니다.');
    }
  }, [timeout]);

  return [copied, copy];
}


/* --- 하위 컴포넌트 --- */

// 헤더
function Header({ apiKey, onLogout, pendingOperations, removeOperation }) {
  const [showOps, setShowOps] = useState(false);
  const opCount = Object.keys(pendingOperations).length;

  const getStatusColor = (status) => {
    if (status === 'succeeded') return 'text-green-400';
    if (status === 'failed') return 'text-red-400';
    return 'text-blue-400';
  };

  return (
    <header className="flex-shrink-0 bg-gray-900 border-b border-gray-700 flex items-center justify-between p-4">
      <div className="flex items-center space-x-2">
        <IconGemini />
        <h1 className="text-xl font-bold text-white">File Store Manager</h1>
      </div>
      <div className="flex items-center space-x-4">
        {/* 작업 큐 */}
        <div className="relative">
          <button 
            onClick={() => setShowOps(!showOps)}
            className="relative p-2 rounded-full text-gray-400 hover:text-white hover:bg-gray-700"
          >
            <IconUploadQueue />
            {opCount > 0 && (
              <span className="absolute top-0 right-0 block h-5 w-5 rounded-full text-xs flex items-center justify-center bg-blue-600 text-white ring-2 ring-gray-900">
                {opCount}
              </span>
            )}
          </button>
          
          {showOps && opCount > 0 && (
            <div className="absolute right-0 mt-2 w-80 bg-gray-800 border border-gray-700 rounded-lg shadow-xl z-50">
              <div className="p-4 border-b border-gray-700">
                <h3 className="font-semibold text-white">진행중인 작업</h3>
              </div>
              <ul className="max-h-64 overflow-y-auto">
                {Object.values(pendingOperations).map(op => (
                  <li key={op.id} className="p-4 border-b border-gray-700 last:border-b-0">
                    <div className="flex items-center justify-between">
                      <span className="text-sm text-gray-300 w-3/4 truncate">{op.description}</span>
                      {op.status === 'processing' && <IconSpinner />}
                      {op.status === 'indexing' && <IconSpinner />}
                      {op.status === 'succeeded' && <IconCheck className="text-green-400" />}
                      {op.status === 'failed' && <IconXSmall className="text-red-400" />}
                    </div>
                    <p className={`text-xs mt-1 ${getStatusColor(op.status)}`}>
                      {op.status === 'failed' ? op.error : op.status}
                    </p>
                    {(op.status === 'succeeded' || op.status === 'failed') && (
                      <button 
                        onClick={() => removeOperation(op.id)}
                        className="text-xs text-gray-500 hover:text-red-400 mt-1"
                      >
                        닫기
                      </button>
                    )}
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>

        <div className="text-sm text-gray-500">
          API Key: ...{apiKey.slice(-4)}
        </div>
        <button
          onClick={onLogout}
          className="bg-gray-700 hover:bg-red-600 text-white text-sm font-semibold py-2 px-4 rounded-lg transition"
        >
          로그아웃
        </button>
      </div>
    </header>
  );
}

// 채팅 사이드바
function ChatSidebar({ chats, selectedChat, onSelectChat, onCreateNewChat, onDeleteChat, onUpdateChat, onNavigateBack, currentStoreName }) {
  const [editingChatId, setEditingChatId] = useState(null);
  const [newTitle, setNewTitle] = useState('');

  const handleStartEdit = (chat) => {
    setEditingChatId(chat.id);
    setNewTitle(chat.title);
  };

  const handleSaveEdit = (chat) => {
    if (newTitle.trim()) {
      onUpdateChat({ ...chat, title: newTitle.trim() });
    }
    setEditingChatId(null);
  };

  const filteredChats = chats.filter(c => c.storeName === selectedChat.storeName);

  return (
    <div className="w-72 flex-shrink-0 bg-gray-900 border-r border-gray-700 flex flex-col">
      <div className="p-4 border-b border-gray-700">
        <button
          onClick={onNavigateBack}
          className="flex items-center space-x-2 text-sm text-gray-400 hover:text-white mb-3"
        >
          <IconArrowLeft />
          <span>모든 프로젝트 (스토어)</span>
        </button>
        <h2 className="text-lg font-semibold text-white truncate" title={currentStoreName}>
          {currentStoreName || "채팅"}
        </h2>
      </div>
      <div className="p-4">
        <button
          onClick={onCreateNewChat}
          className="w-full flex items-center justify-center space-x-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition"
        >
          <IconPlus />
          <span>새 채팅 시작</span>
        </button>
      </div>
      <nav className="flex-1 overflow-y-auto px-2 py-2 space-y-1">
        {filteredChats.length > 0 ? (
          filteredChats.map(chat => (
            <div 
              key={chat.id}
              className={`group flex items-center justify-between p-3 rounded-lg cursor-pointer ${selectedChat?.id === chat.id ? 'bg-blue-800 text-white' : 'text-gray-300 hover:bg-gray-800'}`}
            >
              {editingChatId === chat.id ? (
                <input
                  type="text"
                  value={newTitle}
                  onChange={(e) => setNewTitle(e.target.value)}
                  onBlur={() => handleSaveEdit(chat)}
                  onKeyDown={(e) => e.key === 'Enter' && handleSaveEdit(chat)}
                  className="flex-1 bg-gray-700 text-white p-1 rounded outline-none"
                  autoFocus
                />
              ) : (
                <span className="flex-1 truncate" onClick={() => onSelectChat(chat)}>
                  {chat.title}
                </span>
              )}
              
              <div className="flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
                {editingChatId === chat.id ? (
                  <button onClick={() => handleSaveEdit(chat)} className="p-1 hover:text-white"><IconCheckSmall /></button>
                ) : (
                  <button onClick={() => handleStartEdit(chat)} className="p-1 hover:text-white"><IconEdit /></button>
                )}
                <button onClick={() => onDeleteChat(chat.id)} className="p-1 hover:text-red-400"><IconTrash /></button>
              </div>
            </div>
          ))
        ) : (
          <p className="text-sm text-gray-500 text-center p-4">이 스토어의 채팅 기록이 없습니다.</p>
        )}
      </nav>
    </div>
  );
}

// 스토어 목록 (대시보드)
function FileSearchStoreList({ stores, onCreateStore, onDeleteStore, onSelectStoreForDocs, onSelectStoreForChat }) {
  const [newStoreName, setNewStoreName] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (newStoreName.trim()) {
      onCreateStore(newStoreName.trim());
      setNewStoreName('');
    }
  };

  return (
    <div className="animate-fade-in">
      <div className="mb-8 p-6 bg-gray-900 rounded-lg shadow-lg border border-gray-700">
        <form onSubmit={handleSubmit} className="flex space-x-4">
          <input
            type="text"
            value={newStoreName}
            onChange={(e) => setNewStoreName(e.target.value)}
            className="flex-1 px-4 py-3 bg-gray-800 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="새 프로젝트 (스토어) 이름"
          />
          <button type="submit" className="flex items-center justify-center space-x-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition">
            <IconPlus /> <span>생성</span>
          </button>
        </form>
      </div>

      <h2 className="text-2xl font-bold text-white mb-6">프로젝트 대시보드 ({stores.length})</h2>
      
      {stores.length > 0 ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {stores.map(store => (
            <div key={store.name} className="bg-gray-900 border border-gray-700 rounded-lg shadow-xl p-6 flex flex-col justify-between transition hover:shadow-blue-500/20 hover:-translate-y-1">
              <div>
                <h3 className="text-xl font-bold text-white mb-2 truncate" title={store.displayName}>{store.displayName}</h3>
                <p className="text-sm text-gray-500 truncate mb-4" title={store.name}>{store.name}</p>
                <div className="flex space-x-4 text-sm text-gray-400 mb-6">
                  {/* (수정) 올바른 중첩 구조로 수정 */}
                  <span className="flex items-center space-x-1">
                    <IconFile /> 
                    <span>{store.activeDocumentsCount || 0} Docs</span>
                  </span>
                  <span className="flex items-center space-x-1">
                    <IconCloudUpload />
                    <span>{formatBytes(store.sizeBytes)}</span>
                  </span>
                </div>
              </div>
              <div className="flex items-center space-x-2">
                <button
                  onClick={() => onSelectStoreForDocs(store)} 
                  className="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition text-sm flex items-center justify-center space-x-2"
                >
                  <IconFolder /> <span>문서 관리</span>
                </button>
                <button
                  onClick={() => onSelectStoreForChat(store)}
                  className="flex-1 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg transition text-sm flex items-center justify-center space-x-2"
                >
                  <IconChat /> <span>채팅 시작</span>
                </button>
                <button
                  onClick={() => onDeleteStore(store.name)}
                  className="bg-gray-700 hover:bg-red-600 text-white p-2 rounded-full transition"
                  title="스토어 삭제"
                >
                  <IconTrash />
                </button>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <p className="text-gray-400">생성된 스토어가 없습니다. 새 프로젝트(스토어)를 생성해주세요.</p>
      )}
    </div>
  );
}


// 문서 목록
function DocumentList({ store, documents, onDeleteDocument, onUploadFile, onSelectDocument, onBack, isLoading }) {
  const [file, setFile] = useState(null);
  const [displayName, setDisplayName] = useState('');
  const fileInputRef = useRef(null);

  const handleFileChange = (e) => {
    if (e.target.files.length > 0) {
      const selectedFile = e.target.files[0];
      setFile(selectedFile);
      if (!displayName) {
        setDisplayName(selectedFile.name);
      }
    }
  };

  const handleUpload = () => {
    if (file && store) {
      onUploadFile(store.name, file, displayName);
      setFile(null);
      setDisplayName('');
      if (fileInputRef.current) {
        fileInputRef.current.value = ''; //
      }
    }
  };

  return (
    <div className="animate-fade-in">
      <button onClick={onBack} className="flex items-center space-x-2 text-sm text-blue-400 hover:text-blue-300 mb-6">
        <IconArrowLeft />
        <span>프로젝트 대시보드로 돌아가기</span>
      </button>
      
      <h2 className="text-2xl font-bold text-white mb-6">
        문서 관리: <span className="text-blue-400">{store.displayName}</span>
      </h2>
      
      <div className="mb-8 p-6 bg-gray-900 rounded-lg shadow-lg border border-gray-700">
        <h3 className="text-xl font-semibold text-white mb-4">새 문서 업로드</h3>
        <div className="flex flex-col md:flex-row space-y-4 md:space-y-0 md:space-x-4">
          <input
            type="file"
            ref={fileInputRef}
            onChange={handleFileChange}
            className="flex-1 block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700"
          />
          <input
            type="text"
            value={displayName}
            onChange={(e) => setDisplayName(e.target.value)}
            className="flex-1 px-4 py-3 bg-gray-800 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="문서 표시 이름 (선택 사항)"
          />
          <button 
            onClick={handleUpload} 
            disabled={!file}
            className="flex items-center justify-center space-x-2 bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition disabled:opacity-50"
          >
            <IconCloudUpload /> <span>업로드</span>
          </button>
        </div>
      </div>

      <div className="bg-gray-900 rounded-lg shadow-lg border border-gray-700 overflow-hidden">
        <table className="min-w-full divide-y divide-gray-700">
          <thead className="bg-gray-800">
            <tr>
              <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">표시 이름</th>
              <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">상태</th>
              <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">크기</th>
              <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">MIME 유형</th>
              <th scope="col" className="px-6 py-3 text-right text-xs font-medium text-gray-300 uppercase tracking-wider">작업</th>
            </tr>
          </thead>
          <tbody className="divide-y divide-gray-700">
            {isLoading && !documents.length ? (
              <tr><td colSpan="5" className="text-center py-8 text-gray-400"><IconSpinner /></td></tr>
            ) : (
              documents.map(doc => (
                <tr key={doc.name} className="hover:bg-gray-800">
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-white">{doc.displayName}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm">
                    <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${
                      doc.state === 'ACTIVE' ? 'bg-green-900 text-green-300' : 
                      doc.state === 'PENDING' ? 'bg-yellow-900 text-yellow-300' :
                      'bg-red-900 text-red-300'
                    }`}>
                      {doc.state}
                    </span>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{formatBytes(doc.sizeBytes)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-300">{doc.mimeType}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium space-x-2">
                    <button
                      onClick={() => onSelectDocument(doc)}
                      disabled={doc.state !== 'ACTIVE'}
                      className="text-blue-400 hover:text-blue-300 disabled:opacity-50"
                      title="시맨틱 검색"
                    >
                      <IconSearch />
                    </button>
                    <button
                      onClick={() => onDeleteDocument(doc.name)}
                      className="text-red-400 hover:text-red-300"
                      title="문서 삭제"
                    >
                      <IconTrash />
                    </button>
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </div>
  );
}

// (신규) 문서 시맨틱 검색
function DocumentSearch({ document, apiKey, onBack }) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [copied, copy] = useClipboard();

  const handleSearch = async (e) => {
    e.preventDefault();
    if (!query.trim()) return;

    setIsLoading(true);
    setError(null);
    setResults([]);

    try {
      const endpoint = `${document.name}:query`;
      const data = await apiRequest(endpoint, {
        method: 'POST',
        body: JSON.stringify({
          query: query,
          resultsCount: 10,
          // metadataFilters: [] // 필요시 필터 추가
        }),
      }, apiKey);
      setResults(data.relevantChunks || []);
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  const copyAllResults = () => {
    const allText = results.map((chunk, i) => (
      `[검색 결과 ${i + 1} (청크 ID: ${chunk.chunk.name})]\n${chunk.chunk.text}\n\n`
    )).join('--------------------\n');
    copy(allText);
  };

  return (
    <div className="animate-fade-in">
      <button onClick={onBack} className="flex items-center space-x-2 text-sm text-blue-400 hover:text-blue-300 mb-6">
        <IconArrowLeft />
        <span>문서 목록으로 돌아가기</span>
      </button>

      <h2 className="text-2xl font-bold text-white mb-2">
        시맨틱 검색: <span className="text-blue-400">{document.displayName}</span>
      </h2>
      <p className="text-sm text-gray-500 mb-6">{document.name}</p>

      <form onSubmit={handleSearch} className="mb-8 flex space-x-4">
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          className="flex-1 px-4 py-3 bg-gray-800 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
          placeholder="문서 내용 검색..."
          disabled={isLoading}
        />
        <button
          type="submit"
          className="flex items-center justify-center space-x-2 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition disabled:opacity-50"
          disabled={isLoading || !query.trim()}
        >
          {isLoading ? <IconSpinner /> : <IconSearch />}
          <span>검색</span>
        </button>
      </form>

      {error && (
        <div className="mb-4 bg-red-800 border border-red-600 text-red-200 px-4 py-3 rounded-lg">
          {error}
        </div>
      )}

      <div>
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-xl font-semibold text-white">검색 결과 ({results.length})</h3>
          {results.length > 0 && (
            <button
              onClick={copyAllResults}
              className="flex items-center space-x-2 text-sm bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded-lg transition"
            >
              {copied ? <IconCheck /> : <IconCopy />}
              <span>{copied ? '복사 완료!' : '전체 복사'}</span>
            </button>
          )}
        </div>
        
        {isLoading && results.length === 0 && <p className="text-gray-400">검색 중...</p>}
        
        {!isLoading && results.length === 0 && query && (
          <p className="text-gray-400">검색 결과가 없습니다.</p>
        )}

        <div className="space-y-4">
          {results.map((chunk, index) => (
            <div key={index} className="bg-gray-900 border border-gray-700 rounded-lg p-4">
              <p className="text-sm text-blue-400 mb-2 font-mono" title={chunk.chunk.name}>
                청크 ID: ...{chunk.chunk.name.split('/').pop()}
              </p>
              {/* (수정) chunk.chunk.text가 표시되도록 수정 */}
              <p className="text-gray-300 whitespace-pre-wrap">{chunk.chunk.text}</p>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}


// (신규) 채팅 인터페이스
function ChatInterface({ chat, apiKey, onUpdateChat }) {
  const [messages, setMessages] = useState(chat.messages || []);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const messagesEndRef = useRef(null);
  const [copied, copy] = useClipboard();

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const generateChatResponse = async (userMessage) => {
    setIsLoading(true);
    setError(null);
    
    const endpoint = `models/gemini-2.5-flash:generateContent`;
    const payload = {
      contents: [
        ...messages.map(m => ({
          role: m.role,
          parts: [{ text: m.text }]
        })),
        {
          role: 'user',
          parts: [{ text: userMessage }]
        }
      ],
      tools: [
        {
          fileSearch: {
            fileSearchStoreNames: [chat.storeName]
          }
        }
      ]
    };

    try {
      const data = await apiRequest(endpoint, {
        method: 'POST',
        body: JSON.stringify(payload),
      }, apiKey);

      const modelResponse = data.candidates[0].content.parts[0].text;
      const groundingMetadata = data.candidates[0].groundingMetadata;

      return {
        text: modelResponse,
        groundingMetadata: groundingMetadata
      };

    } catch (err) {
      setError(err.message);
      setIsLoading(false);
      return null;
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!input.trim() || isLoading) return;

    const userMessage = { role: 'user', text: input.trim() };
    const newMessages = [...messages, userMessage];
    setMessages(newMessages);
    setInput('');
    
    // 첫 메시지인 경우 채팅 제목 업데이트
    let updatedChat = { ...chat, messages: newMessages };
    if (chat.title === "새 채팅") {
      updatedChat.title = input.trim().substring(0, 30);
    }
    
    const modelResponse = await generateChatResponse(input.trim());
    setIsLoading(false);

    if (modelResponse) {
      const botMessage = {
        role: 'model',
        text: modelResponse.text,
        groundingMetadata: modelResponse.groundingMetadata
      };
      const finalMessages = [...newMessages, botMessage];
      setMessages(finalMessages);
      // IndexedDB에 최종본 저장
      onUpdateChat({ ...updatedChat, messages: finalMessages });
    } else {
      // 에러 발생 시 사용자 메시지 롤백 (선택)
      // setMessages(messages);
      // IndexedDB에 롤백된 메시지 저장
      onUpdateChat(updatedChat);
    }
  };

  // (신규) 마크다운 파싱 및 복사 버튼 래퍼
  const ChatMessageContent = ({ message }) => {
    const [justCopied, setJustCopied] = useState(false);

    const handleCopy = () => {
      copy(message.text);
      setJustCopied(true);
      setTimeout(() => setJustCopied(false), 1500);
    };

    const renderMarkdown = (text) => {
      // 간단한 마크다운: ```code```를 <pre><code>로 변환
      const codeBlockRegex = /```([\s\S]*?)```/g;
      const parts = text.split(codeBlockRegex);

      return parts.map((part, index) => {
        if (index % 2 === 1) { // 코드 블록 부분
          return (
            <pre key={index} className="bg-gray-950 p-3 rounded-md overflow-x-auto my-2">
              <code className="text-sm text-white">{part.trim()}</code>
            </pre>
          );
        } else { // 일반 텍스트 부분 (줄바꿈 유지)
          return <span key={index} className="whitespace-pre-wrap">{part}</span>;
        }
      });
    };

    return (
      <div className={`relative group w-full max-w-full ${message.role === 'user' ? 'bg-gray-800' : 'bg-gray-900'}`}>
        <div className="max-w-4xl mx-auto px-6 py-6 flex space-x-4">
          <div className="flex-shrink-0 w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center">
            {message.role === 'user' ? <IconUser /> : <IconGemini />}
          </div>
          <div className="flex-1 overflow-hidden">
            <div className="text-lg text-white">
              {renderMarkdown(message.text)}
            </div>

            {/* 인용 정보 표시 */}
            {message.groundingMetadata?.groundingAttributions?.length > 0 && (
              <div className="mt-4 border-t border-gray-700 pt-3">
                <h4 className="text-sm font-semibold text-gray-400 mb-2">참조 (인용)</h4>
                <div className="flex flex-wrap gap-2">
                  {message.groundingMetadata.groundingAttributions.map((attr, idx) => (
                    <a 
                      key={idx}
                      href={attr.web?.uri} // 실제로는 File API 링크가 될 수 있음
                      target="_blank" 
                      rel="noopener noreferrer"
                      className="flex items-center space-x-1 text-xs bg-blue-900 text-blue-300 px-2 py-1 rounded-full hover:bg-blue-800"
                      title={`출처: ${attr.file?.displayName || '알 수 없음'}`}
                    >
                      <span>{attr.file?.displayName ? attr.file.displayName.substring(0, 20) : '출처'}...</span>
                      <IconExternalLink className="w-3 h-3" />
                    </a>
                  ))}
                </div>
              </div>
            )}
            
            {/* 복사 버튼 */}
            {message.role === 'model' && (
              <button
                onClick={handleCopy}
                className="absolute top-2 right-2 p-1.5 rounded-lg bg-gray-800 text-gray-400 opacity-0 group-hover:opacity-100 transition hover:bg-gray-700 hover:text-white"
                title="응답 복사"
              >
                {justCopied ? <IconCheck /> : <IconCopy />}
              </button>
            )}
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="flex flex-col h-full max-h-[calc(100vh-theme(spacing.16))] animate-fade-in">
      <div className="flex-1 overflow-y-auto">
        <div className="flex flex-col min-h-full">
          {messages.length === 0 && (
            <div className="flex-1 flex items-center justify-center">
              <p className="text-gray-500">무엇이든 물어보세요. 이 스토어의 문서를 참조하여 답변합니다.</p>
            </div>
          )}
          
          <div className="flex-1">
            {messages.map((msg, index) => (
              <ChatMessageContent key={index} message={msg} />
            ))}
          </div>

          {isLoading && (
            <div className="w-full max-w-full bg-gray-900">
              <div className="max-w-4xl mx-auto px-6 py-6 flex space-x-4">
                <div className="flex-shrink-0 w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center">
                  <IconGemini />
                </div>
                <div className="flex-1 overflow-hidden flex items-center">
                  <IconSpinner />
                  <span className="ml-2 text-gray-400">생각 중...</span>
                </div>
              </div>
            </div>
          )}
          
          {error && (
            <div className="w-full max-w-full bg-red-900 text-red-200">
              <div className="max-w-4xl mx-auto px-6 py-4">
                <strong>오류:</strong> {error}
              </div>
            </div>
          )}
          
          <div ref={messagesEndRef} />
        </div>
      </div>

      {/* 입력창 */}
      <div className="flex-shrink-0 p-4 bg-gray-950">
        <form onSubmit={handleSubmit} className="max-w-4xl mx-auto flex space-x-4">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            className="flex-1 px-4 py-3 bg-gray-800 text-white rounded-lg border border-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder={isLoading ? "답변 생성 중..." : `${chat.storeDisplayName}에 질문하기...`}
            disabled={isLoading}
          />
          <button
            type="submit"
            className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition disabled:opacity-50"
            disabled={isLoading || !input.trim()}
          >
            전송
          </button>
        </form>
      </div>
    </div>
  );
}


/* --- 메인 앱 컴포넌트 --- */
function App() {
  const [apiKey, setApiKey] = useState(localStorage.getItem('gemini-api-key') || '');
  const [apiKeyValid, setApiKeyValid] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [globalError, setGlobalError] = useState(null);
  
  // 상태 관리
  const [currentView, setCurrentView] = useState('STORES'); // 'STORES', 'DOCS', 'DOC_SEARCH', 'CHAT'
  const [selectedStore, setSelectedStore] = useState(null);
  const [selectedDoc, setSelectedDoc] = useState(null);
  const [selectedChat, setSelectedChat] = useState(null);

  // 데이터
  const [stores, setStores] = useState([]);
  const [documents, setDocuments] = useState([]);
  const [chats, setChats] = useState([]);
  
  // (신규) 백그라운드 작업 모니터링
  const [pendingOperations, setPendingOperations] = useState({});

  const addOperation = (id, description) => {
    setPendingOperations(prev => ({ ...prev, [id]: { id, description, status: 'processing' } }));
  };
  const updateOperation = (id, status, error = null) => {
    setPendingOperations(prev => ({ ...prev, [id]: { ...prev[id], status, error } }));
  };
  const removeOperation = (id) => {
    setPendingOperations(prev => {
      const newState = { ...prev };
      delete newState[id];
      return newState;
    });
  };

  // API 키 유효성 검사
  const validateApiKey = useCallback(async (key) => {
    if (!key) {
      setApiKeyValid(false);
      setIsLoading(false);
      return;
    }
    setIsLoading(true);
    setGlobalError(null);
    try {
      // fileSearchStores.list는 API 키가 유효한지 확인하기 좋은 간단한 GET 요청입니다.
      await apiRequest('fileSearchStores', {}, key);
      setApiKeyValid(true);
      localStorage.setItem('gemini-api-key', key);
    } catch (error) {
      setApiKeyValid(false);
      setGlobalError('API 키가 유효하지 않거나, 네트워크 오류가 발생했습니다.');
      localStorage.removeItem('gemini-api-key');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // 초기화
  useEffect(() => {
    validateApiKey(apiKey);
  }, [apiKey, validateApiKey]);

  // 데이터 로딩 (API 키가 유효할 때)
  useEffect(() => {
    if (apiKeyValid) {
      listStores();
      loadChats();
    } else {
      setStores([]);
      setChats([]);
    }
  }, [apiKeyValid]);


  /* --- 데이터 CRUD 함수 --- */

  // 스토어
  const listStores = useCallback(async () => {
    if (!apiKeyValid) return;
    setIsLoading(true);
    try {
      const data = await apiRequest('fileSearchStores', {}, apiKey);
      setStores(data.fileSearchStores || []);
    } catch (error) {
      setGlobalError(error.message);
    } finally {
      setIsLoading(false);
    }
  }, [apiKey, apiKeyValid]);

  const createStore = async (displayName) => {
    try {
      const newStore = await apiRequest('fileSearchStores', {
        method: 'POST',
        body: JSON.stringify({ displayName }),
      }, apiKey);
      setStores([newStore, ...stores]);
    } catch (error) {
      setGlobalError(`스토어 생성 실패: ${error.message}`);
    }
  };

  const deleteStore = async (storeName) => {
    // IndexedDB에서 관련 채팅 삭제
    const chatsToDelete = chats.filter(c => c.storeName === storeName);
    for (const chat of chatsToDelete) {
      await deleteChatFromDB(chat.id);
    }
    setChats(prev => prev.filter(c => c.storeName !== storeName));
    
    // API에서 스토어 삭제
    try {
      await apiRequest(storeName, {
        method: 'DELETE',
        params: { force: true } // 하위 문서 강제 삭제
      }, apiKey);
      setStores(stores.filter(s => s.name !== storeName));
    } catch (error) {
      setGlobalError(`스토어 삭제 실패: ${error.message}`);
    }
  };

  // 문서
  const listDocuments = useCallback(async (storeName) => {
    if (!apiKeyValid) return;
    setIsLoading(true);
    try {
      const data = await apiRequest(`${storeName}/documents`, {}, apiKey);
      setDocuments(data.documents || []);
    } catch (error) {
      setGlobalError(error.message);
    } finally {
      setIsLoading(false);
    }
  }, [apiKey, apiKeyValid]);

  const uploadFile = async (storeName, file, displayName) => {
    const opId = `upload-${crypto.randomUUID()}`;
    addOperation(opId, `${file.name} 업로드 중...`);

    const metadata = {
      displayName: displayName || file.name,
      // customMetadata: [...] // 필요시 추가
    };

    try {
      const operation = await apiUploadRequest(
        `${storeName}:uploadToFileSearchStore`,
        file,
        metadata,
        apiKey,
        // onProgress (추후 구현)
      );
      updateOperation(opId, 'indexing', '파일 인덱싱 중...');
      pollOperation(operation.name, opId);
    } catch (error) {
      console.error('Upload Failed:', error);
      updateOperation(opId, 'failed', error.message);
    }
  };

  const deleteDocument = async (docName) => {
    try {
      await apiRequest(docName, {
        method: 'DELETE',
        params: { force: true } // 하위 청크 강제 삭제
      }, apiKey);
      setDocuments(documents.filter(d => d.name !== docName));
    } catch (error) {
      setGlobalError(`문서 삭제 실패: ${error.message}`);
    }
  };

  // 작업 폴링
  const pollOperation = useCallback(async (opName, uiOpId) => {
    try {
      const operation = await apiRequest(opName, {}, apiKey);
      if (operation.done) {
        if (operation.error) {
          throw new Error(operation.error.message);
        }
        // 성공
        updateOperation(uiOpId, 'succeeded', '완료');
        // 데이터 새로고침
        if (currentView === 'STORES') listStores();
        if (currentView === 'DOCS' && selectedStore) listDocuments(selectedStore.name);
        
        setTimeout(() => removeOperation(uiOpId), 3000); // 3초 후 목록에서 제거

      } else {
        // 계속 폴링
        setTimeout(() => pollOperation(opName, uiOpId), 3000); // 3초 간격
      }
    } catch (error) {
      updateOperation(uiOpId, 'failed', error.message);
    }
  }, [apiKey, currentView, selectedStore, listStores, listDocuments]);

  // 채팅
  const loadChats = async () => {
    const dbChats = await getChatsFromDB();
    setChats(dbChats);
  };

  const createNewChat = (store) => {
    const newChat = {
      id: crypto.randomUUID(),
      storeName: store.name,
      storeDisplayName: store.displayName,
      title: "새 채팅",
      messages: [],
      createdAt: new Date().toISOString(),
    };
    setChats([newChat, ...chats]);
    setSelectedChat(newChat);
    saveChatToDB(newChat);
    setCurrentView('CHAT');
  };
  
  const updateChat = (chat) => {
    setSelectedChat(chat);
    saveChatToDB(chat);
    setChats(prev => prev.map(c => c.id === chat.id ? chat : c));
  };
  
  const deleteChat = (chatId) => {
    deleteChatFromDB(chatId);
    setChats(prev => prev.filter(c => c.id !== chatId));
    if (selectedChat?.id === chatId) {
      setSelectedChat(null);
      setCurrentView('STORES'); // 스토어 목록으로 이동
    }
  };


  /* --- UI 렌더링 로직 --- */

  const handleApiKeySubmit = (e) => {
    e.preventDefault();
    const key = e.target.elements.apiKey.value;
    setApiKey(key);
    validateApiKey(key);
  };

  // 화면 전환 로직
  const selectStoreForDocs = (store) => {
    setSelectedStore(store);
    listDocuments(store.name);
    setCurrentView('DOCS');
  };

  const selectStoreForChat = (store) => {
    setSelectedStore(store);
    // 이 스토어와 연관된 첫 번째 채팅을 찾거나, 없으면 새로 만듭니다.
    const existingChat = chats.find(c => c.storeName === store.name);
    if (existingChat) {
      setSelectedChat(existingChat);
      setCurrentView('CHAT');
    } else {
      createNewChat(store);
    }
  };

  const selectDocForSearch = (doc) => {
    setSelectedDoc(doc);
    setCurrentView('DOC_SEARCH');
  };

  const navigateTo = (view) => {
    setCurrentView(view);
    // 상태 초기화
    if (view === 'STORES') {
      setSelectedStore(null);
      setSelectedDoc(null);
      setSelectedChat(null);
      listStores(); // 스토어 목록 새로고침
    }
  };
  
  const selectChat = (chat) => {
    setSelectedChat(chat);
    setCurrentView('CHAT');
  };

  // 렌더링
  if (isLoading && !apiKeyValid) {
    return <div className="flex h-screen w-full items-center justify-center bg-gray-950 text-white"><IconSpinner /> 로딩 중...</div>;
  }

  if (!apiKeyValid) {
    return (
      <div className="flex h-screen w-full items-center justify-center bg-gray-900 text-white">
        <div className="w-full max-w-md p-8 bg-gray-800 rounded-lg shadow-xl">
          <h1 className="text-3xl font-bold text-center text-blue-400 mb-6">Gemini File Store 관리자</h1>
          <p className="text-center text-gray-300 mb-8">시작하려면 Gemini API 키를 입력하세요.</p>
          <form onSubmit={handleApiKeySubmit}>
            <input
              type="password"
              name="apiKey"
              defaultValue={apiKey}
              className="w-full px-4 py-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="Gemini API Key"
            />
            <button type="submit" className="w-full mt-6 bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition">
              API 키 저장 및 시작
            </button>
            {globalError && <p className="mt-4 text-center text-red-400">{globalError}</p>}
          </form>
        </div>
      </div>
    );
  }

  // 메인 애플리케이션 UI
  return (
    <div className="flex h-screen bg-gray-950 text-gray-200">
      {/* 채팅 뷰일 때만 2단 레이아웃을 사용
        currentView === 'CHAT' ? 'w-64' : 'w-0' 
        -> w-0으로 하면 사이드바가 사라지므로, 
        채팅 뷰가 아닐 땐 사이드바를 숨기고 메인 컨텐츠가 전체 너비를 차지하도록 수정
      */}
      
      {currentView === 'CHAT' && (
        <ChatSidebar 
          chats={chats} 
          selectedChat={selectedChat}
          onSelectChat={selectChat}
          onCreateNewChat={() => createNewChat(selectedStore)} // 현재 선택된 스토어로 새 채팅
          onDeleteChat={deleteChat}
          onUpdateChat={updateChat}
          onNavigateBack={() => navigateTo('STORES')}
          currentStoreName={selectedStore?.displayName}
        />
      )}

      <div className="flex-1 flex flex-col overflow-hidden">
        <Header 
          apiKey={apiKey} 
          onLogout={() => {
            setApiKey('');
            setApiKeyValid(false);
            localStorage.removeItem('gemini-api-key');
          }}
          pendingOperations={pendingOperations}
          removeOperation={removeOperation}
        />
        <main className="flex-1 overflow-y-auto p-4 md:p-8">
          {globalError && (
            <div className="mb-4 bg-red-800 border border-red-600 text-red-200 px-4 py-3 rounded-lg" role="alert">
              <span className="block sm:inline">{globalError}</span>
              <span className="absolute top-0 bottom-0 right-0 px-4 py-3" onClick={() => setGlobalError(null)}>
                <svg className="fill-current h-6 w-6 text-red-300" role="button" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><title>Close</title><path d="M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 2.828a1.2 1.2 0 1 1-1.697-1.697L8.18 10l-2.828-2.651a1.2 1.2 0 1 1 1.697-1.697L10 8.183l2.651-2.828a1.2 1.2 0 1 1 1.697 1.697L11.819 10l2.828 2.651a1.2 1.2 0 0 1 0 1.698z"/></svg>
              </span>
            </div>
          )}

          {currentView === 'STORES' && (
            <FileSearchStoreList 
              stores={stores}
              onCreateStore={createStore}
              onDeleteStore={deleteStore}
              onSelectStoreForDocs={selectStoreForDocs}
              onSelectStoreForChat={selectStoreForChat}
            />
          )}
          
          {currentView === 'DOCS' && selectedStore && (
            <DocumentList
              store={selectedStore}
              documents={documents}
              onDeleteDocument={deleteDocument}
              onUploadFile={uploadFile}
              onSelectDocument={selectDocForSearch}
              onBack={() => navigateTo('STORES')}
              isLoading={isLoading}
            />
          )}

          {currentView === 'DOC_SEARCH' && selectedDoc && (
            <DocumentSearch
              document={selectedDoc}
              apiKey={apiKey}
              onBack={() => setCurrentView('DOCS')}
            />
          )}

          {currentView === 'CHAT' && selectedChat && (
            <ChatInterface
              key={selectedChat.id} // 채팅이 바뀔 때마다 컴포넌트 강제 리마운트
              chat={selectedChat}
              apiKey={apiKey}
              onUpdateChat={updateChat}
            />
          )}
        </main>
      </div>
    </div>
  );
}


// React 앱 마운트
// (수정) UMD 환경을 가정하여 ReactDOM.createRoot 사용
// (수정) createRoot가 중복 호출되는 경고를 피하고 'default' 오류를 수정하기 위해 로직 변경
const container = document.getElementById('root');
if (!window._geminiAppRoot) {
  // `default` 오류를 피하기 위해 ReactDOM.default를 우선적으로 확인합니다.
  const EffectiveReactDOM = ReactDOM.default || ReactDOM; 
  
  if (EffectiveReactDOM && typeof EffectiveReactDOM.createRoot === 'function') {
    window._geminiAppRoot = EffectiveReactDOM.createRoot(container);
  } else if (typeof ReactDOMClient !== 'undefined') { // `react-dom/client`의 UMD 전역 변수인 ReactDOMClient 확인
    window._geminiAppRoot = ReactDOMClient.createRoot(container);
  } else {
    console.error('Could not find ReactDOM.createRoot or ReactDOMClient.createRoot.');
  }
}

if (window._geminiAppRoot) {
  window._geminiAppRoot.render(<App />);
} else {
  console.error('Failed to create React root.');
}


})(); // (신규) IIFE 종료
