<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>프롬프트 관리자 프로 (최종)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" xintegrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>

    <script type="module">
        // Firebase SDK 모듈 임포트
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
        import { 
            getAuth, 
            GoogleAuthProvider, 
            onAuthStateChanged, 
            signInWithPopup, 
            signOut 
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
        import { 
            getFirestore, 
            collection, 
            doc, 
            getDocs, 
            setDoc, 
            addDoc, 
            deleteDoc, 
            serverTimestamp, 
            getDoc, 
            updateDoc,
            query,
            orderBy
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";

        // Firebase 프로젝트 설정
        // !!! 중요: 아래 firebaseConfig 객체에 실제 Firebase 프로젝트 설정값을 붙여넣으세요. !!!
        const firebaseConfig = {
            apiKey: "AIzaSyAzpL5nTg6v92Uj28QsBpxt1k8wYoGKXtY",
            authDomain: "prompt-76252.firebaseapp.com",
            projectId: "prompt-76252",
            storageBucket: "prompt-76252.firebasestorage.app",
            messagingSenderId: "683129810198",
            appId: "1:683129810198:web:aa39fe66cec551d41df437",
            measurementId: "G-4GCY1XH5HN"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const dbFirestore = getFirestore(app); // Firestore DB 인스턴스
        let currentUser = null; // 현재 로그인된 사용자 정보

        // =================================================================
        // IndexedDB 설정 (캐싱 및 버전 관리용)
        // =================================================================
        const INDEXEDDB_NAME = 'PromptManagerCacheDB';
        const INDEXEDDB_VERSION = 5; // 사용기록 저장소 스키마 변경을 위해 버전 증가 (variablesUsed 추가)
        const CACHE_STORE_PROMPTS = 'cachedPrompts';
        const CACHE_STORE_FOLDERS = 'cachedFolders';
        const CACHE_STORE_VERSIONS = 'promptVersions'; // 프롬프트 버전 기록 저장소
        const CACHE_STORE_SEQUENCES = 'cachedSequences'; // 시퀀스 캐시 저장소
        const CACHE_STORE_USAGE_HISTORY = 'usageHistory'; // 사용 기록 저장소 (새로 추가)

        let indexedDbInstance;

        /**
         * IndexedDB 데이터베이스를 열거나 생성합니다.
         * @returns {Promise<IDBDatabase>} IndexedDB 데이터베이스 인스턴스.
         */
        function openIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(INDEXEDDB_NAME, INDEXEDDB_VERSION);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // 프롬프트 캐시 저장소 생성 또는 가져오기
                    if (!db.objectStoreNames.contains(CACHE_STORE_PROMPTS)) {
                        db.createObjectStore(CACHE_STORE_PROMPTS, { keyPath: 'id' });
                    }
                    // 폴더 캐시 저장소 생성 또는 가져오기
                    if (!db.objectStoreNames.contains(CACHE_STORE_FOLDERS)) {
                        db.createObjectStore(CACHE_STORE_FOLDERS, { keyPath: 'id' });
                    }
                    // 프롬프트 버전 기록 저장소 생성 및 인덱스 추가 또는 가져오기
                    if (!db.objectStoreNames.contains(CACHE_STORE_VERSIONS)) {
                        const versionStore = db.createObjectStore(CACHE_STORE_VERSIONS, { keyPath: 'id', autoIncrement: true });
                        versionStore.createIndex('promptId', 'promptId', { unique: false });
                        versionStore.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                    // 시퀀스 캐시 저장소 생성 또는 가져오기
                    if (!db.objectStoreNames.contains(CACHE_STORE_SEQUENCES)) {
                        db.createObjectStore(CACHE_STORE_SEQUENCES, { keyPath: 'id' });
                    }
                    // 사용 기록 저장소 생성 및 인덱스 추가 또는 가져오기
                    if (!db.objectStoreNames.contains(CACHE_STORE_USAGE_HISTORY)) {
                        const historyStore = db.createObjectStore(CACHE_STORE_USAGE_HISTORY, { keyPath: 'id', autoIncrement: true });
                        historyStore.createIndex('timestamp', 'timestamp', { unique: false });
                    }
                };

                request.onsuccess = (event) => {
                    indexedDbInstance = event.target.result;
                    resolve(indexedDbInstance);
                };

                request.onerror = (event) => {
                    console.error("IndexedDB 열기 오류:", event.target.errorCode);
                    reject(event.target.errorCode);
                };
            });
        }

        /**
         * IndexedDB에서 지정된 Object Store의 모든 항목을 가져옵니다.
         * @param {string} storeName - 데이터를 가져올 Object Store의 이름.
         * @param {string} [indexName=null] - 사용할 인덱스 이름 (선택 사항).
         * @param {*} [query=null] - 인덱스 쿼리 (선택 사항).
         * @returns {Promise<Array<Object>>} 가져온 항목 배열.
         */
        async function getFromIndexedDB(storeName, indexName = null, query = null) {
            if (!indexedDbInstance) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = indexedDbInstance.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                let request;
                if (indexName && query) {
                    const index = store.index(indexName);
                    request = index.getAll(query);
                } else {
                    request = store.getAll();
                }
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        /**
         * IndexedDB에 항목을 추가하거나 업데이트합니다.
         * @param {string} storeName - 항목을 저장할 Object Store의 이름.
         * @param {Object} data - 저장할 데이터 객체. `keyPath`에 해당하는 속성을 포함해야 합니다.
         * @returns {Promise<any>} 추가 또는 업데이트된 항목의 키.
         */
        async function putIntoIndexedDB(storeName, data) {
            if (!indexedDbInstance) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = indexedDbInstance.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        /**
         * IndexedDB에서 특정 항목을 삭제합니다.
         * @param {string} storeName - 항목을 삭제할 Object Store의 이름.
         * @param {*} id - 삭제할 항목의 키.
         * @returns {Promise<void>} 삭제 완료 시 resolve.
         */
        async function deleteFromIndexedDB(storeName, id) {
            if (!indexedDbInstance) await openIndexedDB();
            return new Promise((resolve, reject) => {
                const transaction = indexedDbInstance.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // =================================================================
        // UI 요소 참조 및 상태 관리 (UI Elements and State Management)
        // =================================================================
        const ui = {
            contentView: document.getElementById('content-view'),
            mainHeader: document.getElementById('main-header-title'),
            folderList: document.getElementById('folder-list'),
            libraryList: document.getElementById('library-list'),
            newPromptBtn: document.getElementById('new-prompt-btn'),
            newFolderBtn: document.getElementById('new-folder-btn'),
            searchInput: document.getElementById('search-input'),
            sidebarContent: document.getElementById('sidebar-content'),
            loginBtn: document.getElementById('login-btn'),
            logoutBtn: document.getElementById('logout-btn'),
            userProfile: document.getElementById('user-profile'),
            userEmail: document.getElementById('user-email'),
            userPhoto: document.getElementById('user-photo'),
            toast: document.getElementById('toast'),
            templateModal: {
                overlay: document.getElementById('template-modal-overlay'),
                title: document.getElementById('template-modal-title'),
                body: document.getElementById('template-modal-body'),
                generateBtn: document.getElementById('template-modal-generate-btn'),
                closeBtn: document.getElementById('template-modal-close-btn')
            },
            sequenceModal: { // 시퀀스 모달 UI 요소 추가
                overlay: document.getElementById('sequence-modal-overlay'),
                title: document.getElementById('sequence-modal-title'),
                body: document.getElementById('sequence-modal-body'),
                saveBtn: document.getElementById('sequence-modal-save-btn'),
                runBtn: document.getElementById('sequence-modal-run-btn'),
                closeBtn: document.getElementById('sequence-modal-close-btn'),
                deleteBtn: document.getElementById('sequence-modal-delete-btn')
            },
            sidebar: document.getElementById('sidebar'), // 사이드바 자체 참조 추가
            mobileMenuToggle: document.getElementById('mobile-menu-toggle'), // 모바일 햄버거 메뉴 버튼
            sidebarCloseBtn: document.getElementById('sidebar-close-btn'), // 사이드바 닫기 버튼
            sequenceList: document.getElementById('sequence-list'), // 시퀀스 목록
            newSequenceBtn: document.getElementById('new-sequence-btn'), // 새 시퀀스 버튼
            refreshDataBtn: document.getElementById('refresh-data-btn') // 새로고침 버튼 추가
        };

        // 앱의 전역 상태 (현재 필터, 프롬프트/폴더 데이터)
        let state = { 
            currentFilter: { type: 'all', id: null, name: '모든 항목' }, 
            prompts: [], 
            folders: [],
            sequences: [], // 시퀀스 데이터 추가
            searchResults: null // Fuse.js 검색 결과 저장
        };

        let fuse = null; // Fuse.js 인스턴스

        // 전역 시퀀스 실행 상태
        let activeSequencePrompts = []; // 현재 실행 중인 시퀀스의 프롬프트 객체들 (순서대로)
        let currentSequencePromptIndex = -1; // 현재 실행 중인 프롬프트의 인덱스
        let sequenceSortableInstance = null; // Sortable.js 인스턴스

        // =================================================================
        // Firebase Firestore & IndexedDB 하이브리드 데이터 서비스
        // (Firebase Firestore & IndexedDB Hybrid Data Service)
        // =================================================================
        const dbService = {
            /**
             * 현재 사용자 UID 기반으로 Firestore 컬렉션 참조를 가져옵니다.
             * @param {string} collectionName - 컬렉션 이름 ('prompts', 'folders', 'sequences').
             * @returns {firebase.firestore.CollectionReference} Firestore 컬렉션 참조.
             * @throws {Error} 사용자가 로그인하지 않은 경우.
             */
            getCollectionRef: (collectionName) => {
                if (!currentUser) {
                    console.error("오류: 로그인되지 않았습니다. Firestore에 접근할 수 없습니다.");
                    throw new Error("로그인되지 않았습니다. Firestore에 접근할 수 없습니다.");
                }
                return collection(dbFirestore, 'users', currentUser.uid, collectionName);
            },
            /**
             * 현재 사용자 UID 기반으로 Firestore 문서 참조를 가져옵니다.
             * @param {string} collectionName - 컬렉션 이름.
             * @param {string} id - 문서 ID.
             * @returns {firebase.firestore.DocumentReference} Firestore 문서 참조.
             * @throws {Error} 사용자가 로그인하지 않은 경우.
             */
            getDocRef: (collectionName, id) => {
                if (!currentUser) {
                    console.error("오류: 로그인되지 않았습니다. Firestore에 접근할 수 없습니다.");
                    throw new Error("로그인되지 않았습니다. Firestore에 접근할 수 없습니다.");
                }
                return doc(dbFirestore, 'users', currentUser.uid, collectionName, id);
            },
            /**
             * Firestore 또는 IndexedDB에서 모든 문서를 가져옵니다.
             * 강제 새로고침 옵션이 없으면 IndexedDB 캐시를 먼저 시도합니다.
             * @param {string} collectionName - 컬렉션 이름 ('prompts', 'folders', 'sequences').
             * @param {boolean} [forceRefresh=false] - IndexedDB 캐시를 무시하고 Firestore에서 강제로 가져올지 여부.
             * @returns {Promise<Array<Object>>} 문서 객체 배열.
             */
            getAll: async (collectionName, forceRefresh = false) => {
                if (!currentUser) return [];

                let cacheStoreName;
                if (collectionName === 'prompts') cacheStoreName = CACHE_STORE_PROMPTS;
                else if (collectionName === 'folders') cacheStoreName = CACHE_STORE_FOLDERS;
                else if (collectionName === 'sequences') cacheStoreName = CACHE_STORE_SEQUENCES;
                else throw new Error(`알 수 없는 컬렉션 이름: ${collectionName}`);


                // 1. IndexedDB에서 캐시된 데이터 시도
                if (!forceRefresh) {
                    try {
                        const cachedData = await getFromIndexedDB(cacheStoreName);
                        if (cachedData.length > 0) {
                            console.log(`IndexedDB에서 ${collectionName} 데이터 로드됨.`);
                            return cachedData;
                        }
                    } catch (e) {
                        console.warn(`IndexedDB에서 ${collectionName} 데이터 로드 실패, Firestore 시도:`, e);
                    }
                }

                // 2. Firestore에서 최신 데이터 가져오기
                try {
                    // Firestore 보안 규칙에 orderBy("updatedAt", "desc")에 대한 인덱스가 없을 경우 에러가 발생할 수 있습니다.
                    // 실제 배포 시에는 Firebase 콘솔에서 해당 인덱스를 생성해야 합니다.
                    const q = query(dbService.getCollectionRef(collectionName), orderBy("updatedAt", "desc"));
                    const snapshot = await getDocs(q);
                    const firestoreData = snapshot.docs.map(doc => {
                        const data = doc.data();
                        // Firestore Timestamp를 Date 객체로 변환하여 저장 (IndexedDB 호환성)
                        if (data.createdAt && data.createdAt.toDate) data.createdAt = data.createdAt.toDate();
                        if (data.updatedAt && data.updatedAt.toDate) data.updatedAt = data.updatedAt.toDate();
                        return { id: doc.id, ...data };
                    });

                    // 3. IndexedDB에 캐시 업데이트
                    try {
                        const transaction = indexedDbInstance.transaction([cacheStoreName], 'readwrite');
                        const store = transaction.objectStore(cacheStoreName);
                        store.clear(); // 기존 캐시 삭제
                        for (const item of firestoreData) {
                            store.put(item); // 새 데이터 추가
                        }
                        console.log(`Firestore에서 ${collectionName} 데이터 로드 및 IndexedDB에 캐시됨.`);
                    } catch (e) {
                        console.error("IndexedDB 캐시 업데이트 오류:", e);
                    }
                    
                    return firestoreData;
                } catch (error) {
                    console.error(`Firestore ${collectionName} 데이터 가져오기 오류:`, error);
                    helpers.showToast(`데이터 로드 실패: ${error.message}`);
                    return []; 
                }
            },
            /**
             * Firestore 또는 IndexedDB에서 ID로 특정 문서를 가져옵니다.
             * @param {string} collectionName - 컬렉션 이름.
             * @param {string} id - 문서 ID.
             * @returns {Promise<Object|null>} 문서 객체 또는 null.
             */
            getById: async (collectionName, id) => {
                if (!currentUser) return null;

                let cacheStoreName;
                if (collectionName === 'prompts') cacheStoreName = CACHE_STORE_PROMPTS;
                else if (collectionName === 'folders') cacheStoreName = CACHE_STORE_FOLDERS;
                else if (collectionName === 'sequences') cacheStoreName = CACHE_STORE_SEQUENCES;
                else throw new Error(`알 수 없는 컬렉션 이름: ${collectionName}`);

                // 1. IndexedDB에서 캐시된 단일 항목 시도
                try {
                    const transaction = indexedDbInstance.transaction([cacheStoreName], 'readonly');
                    const store = transaction.objectStore(cacheStoreName);
                    const cachedItem = await new Promise((resolve, reject) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = (event) => reject(event.target.error);
                    });
                    if (cachedItem) {
                        console.log(`IndexedDB에서 ${collectionName}:${id} 로드됨.`);
                        return cachedItem;
                    }
                } catch (e) {
                    console.warn(`IndexedDB에서 ${collectionName}:${id} 로드 실패, Firestore 시도:`, e);
                }

                // 2. Firestore에서 가져오기
                try {
                    const docSnap = await getDoc(dbService.getDocRef(collectionName, id));
                    const item = docSnap.exists() ? { id: docSnap.id, ...docSnap.data() } : null;

                    // 3. IndexedDB에 캐시 업데이트
                    if (item) {
                        // Firestore Timestamp를 Date 객체로 변환하여 저장
                        if (item.createdAt && item.createdAt.toDate) item.createdAt = item.createdAt.toDate();
                        if (item.updatedAt && item.updatedAt.toDate) item.updatedAt = item.updatedAt.toDate();
                        await putIntoIndexedDB(cacheStoreName, item);
                        console.log(`Firestore에서 ${collectionName}:${id} 로드 및 IndexedDB에 캐시됨.`);
                    }
                    return item;
                } catch (error) {
                    console.error(`Firestore ${collectionName}:${id} 데이터 가져오기 오류:`, error);
                    helpers.showToast(`항목 로드 실패: ${error.message}`);
                    return null;
                }
            },
            /**
             * Firestore 및 IndexedDB에 문서를 추가하거나 업데이트합니다.
             * @param {string} collectionName - 컬렉션 이름.
             * @param {Object} item - 저장할 항목 데이터. `id` 필드가 있으면 업데이트, 없으면 추가.
             * @returns {Promise<string>} 저장된 문서의 ID.
             * @throws {Error} 사용자가 로그인하지 않은 경우 또는 저장 오류 발생 시.
             */
            put: async (collectionName, item) => {
                if (!currentUser) throw new Error("로그인되지 않았습니다. 데이터를 저장할 수 없습니다.");
                const cleanItem = { ...item };
                const itemId = cleanItem.id; // item.id는 undefined 또는 실제 ID 문자열이 됨
                delete cleanItem.id; // Firestore 문서 자체에 id를 저장하지 않음

                let resultId;
                try {
                    // createdAt과 updatedAt은 Firestore의 serverTimestamp()로만 설정되도록 보장
                    // IndexedDB put 시점에는 Date 객체로 변환하여 저장
                    const timestampedItem = { 
                        ...cleanItem,
                        updatedAt: serverTimestamp() 
                    };
                    if (!itemId) { // 새 항목인 경우에만 createdAt 설정
                        timestampedItem.createdAt = serverTimestamp();
                    }

                    // itemId가 유효한 문자열 ID인 경우에만 업데이트로 처리
                    if (typeof itemId === 'string' && itemId.trim().length > 0 && itemId !== 'null') { 
                        await setDoc(dbService.getDocRef(collectionName, itemId), timestampedItem, { merge: true });
                        resultId = itemId;
                    } else { // 그 외의 경우 (undefined, null, "", "null")는 새 문서 추가
                        const docRef = await addDoc(dbService.getCollectionRef(collectionName), timestampedItem);
                        resultId = docRef.id;
                    }

                    // IndexedDB 캐시 업데이트: Firestore에 저장된 실제 데이터로 업데이트 (로컬에서는 Date 객체로 변환)
                    const itemForIndexedDB = { id: resultId, ...cleanItem, updatedAt: new Date() }; 
                    if (!itemId) {
                        itemForIndexedDB.createdAt = new Date();
                    }
                    
                    let cacheStoreName;
                    if (collectionName === 'prompts') cacheStoreName = CACHE_STORE_PROMPTS;
                    else if (collectionName === 'folders') cacheStoreName = CACHE_STORE_FOLDERS;
                    else if (collectionName === 'sequences') cacheStoreName = CACHE_STORE_SEQUENCES;
                    else throw new Error(`알 수 없는 컬렉션 이름: ${collectionName}`);

                    await putIntoIndexedDB(cacheStoreName, itemForIndexedDB);
                    
                    return resultId;
                } catch (error) {
                    console.error(`Firestore ${collectionName} 데이터 저장 오류:`, error);
                    helpers.showToast(`데이터 저장 실패: ${error.message}`);
                    throw error; 
                }
            },
            /**
             * Firestore 및 IndexedDB에서 문서를 부분 업데이트합니다.
             * @param {string} collectionName - 컬렉션 이름.
             * @param {string} id - 업데이트할 문서의 ID.
             * @param {Object} data - 업데이트할 필드 객체.
             * @returns {Promise<void>} 업데이트 완료 시 resolve.
             * @throws {Error} 사용자가 로그인하지 않은 경우 또는 업데이트 오류 발생 시.
             */
            update: async (collectionName, id, data) => {
                if (!currentUser) throw new Error("로그인되지 않았습니다. 데이터를 업데이트할 수 없습니다.");
                try {
                    // updatedAt은 항상 서버 타임스탬프로 업데이트
                    const updateData = { ...data, updatedAt: serverTimestamp() };
                    await updateDoc(dbService.getDocRef(collectionName, id), updateData);
                    // IndexedDB 캐시 업데이트: Firestore에서 최신 데이터 가져옴
                    const updatedItem = await dbService.getById(collectionName, id); // Firestore에서 최신 데이터 가져옴
                    if (updatedItem) {
                        let cacheStoreName;
                        if (collectionName === 'prompts') cacheStoreName = CACHE_STORE_PROMPTS;
                        else if (collectionName === 'folders') cacheStoreName = CACHE_STORE_FOLDERS;
                        else if (collectionName === 'sequences') cacheStoreName = CACHE_STORE_SEQUENCES;
                        else throw new Error(`알 수 없는 컬렉션 이름: ${collectionName}`);
                        await putIntoIndexedDB(cacheStoreName, updatedItem);
                    }
                } catch (error) {
                    console.error(`Firestore ${collectionName}:${id} 데이터 업데이트 오류:`, error);
                    helpers.showToast(`데이터 업데이트 실패: ${error.message}`);
                    throw error;
                }
            },
            /**
             * Firestore 및 IndexedDB에서 문서를 삭제합니다.
             * @param {string} collectionName - 컬렉션 이름.
             * @param {string} id - 삭제할 문서의 ID.
             * @returns {Promise<void>} 삭제 완료 시 resolve.
             * @throws {Error} 사용자가 로그인하지 않은 경우 또는 삭제 오류 발생 시.
             */
            delete: async (collectionName, id) => {
                if (!currentUser) throw new Error("로그인되지 않았습니다. 데이터를 삭제할 수 없습니다.");
                try {
                    await deleteDoc(dbService.getDocRef(collectionName, id));
                    // IndexedDB 캐시 삭제
                    let cacheStoreName;
                    if (collectionName === 'prompts') cacheStoreName = CACHE_STORE_PROMPTS;
                    else if (collectionName === 'folders') cacheStoreName = CACHE_STORE_FOLDERS;
                    else if (collectionName === 'sequences') cacheStoreName = CACHE_STORE_SEQUENCES;
                    else throw new Error(`알 수 없는 컬렉션 이름: ${collectionName}`);
                    await deleteFromIndexedDB(cacheStoreName, id);
                } catch (error) {
                    console.error(`Firestore ${collectionName}:${id} 데이터 삭제 오류:`, error);
                    helpers.showToast(`데이터 삭제 실패: ${error.message}`);
                    throw error;
                }
            },
            /**
             * 프롬프트 버전을 IndexedDB에만 저장합니다.
             * @param {string} promptId - 원본 프롬프트의 ID.
             * @param {string} content - 저장할 프롬프트 내용.
             * @param {string} [memo=''] - 버전 기록에 대한 메모.
             * @returns {Promise<void>} 저장 완료 시 resolve.
             */
            savePromptVersion: async (promptId, content, memo = '') => {
                if (!indexedDbInstance) await openIndexedDB();
                const versionData = {
                    promptId: promptId,
                    content: content,
                    timestamp: new Date(),
                    memo: memo
                };
                await putIntoIndexedDB(CACHE_STORE_VERSIONS, versionData);
                helpers.showToast('프롬프트 버전이 저장되었습니다.');
            },
            /**
             * 특정 프롬프트의 모든 버전 기록을 IndexedDB에서 가져옵니다.
             * @param {string} promptId - 버전 기록을 가져올 프롬프트의 ID.
             * @returns {Promise<Array<Object>>} 버전 기록 배열 (최신순).
             */
            getPromptVersions: async (promptId) => {
                if (!indexedDbInstance) await openIndexedDB();
                return new Promise((resolve, reject) => {
                    const transaction = indexedDbInstance.transaction([CACHE_STORE_VERSIONS], 'readonly');
                    const store = transaction.objectStore(CACHE_STORE_VERSIONS);
                    const index = store.index('promptId');
                    const request = index.getAll(promptId);
                    request.onsuccess = () => {
                        // 최신순으로 정렬
                        const sortedVersions = request.result.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
                        resolve(sortedVersions);
                    };
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            /**
             * 모든 데이터를 JSON 파일로 내보냅니다.
             */
            exportData: async () => {
                // Firestore에서 강제 새로고침하여 최신 데이터 가져옴
                const allPrompts = await dbService.getAll('prompts', true); 
                const allFolders = await dbService.getAll('folders', true); 
                const allSequences = await dbService.getAll('sequences', true);
                const data = { prompts: allPrompts, folders: allFolders, sequences: allSequences };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `prompt_manager_backup_${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                helpers.showToast('데이터가 내보내기되었습니다.');
            },
            /**
             * JSON 파일을 읽어 데이터를 가져옵니다.
             * @param {File} file - 가져올 JSON 파일.
             */
            importData: async (file) => {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        if (importedData.prompts && Array.isArray(importedData.prompts)) {
                            // 기존 데이터 삭제 여부 확인
                            const confirmClear = await helpers.showConfirm('기존 데이터를 모두 지우고 가져오겠습니까? (취소 시 기존 데이터에 추가)');
                            if (confirmClear) {
                                // Firestore 및 IndexedDB에서 모두 삭제
                                const currentPrompts = await dbService.getAll('prompts', true);
                                for (const p of currentPrompts) {
                                    await dbService.delete('prompts', p.id);
                                }
                                const currentFolders = await dbService.getAll('folders', true);
                                for (const f of currentFolders) {
                                    await dbService.delete('folders', f.id);
                                }
                                const currentSequences = await dbService.getAll('sequences', true);
                                for (const s of currentSequences) {
                                    await dbService.delete('sequences', s.id);
                                }
                                helpers.showToast('기존 데이터가 지워졌습니다.');
                            }

                            for (const promptData of importedData.prompts) {
                                // ID 필드를 제거하고 Firestore에 새로 추가 (중복 방지)
                                await dbService.put('prompts', {
                                    title: promptData.title,
                                    content: promptData.content,
                                    folderId: promptData.folderId,
                                    tags: promptData.tags || [],
                                    isFavorite: promptData.isFavorite || false,
                                    isTemplate: promptData.isTemplate || false,
                                    usageCount: promptData.usageCount || 0, // 사용 빈도 필드
                                    link: promptData.link || '', // 추가된 link 필드
                                    // createdAt과 updatedAt은 put 함수에서 serverTimestamp()로 자동 설정
                                });
                            }
                            if (importedData.folders && Array.isArray(importedData.folders)) {
                                for (const folderData of importedData.folders) {
                                    await dbService.put('folders', {
                                        name: folderData.name,
                                        // createdAt과 updatedAt은 put 함수에서 serverTimestamp()로 자동 설정
                                    });
                                }
                            }
                            if (importedData.sequences && Array.isArray(importedData.sequences)) {
                                for (const sequenceData of importedData.sequences) {
                                    await dbService.put('sequences', {
                                        name: sequenceData.name,
                                        description: sequenceData.description || '',
                                        promptIds: sequenceData.promptIds || [],
                                        // createdAt과 updatedAt은 put 함수에서 serverTimestamp()로 자동 설정
                                    });
                                }
                            }
                            helpers.showToast('데이터가 성공적으로 가져오기되었습니다!');
                            initializeAppLogic(); // UI 새로고침
                        } else {
                            throw new Error("유효하지 않은 JSON 데이터 형식입니다.");
                        }
                    } catch (e) {
                        console.error("데이터 가져오기 오류:", e);
                        helpers.showToast('데이터 가져오기 실패: ' + e.message);
                    }
                };
                reader.readAsText(file);
            }
        };

        // =================================================================
        // UI 렌더링 함수들 (UI Rendering Functions)
        // =================================================================
        const render = {
            /**
             * 폴더 목록을 렌더링합니다.
             */
            folders: async () => {
                state.folders = await dbService.getAll('folders');
                ui.folderList.innerHTML = state.folders.map(f => `
                    <li class="nav-item" data-filter-type="folder" data-folder-id="${f.id}">
                        <a><i class="nav-icon fa-regular fa-folder"></i> ${f.name}</a>
                    </li>
                `).join('') + `<li class="nav-item" data-filter-type="uncategorized"><a><i class="nav-icon fa-solid fa-inbox"></i> 미분류</a></li>`;
            },
            /**
             * 시퀀스 목록을 렌더링합니다.
             */
            sequences: async () => {
                state.sequences = await dbService.getAll('sequences');
                ui.sequenceList.innerHTML = state.sequences
                    .map(s => `<li class="nav-item" data-filter-type="sequence" data-seq-id="${s.id}">
                                    <a><i class="nav-icon fa-solid fa-layer-group"></i> ${s.name}</a>
                                </li>`).join('');
            },
            /**
             * 프롬프트 목록을 렌더링합니다. 필터링 및 검색 기능을 포함합니다.
             * @param {boolean} [forceRefresh=false] - 데이터 캐시를 강제로 새로고침할지 여부.
             */
            prompts: async (forceRefresh = false) => { // forceRefresh 인자 추가
                ui.mainHeader.textContent = state.currentFilter.name;
                let allItems = [];
                try {
                    // 데이터 로드 시 forceRefresh 인자 전달
                    allItems = await dbService.getAll('prompts', forceRefresh);
                    state.prompts = allItems; // 전역 state.prompts 업데이트
                } catch (e) {
                    console.warn("render.prompts에서 데이터 로드 중 경고:", e); 
                    allItems = [];
                }
                                        
                let filtered = allItems;

                // 현재 필터 타입에 따른 데이터 필터링
                const { type, id } = state.currentFilter;
                if (type === 'folder') filtered = allItems.filter(p => p.folderId === id);
                else if (type === 'uncategorized') filtered = allItems.filter(p => !p.folderId);
                else if (type === 'favorites') filtered = allItems.filter(p => p.isFavorite);
                else if (type === 'templates') filtered = allItems.filter(p => p.isTemplate);
                else if (type === 'prompts') filtered = allItems.filter(p => !p.isTemplate);
                                        
                // 검색어 필터링 (Fuse.js 사용)
                const searchTerm = ui.searchInput.value.toLowerCase();
                if(searchTerm) {
                    if (!fuse || forceRefresh) { // Fuse 인덱스가 없거나 강제 새로고침 시 다시 빌드
                        await buildSearchIndex();
                    }
                    // is:template, is:prompt 특별 검색어 처리
                    if (searchTerm.startsWith('is:template')) {
                        filtered = filtered.filter(p => p.isTemplate);
                    } else if (searchTerm.startsWith('is:prompt')) {
                        filtered = filtered.filter(p => !p.isTemplate);
                    } else if (searchTerm.startsWith('#')) { // #태그명 검색
                        const tag = searchTerm.slice(1);
                        filtered = filtered.filter(p => p.tags?.some(t => t.toLowerCase().includes(tag))); // 태그 배열 내 검색
                    } else {
                        // 일반 검색어는 Fuse.js 사용
                        state.searchResults = fuse.search(searchTerm).map(r => r.item);
                        filtered = state.searchResults;
                    }
                } else {
                    state.searchResults = null; // 검색어 없으면 검색 결과 초기화
                }
                                        
                // 필터링된 항목이 없을 경우 메시지 표시
                if (filtered.length === 0) {
                    ui.contentView.innerHTML = `<div class="content-placeholder">항목을 찾을 수 없습니다.</div>`;
                    return;
                }
                // updatedAt 타임스탬프 기준으로 정렬 (최신순)
                // IndexedDB에서 로드된 Date 객체와 Firestore Timestamp를 모두 처리
                filtered.sort((a, b) => {
                    const dateA = a.updatedAt instanceof Date ? a.updatedAt : (a.updatedAt ? a.updatedAt.toDate() : new Date(0));
                    const dateB = b.updatedAt instanceof Date ? b.updatedAt : (b.updatedAt ? b.updatedAt.toDate() : new Date(0));
                    return dateB.getTime() - dateA.getTime();
                });

                // 프롬프트 목록 HTML 생성 및 렌더링
                ui.contentView.innerHTML = filtered.map(p => {
                    const icon = p.isTemplate ? 'fa-puzzle-piece' : 'fa-file-lines';
                    const tagsHTML = (p.tags || []).map(tag => `<span class="prompt-tag">#${tag}</span>`).join('');
                    const date = p.updatedAt ? (p.updatedAt instanceof Date ? p.updatedAt.toLocaleString() : p.updatedAt.toDate().toLocaleString()) : 'N/A';
                    
                    let buttonsHtml = '';
                    if (p.isTemplate) {
                        buttonsHtml += `<button class="use-btn"><i class="fa-solid fa-wand-magic-sparkles"></i> 사용</button>`;
                    } else if (p.link) { // 템플릿이 아니면서 링크가 있는 경우 '방문' 버튼만
                        buttonsHtml += `<a href="${p.link}" target="_blank" class="visit-link-btn" title="링크 방문"><i class="fa-solid fa-external-link-alt"></i> 방문</a>`;
                    } else { // 템플릿도 링크도 없는 일반 프롬프트는 '복사' 버튼
                        buttonsHtml += `<button class="copy-btn"><i class="fa-regular fa-copy"></i> 복사</button>`;
                    }
                    // 링크가 있으면서 템플릿인 경우 '방문' 버튼 추가 (순서는 '사용' 버튼 뒤에)
                    if (p.isTemplate && p.link) {
                        buttonsHtml += `<a href="${p.link}" target="_blank" class="visit-link-btn" title="링크 방문" style="margin-left: 8px;"><i class="fa-solid fa-external-link-alt"></i> 방문</a>`;
                    }

                    return `
                    <div class="prompt-list-item" data-prompt-id="${p.id}">
                        <i class="prompt-list-icon fa-solid ${icon}" style="color: ${p.isTemplate ? 'var(--accent-blue)' : 'var(--text-secondary)'}"></i>
                        <i class="prompt-list-icon fa-solid fa-star fav-icon ${p.isFavorite ? 'active' : ''}" style="color: ${p.isFavorite ? 'var(--accent-yellow)' : 'var(--text-secondary)'}"></i>
                        <div style="flex-grow:1;">
                            <div class="prompt-title">${p.title}</div>
                            <div class="prompt-subtitle">업데이트: ${date}</div>
                            ${tagsHTML ? `<div class="prompt-tags">${tagsHTML}</div>` : ''}
                        </div>
                        <div class="prompt-actions">
                            ${buttonsHtml}
                            <button class="edit-btn"><i class="fa-regular fa-edit"></i> 편집</button>
                        </div>
                    </div>`;
                }).join('');
            },
            /**
             * 프롬프트 편집기 화면을 렌더링합니다.
             * @param {string|null} id - 편집할 프롬프트의 ID (새 항목인 경우 null).
             */
            promptEditor: async (id) => {
                const isNew = id === null;
                // isFavorite, usageCount, link를 항상 초기화
                let p = { title: '', content: '', folderId: null, tags: [], isFavorite: false, isTemplate: false, usageCount: 0, link: '' };
                if (!isNew) {
                    const fetchedPrompt = await dbService.getById('prompts', id);
                    if (fetchedPrompt) {
                        p = fetchedPrompt;
                    } else {
                        helpers.showToast('항목을 찾을 수 없습니다!');
                        render.prompts(); 
                        return;
                    }
                }
                                        
                // 폴더 선택 드롭다운 옵션 생성
                const folderOpts = state.folders.map(f => `<option value="${f.id}" ${f.id === p.folderId ? 'selected' : ''}>${f.name}</option>`).join('');
                                        
                ui.mainHeader.textContent = isNew ? '새 항목' : `편집: ${p.title}`;
                ui.contentView.innerHTML = `
                    <div class="editor-header">
                        <h2>${isNew ? '새 항목 생성' : '항목 편집'}</h2>
                        <div class="editor-actions">
                            ${!isNew ? `<button class="delete-btn" data-id="${id}"><i class="fa-regular fa-trash-can"></i> 삭제</button>` : ''}
                            <button class="save-btn" id="save-prompt-btn" ${isNew ? '' : `data-id="${id}"`}><i class="fa-regular fa-save"></i> 저장</button>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>제목</label>
                        <input id="title-input" value="${p.title || ''}">
                    </div>
                    <div class="form-group">
                        <label>내용 ${p.isTemplate ? '(플레이스홀더에 {{변수}} 사용)' : ''}</label>
                        <textarea id="content-input">${p.content || ''}</textarea>
                        <div class="file-upload-section">
                            <input type="file" id="large-text-file" accept=".txt,.html,.htm,.md,.json,.csv,.xml,.yaml,.yml,.js,.css,text/*" style="display:none;">
                            <button id="load-text-btn" class="button-like"><i class="fa-solid fa-file-arrow-up"></i> 파일에서 불러오기</button>
                            <span id="loaded-file-name" style="margin-left: 10px; font-size: 0.85rem; color: var(--text-secondary);"></span>
                        </div>
                        <p id="content-size-warning" style="color: var(--accent-yellow); font-size: 0.85rem; margin-top: 5px; display: none;">
                            경고: 내용이 너무 길어 저장에 실패할 수 있습니다. (Firestore 문서 제한 1MB)
                        </p>
                    </div>
                    <div class="form-group">
                        <label>링크 (URL)</label>
                        <input id="link-input" type="url" value="${p.link || ''}" placeholder="예: https://example.com">
                    </div> 
                    <div style="display:flex; gap: 24px;">
                        <div class="form-group" style="flex:1;">
                            <label>폴더</label>
                            <select id="folder-select">
                                <option value="">미분류</option>${folderOpts}
                            </select>
                        </div>
                        <div class="form-group" style="flex:1;">
                            <label>태그 (쉼표로 구분)</label>
                            <input id="tags-input" value="${(p.tags || []).join(', ')}">
                        </div>
                    </div>
                    <div class="is-template-toggle">
                        <input type="checkbox" id="is-template-checkbox" ${p.isTemplate ? 'checked' : ''}>
                        <label for="is-template-checkbox">✨ 재사용 가능한 템플릿으로 만들기</label>
                    </div>
                    ${!isNew ? `
                    <button id="view-versions-btn" class="button-like" style="margin-top: 20px;"><i class="fa-solid fa-history"></i> 버전 기록 보기</button>
                    <div id="versions-history" style="margin-top: 20px; border: 1px solid var(--border-color); padding: 15px; border-radius: 8px; display:none;">
                        <h3>버전 기록</h3>
                        <ul id="versions-list" style="list-style: none; padding: 0;"></ul>
                    </div>
                    ` : ''}
                `;
                // 폴더 드롭다운의 선택된 값 설정 (렌더링 후)
                if (p.folderId) document.getElementById('folder-select').value = p.folderId;

                // 새 항목일 경우 save-prompt-btn에서 data-id 속성 제거
                if (isNew) {
                    const saveBtnElement = document.getElementById('save-prompt-btn');
                    if (saveBtnElement) {
                        saveBtnElement.removeAttribute('data-id');
                    }
                }

                // 파일 업로드 관련 요소 참조
                const largeTextFile = document.getElementById('large-text-file');
                const loadTextBtn = document.getElementById('load-text-btn');
                const loadedFileNameSpan = document.getElementById('loaded-file-name');
                const contentInput = document.getElementById('content-input');
                const contentSizeWarning = document.getElementById('content-size-warning');

                // 파일 불러오기 버튼 클릭 시 파일 입력 요소 트리거
                loadTextBtn.onclick = () => {
                    largeTextFile.click();
                };

                /**
                 * 파일을 읽어 텍스트 영역에 로드하고, 특정 파일 타입에 대해 이스케이프 처리합니다.
                 * @param {File} file - 로드할 파일 객체.
                 * @param {HTMLTextAreaElement} targetTextarea - 텍스트를 로드할 대상 텍스트 영역.
                 * @param {HTMLElement} [fileNameSpan=null] - 파일 이름을 표시할 span 요소 (선택 사항).
                 * @returns {Promise<boolean>} 파일 처리 성공 여부.
                 */
                const handleFileLoad = async (file, targetTextarea, fileNameSpan = null) => {
                    if (!file) {
                        if (fileNameSpan) fileNameSpan.textContent = '';
                        return;
                    }

                    const MAX_FILE_SIZE_MB = 5; // 5 MB 제한
                    if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                        helpers.showToast(`파일 용량이 너무 큽니다. (${MAX_FILE_SIZE_MB}MB 이하로 업로드해주세요.)`);
                        if (fileNameSpan) fileNameSpan.textContent = '';
                        return false; // 파일 처리 실패
                    }

                    if (fileNameSpan) fileNameSpan.textContent = file.name;
                    try {
                        let raw = await file.text();
                        let processedText = raw;

                        // HTML 파일인 경우 태그 이스케이프
                        if (file.name.match(/\.(html?|htm)$/i)) {
                            processedText = raw.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                            helpers.showToast('HTML 파일이 이스케이프되어 불러와졌습니다.');
                        } else if (file.name.match(/\.(json|yaml|yml)$/i)) {
                            // JSON/YAML 등은 prettier 라이브러리로 포맷팅 가능 (여기서는 구현 생략)
                            // processedText = prettier.format(raw, { parser: "json" });
                            helpers.showToast('파일 내용이 불러와졌습니다.');
                        } else {
                            helpers.showToast('파일 내용이 불러와졌습니다.');
                        }

                        targetTextarea.value = processedText;
                        // Only check content size warning for the main editor
                        if (targetTextarea.id === 'content-input') {
                            checkContentSizeWarning(); 
                        }
                        return true; // 파일 처리 성공
                    } catch (error) {
                        console.error("파일 읽기 오류:", error);
                        helpers.showToast('파일을 읽는 중 오류가 발생했습니다.');
                        return false; // 파일 처리 실패
                    }
                };

                // 파일 선택 시 내용 읽어오기 (refactored to use handleFileLoad)
                largeTextFile.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        await handleFileLoad(file, contentInput, loadedFileNameSpan);
                    }
                    e.target.value = ''; // 파일 입력 초기화 (동일 파일 재선택 가능하게)
                };

                // 드래그 앤 드롭 지원
                contentInput.addEventListener('dragover', e => {
                    e.preventDefault(); // 기본 동작 방지 (파일 열림 방지)
                    e.dataTransfer.dropEffect = 'copy'; // 드롭 시 복사 효과 표시
                });

                contentInput.addEventListener('drop', async e => {
                    e.preventDefault(); // 기본 동작 방지
                    const file = e.dataTransfer.files[0];
                    if (file) {
                        await handleFileLoad(file, contentInput, loadedFileNameSpan);
                    }
                });

                // 내용 입력 시 길이 경고 체크
                const checkContentSizeWarning = () => {
                    const contentByteLength = new TextEncoder().encode(contentInput.value).length;
                    const FIREBASE_DOC_LIMIT_BYTES = 1000 * 1024; // 약 1MB (Firestore 문서 제한)
                    const WARNING_THRESHOLD_BYTES = 900 * 1024; // 900KB 이상일 때 경고

                    if (contentByteLength > WARNING_THRESHOLD_BYTES) {
                        contentSizeWarning.style.display = 'block';
                    } else {
                        contentSizeWarning.style.display = 'none';
                    }
                };
                contentInput.addEventListener('input', checkContentSizeWarning);
                // 초기 로드 시에도 경고 체크
                checkContentSizeWarning();


                // 버전 기록 버튼 및 리스너 추가
                const viewVersionsBtn = document.getElementById('view-versions-btn');
                const versionsHistoryDiv = document.getElementById('versions-history');
                const versionsList = document.getElementById('versions-list');
                
                if (viewVersionsBtn) {
                    viewVersionsBtn.addEventListener('click', async () => {
                        if (versionsHistoryDiv.style.display === 'none') {
                            versionsHistoryDiv.style.display = 'block';
                            const versions = await dbService.getPromptVersions(id);
                            if (versions.length === 0) {
                                versionsList.innerHTML = '<li>저장된 버전이 없습니다.</li>';
                            } else {
                                versionsList.innerHTML = versions.map(v => `
                                    <li style="padding: 8px 0; border-bottom: 1px dashed var(--border-color);">
                                        <strong>${v.timestamp.toLocaleString()}</strong>: ${v.memo || '메모 없음'}
                                        <button data-version-id="${v.id}" class="restore-version-btn button-like" style="margin-left: 10px;">복원</button>
                                        <button data-version-id="${v.id}" class="delete-version-btn button-like" style="margin-left: 5px; color: var(--accent-pink); border-color: var(--accent-pink);">삭제</button>
                                    </li>
                                `).join('');
                            }
                        } else {
                            versionsHistoryDiv.style.display = 'none';
                        }
                    });

                    // 버전 복원 및 삭제 이벤트 리스너 (위임)
                    versionsList.addEventListener('click', async (e) => {
                        const versionId = parseInt(e.target.dataset.versionId, 10);
                        if (e.target.classList.contains('restore-version-btn')) {
                            const confirmed = await helpers.showConfirm('이 버전으로 프롬프트를 복원하시겠습니까? 현재 내용은 덮어씌워집니다.');
                            if (confirmed) {
                                const versions = await dbService.getPromptVersions(id);
                                const versionToRestore = versions.find(v => v.id === versionId);
                                if (versionToRestore) {
                                    document.getElementById('content-input').value = versionToRestore.content;
                                    helpers.showToast('버전이 복원되었습니다. 저장을 눌러 적용하세요.');
                                    checkContentSizeWarning(); // 복원 후 내용 길이 경고 업데이트
                                }
                            }
                        } else if (e.target.classList.contains('delete-version-btn')) {
                            const confirmed = await helpers.showConfirm('이 버전을 삭제하시겠습니까?');
                            if (confirmed) {
                                await deleteFromIndexedDB(CACHE_STORE_VERSIONS, versionId);
                                helpers.showToast('버전이 삭제되었습니다.');
                                viewVersionsBtn.click(); // 히스토리 새로고침 (토글 닫고 다시 열기)
                                viewVersionsBtn.click();
                            }
                        }
                    });
                }
            },
            /**
             * 템플릿 사용 모달을 렌더링하고 사용자 입력을 처리합니다.
             * @param {string} id - 사용할 템플릿 프롬프트의 ID.
             * @param {Function} [onCompleteCallback=null] - 템플릿 처리 완료 후 호출될 콜백 함수 (주로 시퀀스 실행 시 사용).
             * @returns {Promise<{inputs: NodeListOf<HTMLTextAreaElement>, preview: HTMLElement, updatePreview: Function}>} 모달 요소 및 프리뷰 업데이트 함수.
             */
            templateModal: async (id, onCompleteCallback = null) => {
                const p = await dbService.getById('prompts', id);
                if (!p) {
                    helpers.showToast('템플릿을 찾을 수 없습니다!');
                    if (onCompleteCallback) onCompleteCallback(true); // 오류 발생 시 시퀀스 종료 신호
                    return Promise.reject(new Error('Template not found'));
                }
                // 템플릿 내용에서 플레이스홀더 추출
                // {{와 }} 사이에 개행 문자가 없는 경우에만 변수로 인식하도록 변경
                const placeholders = [...p.content.matchAll(/{{([^\n}]+?)}}/g)].map(match => match[1].trim()); 
                const uniquePlaceholders = [...new Set(placeholders)];
                                        
                ui.templateModal.title.textContent = `템플릿 사용: ${p.title}`;
                // Change input type="text" to textarea for multi-line input
                ui.templateModal.body.innerHTML = uniquePlaceholders.map(ph => `
                    <div class="form-group">
                        <label for="ph-${ph}">${ph.replace(/_/g, ' ')}</label>
                        <div class="template-input-with-file"> <textarea id="ph-${ph}" data-placeholder="${ph}" rows="1"></textarea> <input type="file" id="file-ph-${ph}" accept=".txt,.html,.htm,.md,.json,.csv,.xml,.yaml,.yml,.js,.css,text/*" style="display:none;">
                            <button class="button-like file-upload-icon-btn" data-target-ph="${ph}" title="파일에서 불러오기">
                                <i class="fa-solid fa-file-arrow-up"></i>
                            </button>
                        </div>
                    </div>`).join('') + `<div class="form-group"><label>미리보기</label><div class="modal-preview" id="template-preview">${p.content}</div></div>`;
                ui.templateModal.overlay.classList.add('show');
                                        
                // Promise를 반환하여 DOM이 준비된 후에 추가 작업을 할 수 있도록 함
                return new Promise(resolve => {
                    // DOM 요소가 완전히 렌더링될 때까지 약간의 지연을 줍니다.
                    setTimeout(() => {
                        const inputs = ui.templateModal.body.querySelectorAll('textarea[data-placeholder]');
                        const preview = document.getElementById('template-preview');
                        
                        /**
                         * 템플릿 미리보기를 업데이트합니다.
                         */
                        const updatePreview = () => {
                            let content = p.content;
                            inputs.forEach(input => {
                                const ph = `{{${input.dataset.placeholder}}}`;
                                const value = input.value;
                                content = content.replaceAll(ph, value || ph); // 입력 값이 없으면 플레이스홀더 유지
                            });
                            preview.textContent = content;
                        };

                        inputs.forEach(input => input.addEventListener('input', updatePreview));
                        updatePreview(); // 초기 미리보기 렌더링

                        /**
                         * 모달 내 파일 로드 및 처리 로직을 위한 헬퍼 함수.
                         * @param {File} file - 로드할 파일.
                         * @param {HTMLTextAreaElement} targetTextarea - 파일 내용을 로드할 텍스트 영역.
                         * @returns {Promise<boolean>} 파일 로드 성공 여부.
                         */
                        const handleModalFileLoad = async (file, targetTextarea) => {
                            if (!file) return;

                            const MAX_FILE_SIZE_MB = 5;
                            if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
                                helpers.showToast(`파일 용량이 너무 큽니다. (${MAX_FILE_SIZE_MB}MB 이하로 업로드해주세요.)`);
                                return false;
                            }

                            try {
                                let raw = await file.text();
                                let processedText = raw;

                                if (file.name.match(/\.(html?|htm)$/i)) {
                                    processedText = raw.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                                    helpers.showToast('HTML 파일이 이스케이프되어 불러와졌습니다.');
                                } else if (file.name.match(/\.(json|yaml|yml)$/i)) {
                                    helpers.showToast('파일 내용이 불러와졌습니다.');
                                } else {
                                    helpers.showToast('파일 내용이 불러와졌습니다.');
                                }

                                targetTextarea.value = processedText;
                                updatePreview(); // Update the template preview after loading
                                return true;
                            } catch (error) {
                                console.error("파일 읽기 오류:", error);
                                helpers.showToast('파일을 읽는 중 오류가 발생했습니다.');
                                return false;
                            }
                        };

                        const fileInputButtons = ui.templateModal.body.querySelectorAll('.file-upload-icon-btn');
                        fileInputButtons.forEach(button => {
                            button.addEventListener('click', () => {
                                const targetPh = button.dataset.targetPh;
                                const fileInput = document.getElementById(`file-ph-${targetPh}`);
                                fileInput.click();
                            });
                        });

                        inputs.forEach(textarea => {
                            const ph = textarea.dataset.placeholder;
                            const fileInput = document.getElementById(`file-ph-${ph}`);

                            // File input change listener
                            fileInput.addEventListener('change', async (e) => {
                                const file = e.target.files[0];
                                if (file) {
                                    await handleModalFileLoad(file, textarea);
                                }
                                e.target.value = ''; // Clear file input
                            });

                            // Drag and drop listeners for each textarea in the modal
                            textarea.addEventListener('dragover', e => {
                                e.preventDefault();
                                e.dataTransfer.dropEffect = 'copy';
                            });

                            textarea.addEventListener('drop', async e => {
                                e.preventDefault();
                                const file = e.dataTransfer.files[0];
                                if (file) {
                                    await handleModalFileLoad(file, textarea);
                                }
                            });
                        });


                        // '생성 및 복사' 버튼 클릭 이벤트
                        ui.templateModal.generateBtn.onclick = async () => {
                            const textToCopy = preview.textContent;
                            const variablesUsed = {}; // 사용된 변수 값들을 저장할 객체
                            inputs.forEach(input => {
                                variablesUsed[input.dataset.placeholder] = input.value;
                            });

                            try {
                                const textarea = document.createElement('textarea');
                                textarea.value = textToCopy;
                                document.body.appendChild(textarea);
                                textarea.select();
                                document.execCommand('copy');
                                document.body.removeChild(textarea);

                                helpers.showToast('템플릿이 생성되어 클립보드에 복사되었습니다!');
                                
                                // 사용 빈도 증가 및 사용 기록 저장
                                if (p.id) {
                                    const currentUsageCount = p.usageCount || 0;
                                    await dbService.update('prompts', p.id, { usageCount: currentUsageCount + 1, updatedAt: serverTimestamp() });
                                    render.prompts(true); // 목록 새로고침 (캐시 강제 업데이트)
                                    // 사용 기록에 generatedContent와 variablesUsed를 함께 저장
                                    helpers.logUsage('template_generate', p.id, p.title, textToCopy, variablesUsed); 
                                }

                                // 콜백 함수가 있으면 호출 (시퀀스 실행 중인 경우)
                                if (onCompleteCallback) {
                                    onCompleteCallback(); // 다음 프롬프트 실행을 알림
                                }
                                // 모달은 자동으로 닫지 않음 (사용자가 수동으로 닫도록 변경)

                            } catch (err) {
                                console.error('텍스트 복사 실패: ', err);
                                helpers.showToast('복사 실패. 다시 시도해 주세요.');
                                if (onCompleteCallback) onCompleteCallback(true); // 오류 발생 시 시퀀스 종료 신호
                            }
                        };

                        // 모달 닫기 버튼 클릭 시 시퀀스 중단
                        ui.templateModal.closeBtn.onclick = () => {
                            ui.templateModal.overlay.classList.remove('show');
                            if (onCompleteCallback) onCompleteCallback(true); // 시퀀스 중단 신호
                        };

                        resolve({ inputs, preview, updatePreview }); // 모달이 렌더링된 후 필요한 요소 반환
                    }, 50); // 작은 지연
                });
            },
            /**
             * 시퀀스 편집기 모달을 렌더링합니다.
             * @param {string|null} id - 편집할 시퀀스의 ID (새 항목인 경우 null).
             */
            sequenceEditor: async (id) => {
                const isNew = id === null;
                let s = { name: '', description: '', promptIds: [] };
                if (!isNew) {
                    const fetchedSequence = await dbService.getById('sequences', id);
                    if (fetchedSequence) {
                        s = fetchedSequence;
                    } else {
                        helpers.showToast('시퀀스를 찾을 수 없습니다!');
                        render.sequences();
                        return;
                    }
                }
                
                // 모든 프롬프트 가져와서 선택 옵션으로 제공
                const allPrompts = await dbService.getAll('prompts');
                state.prompts = allPrompts; // 전역 state.prompts 업데이트 (시퀀스 미리보기에서 사용)

                ui.sequenceModal.title.textContent = isNew ? '새 시퀀스 생성' : `시퀀스 편집: ${s.name}`;
                ui.sequenceModal.body.innerHTML = `
                    <div class="form-group">
                        <label for="sequence-name-input">시퀀스 이름</label>
                        <input type="text" id="sequence-name-input" value="${s.name || ''}">
                    </div>
                    <div class="form-group">
                        <label for="sequence-description-input">설명</label>
                        <textarea id="sequence-description-input">${s.description || ''}</textarea>
                    </div>
                    <div class="form-group">
                        <label for="sequence-prompts-select">시퀀스에 포함할 프롬프트 선택 (Ctrl/Cmd 클릭으로 다중 선택)</label>
                        <select id="sequence-prompts-select" multiple size="10">
                            ${allPrompts.map(p => `<option value="${p.id}">${p.title}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group">
                        <label>시퀀스 순서 조정 (선택된 프롬프트를 드래그하여 순서를 변경하세요.)</label>
                        <div id="sequence-sortable-list" class="sequence-sortable-list">
                            </div>
                    </div>
                `;
                ui.sequenceModal.overlay.classList.add('show');

                // 저장/실행/삭제 버튼 데이터-ID 설정
                ui.sequenceModal.saveBtn.dataset.id = isNew ? '' : id;
                ui.sequenceModal.runBtn.dataset.id = isNew ? '' : id;
                ui.sequenceModal.deleteBtn.dataset.id = isNew ? '' : id;
                ui.sequenceModal.deleteBtn.style.display = isNew ? 'none' : 'inline-block';

                const sequencePromptsSelect = document.getElementById('sequence-prompts-select');
                const sequenceSortableList = document.getElementById('sequence-sortable-list');

                // Sortable.js 인스턴스 초기화 (기존 인스턴스 파괴 후 재생성)
                if (sequenceSortableInstance) {
                    sequenceSortableInstance.destroy();
                }
                Sortable.create(sequenceSortableList, {
                    animation: 150,
                    ghostClass: 'sortable-ghost', // 드래그 시 고스트 클래스
                    handle: '.drag-handle' // 드래그 핸들 지정
                });

                // 초기 선택된 프롬프트들을 Sortable 리스트에 추가하고 select 박스도 선택 상태로 만듦
                s.promptIds.forEach(promptId => {
                    const prompt = allPrompts.find(p => p.id === promptId);
                    if (prompt) {
                        const item = document.createElement('div');
                        item.classList.add('sequence-sortable-item');
                        item.dataset.promptId = prompt.id;
                        item.innerHTML = `
                            <i class="fa-solid fa-grip-vertical drag-handle"></i>
                            <span>${prompt.title}</span>
                            <button class="remove-from-sequence-btn button-like"><i class="fa-solid fa-times"></i></button>
                        `;
                        sequenceSortableList.appendChild(item);
                        // select 박스에서도 해당 옵션을 선택 상태로 만듦
                        const option = sequencePromptsSelect.querySelector(`option[value="${prompt.id}"]`);
                        if (option) {
                            option.selected = true;
                        }
                    }
                });

                // select 박스에서 프롬프트 선택/해제 시 Sortable 리스트 업데이트
                sequencePromptsSelect.addEventListener('change', () => {
                    const currentSortableIds = Array.from(sequenceSortableList.children).map(item => item.dataset.promptId);
                    const selectedIds = Array.from(sequencePromptsSelect.selectedOptions).map(opt => opt.value);

                    // 새로 추가된 항목 (select에서 선택되었지만 sortable list에 없는 경우)
                    selectedIds.forEach(id => {
                        if (!currentSortableIds.includes(id)) {
                            const prompt = allPrompts.find(p => p.id === id);
                            if (prompt) {
                                const item = document.createElement('div');
                                item.classList.add('sequence-sortable-item');
                                item.dataset.promptId = prompt.id;
                                item.innerHTML = `
                                    <i class="fa-solid fa-grip-vertical drag-handle"></i>
                                    <span>${prompt.title}</span>
                                    <button class="remove-from-sequence-btn button-like"><i class="fa-solid fa-times"></i></button>
                                `;
                                sequenceSortableList.appendChild(item);
                            }
                        }
                    });

                    // 제거된 항목 (sortable list에 있지만 select에서 선택 해제된 경우)
                    currentSortableIds.forEach(id => {
                        if (!selectedIds.includes(id)) {
                            const itemToRemove = sequenceSortableList.querySelector(`[data-prompt-id="${id}"]`);
                            if (itemToRemove) {
                                itemToRemove.remove();
                            }
                        }
                    });
                });

                // Sortable 리스트에서 항목 제거 버튼 이벤트 (위임)
                sequenceSortableList.addEventListener('click', (e) => {
                    if (e.target.closest('.remove-from-sequence-btn')) {
                        const item = e.target.closest('.sequence-sortable-item');
                        const promptIdToRemove = item.dataset.promptId;
                        item.remove();
                        // select 박스에서도 선택 해제
                        const optionToDeselect = sequencePromptsSelect.querySelector(`option[value="${promptIdToRemove}"]`);
                        if (optionToDeselect) {
                            optionToDeselect.selected = false;
                        }
                    }
                });
            },
            /**
             * 사용 기록 페이지를 렌더링합니다.
             */
            usageHistory: async () => {
                ui.mainHeader.textContent = '사용 기록';
                const history = await getFromIndexedDB(CACHE_STORE_USAGE_HISTORY);
                history.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime()); // 최신순 정렬

                if (history.length === 0) {
                    ui.contentView.innerHTML = `<div class="content-placeholder">사용 기록이 없습니다.</div>`;
                    return;
                }

                ui.contentView.innerHTML = `
                    <div class="usage-history-list">
                        ${history.map(record => `
                            <div class="usage-history-item" data-record-id="${record.id}" data-record-type="${record.type}">
                                <div class="usage-history-header">
                                    <span class="usage-history-type">${record.type === 'prompt_copy' ? '프롬프트 복사' : record.type === 'template_generate' ? '템플릿 생성' : '시퀀스 실행'}</span>
                                    <span class="usage-history-time">${record.timestamp.toLocaleString()}</span>
                                </div>
                                <div class="usage-history-details">
                                    <strong>${record.itemName}</strong>
                                    ${record.contentSnippet ? `<p class="usage-history-snippet">${record.contentSnippet.trim()}...</p>` : ''}
                                </div>
                                <div class="usage-history-actions">
                                    <button class="reuse-history-btn button-like">
                                        <i class="fa-solid fa-redo"></i> 재사용
                                    </button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
        };

        // =================================================================
        // 이벤트 핸들러 (Event Handlers)
        // =================================================================
        const handlers = {
            /**
             * 사이드바 메뉴 항목 클릭 이벤트 처리.
             * @param {Event} e - 클릭 이벤트 객체.
             */
            sidebar: (e) => {
                const target = e.target.closest('.nav-item');
                if (!target) return;
                // 현재 활성화된 메뉴 항목 초기화
                document.querySelectorAll('.sidebar-nav .nav-item.active').forEach(el => el.classList.remove('active'));
                target.classList.add('active'); // 클릭된 항목 활성화
                                        
                const { filterType, folderId, seqId } = target.dataset;
                if (filterType === 'folder') {
                    const id = folderId;
                    state.currentFilter = { type: 'folder', id, name: state.folders.find(f => f.id === id)?.name || '알 수 없는 폴더' };
                    render.prompts();
                } else if (filterType === 'sequence') {
                    const id = seqId;
                    state.currentFilter = { type: 'sequence', id, name: state.sequences.find(s => s.id === id)?.name || '알 수 없는 시퀀스' };
                    // 시퀀스 클릭 시 시퀀스 편집기 바로 열기
                    render.sequenceEditor(id); 
                } else if (filterType === 'history') { // 사용 기록 메뉴 클릭 시
                    state.currentFilter = { type: 'history', id: null, name: '사용 기록' };
                    render.usageHistory();
                } else {
                    state.currentFilter = { type: filterType, id: null, name: target.textContent.trim() };
                    render.prompts(); // 프롬프트 목록 새로고침
                }
                // 모바일에서 사이드바 메뉴 클릭 시 사이드바 닫기
                if (window.innerWidth <= 768) {
                    ui.sidebar.classList.remove('open');
                    document.body.classList.remove('no-scroll'); // 사이드바 닫힐 때 스크롤 허용
                }
            },
            /**
             * 메인 콘텐츠 영역 클릭 이벤트 처리 (프롬프트 목록 항목, 버튼 등).
             * @param {Event} e - 클릭 이벤트 객체.
             */
            content: async (e) => {
                const promptItem = e.target.closest('.prompt-list-item');
                const historyItem = e.target.closest('.usage-history-item'); // 사용 기록 항목 추가
                
                if (promptItem) {
                    const promptId = promptItem.dataset.promptId;
                                            
                    if (e.target.closest('.edit-btn')) { // 편집 버튼 클릭
                        render.promptEditor(promptId);
                    } else if (e.target.closest('.use-btn')) { // 템플릿 사용 버튼 클릭
                        render.templateModal(promptId);
                    } else if (e.target.closest('.copy-btn')) { // 복사 버튼 클릭
                        const p = await dbService.getById('prompts', promptId);
                        if (p) {
                            // navigator.clipboard.writeText 대신 document.execCommand('copy') 사용
                            const textarea = document.createElement('textarea');
                            textarea.value = p.content;
                            document.body.appendChild(textarea);
                            textarea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textarea);
                            helpers.showToast('클립보드에 복사되었습니다!');
                            // 사용 기록 추가
                            helpers.logUsage('prompt_copy', p.id, p.title, p.content); 
                        }
                    } else if (e.target.closest('.visit-link-btn')) { // '방문' 링크 버튼 클릭
                        e.preventDefault(); // 기본 <a> 태그 동작 막기 (새 탭으로 열기 위해)
                        const p = await dbService.getById('prompts', promptId);
                        if (p && p.link) {
                            window.open(p.link, '_blank');
                            helpers.showToast('링크를 새 탭에서 엽니다.');
                        }
                    }
                    else if (e.target.closest('.fav-icon')) { // 즐겨찾기 아이콘 클릭
                        const p = await dbService.getById('prompts', promptId);
                        if (p) {
                            await dbService.update('prompts', promptId, { isFavorite: !p.isFavorite, updatedAt: serverTimestamp() });
                            helpers.showToast(!p.isFavorite ? '즐겨찾기에 추가되었습니다.' : '즐겨찾기에서 제거되었습니다.');
                            render.prompts(); // 즐겨찾기 상태 변경 후 목록 새로고침
                        }
                    } else if (promptItem) { // 프롬프트 목록 항목 자체 클릭 (편집 버튼이 아닌 경우)
                        // 항목 자체 클릭 시 링크가 있다면 링크로 이동, 없다면 편집 모드로
                        const p = await dbService.getById('prompts', promptId);
                        if (p && p.link) {
                            window.open(p.link, '_blank');
                            helpers.showToast('링크를 새 탭에서 엽니다.');
                        } else {
                            render.promptEditor(promptId);
                        }
                    }
                } else if (historyItem) { // 사용 기록 항목 클릭
                    if (e.target.closest('.reuse-history-btn')) { // 재사용 버튼 클릭
                        const recordId = parseInt(historyItem.dataset.recordId, 10);
                        const recordType = historyItem.dataset.recordType;
                        const historyRecord = await getFromIndexedDB(CACHE_STORE_USAGE_HISTORY, null, recordId); // 특정 recordId로 단일 항목 가져오기
                        const record = historyRecord[0]; // getAll이 배열을 반환하므로 첫 번째 요소 사용

                        if (!record) {
                            helpers.showToast('사용 기록을 찾을 수 없습니다.');
                            return;
                        }

                        if (record.type === 'prompt_copy') {
                            try {
                                const textarea = document.createElement('textarea');
                                textarea.value = record.content;
                                document.body.appendChild(textarea);
                                textarea.select();
                                document.execCommand('copy');
                                document.body.removeChild(textarea);
                                helpers.showToast('프롬프트가 클립보드에 복사되었습니다!');
                            } catch (err) {
                                console.error('텍스트 복사 실패: ', err);
                                helpers.showToast('복사 실패. 다시 시도해 주세요.');
                            }
                        } else if (record.type === 'template_generate') {
                            const originalTemplate = await dbService.getById('prompts', record.itemId);
                            if (!originalTemplate) {
                                helpers.showToast('원본 템플릿을 찾을 수 없습니다. (삭제되었을 수 있습니다.)');
                                return;
                            }
                            
                            // 템플릿 모달을 열고, 모달이 완전히 렌더링된 후에 변수를 채웁니다.
                            const { inputs, preview, updatePreview } = await render.templateModal(originalTemplate.id);

                            if (record.variablesUsed) {
                                for (const placeholder in record.variablesUsed) {
                                    const value = record.variablesUsed[placeholder];
                                    // querySelector를 사용하여 데이터-플레이스홀더 속성으로 요소를 찾음
                                    const inputElement = ui.templateModal.body.querySelector(`textarea[data-placeholder="${placeholder}"]`);
                                    if (inputElement) {
                                        inputElement.value = value;
                                    }
                                }
                                updatePreview(); // 변수 채운 후 미리보기 업데이트
                            }
                            helpers.showToast('템플릿이 미리 채워져 모달에 로드되었습니다!');
                        }
                    }
                }
            },
            /**
             * 편집기 화면 내 버튼 클릭 이벤트 처리 (저장, 삭제).
             * @param {Event} e - 클릭 이벤트 객체.
             */
            editor: async (e) => {
                const saveBtn = e.target.closest('.save-btn');
                const deleteBtn = e.target.closest('.delete-btn');

                if (saveBtn) { // 저장 버튼 클릭
                    const idFromDataset = saveBtn.dataset.id;
                    // id가 undefined, null, 빈 문자열, 또는 "null" 문자열인 경우 null로 처리하여 새 문서 생성을 유도
                    const id = (typeof idFromDataset === 'string' && idFromDataset.trim().length > 0 && idFromDataset !== 'null') ? idFromDataset : null; 
                    
                    const tags = document.getElementById('tags-input').value.split(',').map(t => t.trim()).filter(Boolean);
                    const currentContent = document.getElementById('content-input').value; // 버전 저장을 위해 현재 내용 가져옴
                    const link = document.getElementById('link-input').value.trim(); // 링크 필드 값 가져오기
                    
                    // Firestore 문서 크기 제한 (1MB) 경고
                    const contentByteLength = new TextEncoder().encode(currentContent).length;
                    const FIREBASE_DOC_LIMIT_BYTES = 1000 * 1024; // Approx 1MB
                    if (contentByteLength > FIREBASE_DOC_LIMIT_BYTES) {
                        helpers.showToast('오류: 내용이 너무 길어 저장할 수 없습니다. (Firestore 문서 제한 1MB 초과)');
                        return; // 저장 중단
                    }

                    // isFavorite과 usageCount를 기존 값으로 유지
                    let existingPromptData = { isFavorite: false, usageCount: 0 };
                    if (id) {
                        const existingPrompt = await dbService.getById('prompts', id);
                        if (existingPrompt) {
                            existingPromptData.isFavorite = existingPrompt.isFavorite !== undefined ? existingPrompt.isFavorite : false;
                            existingPromptData.usageCount = existingPrompt.usageCount !== undefined ? existingPrompt.usageCount : 0;
                        }
                    }

                    let data = {
                        title: document.getElementById('title-input').value,
                        content: currentContent,
                        folderId: document.getElementById('folder-select').value || null,
                        tags: tags,
                        isTemplate: document.getElementById('is-template-checkbox').checked,
                        link: link, 
                        isFavorite: existingPromptData.isFavorite, // 기존 값 유지
                        usageCount: existingPromptData.usageCount // 기존 값 유지
                    };
                                                
                    try {
                        const savedId = await dbService.put('prompts', { id: id, ...data }); // id를 명시적으로 전달
                        helpers.showToast(id ? '항목이 업데이트되었습니다!' : '항목이 저장되었습니다!');

                        // 프롬프트 버전 관리: 자동 저장 및 히스토리
                        if (savedId) {
                            const memo = prompt('이 버전에 대한 메모를 남겨주세요 (선택 사항):');
                            await dbService.savePromptVersion(savedId, currentContent, memo || '');
                        }

                    } catch (error) {
                        console.error("항목 저장 오류:", error);
                        helpers.showToast('항목 저장 오류: ' + error.message);
                        //throw error; // 에러를 다시 던져서 상위 핸들러에서 처리하도록 할 수 있음
                    }

                    await render.folders(); // 폴더 목록 새로고침 (폴더 변경 가능성)
                    state.currentFilter = { type: 'all', id: null, name: '모든 항목' }; // 모든 항목 뷰로 돌아감
                    await render.prompts(true); // 프롬프트 목록 새로고침 (캐시 강제 업데이트)
                }

                if (deleteBtn) { // 삭제 버튼 클릭
                    const id = deleteBtn.dataset.id;
                    const confirmed = await helpers.showConfirm('이 항목을 영구적으로 삭제하시겠습니까?');
                    if (confirmed) {
                        try {
                            await dbService.delete('prompts', id);
                            helpers.showToast('항목이 삭제되었습니다.');
                        } catch (error) {
                            console.error("항목 삭제 오류:", error);
                            helpers.showToast('항목 삭제 오류: ' + error.message);
                        }
                        state.currentFilter = { type: 'all', id: null, name: '모든 항목' }; // 모든 항목 뷰로 돌아감
                        await render.prompts(true); // 프롬프트 목록 새로고침 (캐시 강제 업데이트)
                    }
                }
            }
        };

        // =================================================================
        // 헬퍼 함수 (Helper Functions)
        // =================================================================
        const helpers = {
            /**
             * 사용자에게 짧은 토스트 알림 메시지를 표시합니다.
             * @param {string} msg - 표시할 메시지.
             */
            showToast: (msg) => {
                ui.toast.textContent = msg;
                ui.toast.classList.add('show');
                setTimeout(() => ui.toast.classList.remove('show'), 3000);
            },
            /**
             * 시퀀스 실행을 중단하고 상태를 초기화합니다.
             */
            resetSequenceExecution: () => {
                activeSequencePrompts = [];
                currentSequencePromptIndex = -1;
                ui.templateModal.overlay.classList.remove('show'); // 혹시 열려있는 템플릿 모달 닫기
                helpers.showToast('시퀀스 실행이 종료되었습니다.');
            },
            /**
             * 사용자에게 사용자 정의 확인 대화 상자를 표시합니다.
             * @param {string} message - 확인 메시지.
             * @returns {Promise<boolean>} 사용자가 '확인'을 클릭하면 true, '취소'를 클릭하면 false.
             */
            showConfirm: (message) => {
                return new Promise(resolve => {
                    const modalOverlay = document.createElement('div');
                    modalOverlay.classList.add('modal-overlay', 'show');
                    modalOverlay.innerHTML = `
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3>확인</h3>
                                <button class="close-btn">&times;</button>
                            </div>
                            <div class="modal-body">
                                <p>${message}</p>
                            </div>
                            <div class="modal-footer">
                                <button id="confirm-cancel-btn" class="button-like">취소</button>
                                <button id="confirm-ok-btn" class="generate-btn">확인</button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(modalOverlay);

                    const closeAndResolve = (result) => {
                        modalOverlay.classList.remove('show');
                        modalOverlay.addEventListener('transitionend', () => modalOverlay.remove(), { once: true });
                        resolve(result);
                    };

                    modalOverlay.querySelector('.close-btn').onclick = () => closeAndResolve(false);
                    modalOverlay.querySelector('#confirm-cancel-btn').onclick = () => closeAndResolve(false);
                    modalOverlay.querySelector('#confirm-ok-btn').onclick = () => closeAndResolve(true);
                    modalOverlay.onclick = (e) => {
                        if (e.target === modalOverlay) {
                            closeAndResolve(false);
                        }
                    };
                });
            },
            /**
             * 사용 기록을 IndexedDB에 저장하고 최신 20개 기록만 유지합니다.
             * @param {'prompt_copy'|'template_generate'|'sequence_run'} type - 사용 기록의 타입.
             * @param {string} itemId - 관련된 프롬프트 또는 시퀀스의 ID.
             * @param {string} itemName - 관련된 프롬프트 또는 시퀀스의 이름.
             * @param {string} [content=''] - 프롬프트 내용 또는 생성된 내용 (스니펫용).
             * @param {Object} [variablesUsed=null] - 템플릿 사용 시 채워진 변수들.
             * @returns {Promise<void>}
             */
            logUsage: async (type, itemId, itemName, content = '', variablesUsed = null) => {
                if (!indexedDbInstance) await openIndexedDB();
                const record = {
                    type,
                    itemId, // promptId or sequenceId
                    itemName,
                    timestamp: new Date(),
                    content: content, // 전체 내용 저장 (재사용 시 필요)
                    contentSnippet: content.substring(0, 100), // 내용 스니펫을 최대 100자로 제한 (표시용)
                    variablesUsed: variablesUsed // 템플릿 사용 시 채워진 변수들
                };
                await putIntoIndexedDB(CACHE_STORE_USAGE_HISTORY, record);

                // 최신 20개 기록만 유지
                const allRecords = await getFromIndexedDB(CACHE_STORE_USAGE_HISTORY);
                if (allRecords.length > 20) {
                    const sortedRecords = allRecords.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
                    for (let i = 20; i < sortedRecords.length; i++) {
                        await deleteFromIndexedDB(CACHE_STORE_USAGE_HISTORY, sortedRecords[i].id);
                    }
                }
            }
        };

        // =================================================================
        // Fuse.js 검색 인덱스 빌드
        // =================================================================
        /**
         * Fuse.js 검색 인덱스를 빌드합니다.
         */
        async function buildSearchIndex() {
            const data = await dbService.getAll('prompts'); // 모든 프롬프트 가져오기
            fuse = new Fuse(data, { 
                keys: ['title', 'content', 'tags'], 
                includeScore: true, 
                threshold: 0.3 // 오타 허용 범위 (0.0 = 정확 일치, 1.0 = 모든 항목)
            });
            console.log("Fuse.js 검색 인덱스 빌드 완료.");
        }

        // =================================================================
        // 시퀀스 실행 로직
        // =================================================================

        /**
         * 시퀀스의 다음 프롬프트를 실행합니다.
         * @param {boolean} [forceStop=false] - 시퀀스 실행을 강제로 중단할지 여부.
         */
        async function executeNextPromptInSequence(forceStop = false) {
            if (forceStop || currentSequencePromptIndex >= activeSequencePrompts.length) {
                // 시퀀스 종료 또는 강제 중단
                helpers.resetSequenceExecution();
                return;
            }

            const currentPrompt = activeSequencePrompts[currentSequencePromptIndex];

            // 템플릿 프롬프트인 경우 템플릿 모달 사용
            if (currentPrompt.isTemplate) {
                render.templateModal(currentPrompt.id, (isErrorOrCanceled) => {
                    if (isErrorOrCanceled) {
                        helpers.resetSequenceExecution(); // 모달에서 취소 또는 오류 발생 시 시퀀스 중단
                    } else {
                        currentSequencePromptIndex++;
                        executeNextPromptInSequence(); // 다음 프롬프트 실행
                    }
                });
            } else {
                // 일반 프롬프트인 경우 즉시 클립보드에 복사
                try {
                    const textarea = document.createElement('textarea');
                    textarea.value = currentPrompt.content;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    helpers.showToast(`'${currentPrompt.title}' 프롬프트가 클립보드에 복사되었습니다!`);
                    // 사용 기록 추가
                    helpers.logUsage('prompt_copy', currentPrompt.id, currentPrompt.title, currentPrompt.content); 
                } catch (err) {
                    console.error('텍스트 복사 실패: ', err);
                    helpers.showToast(`'${currentPrompt.title}' 복사 실패. 시퀀스를 중단합니다.`);
                    helpers.resetSequenceExecution();
                    return;
                }

                currentSequencePromptIndex++;
                // 다음 프롬프트로 넘어가기 전 짧은 딜레이 (사용자가 토스트 메시지를 볼 수 있도록)
                setTimeout(() => {
                    executeNextPromptInSequence();
                }, 1000); // 1초 딜레이
            }
        }

        /**
         * 시퀀스 실행을 시작합니다.
         * @param {string} sequenceId - 실행할 시퀀스의 ID.
         */
        async function startSequenceExecution(sequenceId) {
            const sequence = await dbService.getById('sequences', sequenceId);
            if (!sequence || !sequence.promptIds || sequence.promptIds.length === 0) {
                helpers.showToast('실행할 프롬프트가 없는 시퀀스입니다.');
                return;
            }

            // 시퀀스에 포함된 프롬프트 객체들을 순서대로 가져와 activeSequencePrompts에 저장
            activeSequencePrompts = [];
            for (const promptId of sequence.promptIds) {
                const prompt = state.prompts.find(p => p.id === promptId); // 캐시된 state.prompts에서 찾기
                if (prompt) {
                    activeSequencePrompts.push(prompt);
                } else {
                    helpers.showToast(`시퀀스에 포함된 프롬프트 (ID: ${promptId})를 찾을 수 없습니다. 시퀀스 실행을 중단합니다.`);
                    helpers.resetSequenceExecution();
                    return;
                }
            }

            currentSequencePromptIndex = 0;
            ui.sequenceModal.overlay.classList.remove('show'); // 시퀀스 편집 모달 닫기
            helpers.showToast(`'${sequence.name}' 시퀀스를 시작합니다.`);
            // 사용 기록 추가
            helpers.logUsage('sequence_run', sequenceId, sequence.name); 
            executeNextPromptInSequence(); // 첫 번째 프롬프트 실행 시작
        }


        // =================================================================
        // 앱 초기화 및 인증 로직 (App Initialization and Authentication Logic)
        // =================================================================
        /**
         * 애플리케이션의 핵심 로직을 초기화합니다. IndexedDB 초기화, 데이터 로드, 이벤트 리스너 설정 등을 포함합니다.
         */
        async function initializeAppLogic() {            
            // IndexedDB 초기화
            await openIndexedDB();

            // UI 요소들을 먼저 보이게 설정 (데이터 로드 전에 빈 화면 방지)
            ui.sidebarContent.style.display = 'flex';            
            ui.sidebarContent.style.flexDirection = 'column';            
            ui.contentView.innerHTML = '<div class="content-placeholder">데이터를 불러오는 중...</div>'; // 로딩 메시지 표시
            
            // 데이터 로드 및 렌더링을 기다림
            await render.folders();            
            await render.sequences(); // 시퀀스 목록 렌더링
            await render.prompts();                          
            
            // Fuse.js 검색 인덱스 빌드 (데이터 로드 후)
            await buildSearchIndex();

            // Event Listeners after user is logged in
            ui.newPromptBtn.addEventListener('click', () => render.promptEditor(null));            
            ui.newFolderBtn.addEventListener('click', async () => {                
                const name = prompt('새 폴더 이름을 입력하세요:');                
                if (name?.trim()) {                    
                    try {                        
                        await dbService.put('folders', { name: name.trim() }); // createdAt, updatedAt은 put 함수에서 처리                        
                        await render.folders();                        
                        helpers.showToast('폴더가 생성되었습니다!');                    
                    } catch (error) {                        
                        console.error("폴더 생성 오류:", error);                        
                        helpers.showToast('폴더 생성 오류: ' + error.message);                    
                    }                
                }            
            });            
            ui.newSequenceBtn.addEventListener('click', () => render.sequenceEditor(null)); // 새 시퀀스 버튼 이벤트

            ui.libraryList.addEventListener('click', handlers.sidebar);            
            ui.folderList.addEventListener('click', handlers.sidebar);            
            ui.sequenceList.addEventListener('click', handlers.sidebar); // 시퀀스 목록 클릭 이벤트

            // 메인 콘텐츠 영역 클릭 이벤트는 재사용 버튼도 처리해야 하므로 위임 패턴을 유지
            ui.contentView.addEventListener('click', handlers.content); 
            // 편집기 내 버튼은 여전히 editor 핸들러 사용
            ui.contentView.addEventListener('click', handlers.editor);

            ui.searchInput.addEventListener('input', () => render.prompts()); // 검색 입력 시 프롬프트 목록 새로고침

            // 템플릿 모달 닫기 (자동 닫힘 방지 후 사용자가 수동으로 닫을 때)
            ui.templateModal.closeBtn.addEventListener('click', () => {
                ui.templateModal.overlay.classList.remove('show');
            });            
            ui.templateModal.overlay.addEventListener('click', e => { // 모달 외부 클릭 시 닫기
                if (e.target === ui.templateModal.overlay) { 
                    ui.templateModal.overlay.classList.remove('show');
                }
            });

            // 시퀀스 모달 이벤트 리스너
            ui.sequenceModal.closeBtn.addEventListener('click', () => ui.sequenceModal.overlay.classList.remove('show'));
            ui.sequenceModal.overlay.addEventListener('click', e => {
                if (e.target === ui.sequenceModal.overlay) {
                    ui.sequenceModal.overlay.classList.remove('show');
                }
            });
            ui.sequenceModal.saveBtn.addEventListener('click', async () => {
                const id = ui.sequenceModal.saveBtn.dataset.id || null;
                const name = document.getElementById('sequence-name-input').value;
                const description = document.getElementById('sequence-description-input').value;
                
                // Sortable.js 리스트에서 현재 순서대로 promptIds 가져오기
                const sequenceSortableList = document.getElementById('sequence-sortable-list');
                const promptIds = Array.from(sequenceSortableList.children).map(item => item.dataset.promptId);

                if (!name.trim()) {
                    helpers.showToast('시퀀스 이름을 입력해주세요.');
                    return;
                }

                const data = {
                    name: name.trim(),
                    description: description.trim(),
                    promptIds: promptIds, // 정렬된 ID 배열 저장
                };
                // createdAt, updatedAt은 put 함수에서 처리

                try {
                    await dbService.put('sequences', { id: id, ...data });
                    helpers.showToast(id ? '시퀀스가 업데이트되었습니다!' : '시퀀스가 저장되었습니다!');
                    ui.sequenceModal.overlay.classList.remove('show');
                    await render.sequences(); // 시퀀스 목록 새로고침
                } catch (error) {
                    console.error("시퀀스 저장 오류:", error);
                    helpers.showToast('시퀀스 저장 오류: ' + error.message);
                }
            });
            ui.sequenceModal.deleteBtn.addEventListener('click', async () => {
                const id = ui.sequenceModal.deleteBtn.dataset.id;
                const confirmed = await helpers.showConfirm('이 시퀀스를 영구적으로 삭제하시겠습니까?');
                if (confirmed) {
                    try {
                        await dbService.delete('sequences', id);
                        helpers.showToast('시퀀스가 삭제되었습니다.');
                        ui.sequenceModal.overlay.classList.remove('show');
                        await render.sequences();
                    } catch (error) {
                        console.error("시퀀스 삭제 오류:", error);
                        helpers.showToast('시퀀스 삭제 오류: ' + error.message);
                    }
                }
            });
            ui.sequenceModal.runBtn.addEventListener('click', async () => {
                const id = ui.sequenceModal.runBtn.dataset.id;
                startSequenceExecution(id); // 시퀀스 실행 시작
            });


            // 모바일 햄버거 메뉴 토글 버튼 이벤트 리스너
            ui.mobileMenuToggle.addEventListener('click', () => {
                ui.sidebar.classList.toggle('open');
                document.body.classList.toggle('no-scroll'); // 사이드바 열릴 때 스크롤 막기
            });

            // 사이드바 닫기 버튼 이벤트 리스너
            ui.sidebarCloseBtn.addEventListener('click', () => {
                ui.sidebar.classList.remove('open');
                document.body.classList.remove('no-scroll'); // 사이드바 닫힐 때 스크롤 허용
            });

            // 사이드바 외부 클릭 시 닫기 (모바일 햄버거 메뉴용)
            document.addEventListener('click', (e) => {
                // 사이드바가 열려 있고, 클릭된 요소가 사이드바 내부나 햄버거 메뉴 토글 버튼이 아닌 경우
                if (ui.sidebar.classList.contains('open') && !ui.sidebar.contains(e.target) && !ui.mobileMenuToggle.contains(e.target)) {
                    ui.sidebar.classList.remove('open');
                    document.body.classList.remove('no-scroll'); // 사이드바 닫힐 때 스크롤 허용
                }
            });


            // 데이터 내보내기/가져오기 버튼 추가 (설정 섹션이 없으므로 임시로 추가)
            const dataMgmtSection = document.createElement('div');
            dataMgmtSection.style = "padding: 16px; border-top: 1px solid var(--border-color); margin-top: 20px;";
            dataMgmtSection.innerHTML = `
                <h3 class="nav-section-title" style="padding: 0;">데이터 관리</h3>
                <button id="export-data-btn" class="button-like" style="width:100%; padding: 8px; margin-top: 10px; background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">데이터 내보내기</button>
                <input type="file" id="import-data-input" accept=".json" style="display: none;">
                <button id="import-data-btn" class="button-like" style="width:100%; padding: 8px; margin-top: 10px; background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">데이터 가져오기</button>
                <button id="refresh-data-btn" class="button-like" style="width:100%; padding: 8px; margin-top: 10px; background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 4px;">데이터 새로고침</button>
            `;
            ui.sidebarContent.appendChild(dataMgmtSection);

            document.getElementById('export-data-btn').addEventListener('click', dbService.exportData);
            document.getElementById('import-data-btn').addEventListener('click', () => {
                document.getElementById('import-data-input').click();
            });
            document.getElementById('import-data-input').addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    dbService.importData(e.target.files[0]);
                }
            });
            // 새로고침 버튼 이벤트 리스너 추가
            ui.refreshDataBtn.addEventListener('click', async () => {
                helpers.showToast('데이터를 새로고침합니다...');
                await render.folders(true); // 폴더 강제 새로고침
                await render.sequences(true); // 시퀀스 강제 새로고침
                await render.prompts(true); // 프롬프트 강제 새로고침
                helpers.showToast('데이터 새로고침 완료.');
            });

            // 전역 단축키 (N: 새 항목, F: 풀스크린 편집 토글)
            document.addEventListener('keydown', (e) => {
                if (e.key === 'n' && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) { // 'N' 키만 눌렸을 때
                    e.preventDefault();
                    ui.newPromptBtn.click();
                }
                if (e.key === 'f' && !e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey) { // 'F' 키만 눌렸을 때
                    e.preventDefault();
                    document.body.classList.toggle('fullscreen-editor-mode'); // body에 클래스 토글
                    document.body.classList.toggle('no-scroll'); // 풀스크린 모드 시 스크롤 막기
                    const editorArea = document.querySelector('.main-content .content-view');
                    if (editorArea) {
                        editorArea.classList.toggle('fullscreen-editor');
                        if (editorArea.classList.contains('fullscreen-editor')) {
                            helpers.showToast('풀스크린 편집 모드');
                        } else {
                            helpers.showToast('풀스크린 편집 모드 종료');
                        }
                    }
                }
            });
        }        

        // Firebase 인증 상태 변화 감지 옵저버
        onAuthStateChanged(auth, async user => { 
            if (user) {                
                currentUser = user;                
                ui.loginBtn.style.display = 'none';                // 로그인 버튼 숨김
                ui.userProfile.style.display = 'flex';               // 사용자 프로필 표시
                ui.userEmail.textContent = user.displayName || user.email; // 사용자 이름/이메일 표시
                ui.userPhoto.src = user.photoURL || `https://via.placeholder.com/32`; // 사용자 사진 표시 (없으면 플레이스홀더)
                await initializeAppLogic(); // 로그인 후 앱 기능 초기화 및 데이터 로드
            } else {                
                currentUser = null;                
                ui.loginBtn.style.display = 'block';                // 로그인 버튼 표시
                ui.userProfile.style.display = 'none';               // 사용자 프로필 숨김
                ui.sidebarContent.style.display = 'none';             // 로그인되지 않았을 때 사이드바 내용 숨김
                ui.contentView.innerHTML = '<div class="content-placeholder">프롬프트를 관리하려면 로그인해주세요.</div>'; // 로그인 유도 메시지
                ui.mainHeader.textContent = "환영합니다";               // 메인 헤더 텍스트 변경
            }        
        });        

        // 로그인 버튼 이벤트 리스너
        ui.loginBtn.addEventListener('click', () => {            
            const provider = new GoogleAuthProvider();            
            signInWithPopup(auth, provider).catch(error => {                
                console.error("로그인 실패:", error);                
                helpers.showToast("로그인에 실패했습니다. 자세한 내용은 콘솔을 확인해주세요.");
            });        
        });        

        // 로그아웃 버튼 이벤트 리스너
        ui.logoutBtn.addEventListener('click', () => {            
            signOut(auth);        
        });    
    </script>    
    <style>        
        /* 기본 스타일 및 변수 정의 */
        :root{--bg-primary:#131314;--bg-secondary:#1e1f20;--bg-tertiary:#2d2e30;--bg-hover:#3c4043;--text-primary:#e2e2e3;--text-secondary:#bdc1c6;--accent-blue:#8ab4f8;--accent-yellow:#fdd663;--accent-pink:#f28b82;--border-color:#3c4043;--sidebar-width:280px;--header-height:64px}        
        *{margin:0;padding:0;box-sizing:border-box}        
        body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;background-color:var(--bg-primary);color:var(--text-primary);display:flex;height:100vh;} /* overflow:hidden 제거 */
        button{font-family:inherit; cursor: pointer;}        
        
        /* body에 스크롤 막는 클래스 추가 */
        body.no-scroll {
            overflow: hidden;
        }

        /* 인증 섹션 스타일 */
        #auth-section{padding:16px;border-bottom:1px solid var(--border-color); display:flex; flex-direction:column; align-items:center; gap: 10px;}        
        #login-btn{width:100%;padding:10px;background-color:var(--accent-blue);color:var(--bg-primary);border:none;border-radius:6px;font-weight:500}        
        #user-profile{display:none;align-items:center;gap:10px; width:100%;}        
        #user-profile img{width:32px;height:32px;border-radius:50%}        
        #user-profile p{font-size:.9rem;flex-grow:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}        
        #logout-btn{background:none;border:1px solid var(--border-color);color:var(--text-secondary);padding:6px 10px;border-radius:6px; flex-shrink: 0;}        
        
        /* 사이드바 스타일 */
        .sidebar{width:var(--sidebar-width);background-color:var(--bg-secondary);display:flex;flex-direction:column;flex-shrink:0;height:100%}.sidebar-content{flex-grow:1;overflow-y:auto; min-height:0;} /* min-height:0 추가 */
        .new-prompt-btn{display:flex;align-items:center;gap:12px;background-color:var(--bg-primary);color:var(--text-primary);border:1px solid var(--border-color);border-radius:24px;padding:10px 16px;font-size:.9rem;cursor:pointer;margin:8px 16px;white-space:nowrap}.new-prompt-btn:hover{background-color:#282a2c}.nav-section-title{font-size:.9rem;color:var(--text-secondary);padding:16px 16px 8px;font-weight:500}.nav-list{list-style:none}.nav-item a{display:flex;align-items:center;gap:16px;padding:10px 16px;color:var(--text-primary);text-decoration:none;border-radius:4px;font-size:.9rem;white-space:nowrap;cursor:pointer}.nav-item a:hover{background-color:var(--bg-tertiary)}.nav-item.active a{background-color:var(--accent-blue);color:var(--bg-primary)}.nav-icon{width:24px;text-align:center;font-size:1rem}.new-folder-btn{width:calc(100% - 32px);margin:10px 16px;padding:10px;background:none;border:1px dashed var(--border-color);color:var(--text-secondary);border-radius:4px}.new-folder-btn:hover{background-color:var(--bg-tertiary)}        
        
        /* 메인 콘텐츠 스타일 */
        .main-content{flex-grow:1;display:flex;flex-direction:column; min-height:0;} /* min-height:0 추가 */
        /* Adjusted main-header for top search bar */
        .main-header{
            display: flex;
            flex-direction: column; /* Stack items vertically */
            align-items: flex-start; /* Align items to the start */
            padding: 16px 24px 0; /* Padding top and sides, no padding bottom */
            height: auto; /* Height adapts to content */
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            gap: 10px; /* Space between title/toggle and search bar */
        }
        .main-header-top-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding-bottom: 16px; /* Padding below the title/toggle row */
        }
        .main-header h1{font-size:1.4rem;font-weight:500; margin: 0;} /* Reset margin */
        .search-wrapper{
            position:relative;
            width: 100%; /* Make search bar full width within header */
            margin-bottom: 16px; /* Space below search bar */
        }        
        .search-input{background-color:var(--bg-secondary);border:1px solid var(--border-color);border-radius:8px;color:var(--text-primary);padding:8px 16px 8px 36px;font-size:1rem; width: 100%;}
        .search-wrapper .fa-magnifying-glass{position:absolute;left:12px;top:11px;color:var(--text-secondary)}        
        
        /* 콘텐츠 뷰 및 목록 항목 스타일 */
        .content-view{
            flex:1 1 auto; /* flex-grow:1; 대신 flex:1 1 auto; 사용 */
            overflow-y:auto;
            padding:24px;
            min-height:0; /* min-height:0 추가 */
            -webkit-overflow-scrolling:touch; /* iOS 부드러운 스크롤 */
        }
        .content-placeholder{padding:50px 20px;text-align:center;color:var(--text-secondary)}
        /* 프롬프트 목록을 더 얇게 만들기 (패딩 조정) */
        .prompt-list-item{display:flex;align-items:center;padding:10px 16px;border-bottom:1px solid var(--border-color);cursor:pointer;gap:16px}
        .prompt-list-item:hover{background-color:var(--bg-secondary)}.prompt-list-icon{font-size:1.1rem;color:var(--text-secondary);width:20px}.prompt-title{font-weight:500}.prompt-subtitle{font-size:.8rem;color:var(--text-secondary);margin-top:4px}.prompt-tags{display:flex;gap:6px;margin-top:8px}.prompt-tag{background-color:var(--bg-tertiary);color:var(--text-secondary);font-size:.75rem;padding:2px 6px;border-radius:4px}.prompt-actions{margin-left:auto;display:flex;gap:8px}.prompt-actions button, .prompt-actions a.visit-link-btn{background-color:var(--bg-tertiary);border:1px solid var(--border-color);color:var(--text-primary);padding:8px 12px;border-radius:6px; text-decoration: none; display: flex; align-items: center; justify-content: center; gap: 6px;} /* Added a.visit-link-btn */
        .prompt-actions button:hover, .prompt-actions a.visit-link-btn:hover{background-color:var(--bg-hover)}        
        
        /* 편집기 스타일 */
        .editor-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:24px}.editor-actions button{background-color:var(--bg-tertiary);border:1px solid var(--border-color);color:var(--text-primary);padding:10px 16px;border-radius:6px;margin-left:8px}.editor-actions button.save-btn{background-color:var(--accent-blue);color:var(--bg-primary);border:none}.editor-actions button.delete-btn{color:var(--accent-pink);border-color:var(--accent-pink)}        
        .form-group{margin-bottom:24px}.form-group label{display:block;font-size:.9rem;color:var(--text-secondary);margin-bottom:8px}.form-group input,.form-group textarea,.form-group select{width:100%;background-color:var(--bg-secondary);border:1px solid var(--border-color);border-radius:8px;color:var(--text-primary);padding:12px;font-size:1rem;font-family:inherit}.form-group textarea{height:300px;resize:vertical}        
        .is-template-toggle{display:flex;align-items:center;gap:10px;margin-top:16px;font-size:.9rem}        
        
        /* 모달 스타일 */
        .modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:1000;opacity:0;visibility:hidden;transition:opacity .3s,visibility .3s}.modal-overlay.show{opacity:1;visibility:visible}.modal-content{background-color:var(--bg-secondary);padding:24px;border-radius:8px;width:90%;max-width:600px;box-shadow:0 5px 15px rgba(0,0,0,0.3)}.modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}.modal-header h3{color:var(--accent-blue)}.modal-header .close-btn{background:none;border:none;color:var(--text-secondary);font-size:1.5rem;cursor:pointer}.modal-body{max-height:60vh;overflow-y:auto}.modal-body .form-group label{font-weight:500;color:var(--accent-blue);}.modal-preview{background-color:var(--bg-primary);padding:12px;border-radius:4px;margin-top:16px;white-space:pre-wrap;font-family:monospace;max-height:150px;overflow-y:auto}.modal-footer{display:flex;justify-content:flex-end;gap:10px;margin-top:24px}.modal-footer button{padding:10px 16px;border-radius:6px;cursor:pointer;border:none}.modal-footer .generate-btn{background-color:var(--accent-blue);color:var(--bg-primary)}        
        
        /* 토스트 알림 스타일 */
        .toast{position:fixed;bottom:20px;right:20px;background-color:var(--bg-tertiary);color:var(--text-primary);padding:12px 20px;border-radius:6px;border-left:4px solid var(--accent-blue);opacity:0;visibility:hidden;transition:opacity .3s,visibility .3s,transform .3s;transform:translateY(20px);z-index:2000}.toast.show{opacity:1;visibility:visible;transform:translateY(0)}    
        
        /* 풀스크린 편집 모드 (24번) */
        body.fullscreen-editor-mode {
            overflow: hidden; /* 스크롤바 숨김 */
        }
        .main-content .content-view.fullscreen-editor {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            background-color: var(--bg-primary);
            z-index: 999; /* 다른 요소 위에 표시 */
            overflow-y: auto;
        }
        /* 풀스크린 시 사이드바 숨김 (모바일에서는 햄버거 메뉴로 제어) */
        body.fullscreen-editor-mode .sidebar { 
            display: none; 
        }
        /* 풀스크린 시 검색창 숨김 (모바일에서는 다시 표시될 수 있음) */
        body.fullscreen-editor-mode .main-header .search-wrapper {
            display: none; 
        }

        /* 반응형 디자인 개선 (26번) */
        /* 모바일 햄버거 메뉴 버튼은 데스크탑에서 숨김 */
        #mobile-menu-toggle {
            display: none; 
        }

        @media (max-width: 768px) {
            /* 모바일에서 햄버거 메뉴 버튼 표시 */
            #mobile-menu-toggle {
                display: block; 
                background: none;
                border: none;
                color: var(--text-secondary);
                font-size: 1.5rem;
                cursor: pointer;
                padding: 8px;
            }
            #mobile-menu-toggle:hover {
                background-color: var(--bg-tertiary);
                border-radius: 50%;
            }

            .sidebar {
                position: fixed;
                top: 0;
                left: -100%; /* 기본적으로 숨김 */
                height: 100%;
                width: 250px; /* 모바일 사이드바 너비 */
                z-index: 1000;
                transition: left 0.3s ease-in-out;
            }
            .sidebar.open {
                left: 0; /* 열릴 때 표시 */
            }

            /* 사이드바 닫기 버튼 (모바일에서만 표시) */
            #sidebar-close-btn {
                display: block;
                background: none;
                border: none;
                color: var(--text-secondary);
                font-size: 1.8rem;
                cursor: pointer;
                padding: 8px;
                position: absolute;
                top: 10px;
                right: 10px;
                z-index: 1001;
            }
            #sidebar-close-btn:hover {
                background-color: var(--bg-tertiary);
                border-radius: 50%;
            }
            
            .main-content {
                width: 100%;
            }
            .main-header {
                padding: 16px; /* 모바일 헤더 패딩 조정 */
                flex-direction: column; /* 스택 유지 */
                align-items: flex-start;
                gap: 15px;
            }
            .main-header-top-row {
                padding-bottom: 0; /* 모바일에서는 추가 패딩 없음 */
            }
            .main-header h1 {
                font-size: 1.2rem;
                flex-grow: 1; /* 제목이 남은 공간 차지 */
            }
            .main-header .search-wrapper {
                width: 100%; /* 검색창 너비 조정 */
                margin-bottom: 0; /* 모바일에서는 검색창 아래 여백 없음 */
            }
            .search-input {
                width: 100%;
            }
            .prompt-list-item {
                flex-wrap: wrap; /* 작은 화면에서 항목 줄바꿈 */
            }
            .prompt-actions {
                width: 100%; /* 버튼이 아래로 내려오도록 */
                justify-content: flex-end; /* 오른쪽 정렬 */
                margin-top: 10px;
            }
            .editor-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }
            .editor-actions {
                width: 100%;
                justify-content: flex-end;
            }

            /* 풀스크린 모드에서 사이드바 숨김 (모바일) */
            body.fullscreen-editor-mode .sidebar { 
                display: none; 
            }
            /* 풀스크린 모드에서 모바일 검색창도 숨김 */
            body.fullscreen-editor-mode .main-header .search-wrapper {
                display: none;
            }
        }
        /* 버튼 공통 스타일 (버전 기록 버튼 등) */
        .button-like {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.9rem;
            white-space: nowrap; /* 버튼 텍스트 줄바꿈 방지 */
        }
        .button-like:hover {
            background-color: var(--bg-hover);
        }
        /* 시퀀스 모달을 위한 추가 스타일 */
        .modal-sequence-content {
            background-color: var(--bg-secondary);
            padding: 24px;
            border-radius: 8px;
            width: 90%;
            max-width: 700px; /* 템플릿 모달보다 약간 넓게 */
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .modal-sequence-footer {
            display: flex;
            justify-content: space-between; /* 저장/실행 버튼과 삭제 버튼 분리 */
            gap: 10px;
            margin-top: 24px;
        }
        .modal-sequence-footer .left-actions {
            display: flex;
            gap: 10px;
        }
        .modal-sequence-footer .delete-btn {
            background: none;
            color: var(--accent-pink);
            border: 1px solid var(--accent-pink);
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
        }

        /* 파일 업로드 섹션 스타일 (메인 편집기) */
        .file-upload-section {
            display: flex;
            align-items: center;
            margin-top: 10px;
            gap: 10px;
        }
        .file-upload-section .button-like {
            padding: 8px 12px;
            font-size: 0.85rem;
        }

        /* Sortable.js를 위한 시퀀스 프롬프트 목록 스타일 */
        .sequence-sortable-list {
            min-height: 100px; /* 드래그 앤 드롭 영역 확보 */
            border: 1px dashed var(--border-color);
            border-radius: 8px;
            padding: 10px;
            background-color: var(--bg-primary);
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            max-height: 250px;
            min-height: 0; /* min-height:0 추가 */
        }
        .sequence-sortable-item {
            display: flex;
            align-items: center;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.95rem;
            cursor: grab; /* 드래그 가능함을 나타냄 */
            gap: 10px;
        }
        .sequence-sortable-item:active {
            cursor: grabbing;
        }
        .sequence-sortable-item .drag-handle {
            cursor: grab;
            color: var(--text-secondary);
            font-size: 1.1rem;
            margin-right: 5px;
        }
        .sequence-sortable-item span {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .sequence-sortable-item .remove-from-sequence-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1rem;
            padding: 4px;
            border-radius: 4px;
            cursor: pointer;
            line-height: 1; /* 아이콘 정렬 */
        }
        .sequence-sortable-item .remove-from-sequence-btn:hover {
            background-color: var(--bg-hover);
            color: var(--accent-pink);
        }
        /* Sortable.js 고스트 클래스 */
        .sortable-ghost {
            opacity: 0.4;
            background-color: var(--accent-blue);
            border: 1px dashed var(--accent-blue);
        }

        /* New style for template input with file button in modal */
        .template-input-with-file {
            display: flex;
            align-items: center;
            gap: 8px; /* Space between textarea and button */
        }

        .template-input-with-file textarea {
            flex-grow: 1; /* Allow textarea to take available space */
            min-width: 0; /* Prevent flex item from overflowing */
            height: auto; /* Allow textarea to adjust height based on rows */
            resize: vertical; /* Allow vertical resize */
        }

        .file-upload-icon-btn {
            padding: 8px 10px; /* Adjust padding for icon-only button */
            font-size: 1rem; /* Adjust icon size */
            width: auto; /* Allow button to size based on content */
            flex-shrink: 0; /* Prevent button from shrinking */
        }

        /* 데이터 새로고침 버튼 스타일 */
        #refresh-data-btn {
            margin-top: 10px;
            width: 100%;
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px;
            border-radius: 4px;
        }
        #refresh-data-btn:hover {
            background-color: var(--bg-hover);
        }

        /* 사용 기록 목록 스타일 */
        .usage-history-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .usage-history-item {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .usage-history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0; /* Padding moved to gap */
        }
        .usage-history-type {
            font-weight: bold;
            color: var(--accent-blue);
        }
        .usage-history-details strong {
            color: var(--text-primary);
            font-size: 1rem;
        }
        .usage-history-snippet {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
            white-space: pre-wrap;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis; /* For multiline text overflow */
            margin-top: 4px;
        }
        .usage-history-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 8px;
        }
        .usage-history-actions .reuse-history-btn {
            padding: 6px 10px;
            font-size: 0.8rem;
        }
    </style>
</head>
<body>
    <aside class="sidebar" id="sidebar">
        <div id="auth-section">
            <button id="login-btn"><i class="fa-brands fa-google"></i> Google 계정으로 로그인</button>
            <div id="user-profile">
                <img id="user-photo" src="" alt="사용자 사진">
                <p id="user-email"></p>
                <button id="logout-btn" title="로그아웃"><i class="fa-solid fa-arrow-right-from-bracket"></i></button>
            </div>
        </div>
        <div class="sidebar-content" id="sidebar-content" style="display:none;">
            <button class="new-prompt-btn" id="new-prompt-btn"><i class="fa-solid fa-plus"></i> 새 항목</button>
            <nav class="sidebar-nav">
                <h3 class="nav-section-title">라이브러리</h3>
                <ul class="nav-list" id="library-list">
                    <li class="nav-item active" data-filter-type="all"><a><i class="nav-icon fa-solid fa-book-bookmark"></i> 모든 항목</a></li>
                    <li class="nav-item" data-filter-type="favorites"><a><i class="nav-icon fa-solid fa-star"></i> 즐겨찾기</a></li>
                    <li class="nav-item" data-filter-type="templates"><a><i class="nav-icon fa-solid fa-puzzle-piece"></i> 템플릿만</a></li>
                    <li class="nav-item" data-filter-type="prompts"><a><i class="nav-icon fa-solid fa-file-lines"></i> 프롬프트만</a></li>
                    <li class="nav-item" data-filter-type="history"><a><i class="nav-icon fa-solid fa-history"></i> 사용 기록</a></li> <!-- 사용 기록 메뉴 추가 -->
                </ul>
                <h3 class="nav-section-title">폴더</h3>
                <ul class="nav-list" id="folder-list"></ul>
                <button class="new-folder-btn" id="new-folder-btn"><i class="fa-solid fa-folder-plus"></i> 새 폴더</button>
                
                <h3 class="nav-section-title">시퀀스</h3>
                <ul class="nav-list" id="sequence-list"></ul>
                <button id="new-sequence-btn" class="new-folder-btn">
                    <i class="fa-solid fa-layer-group"></i> 새 시퀀스
                </button>
            </nav>
        </div>
        <button id="sidebar-close-btn" style="display: none;"><i class="fa-solid fa-times"></i></button>
    </aside>

    <main class="main-content">
        <header class="main-header">
            <div class="main-header-top-row">
                <button id="mobile-menu-toggle"><i class="fa-solid fa-bars"></i></button>
                <h1 id="main-header-title">환영합니다</h1>
            </div>
            <div class="search-wrapper">
                <i class="fa-solid fa-magnifying-glass"></i>
                <input type="text" class="search-input" id="search-input" placeholder="검색...">
            </div>
        </header>
        <div class="content-view" id="content-view">
            <div class="content-placeholder">프롬프트를 관리하려면 로그인해주세요.</div>
        </div>
    </main>

    <div class="modal-overlay" id="template-modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="template-modal-title">템플릿 사용</h3>
                <button class="close-btn" id="template-modal-close-btn">&times;</button>
            </div>
            <div class="modal-body" id="template-modal-body">
                </div>
            <div class="modal-footer">
                <button id="template-modal-generate-btn" class="generate-btn"><i class="fa-solid fa-wand-magic-sparkles"></i> 생성 및 복사</button>
            </div>
        </div>
    </div>
    
    <div class="modal-overlay" id="sequence-modal-overlay">
        <div class="modal-sequence-content">
            <div class="modal-header">
                <h3 id="sequence-modal-title">새 시퀀스 생성</h3>
                <button class="close-btn" id="sequence-modal-close-btn">&times;</button>
            </div>
            <div class="modal-body" id="sequence-modal-body">
                </div>
            <div class="modal-sequence-footer">
                <div class="left-actions">
                    <button id="sequence-modal-save-btn" class="generate-btn"><i class="fa-regular fa-save"></i> 저장</button>
                    <button id="sequence-modal-run-btn" class="button-like"><i class="fa-solid fa-play"></i> 실행</button>
                </div>
                <button id="sequence-modal-delete-btn" class="delete-btn" style="display: none;"><i class="fa-regular fa-trash-can"></i> 삭제</button>
            </div>
        </div>
    </div>
        
    <div class="toast" id="toast"></div>

</body>
</html>
