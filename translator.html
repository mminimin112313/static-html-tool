<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TrAssist Pro — Auto-Save & Versioning</title>
    
    <!-- Preconnects for Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- External libraries (JSZip and diff) -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/diff@5.1.0/dist/diff.min.js"></script>

    <style>
    /* CSS variables for theming and fonts */
    :root {
        --font-ui: 'Inter', sans-serif;
        --font-mono: 'JetBrains Mono', monospace;
        --color-primary: #2563EB;
        --color-primary-hover: #1D4ED8;
        --color-primary-text: #FFFFFF;
        --color-text-primary: #111827;
        --color-text-secondary: #6B7280;
        --color-text-placeholder: #9CA3AF;
        --color-bg: #F9FAFB;
        --color-surface: #FFFFFF;
        --color-border: #E5E7EB;
        --color-border-hover: #D1D5DB;
        --color-danger: #DC2626;
        --color-green: #059669;
        --color-red: #B91C1C;
        --status-todo: #9CA3AF;
        --status-wip: #F59E0B;
        --status-done: #10B981;
        --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.04);
        --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.08), 0 2px 4px -2px rgb(0 0 0 / 0.08);
        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
    }
    /* Reset and base styles */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html { -webkit-font-smoothing: antialiased; }
    body {
        font-family: var(--font-ui);
        background-color: var(--color-bg);
        color: var(--color-text-primary);
        font-size: 15px;
        line-height: 1.6;
    }
    /* Header styling */
    .app-header {
        position: sticky;
        top: 0;
        background-color: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(12px);
        border-bottom: 1px solid var(--color-border);
        padding: 12px 24px;
        display: flex;
        align-items: center;
        gap: 16px;
        z-index: 10;
    }
    .logo {
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 600;
        font-size: 1.125rem;
    }
    .logo i { color: var(--color-primary); }

    /* Layout for the three panes */
    .main-workspace {
        display: grid;
            grid-template-columns: minmax(280px, 0.8fr) 1.5fr minmax(360px, 1fr);
            gap: 20px;
            padding: 20px;
            height: calc(100vh - 71px);
            max-width: 1920px;
            margin: 0 auto;
    }
    .pane {
        background-color: var(--color-surface);
        border: 1px solid var(--color-border);
        border-radius: 12px;
        box-shadow: var(--shadow-sm);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    .pane__header {
        padding: 12px 16px;
        border-bottom: 1px solid var(--color-border);
        flex-shrink: 0;
        display: flex;
        align-items: center;
        gap: 12px;
    }
    .pane__title {
        font-weight: 600;
        font-size: 0.95rem;
        color: var(--color-text-primary);
    }
    .pane__body { padding: 8px; overflow-y: auto; flex-grow: 1; }
    .pane__body--padded { padding: 16px; }

    /* Button styles */
    .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        font-family: inherit;
        font-weight: 500;
        font-size: 0.875rem;
        padding: 8px 14px;
        border-radius: 8px;
        border: 1px solid transparent;
        cursor: pointer;
        transition: all 0.15s ease-out;
        white-space: nowrap;
    }
    .btn:disabled { cursor: not-allowed; opacity: 0.5; }
    .btn i { width: 16px; height: 16px; }
    .btn .animate-spin { animation: spin 1s linear infinite; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

    .btn--primary {
        background-color: var(--color-primary);
        color: var(--color-primary-text);
        border-color: var(--color-primary);
        box-shadow: var(--shadow-sm);
    }
    .btn--primary:not(:disabled):hover { background-color: var(--color-primary-hover); }
    .btn--secondary {
        background-color: var(--color-surface);
        color: var(--color-text-primary);
        border-color: var(--color-border-hover);
        box-shadow: var(--shadow-sm);
    }
    .btn--secondary:not(:disabled):hover {
        border-color: #9CA3AF;
        background-color: var(--color-bg);
    }
    .btn--icon {
        padding: 8px;
        background: transparent;
        color: var(--color-text-secondary);
        border-color: transparent;
    }
    .btn--icon:not(:disabled):hover {
        color: var(--color-text-primary);
        background-color: var(--color-bg);
    }

    .form-select {
        flex-shrink: 1;
        max-width: 350px;
        min-width: 150px;
        padding: 8px 12px;
        border: 1px solid var(--color-border-hover);
        border-radius: 8px;
        font-family: inherit;
        font-size: 0.9rem;
        background-color: var(--color-surface);
    }

    /* Welcome screen styling */
    #welcomeScreen {
        position: fixed;
        inset: 0;
        background-color: var(--color-bg);
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 100;
        transition: opacity 0.3s ease-out;
    }
    #welcomeScreen.hidden { opacity: 0; pointer-events: none; }

    /* File tree */
    .file-tree { display: flex; flex-direction: column; gap: 2px; padding: 4px; }
    .tree-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        user-select: none;
        font-size: 0.875rem;
    }
    .tree-item:hover { background-color: #F3F4F6; }
    .tree-item.active {
        background-color: #E0E7FF;
        color: var(--color-primary);
        font-weight: 600;
    }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
    .status-dot--0 { background-color: var(--status-todo); }
    .status-dot--1 { background-color: var(--status-wip); }
    .status-dot--2 { background-color: var(--status-done); }

    /* Source blocks */
    .source-blocks-container { padding: 8px; display: flex; flex-direction: column; gap: 12px; }
    .source-block {
        border: 1px solid var(--color-border);
        border-radius: 10px;
        padding: 12px 16px;
        cursor: pointer;
        transition: all 0.15s ease-out;
    }
    .source-block:hover { border-color: var(--color-border-hover); background-color: #F9FAFB; }
    .source-block.selected {
        border-color: var(--color-primary);
        background-color: #EFF6FF;
        box-shadow: 0 0 0 1px var(--color-primary);
    }
    .source-block__meta {
        display: flex;
        justify-content: space-between;
        font-size: 0.75rem;
        color: var(--color-text-secondary);
        margin-bottom: 8px;
        font-family: var(--font-mono);
    }
    .source-block__text {
        white-space: pre-wrap;
        word-break: break-word;
        font-size: 0.92rem;
        line-height: 1.7;
    }

    /* Translation pane */
    .translation-pane-body { display: flex; flex-direction: column; gap: 16px; }
    #translationArea {
        width: 100%;
        flex-grow: 1;
        padding: 12px;
        border: 1px solid var(--color-border);
        border-radius: 10px;
        font-size: 0.92rem;
        line-height: 1.7;
        font-family: var(--font-mono);
        resize: none;
    }
    #translationArea:focus { outline: none; border-color: var(--color-primary); }
    .action-group { display: flex; align-items: center; gap: 12px; }
    #saveStatus {
        font-size: 0.8rem;
        color: var(--color-text-secondary);
        transition: opacity 0.3s;
        flex-grow: 1;
        text-align: right;
        padding-right: 8px;
    }

    /* Dialogs */
    dialog { border: none; border-radius: 12px; padding: 0; box-shadow: var(--shadow-lg); max-width: 90vw; }
    dialog::backdrop { background-color: rgba(0, 0, 0, 0.4); backdrop-filter: blur(4px); }
    .dialog__header {
        padding: 16px 24px;
        border-bottom: 1px solid var(--color-border);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .dialog__body { padding: 24px; }
    .dialog__footer {
        padding: 12px 24px;
        border-top: 1px solid var(--color-border);
        background-color: var(--color-bg);
        display: flex;
        justify-content: flex-end;
        gap: 12px;
    }
    #historyDialog .revision-list {
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid var(--color-border);
        border-radius: 8px;
    }
    #historyDialog .revision-item {
        padding: 8px 12px;
        cursor: pointer;
        border-bottom: 1px solid var(--color-border);
        font-size: 0.875rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    #historyDialog .revision-item:last-child { border-bottom: none; }
    #historyDialog .revision-item:hover { background-color: #F3F4F6; }
    #historyDialog .revision-item.selected { background-color: #E0E7FF; }
    #diffOutput {
        margin-top: 16px;
        padding: 16px;
        border-radius: 8px;
        background-color: var(--color-bg);
        max-height: 300px;
        overflow-y: auto;
        white-space: pre-wrap;
        font-family: var(--font-mono);
        font-size: 0.85rem;
        line-height: 1.6;
    }
    #diffOutput ins {
        background-color: #D1FAE5;
        color: var(--color-green);
        text-decoration: none;
    }
    #diffOutput del {
        background-color: #FEE2E2;
        color: var(--color-red);
        text-decoration: none;
    }

    /* Dropdowns and toasts */
    .dropdown { position: relative; }
    .dropdown-menu {
        display: none;
        position: absolute;
        right: 0;
        top: calc(100% + 8px);
        background: white;
        border: 1px solid var(--color-border);
        border-radius: 8px;
        box-shadow: var(--shadow-md);
        z-index: 20;
        min-width: 200px;
        overflow: hidden;
    }
    .dropdown-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 14px;
        background: none;
        border: none;
        width: 100%;
        text-align: left;
        cursor: pointer;
        font-size: 0.875rem;
    }
    .dropdown-item:hover { background-color: var(--color-bg); }
    .toast-wrap {
        position: fixed;
        right: 24px;
        bottom: 24px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        z-index: 9999;
    }
    .toast {
        padding: 12px 18px;
        border-radius: 8px;
        box-shadow: var(--shadow-md);
        background-color: var(--color-surface);
        border: 1px solid var(--color-border);
        border-left: 4px solid var(--color-primary);
        animation: toast-in 0.3s ease-out;
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 500;
    }
    .toast.ok { border-left-color: var(--status-done); }
    .toast.error { border-left-color: var(--color-danger); }
    @keyframes toast-in {
        from { opacity: 0; transform: translateY(12px); }
        to { opacity: 1; transform: translateY(0); }
    }

    /* Button label visibility: hide labels by default, show on hover or via .show-label class */
    .btn-label {
        display: none;
    }
    .btn:hover .btn-label,
    .btn.show-label .btn-label {
        display: inline-block;
        margin-left: 4px;
    }
    /* Micro interactions for buttons */
    .btn {
        transition: transform 0.15s ease, background-color 0.2s;
    }
    .btn:active {
        transform: scale(0.95);
    }
    /* Progress bar for project list */
    .project-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 14px;
        border-bottom: 1px solid var(--color-border);
        cursor: pointer;
    }
    .project-item:hover {
        background-color: #F3F4F6;
    }
    .project-name {
        font-weight: 500;
    }
    .project-progress {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 120px;
    }
    .project-progress-bar {
        flex-grow: 1;
        height: 8px;
        background-color: var(--color-border);
        border-radius: 4px;
        overflow: hidden;
        position: relative;
    }
    .project-progress-bar__fill {
        height: 100%;
        background-color: var(--color-primary);
        width: 0%;
    }

    /* Center the settings dialog when open. This ensures the settings
       modal appears in the middle of the viewport horizontally and
       vertically. */
    #settingsDlg[open] {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        margin: 0;
    }

    /* Center the project management dialog when open */
    #projectMgmtDlg[open] {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        margin: 0;
    }

        /* Responsive layout adjustments */
        /* For medium screens, collapse to two columns */
        @media (max-width: 1200px) {
            .main-workspace {
                grid-template-columns: 1fr 1fr;
                /* Allow height to auto-adjust when the layout collapses */
                height: auto;
            }
            .pane {
                /* Remove strict height in medium layouts */
                min-height: auto;
            }
            /* Allow header items to wrap on medium screens */
            .app-header {
                flex-wrap: wrap;
            }
        }
        /* For small screens, stack panes vertically and wrap header items */
        @media (max-width: 768px) {
            .app-header {
                flex-wrap: wrap;
                gap: 8px;
            }
            .main-workspace {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
                height: auto;
                /* Reduce padding and gaps for tight screens */
                padding: 12px;
                gap: 12px;
            }
            .pane {
                min-height: auto;
            }
            /* Hide text labels on header buttons and shrink padding */
            .app-header .btn-label {
                display: none;
            }
            .app-header .btn {
                padding-left: 10px;
                padding-right: 10px;
            }
            /* Shorten the project file list height for better overview */
            #fileTree {
                max-height: 300px;
                overflow-y: auto;
            }
        }
    </style>
</head>
<body>
    <!-- Welcome screen shown on first load or when no projects exist -->
    <div id="welcomeScreen">
        <div style="max-width: 500px;">
            <i data-lucide="file-text" style="width: 48px; height: 48px; margin: 0 auto 16px; color: var(--color-primary);"></i>
            <h1 style="font-size: 2.25rem; font-weight: 700;">TrAssist에 오신 것을 환영합니다</h1>
            <p style="color: var(--color-text-secondary); margin: 8px 0 24px;">텍스트 파일 번역을 효율적으로 도와주는 간단한 도구입니다.</p>
            <input id="zipFileInput" type="file" accept=".zip" style="display: none;" />
            <button id="btnOpenZip" class="btn btn--primary" style="font-size: 1rem; padding: 12px 24px;">
                <i data-lucide="plus-circle"></i> ZIP에서 새 프로젝트 만들기
            </button>
        </div>
    </div>
    
    <!-- Application header -->
    <header class="app-header">
        <div class="logo"><i data-lucide="file-text"></i><span>TrAssist</span></div>
        <select id="projectSelect" class="form-select"></select>
        <div id="projectProgress" style="min-width:150px; margin-left:12px;">
            <!-- Progress indicator for current project will be inserted here -->
        </div>
            <button id="btnManageProjects" class="btn btn--secondary"><i data-lucide="folder-cog"></i><span class="btn-label">프로젝트 관리</span></button>
        <div style="flex-grow: 1;"></div>
            <button id="btnExportZip" class="btn btn--secondary"><i data-lucide="archive"></i><span class="btn-label">번역 내보내기</span></button>
            <!-- Button to create a new project from a ZIP file even after initialization -->
            <button id="btnOpenZipHeader" class="btn btn--secondary"><i data-lucide="plus-circle"></i><span class="btn-label">ZIP 프로젝트 만들기</span></button>
        <div class="dropdown">
            <button id="btnDataActions" class="btn btn--icon" title="데이터 관리"><i data-lucide="database"></i></button>
            <div id="dataDropdownMenu" class="dropdown-menu">
                <button id="btnFullExport" class="dropdown-item"><i data-lucide="download"></i><span class="btn-label">전체 백업 내보내기</span></button>
                <button id="btnFullImport" class="dropdown-item"><i data-lucide="upload"></i><span class="btn-label">전체 백업 가져오기</span></button>
            </div>
        </div>
            <button id="btnSettings" class="btn btn--secondary" title="설정"><i data-lucide="settings-2"></i><span class="btn-label">설정</span></button>
        <input id="importFile" type="file" accept=".json" style="display:none;" />
    </header>

    <!-- Main workspace with three panes -->
    <main id="mainWorkspace" class="main-workspace" style="display: none;">
        <!-- Project files list -->
        <aside class="pane">
             <div class="pane__header"><span class="pane__title">프로젝트 파일</span></div>
             <div id="fileTree" class="pane__body file-tree"></div>
        </aside>

        <!-- Translation pane (now second) -->
        <section class="pane">
            <div class="pane__header">
                <span class="pane__title">번역</span>
                <button id="btnHistory" class="btn btn--icon" title="Version History"><i data-lucide="history"></i></button>
                <div style="flex-grow:1;"></div>
                <span id="langBadge" style="font-family: var(--font-mono); font-size: 0.8rem; background: #F3F4F6; padding: 2px 8px; border-radius: 6px;"></span>
            </div>
            <div class="pane__body--padded translation-pane-body">
                <button id="btnCopyPrompt" class="btn btn--primary"><i data-lucide="clipboard-copy"></i><span class="btn-label">AI 프롬프트 복사</span></button>
                <textarea id="translationArea" placeholder="여기에 번역을 붙여넣으세요... (자동 저장)"></textarea>
                <div class="action-group">
                    <span id="saveStatus"></span>
                    <button id="btnMarkDone" class="btn btn--secondary" title="완료로 표시"><i data-lucide="check-circle-2"></i><span class="btn-label">완료</span></button>
                </div>
            </div>
        </section>

        <!-- Source text pane (now third) -->
        <section class="pane">
            <div class="pane__header"><span id="pathLabel" class="pane__title" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-family: var(--font-mono); font-weight: 400; font-size: 0.875rem;">파일 선택</span></div>
            <div id="sourceContainer" class="pane__body source-blocks-container"></div>
        </section>
    </main>
    
    <!-- Settings and history dialogs -->
    <dialog id="settingsDlg"></dialog>
    <dialog id="historyDialog" style="width: 800px; max-width: 95vw;">
        <div class="dialog__header"><h2>버전 기록</h2><button class="btn btn--icon" onclick="this.closest('dialog').close()"><i data-lucide="x"></i></button></div>
        <div class="dialog__body" style="display: flex; gap: 16px; flex-wrap: wrap;">
            <div style="flex:1; min-width: 250px;">
                <h4 style="font-weight:500; margin-bottom: 8px;">비교할 버전을 선택하세요</h4>
                <div id="revisionList" class="revision-list"></div>
            </div>
            <div style="flex:2; min-width: 300px;">
                <h4 style="font-weight:500; margin-bottom: 8px;">현재 버전과의 변경 사항</h4>
                <div id="diffOutput">변경 사항을 보려면 버전을 선택하세요.</div>
            </div>
        </div>
        <div class="dialog__footer">
            <button class="btn btn--secondary" onclick="this.closest('dialog').close()">닫기</button>
                <button id="btnRestoreVersion" class="btn btn--primary" disabled><i data-lucide="undo-2"></i><span class="btn-label">선택한 버전 복원</span></button>
        </div>
    </dialog>

    <!-- Project management dialog: lists projects with progress metrics -->
    <dialog id="projectMgmtDlg" style="width: 600px; max-width: 95vw;">
        <div class="dialog__header">
            <h2>프로젝트 관리</h2>
            <button class="btn btn--icon" onclick="this.closest('dialog').close()"><i data-lucide="x"></i></button>
        </div>
        <div class="dialog__body">
            <div id="projectList" style="max-height:400px; overflow-y:auto;"></div>
        </div>
        <div class="dialog__footer">
            <button class="btn btn--secondary" onclick="this.closest('dialog').close()">닫기</button>
        </div>
    </dialog>
    
    <!-- Toast notifications -->
    <div class="toast-wrap" id="toastWrap"></div>

<!-- Load lucide icons library -->
<!-- Using unpkg without /dist ensures lucide attaches itself to window and defines global variable -->
<script src="https://unpkg.com/lucide@latest"></script>

<script>
// The script below implements the application's logic. It has been updated
// to ensure that the global variable `lucide` is defined even if the
// external script fails to load. This prevents a ReferenceError during
// initialization and allows the rest of the application to function.
'use strict';

// Provide a fallback for the lucide global if it isn't available yet. We
// define a minimal stub with a no-op createIcons() so that calls won't
// throw. When the real lucide script loads it will override this stub.
if (typeof window.lucide === 'undefined') {
    window.lucide = { createIcons: () => {} };
}
// Also bind the local variable `lucide` (used throughout this script) to
// the global object. This ensures that lucide.createIcons() is always
// callable.
var lucide = window.lucide;

// Constants for IndexedDB name and version
const DB_NAME = 'trassist-v6-final';
const DB_VERSION = 1;
let db;

// --- UTILITIES ---
// Debounce function to limit how often a function executes
function debounce(func, delay) {
  let t;
  return (...a) => {
    clearTimeout(t);
    t = setTimeout(() => func.apply(this, a), delay);
  };
}
// Toast helper to show notifications
function toast(msg, type = 'info') {
  const div = document.createElement('div');
  div.className = `toast ${type}`;
  div.innerHTML = `<span>${msg}</span>`;
  els.toastWrap.appendChild(div);
  setTimeout(() => div.remove(), 2800);
}

// --- DATABASE HELPERS ---
// Open (or create) IndexedDB with the expected stores
function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains('projects')) db.createObjectStore('projects', { keyPath: 'id' });
      if (!db.objectStoreNames.contains('files')) db.createObjectStore('files', { keyPath: ['projectId', 'path'] });
      if (!db.objectStoreNames.contains('settings')) db.createObjectStore('settings', { keyPath: 'id' });
      if (!db.objectStoreNames.contains('revisions')) {
          const revStore = db.createObjectStore('revisions', { keyPath: 'id', autoIncrement: true });
          revStore.createIndex('file_idx', ['projectId', 'path']);
      }
    };
    req.onsuccess = (e) => { db = e.target.result; resolve(); };
    req.onerror = (e) => reject(e.target.error);
  });
}
// Transaction shortcut
function tx(store, mode='readonly') { return db.transaction(store, mode).objectStore(store); }
// CRUD operations for IndexedDB
function idbGet(store, key) {
  return new Promise((res, rej) => {
    const r = tx(store).get(key);
    r.onsuccess = () => res(r.result);
    r.onerror = () => rej(r.error);
  });
}
function idbPut(store, val) {
  return new Promise((res, rej) => {
    const r = tx(store, 'readwrite').put(val);
    r.onsuccess = () => res();
    r.onerror = () => rej(r.error);
  });
}
function idbGetAll(store, index, query) {
    return new Promise((res, rej) => {
        const objectStore = tx(store);
        const request = index ? objectStore.index(index).getAll(query) : objectStore.getAll(query);
        request.onsuccess = () => res(request.result);
        request.onerror = () => rej(request.error);
    });
}
function idbClear(storeName) {
  return new Promise((res, rej) => {
    const r = tx(storeName, 'readwrite').clear();
    r.onsuccess = res;
    r.onerror = rej;
  });
}

// --- GLOBAL STATE & DOM ELEMENTS ---
let currentProjectId = null;
let currentFilePath = null;
let currentSourceBlocks = [];
let selectedBlockIndices = new Set();
// Map of all DOM elements with an ID for quick access
const els = Object.fromEntries(Array.from(document.querySelectorAll('[id]')).map(el => [el.id, el]));

// --- CORE LOGIC ---
// Default prompt template with placeholders
// Updated default prompt: Use an XML meta-prompt for translation. This prompt gives
// explicit guidance to a translation model about tone, style, persona, and
// process. The placeholder {{번역대상}} will be replaced with the text to
// translate, and other placeholders like {{source_lang}}, {{target_lang}},
// {{instructions}}, {{path}}, and {{filename}} can still be used if needed.
const DEFAULT_TEMPLATE = `<?xml version="2.0" encoding="UTF-8"?>
<metaPrompt>
  <purpose>
    천천히 심혈을 기울여서 essentialContext에 제공된 특정 문서를 입력받아, 원문의 톤앤매너를 완벽하게 유지하면서도 가장 유려하고 자연스러운 문어체 한국어 문장으로 차근차근 천천히 변환한다.
    최종 결과물은 즉시 출판 가능하도록 가독성, 읽기 쉬우면서, 학문적 엄밀성을 보전하고, 의미 전달의 정확성, 어법 준수성 등 좋은 글의 모든 특성을 최고 수준으로 충족해야 한다.
  </purpose>

  <promptDesignFramework>

    <objectiveDefinition id="1" title="목표 정의: 과업의 제1원칙">
      <finalDeliverable id="1.1" description="프롬프트를 통해 얻고자 하는 최종 결과물">
         이 문서의 콘텐츠는 사용자가 제공한 원문을 한국어 문어체 문장으로 변환 하고, 전문가 수준으로 다듬어 즉시 출판하여 베스트셀러가 될 수 있는 상태의 글이다.
      </finalDeliverable>
      <coreTask id="1.2" description="LLM이 수행해야 할 핵심적인 동사">
        번역(Translate), 교정(Refine), 그리고 형식화(Format). 단순히 단어를 옮기는 것을 넘어, 전문 편집자로서 원문의 의미와 뉘앙스를 살리면서 한국어 독자에게 최적화된 콘텐츠로 재구성하고, 지정된 XML 형식에 맞춰 구조화해야 한다.
      </coreTask>
      <successCriteria id="1.3" description="결과물이 '성공'이라고 판단할 객관적인 기준">
        - 결과물은 문법적으로 완벽한(well-formed) 한국어
        - 학문적 엄밀성 및 정홛성
        - 결과물이 읽기 쉬움
        - 일문 일의주의에 따라 문장을 작성
        - 번역문은 원문의 핵심 의미, 세부 뉘앙스, 그리고 저자의 의도를 100% 보존한다.
        - 한국어 문장은 문법적으로 완벽하며, 원문의 어조와 스타일을 유지하면서도 자연스럽고 유려하다.
        - 제목, 요약, 소제목, 문단 나누기 등 내용의 논리적 흐름을 반영하여 가독성을 극대화한다.
        - '[여기에 입력]'과 같은 플레이스홀더 텍스트가 최종 결과물에 남아있지 않다.
      </successCriteria>
    </objectiveDefinition>

    <personaAssignment id="2" title="역할 부여: 최적의 인지 모델 설계">
      <expertPersona id="2.1" description="과업을 가장 잘 수행할 전문가의 상세한 묘사">
        당신은 '마스터 번역가 겸 콘텐츠 전략가'입니다. 20년 경력의 국제회의 통역사이자 여러 권의 베스트셀러 기술 서적을 번역한 경험이 있습니다. 당신은 단순히 언어를 변환하는 것을 넘어, 문화적 맥락과 미묘한 뉘앙스까지 포착하여 독자의 마음을 움직이는 글을 만들어내는 전문가입니다. 또한, 디지털 콘텐츠의 가독성과 검색엔진최적화(SEO)에 대한 깊은 이해를 바탕으로, 번역된 콘텐츠가 온라인 환경에서 최고의 성과를 낼 수 있도록 구조화하는 능력을 갖추고 있습니다.
      </expertPersona>
      <audience id="2.2" description="결과물을 소비할 대상과 그들의 지식 수준">
        제공될 원문의 내용, 어휘, 스타일을 분석하여 잠재 독자층(예: 기술 전문가, 일반 대중, 특정 분야의 학생 등)을 추론하고, 그들의 지식 수준과 관심사에 맞춰 가장 이해하기 쉬운 어휘와 문장 구조를 선택해야 한다.
      </audience>
      <toneAndStyle id="2.3" description="결과물의 어조와 스타일 및 정신적 도구">
        - **톤앤매너 복제:** 원문의 톤(예: 학술적, 유머러스함, 진지함, 대중적)을 정확히 분석하고, 그 느낌을 한국어의 표현으로 완벽하게 재현해야 한다. 직역으로 어색해지는 관용구나 문화적 표현은 한국 독자가 즉시 이해할 수 있는 자연스러운 표현으로 의역한다.
      - 문어체의 사용 : 베스트셀러처럼 잘 읽히는 문어체를 사용하여, 원본의 모든 내용과 정보를 포함하면서도 술술 읽혀야만 한다.
        - **정신적 도구 (Mental Model):** '독자의 입장에서 생각하기'. 문장을 완성하기 전에, 잠재 독자의 관점에서 그 문장을 소리 내어 읽어본다고 상상하라. '이 문장은 명확한가? 매력적인가? 이전 내용과 자연스럽게 연결되는가?'를 끊임없이 자문하며 결과물을 다듬어라.
      </toneAndStyle>
    </personaAssignment>

    <contextAndFormat id="3" title="맥락 제공 및 형식 지정">
      <essentialContext id="3.1" description="과업 수행에 필요한 모든 배경 정보, 데이터, 이전 대화 내용">
        <![CDATA[
          <!-- 여기에 번역할 원문을 입력하십시오. -->
{{text}}
        ]]>
      </essentialContext>
      <outputFormat id="3.2" description="결과물이 출력되어야 할 정확한 형식 또는 템플릿">
        <![CDATA[
입력에 따라서 적절한 형식으로.
        ]]>
      </outputFormat>
    </contextAndFormat>

    <reasoningDesign id="4" title="추론 과정 설계: 생각의 경로 구축">
      <reasoningFramework id="4.1" description="과업 복잡성에 따른 추론 방식 선택">
        <option type="ProblemDecomposition" description="복잡한 프로젝트 수행 시 사용">
          <instruction>아래의 최종 목표를 달성하기 위해, 다음의 하위 작업들을 명시된 순서대로 반드시 수행하라. 각 단계의 결과는 다음 단계의 입력으로 사용된다.</instruction>
          <subTasks>
            <task id="1">**1단계: 원문 심층 분석 (Analyze):** 제공된 원문을 최소 3회 이상 정독하여 핵심 메시지, 논리 구조, 저자의 어조와 문체, 그리고 숨은 의도를 완벽하게 파악한다.</task>
            <task id="2">**2단계: 초벌 번역 및 뉘앙스 포착 (Translate & Capture):** 원문의 의미를 정확하게 전달하는 데 초점을 맞춰 초벌 번역을 수행한다. 특히 기술 용어, 관용 표현, 문화적 배경이 담긴 뉘앙스를 놓치지 않도록 주의한다.</task>
            <task id="3">**3단계: 윤문 및 유려함 확보 (Refine & Polish):** 초벌 번역 결과물을 한국어 독자의 시각에서 어색함이 없도록 다듬는다. 그러면서 동시에 문어체로 작성항다.  딱딱한 번역투 문장을 자연스러운 한국어 문장으로 재구성하고, 더 적절한 어휘를 선택하여 글 전체의 유려함을 극대화한다.</task>
            <task id="4">**4단계: 콘텐츠 구조화 및 형식화 (Structure & Format):** 완성된 내용을 가독성을 높이기 위해 본문을 논리적인 문단과 소제목으로 나누고, 핵심 키워드를 추출하여 태그를 생성한다.</task>
          </subTasks>
        </option>
      </reasoningFramework>
      <fewShotExamples id="4.2" description="1~3개의 고품질 입/출력 예시로 결과물 패턴 학습">
        <example id="1">
          <input><![CDATA[
            Title: The Unseen Power of Micro-interactions

            Micro-interactions are the small, often unnoticed animations and design elements that make a user interface feel alive. Think of the "like" button animation on Twitter, or the subtle bounce when you pull to refresh a feed. While seemingly minor, these details are critical. They provide feedback, guide users, and add a touch of personality to a digital product, transforming a functional tool into an enjoyable experience. Good micro-interactions are almost invisible, doing their job without shouting for attention.
          ]]></input>
          <output><![CDATA[
          ]]></output>
        </example>
      </fewShotExamples>
    </constraints>

    <constraints id="5" title="제약 조건 설정: 탐색 공간 제어">
      <mustInclude id="5.1" description="결과물에 반드시 포함되어야 할 키워드, 개념, 데이터 포인트">
        - 최종 결과물은 번역문이어야 한다.
        - 원문에 포함된 모든 정보는 번역문에 반드시 포함되어야 한다.
        - 
      </mustInclude>
      <mustAvoid id="5.2" description="반드시 피해야 할 주제, 표현, 단어, 편향, 가정">
        - 단어 대 단어 식의 기계적인 직역.
        - 원문의 정보를 누락하거나, 원문에 없는 내용을 임의로 추가하는 행위.
        - 한국어 독자가 읽기에 어색하거나 부자연스러운 번역투 문장.
        - 최종 결과물에 '여기를 채우세요'와 같은 미완성된 플레이스홀더를 남기는 것.
      </mustAvoid>
      <selfCorrectionCommand id="5.3" description="생성될 프롬프트 마지막에 포함될 최종 검증 명령">
        <![CDATA[
          모든 지시사항을 완수한 후, 최종 답변을 제출하기 전에 잠시 멈추고 스스로 '레드팀'의 역할을 수행하라. 내가 제시한 모든 요구사항(역할, 형식, 내용, 제약 조건 등)이 100% 충족되었는지, 논리적 비약이나 모순은 없는지, 더 나은 대안은 없는지 최소 세 번 이상 교차 검증하고, 그 결과를 반영하여 최종적으로 완벽하고 군더더기 없는 결과물만 출력하라.
        ]]>
      </selfCorrectionCommand>
    </constraints>

  </promptDesignFramework>
  <!-- 추가 정보: 동적으로 채워질 자리표시자 -->
  <variables>
    <sourceLang>{{source_lang}}</sourceLang>
    <targetLang>{{target_lang}}</targetLang>
    <path>{{path}}</path>
    <filename>{{filename}}</filename>
    <instructions>{{instructions}}</instructions>
  </variables>
</metaPrompt>`;

// Default settings if none are stored
function defaultSettings() {
    return {
        id: 'global',
        sourceLang: 'ko',
        targetLang: 'en',
        styleNotes: 'Maintain a consistent tone and preserve formatting.',
        promptTemplate: DEFAULT_TEMPLATE,
        // Do not split text by default; treat the entire file as a single block. Users can override via settings.
        splitMode: 'none',
        maxChunk: 800
    };
}

// Load settings from IndexedDB or create defaults
async function loadSettings() {
    let s = await idbGet('settings', 'global');
    // If no settings exist, create default settings.
    if (!s) {
        s = defaultSettings();
        await idbPut('settings', s);
    } else {
        // If splitMode is missing from older versions, default to 'none'
        if (!('splitMode' in s)) {
            s.splitMode = 'none';
            await idbPut('settings', s);
        }
    }
    updateLangBadge(s.sourceLang, s.targetLang);
    return s;
}

// Update the language badge at the top of translation pane
function updateLangBadge(source, target) {
    els.langBadge.textContent = `${(source || 'KO').toUpperCase()} → ${(target || 'EN').toUpperCase()}`;
}

// Persist last opened project and file in localStorage for convenience
const saveCurrentState = () => {
    if (currentProjectId) localStorage.setItem('lastProjectId', currentProjectId);
    if (currentFilePath) {
        localStorage.setItem(`lastFile-${currentProjectId}`, currentFilePath);
        localStorage.setItem(`selection-${currentProjectId}-${currentFilePath}`, JSON.stringify(Array.from(selectedBlockIndices)));
    }
};

// Restore last opened project/file after reload
async function restoreLastState() {
    const lastProjectId = localStorage.getItem('lastProjectId');
    if (!lastProjectId) return;
    const projects = await idbGetAll('projects');
    if (projects.some(p => p.id === lastProjectId)) {
        currentProjectId = lastProjectId;
        els.projectSelect.value = currentProjectId;
        await renderTree();
        const lastFile = localStorage.getItem(`lastFile-${lastProjectId}`);
        if (lastFile) {
            const fileExists = (await idbGet('files', [currentProjectId, lastFile])) !== undefined;
            if (fileExists) {
                await openFile(lastFile, true);
                await updateCurrentProjectProgress();
            }
        }
    }
}

// Update the save status indicator in the UI
const updateSaveStatus = (status) => {
    if (!els.saveStatus) return;
    els.saveStatus.style.opacity = '1';
    if (status === 'saving') els.saveStatus.textContent = 'Saving...';
    else if (status === 'saved') {
        els.saveStatus.textContent = `Saved at ${new Date().toLocaleTimeString()}`;
        setTimeout(() => { if(els.saveStatus) els.saveStatus.style.opacity = '0'; }, 2000);
    } else {
        els.saveStatus.textContent = '';
        els.saveStatus.style.opacity = '0';
    }
};

// Debounced saving of translations and revision history
const debouncedSave = debounce(async (text) => {
    if (!currentProjectId || !currentFilePath) return;
    updateSaveStatus('saving');
    await idbPut('revisions', { projectId: currentProjectId, path: currentFilePath, content: text, timestamp: Date.now() });
    const fileRec = await idbGet('files', [currentProjectId, currentFilePath]);
    if (fileRec) {
        fileRec.translation = text;
        // Update status to WIP if user has entered some translation
        if (text.trim().length > 0 && fileRec.status === 0) fileRec.status = 1;
        await idbPut('files', fileRec);
    }
    await renderTree();
    await updateCurrentProjectProgress();
    updateSaveStatus('saved');
}, 1500);

// Open a file from the tree and display its source/translation
async function openFile(path, restoreSelection = false) {
    if (!path) {
        els.pathLabel.textContent = '파일 선택';
        els.sourceContainer.innerHTML = '<p style="padding:16px; color:var(--color-text-secondary); text-align:center;">목록에서 파일을 선택하세요.</p>';
        els.translationArea.value = '';
        currentFilePath = null;
        return;
    }
    const rec = await idbGet('files', [currentProjectId, path]);
    if (!rec) { toast(`File not found: ${path}`, 'error'); return; }
    currentFilePath = path;
    els.pathLabel.textContent = path;
    els.translationArea.value = rec.translation || '';
    updateSaveStatus('');
    selectedBlockIndices.clear();
    const settings = await idbGet('settings', 'global') || defaultSettings();
    currentSourceBlocks = splitText(rec.text, settings.splitMode, settings.maxChunk);
    paintBlocks();
    if (restoreSelection) {
        const savedSelection = localStorage.getItem(`selection-${currentProjectId}-${path}`);
        if (savedSelection) {
            try {
                const indices = JSON.parse(savedSelection);
                selectedBlockIndices = new Set(indices);
                document.querySelectorAll('.source-block').forEach(el => {
                    if (selectedBlockIndices.has(parseInt(el.dataset.index, 10))) el.classList.add('selected');
                });
            } catch (e) { console.error("Could not parse selection", e); }
        }
    }
    // If there is exactly one block and nothing is selected, automatically select it for convenience
    if (currentSourceBlocks.length === 1 && selectedBlockIndices.size === 0) {
        selectedBlockIndices.add(0);
        const blockEl = els.sourceContainer.querySelector('.source-block');
        if (blockEl) blockEl.classList.add('selected');
    }
    document.querySelectorAll('.tree-item').forEach(el => el.classList.toggle('active', el.dataset.path === path));
    saveCurrentState();
}

// Split text into blocks based on the chosen mode and chunk size
function splitText(text, mode = 'auto', maxLen = 800) {
    if (!text || !text.trim()) return [];
    // If mode is 'none', do not split at all; return the entire text as a single block
    if (mode === 'none') {
        const trimmed = text.trim();
        return trimmed ? [trimmed] : [];
    }
    let chunks = [];
    if (mode === 'line') {
        chunks = text.split(/\r?\n/);
    } else if (mode === 'paragraph') {
        chunks = text.split(/\n{2,}/);
    } else {
        // auto: try paragraphs first, then fallback to lines
        chunks = text.split(/\n{2,}/);
        if (chunks.length < 2) chunks = text.split(/\r?\n/);
    }
    const out = [];
    let currentChunk = '';
    for (const chunk of chunks) {
        const trimmedChunk = chunk.trim();
        if (!trimmedChunk) continue;
        if (currentChunk.length > 0 && (currentChunk.length + trimmedChunk.length + 2) > maxLen) {
            out.push(currentChunk);
            currentChunk = '';
        }
        currentChunk = currentChunk ? `${currentChunk}\n\n${trimmedChunk}` : trimmedChunk;
    }
    if (currentChunk) out.push(currentChunk);
    return out;
}

// Render the source blocks in the UI
function paintBlocks() {
    els.sourceContainer.innerHTML = '';
    if (!currentSourceBlocks.length) {
        els.sourceContainer.innerHTML = '<p style="padding:16px; color:var(--color-text-secondary); text-align:center;">이 파일은 비어 있습니다.</p>';
        return;
    }
    currentSourceBlocks.forEach((block, idx) => {
        const card = document.createElement('div');
        card.className = 'source-block';
        card.dataset.index = idx;
        card.innerHTML = `<div class="source-block__meta"><span>#${idx+1}</span><span>${block.length} chars</span></div><div class="source-block__text"></div>`;
        card.querySelector('.source-block__text').textContent = block;
        card.addEventListener('click', () => {
            card.classList.toggle('selected');
            const i = parseInt(card.dataset.index, 10);
            if (selectedBlockIndices.has(i)) selectedBlockIndices.delete(i);
            else selectedBlockIndices.add(i);
            saveCurrentState();
        });
        els.sourceContainer.appendChild(card);
    });
}

// Render the project tree in the left pane
async function renderTree() {
    if (!currentProjectId) return;
    const files = await getFilesOfCurrent();
    els.fileTree.innerHTML = '';
    if (!files.length) {
        els.fileTree.innerHTML = '<p style="padding:16px; color:var(--color-text-secondary);">텍스트 파일이 없습니다.</p>';
        return;
    }
    files.forEach(file => {
        const item = document.createElement('div');
        item.className = 'tree-item';
        item.dataset.path = file.path;
        item.innerHTML = `<span class="status-dot status-dot--${file.status}"></span><span style="overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${file.path}</span>`;
        // Show the full file path on hover using the title attribute
        item.setAttribute('title', file.path);
        item.addEventListener('click', () => openFile(file.path));
        item.classList.toggle('active', file.path === currentFilePath);
        els.fileTree.appendChild(item);
    });
    // Update progress indicator when the tree is re-rendered
    await updateCurrentProjectProgress();
}

// Refresh the project dropdown and toggle welcome screen/main workspace
async function refreshProjectList() {
    const allProjects = await idbGetAll('projects');
    els.projectSelect.innerHTML = '';
    if (!allProjects.length) {
        els.welcomeScreen.classList.remove('hidden');
        els.mainWorkspace.style.display = 'none';
        return;
    }
    els.welcomeScreen.classList.add('hidden');
    els.mainWorkspace.style.display = 'grid';
    allProjects.forEach(p => {
        const opt = document.createElement('option');
        opt.value = p.id;
        opt.textContent = p.name;
        els.projectSelect.appendChild(opt);
    });
}

// Create a new project by reading a ZIP of text files
async function createProjectFromZip(file) {
    const name = file.name.replace(/\.zip$/i, '');
    const id = 'p_' + Date.now();
    await idbPut('projects', { id, name, createdAt: Date.now() });
    try {
        const zip = await JSZip.loadAsync(file);
        const filePromises = [];
        zip.forEach((path, entry) => {
            if (entry.dir || !isTextLike(path)) return;
            const promise = entry.async('string').then(text => idbPut('files', { projectId: id, path, text, status: 0, translation: '' }));
            filePromises.push(promise);
        });
        await Promise.all(filePromises);
        toast(`프로젝트 "${name}"이(가) 생성되었습니다. 파일 ${filePromises.length}개를 불러왔습니다.`, 'ok');
        currentProjectId = id;
        await refreshProjectList();
        els.projectSelect.value = id;
        await renderTree();
        const first = (await getFilesOfCurrent())[0]?.path;
        await openFile(first);
        await updateCurrentProjectProgress();
    } catch (e) {
        toast(`ZIP 파일을 읽는 중 오류가 발생했습니다: ${e.message}`, 'error');
    }
}

// Helper to check if a file path is text-like based on extension
// Determine whether a file is likely to be plain text based on its extension.
// This function now includes a comprehensive list of extensions for documents,
// subtitles, source code, configuration, markup, and other common text-like
// formats. It allows the importer to handle a wide variety of text files such as
// SMI, HTML, subtitle formats, scripts, configs, and more. The list can be
// further extended as needed.
function isTextLike(path) {
    const lower = path.toLowerCase();
    const textExtensions = [
        // Plain text and markup
        '.txt', '.text', '.md', '.markdown', '.html', '.htm', '.xhtml', '.xml', '.svg', '.json', '.json5', '.yaml', '.yml',
        '.csv', '.tsv', '.psv', '.log', '.rtf', '.tex', '.sty', '.cls', '.texi', '.texinfo',
        '.org', '.rst', '.adoc', '.asciidoc', '.textile', '.vue', '.jsx', '.tsx', '.jsx', '.vue',
        // Data and configuration files
        '.ini', '.cfg', '.conf', '.config', '.toml', '.properties', '.prefs', '.plist', '.env',
        // Stylesheets and scripts
        '.css', '.scss', '.less', '.js', '.mjs', '.ts', '.jsx', '.tsx', '.coffee', '.ps1',
        // Programming languages
        '.py', '.rb', '.pl', '.php', '.java', '.c', '.cpp', '.cc', '.h', '.hpp', '.cs', '.swift', '.go', '.rs', '.dart', '.kt', '.kts', '.groovy', '.scala', '.r', '.R', '.rmd', '.m', '.mm', '.matlab', '.lua', '.sql', '.vb', '.vbs', '.ps1', '.sh', '.bash', '.zsh', '.fish', '.cmd', '.bat', '.make', '.mak', '.gradle',
        // Subtitle and caption formats
        '.srt', '.vtt', '.smi', '.sami', '.ssa', '.ass', '.sub', '.lrc', '.dfxp', '.ttml', '.vtt', '.sup', '.vbs', '.vat',
        // Miscellaneous text-like files
        '.yaml', '.yml', '.csv', '.tsv', '.psv', '.jsonl', '.mdx', '.rpy', '.tex', '.sty', '.lisp', '.clj', '.cljc', '.edn', '.dart', '.fs', '.fsi', '.fsx', '.elm', '.purs', '.ipynb', '.ipynb', '.tsconfig', '.babelrc', '.eslintrc', '.prettierrc'
    ];
    return textExtensions.some(ext => lower.endsWith(ext));
}

// Retrieve all files for current project
async function getFilesOfCurrent() {
    if (!currentProjectId) return [];
    return (await idbGetAll('files')).filter(f => f.projectId === currentProjectId);
}

// Compute progress for a given project. Returns an object with counts and percentage.
async function getProjectProgress(projectId) {
    const files = (await idbGetAll('files')).filter(f => f.projectId === projectId);
    const total = files.length;
    let done = 0, wip = 0, todo = 0;
    files.forEach(f => {
        if (f.status === 2) done++;
        else if (f.status === 1) wip++;
        else todo++;
    });
    const percentDone = total ? Math.round((done / total) * 100) : 0;
    return { total, done, wip, todo, percentDone };
}

// Update the progress indicator in the header for the current project
async function updateCurrentProjectProgress() {
    if (!currentProjectId || !els.projectProgress) return;
    const { total, done, wip, percentDone } = await getProjectProgress(currentProjectId);
    if (total === 0) {
        els.projectProgress.innerHTML = '';
        return;
    }
    const barWidth = percentDone;
    els.projectProgress.innerHTML = `
        <div class="project-progress-bar">
            <div class="project-progress-bar__fill" style="width:${barWidth}%"></div>
        </div>
        <span style="font-size:0.75rem; color: var(--color-text-secondary); white-space: nowrap;">${done}/${total} 완료 (${percentDone}%)</span>
    `;
}

// Show the project management dialog and populate it with projects and their progress
async function showProjectManagement() {
    const projects = await idbGetAll('projects');
    const container = document.getElementById('projectList');
    container.innerHTML = '';
    if (!projects.length) {
        container.innerHTML = '<p style="padding:12px; color:var(--color-text-secondary);">프로젝트가 없습니다.</p>';
    } else {
        for (const project of projects) {
            const progress = await getProjectProgress(project.id);
            const div = document.createElement('div');
            div.className = 'project-item';
            div.dataset.projectId = project.id;
            // Build progress bar
            const bar = `<div class="project-progress-bar"><div class="project-progress-bar__fill" style="width:${progress.percentDone}%"></div></div>`;
            div.innerHTML = `
                <span style="display:flex; align-items:center; gap:8px;">
                    <i data-lucide="folder"></i>
                    <span class="project-name">${project.name}</span>
                </span>
                <div class="project-progress" style="width:160px;">
                    ${bar}
                    <span style="font-size:0.75rem; color:var(--color-text-secondary);">${progress.done}/${progress.total}</span>
                </div>
            `;
            div.addEventListener('click', async () => {
                currentProjectId = project.id;
                els.projectSelect.value = project.id;
                await renderTree();
                await openFile((await getFilesOfCurrent())[0]?.path);
                await updateCurrentProjectProgress();
                document.getElementById('projectMgmtDlg').close();
            });
            container.appendChild(div);
        }
    }
    const dlg = document.getElementById('projectMgmtDlg');
    dlg.showModal();
    lucide.createIcons();
}

// Build the AI prompt text from selected blocks
async function buildPromptText() {
    if (!currentFilePath) return null;
    const settings = await idbGet('settings','global') || defaultSettings();
    const fileRecord = await idbGet('files', [currentProjectId, currentFilePath]);
    const sourceText = [...selectedBlockIndices].sort((a,b) => a - b).map(i => currentSourceBlocks[i]).join('\n\n') || fileRecord.text || '';
    if (!sourceText.trim()) return null;
    const template = settings.promptTemplate || DEFAULT_TEMPLATE;
        // Replace common placeholders. Also support replacing the Korean placeholder
        // {{번역대상}} so that the metaPrompt can insert the text to translate.
        return template
            .replaceAll('{{source_lang}}', settings.sourceLang)
            .replaceAll('{{target_lang}}', settings.targetLang)
            .replaceAll('{{path}}', currentFilePath)
            .replaceAll('{{filename}}', currentFilePath.split('/').pop())
            .replaceAll('{{instructions}}', settings.styleNotes || '')
            .replaceAll('{{text}}', sourceText)
            .replaceAll('{{번역대상}}', sourceText);
}

// Copy the AI prompt to clipboard
async function copyPrompt() {
    const btn = els.btnCopyPrompt;
    const text = btn.querySelector('span');
    // Try to find an existing icon element (svg or i) if present
    let iconEl = btn.querySelector('svg');
    if (!iconEl) iconEl = btn.querySelector('i');
    btn.disabled = true;
    if (iconEl) iconEl.classList.add('animate-spin');
    text.textContent = '복사 중...';
    const prompt = await buildPromptText();
    if (prompt) {
        try {
            // Prefer the Clipboard API when available
            if (navigator.clipboard && navigator.clipboard.writeText) {
                await navigator.clipboard.writeText(prompt);
            } else {
                // Fallback: create a temporary textarea and copy via execCommand
                const tempArea = document.createElement('textarea');
                tempArea.value = prompt;
                // Avoid affecting layout
                tempArea.style.position = 'fixed';
                tempArea.style.top = '-1000px';
                document.body.appendChild(tempArea);
                tempArea.select();
                try {
                    document.execCommand('copy');
                } finally {
                    document.body.removeChild(tempArea);
                }
            }
            // Mark file as in progress if it is currently TODO (status 0)
            if (currentProjectId && currentFilePath) {
                const rec = await idbGet('files', [currentProjectId, currentFilePath]);
                if (rec && rec.status === 0) {
                    rec.status = 1;
                    await idbPut('files', rec);
                    await renderTree();
                }
                await updateCurrentProjectProgress();
            }
            toast('프롬프트가 복사되었습니다!', 'ok');
        } catch(e) {
            toast('복사에 실패했습니다.', 'error');
        }
    } else {
        toast('프롬프트를 생성할 블록을 선택하세요.', 'error');
    }
    setTimeout(() => {
        btn.disabled = false;
        // Remove the spinner class if it was added
        if (iconEl) iconEl.classList.remove('animate-spin');
        text.textContent = 'AI 프롬프트 복사';
    }, 1000);
}

// Show revision history for the current file
async function showHistory() {
    if (!currentProjectId || !currentFilePath) return toast('먼저 파일을 열어주세요.');
    const revisions = (await idbGetAll('revisions', 'file_idx', IDBKeyRange.bound([currentProjectId, currentFilePath], [currentProjectId, currentFilePath, '\uffff']))).sort((a,b) => b.timestamp - a.timestamp);
    const listEl = els.historyDialog.querySelector('#revisionList');
    const diffEl = els.historyDialog.querySelector('#diffOutput');
    const restoreBtn = els.historyDialog.querySelector('#btnRestoreVersion');
    listEl.innerHTML = '';
    diffEl.innerHTML = '변경 사항을 보려면 버전을 선택하세요.';
    restoreBtn.disabled = true;
    if (!revisions.length) {
        listEl.innerHTML = '<div style="padding:12px; color:var(--color-text-secondary);">기록이 없습니다.</div>';
    } else {
        revisions.forEach(rev => {
            const item = document.createElement('div');
            item.className = 'revision-item';
            item.dataset.id = rev.id;
            item.innerHTML = `<span>${new Date(rev.timestamp).toLocaleString()}</span><i data-lucide="chevron-right" style="width:16px; color:var(--color-text-secondary);"></i>`;
            item.addEventListener('click', () => {
                listEl.querySelectorAll('.revision-item').forEach(el => el.classList.remove('selected'));
                item.classList.add('selected');
                restoreBtn.disabled = false;
                const currentText = els.translationArea.value;
                diffEl.innerHTML = '';
                const diff = Diff.diffChars(rev.content, currentText);
                diff.forEach(part => {
                    const node = document.createElement(part.added ? 'ins' : part.removed ? 'del' : 'span');
                    node.textContent = part.value;
                    diffEl.appendChild(node);
                });
                lucide.createIcons();
            });
            listEl.appendChild(item);
        });
    }
    els.historyDialog.showModal();
    lucide.createIcons();
}

// Export entire database to a JSON file
async function fullExport() {
    toast('내보내는 중...');
    try {
        const data = {
            projects: await idbGetAll('projects'),
            files: await idbGetAll('files'),
            settings: await idbGetAll('settings'),
            revisions: await idbGetAll('revisions'),
        };
        const blob = new Blob([JSON.stringify({ v:2, ts: Date.now(), data })], {type:'application/json'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `trassist_backup_${new Date().toISOString().slice(0,10)}.json`;
        a.click();
        URL.revokeObjectURL(a.href);
    } catch(e) {
        toast('내보내기에 실패했습니다!', 'error');
    }
}

// Import full backup JSON and replace current DB
async function fullImport() {
    if (!confirm('현재 모든 데이터를 삭제하고 백업 파일로 교체합니다. 계속하시겠습니까?')) return;
    const file = els.importFile.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const backup = JSON.parse(e.target.result);
            if (!backup.v || !backup.data) throw new Error('Invalid backup file format.');
            toast('가져오는 중... 잠시만 기다려 주세요.');
            await Promise.all([idbClear('projects'), idbClear('files'), idbClear('settings'), idbClear('revisions')]);
            await Promise.all([
                ...backup.data.projects.map(item => idbPut('projects', item)),
                ...backup.data.files.map(item => idbPut('files', item)),
                ...backup.data.settings.map(item => idbPut('settings', item)),
                ...backup.data.revisions.map(item => idbPut('revisions', item)),
            ]);
            toast('가져오기가 성공했습니다! 다시 로드합니다...', 'ok');
            setTimeout(() => window.location.reload(), 1500);
        } catch(err) {
            toast(`가져오기에 실패했습니다: ${err.message}`, 'error');
        }
    };
    reader.readAsText(file);
}

// Render the settings modal dialog
async function renderSettingsModal() {
    const s = await idbGet('settings', 'global') || defaultSettings();
        els.settingsDlg.innerHTML = `
        <form method="dialog" style="width:500px;">
            <div class="dialog__header">
                <h2>설정</h2>
                <button class="btn btn--icon" value="cancel" title="닫기"><i data-lucide="x"></i></button>
            </div>
            <div class="dialog__body" style="display:flex; flex-direction:column; gap: 16px;">
                <!-- Language selection -->
                <div>
                    <label class="form-label" style="font-weight:500;">언어</label>
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <input id="dlgSourceLang" class="form-select" style="width:100%;" value="${s.sourceLang}" />
                        <i data-lucide="arrow-right" style="color: var(--color-text-secondary);"></i>
                        <input id="dlgTargetLang" class="form-select" style="width:100%;" value="${s.targetLang}" />
                    </div>
                </div>
                <!-- Text split mode selection -->
                <div>
                    <label class="form-label" style="font-weight:500;">텍스트 분할 방식</label>
                    <select id="dlgSplitMode" class="form-select" style="width:100%;">
                        <option value="none" ${s.splitMode === 'none' ? 'selected' : ''}>분할 안 함 (전체 텍스트)</option>
                        <option value="auto" ${s.splitMode === 'auto' ? 'selected' : ''}>자동 (문단 우선)</option>
                        <option value="paragraph" ${s.splitMode === 'paragraph' ? 'selected' : ''}>문단별</option>
                        <option value="line" ${s.splitMode === 'line' ? 'selected' : ''}>줄별</option>
                    </select>
                    <p style="font-size:0.75rem; color: var(--color-text-secondary); margin-top:4px;">블록 선택 없이 전체 복사를 위해 ‘분할 안 함’을 선택하세요.</p>
                </div>
                <!-- Style notes -->
                <div>
                    <label class="form-label" style="font-weight:500;">지침</label>
                    <textarea id="dlgStyleNotes" class="form-select" style="width:100%; min-height: 80px; resize: vertical; font-family:var(--font-ui);">${s.styleNotes}</textarea>
                </div>
                <!-- Prompt template -->
                <div>
                    <label class="form-label" style="font-weight:500;">AI 프롬프트 템플릿</label>
                    <textarea id="dlgPromptTemplate" class="form-select" style="width:100%; min-height: 150px; resize: vertical; font-family:var(--font-mono);">${s.promptTemplate}</textarea>
                </div>
            </div>
            <div class="dialog__footer">
                <button type="button" id="btnResetTemplate" class="btn btn--secondary" style="margin-right:auto;">템플릿 초기화</button>
                <button class="btn btn--secondary" value="cancel">취소</button>
                <button class="btn btn--primary" value="save">저장</button>
            </div>
        </form>`;
    els.settingsDlg.showModal();
    lucide.createIcons();
    // Reset template button resets to default
    document.getElementById('btnResetTemplate').addEventListener('click', () => {
        document.getElementById('dlgPromptTemplate').value = DEFAULT_TEMPLATE;
    });
    // Handle save/cancel events
        els.settingsDlg.onclose = async () => {
            if (els.settingsDlg.returnValue === 'save') {
                const newSettings = {
                    id: 'global',
                    sourceLang: document.getElementById('dlgSourceLang').value,
                    targetLang: document.getElementById('dlgTargetLang').value,
                    styleNotes: document.getElementById('dlgStyleNotes').value,
                    promptTemplate: document.getElementById('dlgPromptTemplate').value,
                    // Persist the chosen split mode
                    splitMode: document.getElementById('dlgSplitMode').value,
                };
                await idbPut('settings', newSettings);
                updateLangBadge(newSettings.sourceLang, newSettings.targetLang);
                toast('설정이 저장되었습니다!', 'ok');
            }
        };
}

// Setup event listeners for UI actions
function setupEventListeners() {
    els.btnOpenZip.addEventListener('click', () => els.zipFileInput.click());
    // Additional button in the header to open a ZIP file at any time
    if (els.btnOpenZipHeader) {
        els.btnOpenZipHeader.addEventListener('click', () => els.zipFileInput.click());
    }
    // Project management button
    if (els.btnManageProjects) {
        els.btnManageProjects.addEventListener('click', () => showProjectManagement());
    }
    els.zipFileInput.addEventListener('change', async e => { if(e.target.files[0]) await createProjectFromZip(e.target.files[0]); });
    els.projectSelect.addEventListener('change', async () => {
        currentProjectId = els.projectSelect.value;
        await renderTree();
        const firstFile = (await getFilesOfCurrent())[0]?.path;
        await openFile(firstFile);
        await updateCurrentProjectProgress();
    });
    els.btnExportZip.addEventListener('click', async () => {
        if (!currentProjectId) return toast('프로젝트가 로드되지 않았습니다.');
        const project = await idbGet('projects', currentProjectId);
        const files = await getFilesOfCurrent();
        const zip = new JSZip();
        files.filter(f => f.translation?.trim()).forEach(f => zip.file(f.path, f.translation));
        if (Object.keys(zip.files).length === 0) return toast('내보낼 번역된 파일이 없습니다.', 'error');
        const blob = await zip.generateAsync({ type: 'blob' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${project.name}_translated.zip`;
        a.click();
        URL.revokeObjectURL(a.href);
    });
    els.btnSettings.addEventListener('click', renderSettingsModal);
    els.btnCopyPrompt.addEventListener('click', copyPrompt);
    els.translationArea.addEventListener('input', () => debouncedSave(els.translationArea.value));
    els.btnMarkDone.addEventListener('click', async () => {
        if (!currentFilePath) return toast('No file selected.', 'error');
        const rec = await idbGet('files', [currentProjectId, currentFilePath]);
        rec.status = 2;
        await idbPut('files', rec);
        await renderTree();
        await updateCurrentProjectProgress();
        toast('완료로 표시되었습니다.', 'ok');
    });
    els.btnHistory.addEventListener('click', showHistory);
    els.btnDataActions.addEventListener('click', (e) => {
        e.stopPropagation();
        els.dataDropdownMenu.style.display = 'block';
    });
    document.addEventListener('click', () => { els.dataDropdownMenu.style.display = 'none'; });
    els.btnFullExport.addEventListener('click', fullExport);
    els.btnFullImport.addEventListener('click', () => els.importFile.click());
    els.importFile.addEventListener('change', fullImport);
    els.btnRestoreVersion.addEventListener('click', async () => {
        const selectedItem = els.historyDialog.querySelector('.revision-item.selected');
        if (!selectedItem) return;
        const revId = parseInt(selectedItem.dataset.id, 10);
        const revision = await idbGet('revisions', revId);
        if (revision) {
            els.translationArea.value = revision.content;
            els.translationArea.dispatchEvent(new Event('input', { bubbles: true }));
            els.historyDialog.close();
            toast('버전이 복원되었습니다!', 'ok');
        }
    });
}

    // Setup button interactions for touch devices (show labels on tap)
    function setupButtonInteractions() {
        const isTouch = window.matchMedia('(hover: none)').matches;
        document.querySelectorAll('.btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (isTouch) {
                    btn.classList.add('show-label');
                    // Clear any existing timeout on this button
                    if (btn._labelTimeout) clearTimeout(btn._labelTimeout);
                    btn._labelTimeout = setTimeout(() => {
                        btn.classList.remove('show-label');
                    }, 1500);
                }
            });
        });
    }

// Application initialization
async function init() {
    try {
        await openDB();
        await loadSettings();
        await refreshProjectList();
            await restoreLastState();
            setupEventListeners();
            setupButtonInteractions();
            // After everything is set up, ensure icons are rendered. If lucide
            // failed to load, our stub will simply no-op here.
            lucide.createIcons();
    } catch(e) {
        console.error("Initialization failed:", e);
        document.body.innerHTML = `<div style="padding:40px; text-align:center;"><h1>Fatal Error</h1><p>Could not initialize application. Your browser might not support IndexedDB or is in private mode.</p><p style="color:red;">${e.message}</p></div>`;
    }
}

// Kick off the app once DOM is ready
document.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>
