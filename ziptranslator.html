<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>eBook 번역 관리 도구 v5.1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <style>
        /* 기본 스타일 및 애니메이션 */
        body { font-family: 'Pretendard', sans-serif; background-color: #f0f2f5; }
        .card { background-color: white; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); transition: all 0.2s ease-in-out; }
        .card:hover { transform: translateY(-5px); box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); }
        .btn { padding: 0.6rem 1.2rem; border-radius: 0.5rem; font-weight: 600; transition: all 0.2s ease-in-out; }
        .btn-primary { background-color: #2563eb; color: white; }
        .btn-primary:hover { background-color: #1d4ed8; }
        .btn-danger { background-color: #dc2626; color: white; }
        .btn-danger:hover { background-color: #b91c1c; }
        .btn-secondary { background-color: #e5e7eb; color: #374151; }
        .btn-secondary:hover { background-color: #d1d5db; }
        .btn-warning { background-color: #f97316; color: white; }
        .btn-warning:hover { background-color: #ea580c; }
        .progress-bar-bg { background-color: #e5e7eb; }
        .progress-bar { background-color: #2563eb; transition: width 0.5s ease-in-out; }
        .sidebar { scrollbar-width: thin; scrollbar-color: #a0aec0 #f0f2f5; }
        .sidebar::-webkit-scrollbar { width: 6px; }
        .sidebar::-webkit-scrollbar-track { background: #f0f2f5; }
        .sidebar::-webkit-scrollbar-thumb { background-color: #a0aec0; border-radius: 10px; border: 3px solid #f0f2f5; }
        .status-icon { width: 1rem; height: 1rem; }
        .status-untranslated { color: #9ca3af; }
        .status-translated { color: #22c55e; }
        .modal-backdrop { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 50; }
        .modal-content { background: white; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25); }
        .file-item.copied-prompt { background-color: #fffbeb; }

        /* 토스트 메시지 스타일 */
        @keyframes toast-in {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes toast-out {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        .toast {
            animation: toast-in 0.5s ease, toast-out 0.5s ease 2.5s forwards;
            min-width: 250px;
        }
    </style>
</head>
<body class="text-gray-800">

    <div id="app" class="min-h-screen">

        <div id="loading-view" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex-col items-center justify-center z-50 hidden">
            <div class="w-16 h-16 border-4 border-t-4 border-t-blue-500 border-gray-200 rounded-full animate-spin"></div>
            <p id="loading-message" class="text-white text-xl mt-4">프로젝트 처리 중...</p>
        </div>
        
        <div id="confirm-modal" class="modal-backdrop hidden">
            <div class="modal-content w-full max-w-md">
                <h3 id="confirm-title" class="text-lg font-bold mb-4">프로젝트 삭제</h3>
                <p id="confirm-message" class="mb-6">정말로 이 프로젝트를 삭제하시겠습니까? 모든 관련 데이터가 영구적으로 제거됩니다.</p>
                <div class="flex justify-end space-x-4">
                    <button id="confirm-cancel-btn" class="btn btn-secondary">취소</button>
                    <button id="confirm-ok-btn" class="btn btn-danger">삭제</button>
                </div>
            </div>
        </div>

        <div id="dashboard-view">
            <header class="bg-white shadow-sm sticky top-0 z-10">
                <div class="max-w-7xl mx-auto py-4 px-4 sm:px-6 lg:px-8 flex justify-between items-center">
                    <h1 class="text-2xl font-bold text-gray-900">eBook 번역 대시보드</h1>
                    <button id="new-project-btn" class="btn btn-primary">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                        새 프로젝트 시작
                    </button>
                    <input type="file" id="zip-file-input" class="hidden" accept=".zip">
                </div>
            </header>
            <main>
                <div class="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
                    <div id="project-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        </div>
                     <div id="no-project-message" class="text-center py-12 text-gray-500 hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                          <path stroke-linecap="round" stroke-linejoin="round" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />
                        </svg>
                        <h3 class="mt-2 text-sm font-medium text-gray-900">프로젝트 없음</h3>
                        <p class="mt-1 text-sm text-gray-500">새 프로젝트를 시작하여 번역 작업을 시작하세요.</p>
                    </div>
                </div>
            </main>
        </div>

        <div id="workspace-view" class="hidden h-screen flex flex-col">
            <header class="bg-white shadow-sm flex-shrink-0">
                <div class="max-w-full mx-auto py-3 px-4 sm:px-6 lg:px-8 flex justify-between items-center">
                    <div class="flex items-center space-x-4">
                        <button id="back-to-dashboard-btn" class="p-2 rounded-full hover:bg-gray-200">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg>
                        </button>
                        <h2 id="workspace-project-name" class="text-xl font-bold"></h2>
                    </div>
                    <div class="flex items-center space-x-4">
                        <button id="export-btn" class="btn btn-secondary">내보내기</button>
                        <button id="copy-prompt-btn" class="btn btn-secondary">프롬프트 복사</button>
                        <button id="save-translation-btn" class="btn btn-primary">저장</button>
                    </div>
                </div>
            </header>
            <main class="flex-grow flex overflow-hidden">
                <aside class="w-1/4 bg-gray-50 border-r border-gray-200 flex flex-col">
                    <div class="p-4 border-b">
                        <h3 class="font-semibold">파일 목록</h3>
                    </div>
                    <div id="file-list" class="flex-grow overflow-y-auto sidebar p-2">
                        </div>
                </aside>

                <div class="w-3/4 flex flex-col overflow-hidden">
                     <div class="p-4 border-b bg-gray-50">
                        <label for="prompt-template-input" class="block text-sm font-medium text-gray-700 mb-1">프롬프트 템플릿 ( `&lt;&lt;원문&gt;&gt;` 변수 사용)</label>
                        <input type="text" id="prompt-template-input" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500" placeholder="예: 다음 텍스트를 한국어로 번역해줘: <<원문>>">
                    </div>
                    <div class="flex-grow flex min-h-0">
                        <section class="w-1/2 border-r p-4 flex flex-col">
                            <h3 class="text-lg font-semibold mb-2 flex-shrink-0">원문: <span id="original-file-name" class="font-normal text-gray-600"></span></h3>
                            <div class="flex-grow bg-gray-100 rounded-md p-3 overflow-y-auto">
                                <pre id="original-text" class="whitespace-pre-wrap text-sm leading-relaxed"></pre>
                            </div>
                        </section>
                        <section class="w-1/2 p-4 flex flex-col">
                            <h3 class="text-lg font-semibold mb-2 flex-shrink-0">번역문</h3>
                            <textarea id="translated-text" class="flex-grow w-full border border-gray-300 rounded-md p-3 text-sm leading-relaxed focus:ring-blue-500 focus:border-blue-500" placeholder="여기에 번역문을 입력하세요..."></textarea>
                        </section>
                    </div>
                </div>
            </main>
        </div>
    </div>
    
    <div id="toast-container" class="fixed top-5 right-5 z-[100] space-y-2"></div>

    <script id="worker" type="javascript/worker">
        // 워커 스코프에서 JSZip 라이브러리를 로드합니다.
        self.importScripts('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');

        self.onmessage = async (e) => {
            const { type, payload } = e.data;

            if (type === 'PROCESS_ZIP') {
                const { file } = payload;
                const zip = new JSZip();

                try {
                    self.postMessage({ type: 'PROGRESS', payload: 'ZIP 파일 로딩 중...' });
                    const content = await zip.loadAsync(file);
                    self.postMessage({ type: 'PROGRESS', payload: '파일 목록 분석 중...' });
                    
                    const filesToProcess = [];
                    content.forEach((relativePath, zipEntry) => {
                        if (!zipEntry.dir && relativePath.toLowerCase().endsWith('.txt')) {
                            filesToProcess.push(zipEntry);
                        }
                    });

                    const totalFiles = filesToProcess.length;
                    const extractedFiles = [];

                    for (let i = 0; i < totalFiles; i++) {
                        const zipEntry = filesToProcess[i];
                        const text = await zipEntry.async('string');
                        extractedFiles.push({
                            name: zipEntry.name,
                            originalText: text,
                        });
                        if ((i + 1) % 10 === 0 || i + 1 === totalFiles) {
                           self.postMessage({ type: 'PROGRESS', payload: `파일 처리 중... (${i + 1}/${totalFiles})` });
                        }
                    }

                    self.postMessage({ type: 'SUCCESS', payload: { files: extractedFiles } });
                } catch (error) {
                    self.postMessage({ type: 'ERROR', payload: error.message });
                }
            }
        };
    </script>

    <script type="module">
        const DB_NAME = 'eBookTranslatorDB';
        const DB_VERSION = 1;
        const PROJECTS_STORE = 'projects';
        const FILES_STORE = 'files';

        let db;
        let worker;
        let currentProjectId = null;
        let currentFile = null;
        let workspaceFileMap = new Map();

        // DOM 요소
        const views = {
            loading: document.getElementById('loading-view'),
            dashboard: document.getElementById('dashboard-view'),
            workspace: document.getElementById('workspace-view'),
        };
        const loadingMessage = document.getElementById('loading-message');
        const newProjectBtn = document.getElementById('new-project-btn');
        const zipFileInput = document.getElementById('zip-file-input');
        const projectList = document.getElementById('project-list');
        const noProjectMessage = document.getElementById('no-project-message');
        const backToDashboardBtn = document.getElementById('back-to-dashboard-btn');
        const workspaceProjectName = document.getElementById('workspace-project-name');
        const fileListContainer = document.getElementById('file-list');
        const originalFileName = document.getElementById('original-file-name');
        const originalTextEl = document.getElementById('original-text');
        const translatedTextEl = document.getElementById('translated-text');
        const saveTranslationBtn = document.getElementById('save-translation-btn');
        const copyPromptBtn = document.getElementById('copy-prompt-btn');
        const exportBtn = document.getElementById('export-btn');
        const promptTemplateInput = document.getElementById('prompt-template-input');
        const confirmModal = document.getElementById('confirm-modal');
        const confirmOkBtn = document.getElementById('confirm-ok-btn');
        const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
        const toastContainer = document.getElementById('toast-container');

        // --- 유틸리티 ---
        const utils = {
            /**
             * 텍스트를 클립보드에 복사합니다.
             * 최신 Clipboard API를 우선적으로 사용하고, 지원되지 않을 경우 execCommand로 fallback합니다.
             * @param {string} text - 복사할 텍스트
             * @returns {Promise<boolean>} 복사 성공 여부를 나타내는 Promise
             */
            async copyToClipboard(text) {
                // 최신 방법: navigator.clipboard (보안 컨텍스트 필요: https, localhost)
                if (navigator.clipboard && window.isSecureContext) {
                    try {
                        await navigator.clipboard.writeText(text);
                        return true;
                    } catch (err) {
                        console.error('navigator.clipboard.writeText 실패:', err);
                        // 실패 시 아래의 fallback으로 넘어감
                    }
                }

                // Fallback 방법: execCommand (구형 브라우저 및 모바일 환경 지원)
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed"; // 화면에 보이지 않게 처리
                textArea.style.top = "-9999px";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                
                textArea.focus();
                textArea.select();

                let success = false;
                try {
                    success = document.execCommand('copy');
                } catch (err) {
                    console.error('document.execCommand 실패:', err);
                    success = false;
                }

                document.body.removeChild(textArea);
                return success;
            }
        };

        // --- 데이터베이스 관리 ---
        const dbManager = {
            initDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onerror = (event) => reject("IndexedDB 열기 실패: " + event.target.errorCode);
                    request.onsuccess = (event) => {
                        db = event.target.result;
                        resolve(db);
                    };
                    request.onupgradeneeded = (event) => {
                        const dbInstance = event.target.result;
                        if (!dbInstance.objectStoreNames.contains(PROJECTS_STORE)) {
                            dbInstance.createObjectStore(PROJECTS_STORE, { keyPath: 'id' });
                        }
                        if (!dbInstance.objectStoreNames.contains(FILES_STORE)) {
                            const fileStore = dbInstance.createObjectStore(FILES_STORE, { keyPath: ['projectId', 'name'] });
                            fileStore.createIndex('by_project', 'projectId', { unique: false });
                        }
                    };
                });
            },
            addProject(project) {
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([PROJECTS_STORE], 'readwrite');
                    const store = transaction.objectStore(PROJECTS_STORE);
                    store.add(project);
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = (event) => reject(event.target.error);
                });
            },
            getProjects() {
                return new Promise((resolve, reject) => {
                    const store = db.transaction([PROJECTS_STORE], 'readonly').objectStore(PROJECTS_STORE);
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            getProject(id) {
                return new Promise((resolve, reject) => {
                    const store = db.transaction([PROJECTS_STORE], 'readonly').objectStore(PROJECTS_STORE);
                    const request = store.get(id);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            updateProject(project) {
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([PROJECTS_STORE], 'readwrite');
                    const store = transaction.objectStore(PROJECTS_STORE);
                    store.put(project);
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = (event) => reject(event.target.error);
                });
            },
            deleteProject(id) {
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([PROJECTS_STORE, FILES_STORE], 'readwrite');
                    const projectsStore = transaction.objectStore(PROJECTS_STORE);
                    const filesStore = transaction.objectStore(FILES_STORE);
                    
                    projectsStore.delete(id);

                    const fileIndex = filesStore.index('by_project');
                    const keyRange = IDBKeyRange.only(id);
                    const cursorRequest = fileIndex.openCursor(keyRange);

                    cursorRequest.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            cursor.delete();
                            cursor.continue();
                        }
                    };
                    
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = (event) => reject(event.target.error);
                });
            },
            addFiles(files) {
                 return new Promise((resolve, reject) => {
                    const transaction = db.transaction([FILES_STORE], 'readwrite');
                    const store = transaction.objectStore(FILES_STORE);
                    let count = 0;
                    if (files.length === 0) {
                        resolve();
                        return;
                    }
                    files.forEach(file => {
                        const request = store.add(file);
                        request.onsuccess = () => {
                            count++;
                            if (count === files.length) {
                                resolve();
                            }
                        };
                    });
                    transaction.onerror = (event) => reject(event.target.error);
                });
            },
            getFilesForProject(projectId) {
                return new Promise((resolve, reject) => {
                    const store = db.transaction([FILES_STORE], 'readonly').objectStore(FILES_STORE);
                    const index = store.index('by_project');
                    const request = index.getAll(projectId);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            updateFile(file) {
                 return new Promise((resolve, reject) => {
                    const transaction = db.transaction([FILES_STORE], 'readwrite');
                    const store = transaction.objectStore(FILES_STORE);
                    store.put(file);
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = (event) => reject(event.target.error);
                });
            }
        };

        // --- UI 렌더링 ---
        const uiManager = {
            switchView(viewName) {
                Object.values(views).forEach(v => v.classList.add('hidden'));
                if (views[viewName]) {
                    views[viewName].classList.remove('hidden');
                }
            },
            showLoading(message) {
                loadingMessage.textContent = message;
                views.loading.classList.remove('hidden');
                views.loading.classList.add('flex');
            },
            hideLoading() {
                views.loading.classList.add('hidden');
                views.loading.classList.remove('flex');
            },
            async renderDashboard() {
                const projects = await dbManager.getProjects();
                projectList.innerHTML = '';
                if (projects.length === 0) {
                    noProjectMessage.classList.remove('hidden');
                } else {
                    noProjectMessage.classList.add('hidden');
                    // 최신 프로젝트가 위로 오도록 정렬
                    projects.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                    
                    for (const project of projects) {
                        const files = await dbManager.getFilesForProject(project.id);
                        const totalFiles = files.length;
                        const translatedFiles = files.filter(f => f.status === 'translated').length;
                        const progress = totalFiles > 0 ? Math.round((translatedFiles / totalFiles) * 100) : 0;
                        
                        const card = document.createElement('div');
                        card.className = 'card p-6';
                        card.innerHTML = `
                            <div class="flex justify-between items-start">
                                <h3 class="text-xl font-bold mb-2 truncate" title="${project.name}">${project.name}</h3>
                                <button data-project-id="${project.id}" class="delete-project-btn p-2 text-gray-400 hover:text-red-600 rounded-full flex-shrink-0">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clip-rule="evenodd" /></svg>
                                </button>
                            </div>
                            <p class="text-sm text-gray-500 mb-4">생성일: ${new Date(project.createdAt).toLocaleDateString()}</p>
                            <div class="mb-2">
                                <div class="flex justify-between text-sm font-medium text-gray-600">
                                    <span>진행률</span>
                                    <span>${progress}% (${translatedFiles}/${totalFiles})</span>
                                </div>
                                <div class="w-full progress-bar-bg rounded-full h-2.5 mt-1">
                                    <div class="progress-bar h-2.5 rounded-full" style="width: ${progress}%"></div>
                                </div>
                            </div>
                            <div class="mt-6 text-right">
                                <button data-project-id="${project.id}" class="open-project-btn btn btn-primary">작업 시작</button>
                            </div>
                        `;
                        projectList.appendChild(card);
                    }
                }
                this.switchView('dashboard');
            },
            async renderWorkspace(projectId) {
                currentProjectId = projectId;
                const project = await dbManager.getProject(projectId);
                const files = await dbManager.getFilesForProject(projectId);

                workspaceProjectName.textContent = project.name;
                promptTemplateInput.value = project.promptTemplate || '다음 텍스트를 한국어로 번역해줘: <<원문>>';
                
                workspaceFileMap.clear();
                files.forEach(file => workspaceFileMap.set(file.name, file));
                
                const fileTree = {};
                files.forEach(file => {
                    let currentLevel = fileTree;
                    const pathParts = file.name.split('/');
                    pathParts.forEach((part, index) => {
                        if (index === pathParts.length - 1) {
                            currentLevel[part] = file;
                        } else {
                            if (!currentLevel[part]) {
                                currentLevel[part] = {};
                            }
                            currentLevel = currentLevel[part];
                        }
                    });
                });

                fileListContainer.innerHTML = this.buildFileTreeHTML(fileTree);

                this.clearWorkspaceView();
                this.switchView('workspace');
            },
            buildFileTreeHTML(node, path = '') {
                let html = '<ul class="space-y-1">';
                Object.keys(node).sort((a, b) => {
                    const aIsDir = typeof node[a] === 'object' && node[a] !== null && !node[a].name;
                    const bIsDir = typeof node[b] === 'object' && node[b] !== null && !node[b].name;
                    if (aIsDir && !bIsDir) return -1;
                    if (!aIsDir && bIsDir) return 1;
                    return a.localeCompare(b);
                }).forEach(key => {
                    const currentPath = path ? `${path}/${key}` : key;
                    const isDir = typeof node[key] === 'object' && node[key] !== null && !node[key].name;
                    if (isDir) {
                        html += `
                            <li>
                                <details open>
                                    <summary class="flex items-center p-1 rounded cursor-pointer hover:bg-gray-200">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1 text-yellow-500" viewBox="0 0 20 20" fill="currentColor"><path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" /></svg>
                                        <span class="font-medium text-sm">${key}</span>
                                    </summary>
                                    <div class="ml-4">${this.buildFileTreeHTML(node[key], currentPath)}</div>
                                </details>
                            </li>
                        `;
                    } else {
                        const file = node[key];
                        const iconClass = file.status === 'translated' ? 'status-translated' : 'status-untranslated';
                        const iconPath = file.status === 'translated' 
                            ? 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z'
                            : 'M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 5.555a.5.5 0 01.9 0v3.9a.5.5 0 01-.45.495l-2.438.406a.5.5 0 01-.555-.555l.406-2.438A.5.5 0 019.555 6.45V5.555z';
                        const promptCopiedClass = file.promptCopied ? 'copied-prompt' : '';
                        
                        html += `
                            <li class="file-item p-1 rounded cursor-pointer hover:bg-blue-100 flex items-center ${promptCopiedClass}" data-project-id="${file.projectId}" data-file-name="${file.name}">
                                <svg xmlns="http://www.w3.org/2000/svg" id="status-icon-${file.name.replace(/[^a-zA-Z0-9]/g, '-')}" class="status-icon flex-shrink-0 mr-2 ${iconClass}" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="${iconPath}" clip-rule="evenodd" /></svg>
                                <span class="text-sm truncate" title="${key}">${key}</span>
                            </li>
                        `;
                    }
                });
                html += '</ul>';
                return html;
            },
            updateFileStatusIcon(fileName, status) {
                const icon = document.getElementById(`status-icon-${fileName.replace(/[^a-zA-Z0-9]/g, '-')}`);
                if (icon) {
                    const iconClass = status === 'translated' ? 'status-translated' : 'status-untranslated';
                    const iconPath = status === 'translated' 
                        ? 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z'
                        : 'M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 5.555a.5.5 0 01.9 0v3.9a.5.5 0 01-.45.495l-2.438.406a.5.5 0 01-.555-.555l.406-2.438A.5.5 0 019.555 6.45V5.555z';
                    
                    icon.classList.remove('status-translated', 'status-untranslated');
                    icon.classList.add(iconClass);
                    icon.querySelector('path').setAttribute('d', iconPath);
                }
            },
            updatePromptCopiedIndicator(fileName, isCopied) {
                 const fileItem = fileListContainer.querySelector(`[data-file-name="${fileName}"]`);
                if (fileItem) {
                    if (isCopied) {
                        fileItem.classList.add('copied-prompt');
                    } else {
                        fileItem.classList.remove('copied-prompt');
                    }
                }
            },
            clearWorkspaceView() {
                currentFile = null;
                originalFileName.textContent = '';
                originalTextEl.textContent = '좌측 목록에서 번역할 파일을 선택하세요.';
                translatedTextEl.value = '';
                copyPromptBtn.classList.remove('btn-warning');
                copyPromptBtn.classList.add('btn-secondary');
            },
            showConfirm(title, message) {
                return new Promise(resolve => {
                    document.getElementById('confirm-title').textContent = title;
                    document.getElementById('confirm-message').textContent = message;
                    confirmModal.classList.remove('hidden');

                    const onOk = () => {
                        cleanup();
                        resolve(true);
                    };
                    const onCancel = () => {
                        cleanup();
                        resolve(false);
                    };
                    
                    const cleanup = () => {
                        confirmOkBtn.removeEventListener('click', onOk);
                        confirmCancelBtn.removeEventListener('click', onCancel);
                        confirmModal.classList.add('hidden');
                    };

                    confirmOkBtn.addEventListener('click', onOk, { once: true });
                    confirmCancelBtn.addEventListener('click', onCancel, { once: true });
                });
            },
            /**
             * 토스트 메시지를 화면에 표시합니다.
             * @param {string} message - 표시할 메시지
             * @param {'success'|'error'|'info'} type - 메시지 종류 (CSS 클래스 결정)
             * @param {number} duration - 메시지 표시 시간 (ms)
             */
            showToast(message, type = 'success', duration = 3000) {
                const toast = document.createElement('div');
                let bgColor, textColor;

                switch (type) {
                    case 'error':
                        bgColor = 'bg-red-500'; textColor = 'text-white';
                        break;
                    case 'info':
                        bgColor = 'bg-blue-500'; textColor = 'text-white';
                        break;
                    case 'success':
                    default:
                        bgColor = 'bg-green-500'; textColor = 'text-white';
                        break;
                }

                toast.className = `toast p-4 rounded-lg shadow-lg ${bgColor} ${textColor} text-sm font-semibold`;
                toast.textContent = message;
                
                toastContainer.appendChild(toast);

                setTimeout(() => {
                    toast.remove();
                }, duration);
            }
        };

        // --- 이벤트 핸들러 ---
        const eventHandlers = {
            init() {
                // 대시보드
                newProjectBtn.addEventListener('click', () => zipFileInput.click());
                zipFileInput.addEventListener('change', this.handleFileSelect.bind(this));
                projectList.addEventListener('click', (e) => {
                    const openBtn = e.target.closest('.open-project-btn');
                    const deleteBtn = e.target.closest('.delete-project-btn');
                    if (openBtn) {
                        uiManager.renderWorkspace(openBtn.dataset.projectId);
                    }
                    if (deleteBtn) {
                        this.handleDeleteProject(deleteBtn.dataset.projectId);
                    }
                });

                // 작업 공간
                backToDashboardBtn.addEventListener('click', async () => {
                    currentProjectId = null;
                    uiManager.showLoading('대시보드 로딩 중...');
                    await uiManager.renderDashboard();
                    uiManager.hideLoading();
                });
                fileListContainer.addEventListener('click', (e) => {
                    const fileItem = e.target.closest('.file-item');
                    if (fileItem) {
                        this.handleFileSelectInWorkspace(fileItem.dataset.projectId, fileItem.dataset.fileName);
                    }
                });
                saveTranslationBtn.addEventListener('click', this.handleSaveTranslation.bind(this));
                copyPromptBtn.addEventListener('click', this.handleCopyPrompt.bind(this));
                exportBtn.addEventListener('click', this.handleExport.bind(this));
                // blur 이벤트는 사용자가 다른 곳을 클릭할 때마다 저장되어 불편할 수 있으므로, 명시적인 저장 버튼으로만 저장하도록 변경.
                // translatedTextEl.addEventListener('blur', this.handleSaveTranslation.bind(this));
                promptTemplateInput.addEventListener('blur', this.handleSavePromptTemplate.bind(this));
            },
            async handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                uiManager.showLoading('프로젝트 생성 중...');
                worker.postMessage({ type: 'PROCESS_ZIP', payload: { file } });
                
                zipFileInput.value = ''; // 동일 파일 재선택을 위해 초기화
            },
            async handleDeleteProject(projectId) {
                const project = await dbManager.getProject(projectId);
                const confirmed = await uiManager.showConfirm('프로젝트 삭제', `정말로 '${project.name}' 프로젝트를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.`);
                if (confirmed) {
                    await dbManager.deleteProject(projectId);
                    uiManager.showToast(`'${project.name}' 프로젝트가 삭제되었습니다.`, 'info');
                    uiManager.renderDashboard();
                }
            },
            async handleFileSelectInWorkspace(projectId, fileName) {
                // 다른 파일 선택 시, 이전 파일의 변경사항이 있다면 자동 저장
                if (currentFile && translatedTextEl.value !== (currentFile.translatedText || '')) {
                    await this.handleSaveTranslation(false); // 자동저장이므로 다음 파일로 넘어가지 않음
                }

                const file = workspaceFileMap.get(fileName);
                if (file) {
                    currentFile = file;
                    originalFileName.textContent = currentFile.name;
                    originalTextEl.textContent = currentFile.originalText;
                    translatedTextEl.value = currentFile.translatedText || '';

                    document.querySelectorAll('.file-item.bg-blue-100').forEach(el => el.classList.remove('bg-blue-100'));
                    const fileItem = fileListContainer.querySelector(`[data-file-name="${fileName}"]`);
                    if(fileItem) fileItem.classList.add('bg-blue-100');


                    if (currentFile.promptCopied) {
                        copyPromptBtn.classList.remove('btn-secondary');
                        copyPromptBtn.classList.add('btn-warning');
                    } else {
                        copyPromptBtn.classList.remove('btn-warning');
                        copyPromptBtn.classList.add('btn-secondary');
                    }
                }
            },
            async handleSaveTranslation(moveToNext = true) {
                if (!currentFile) {
                    if (moveToNext === true) uiManager.showToast('저장할 파일이 선택되지 않았습니다.', 'error');
                    return;
                };
                
                const newText = translatedTextEl.value;
                const originalTranslatedText = currentFile.translatedText || '';

                // 변경사항이 없으면 저장 로직을 실행하지 않음
                if (newText === originalTranslatedText && moveToNext) return;

                const newStatus = newText.trim() ? 'translated' : 'untranslated';
                currentFile.translatedText = newText;
                currentFile.status = newStatus;
                
                await dbManager.updateFile(currentFile);
                uiManager.updateFileStatusIcon(currentFile.name, newStatus);
                uiManager.showToast(`'${currentFile.name}' 저장 완료!`, 'success');

                // 로컬 맵 상태 업데이트
                workspaceFileMap.get(currentFile.name).status = newStatus;
                workspaceFileMap.get(currentFile.name).translatedText = newText;

                // 저장 후 다음 미번역 파일로 자동 이동 (moveToNext가 true일 때만)
                if (moveToNext) {
                    const fileItems = Array.from(fileListContainer.querySelectorAll('.file-item'));
                    const fileNamesInOrder = fileItems.map(item => item.dataset.fileName);
                    const currentIndex = fileNamesInOrder.indexOf(currentFile.name);

                    if (currentIndex !== -1) {
                        // 현재 파일 다음부터 탐색
                        for (let i = currentIndex + 1; i < fileNamesInOrder.length; i++) {
                            const nextFileName = fileNamesInOrder[i];
                            if (workspaceFileMap.get(nextFileName)?.status === 'untranslated') {
                                this.handleFileSelectInWorkspace(currentProjectId, nextFileName);
                                return;
                            }
                        }
                        // 처음부터 현재 파일 이전까지 탐색
                        for (let i = 0; i < currentIndex; i++) {
                            const nextFileName = fileNamesInOrder[i];
                            if (workspaceFileMap.get(nextFileName)?.status === 'untranslated') {
                                this.handleFileSelectInWorkspace(currentProjectId, nextFileName);
                                return;
                            }
                        }
                    }
                    uiManager.showToast('모든 파일의 번역이 완료되었습니다!', 'info');
                }
            },
            async handleSavePromptTemplate() {
                if (!currentProjectId) return;
                const project = await dbManager.getProject(currentProjectId);
                const newTemplate = promptTemplateInput.value;
                if (project.promptTemplate === newTemplate) return;

                project.promptTemplate = newTemplate;
                await dbManager.updateProject(project);
                uiManager.showToast('프롬프트 템플릿이 저장되었습니다.');
            },
            async handleCopyPrompt() {
                if (!currentFile || !currentFile.originalText) {
                    uiManager.showToast('프롬프트를 복사할 파일이 선택되지 않았습니다.', 'error');
                    return;
                }

                if (!currentFile.promptCopied) {
                    currentFile.promptCopied = true;
                    await dbManager.updateFile(currentFile);
                    workspaceFileMap.get(currentFile.name).promptCopied = true;
                    copyPromptBtn.classList.remove('btn-secondary');
                    copyPromptBtn.classList.add('btn-warning');
                    uiManager.updatePromptCopiedIndicator(currentFile.name, true);
                }

                const template = promptTemplateInput.value || '<<원문>>';
                const promptText = template.replace('<<원문>>', currentFile.originalText);

                const success = await utils.copyToClipboard(promptText);

                if (success) {
                    uiManager.showToast('프롬프트가 클립보드에 복사되었습니다.');
                } else {
                    uiManager.showToast('클립보드 복사에 실패했습니다. 브라우저 권한을 확인해주세요.', 'error');
                }
            },
            async handleExport() {
                if (!currentProjectId) return;

                uiManager.showLoading('내보내기 파일 생성 중...');
                const project = await dbManager.getProject(currentProjectId);
                const files = await dbManager.getFilesForProject(currentProjectId);
                
                // 원본 ZIP 파일의 디렉토리 구조 순서대로 정렬
                const sortedFiles = files.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

                let fullText = `프로젝트: ${project.name}\n`;
                fullText += `내보내기 날짜: ${new Date().toLocaleString()}\n`;
                fullText += "========================================\n\n";

                sortedFiles.forEach(file => {
                    fullText += `--- 파일: ${file.name} ---\n`;
                    fullText += (file.translatedText || "[번역되지 않음]") + "\n\n";
                });

                const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${project.name}_번역본.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                uiManager.hideLoading();
                uiManager.showToast('번역본이 텍스트 파일로 내보내졌습니다.', 'info');
            }
        };

        // --- 웹 워커 설정 및 메시지 핸들링 ---
        function setupWorker() {
            const workerScript = document.getElementById('worker').textContent;
            const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
            worker = new Worker(URL.createObjectURL(workerBlob));

            worker.onmessage = async (e) => {
                const { type, payload } = e.data;
                switch (type) {
                    case 'PROGRESS':
                        uiManager.showLoading(payload);
                        break;
                    case 'SUCCESS':
                        const newProjectId = `proj_${Date.now()}`;
                        const zipFile = zipFileInput.files[0];
                        const projectName = zipFile ? zipFile.name.replace(/\.zip$/i, '') : '새 프로젝트';
                        
                        const newProject = {
                            id: newProjectId,
                            name: projectName,
                            createdAt: new Date(),
                            promptTemplate: `\n<?xml version="1.0" encoding="UTF-8"?>\n<metaPrompt>\n  <purpose>\n    천천히 심혈을 기울여서 essentialContext에 제공된 특정 문서를 입력받아, 원문의 톤앤매너를 완벽하게 유지하면서도 가장 유려하고 자연스러운 문어체 한국어 문장으로 차근차근 천천히 변환한다.\n    최종 결과물은 즉시 출판 가능하도록 가독성, 읽기 쉬우면서, 학문적 엄밀성을 보전하고, 의미 전달의 정확성, 어법 준수성 등 좋은 글의 모든 특성을 최고 수준으로 충족해야 한다.\n  </purpose>\n\n  <promptDesignFramework>\n\n    <objectiveDefinition id="1" title="목표 정의: 과업의 제1원칙">\n      <finalDeliverable id="1.1" description="프롬프트를 통해 얻고자 하는 최종 결과물">\n        이 문서의 콘텐츠는 사용자가 제공한 원문을 한국어 문어체 문장으로 변환 하고, 전문가 수준으로 다듬어 즉시 출판하여 베스트셀러가 될 수 있는 상태의 글이다.\n      </finalDeliverable>\n      <coreTask id="1.2" description="LLM이 수행해야 할 핵심적인 동사">\n        번역(Translate), 교정(Refine), 그리고 형식화(Format). 단순히 단어를 옮기는 것을 넘어, 전문 편집자로서 원문의 의미와 뉘앙스를 살리면서 한국어 독자에게 최적화된 콘텐츠로 재구성하고, 지정된 XML 형식에 맞춰 구조화해야 한다.\n      </coreTask>\n      <successCriteria id="1.3" description="결과물이 '성공'이라고 판단할 객관적인 기준">\n        - 결과물은 문법적으로 완벽한(well-formed) 한국어\n        - 학문적 엄밀성 및 정홛성\n        - 결과물이 읽기 쉬움\n        - 일문 일의주의에 따라 문장을 작성\n        - 번역문은 원문의 핵심 의미, 세부 뉘앙스, 그리고 저자의 의도를 100% 보존한다.\n        - 한국어 문장은 문법적으로 완벽하며, 원문의 어조와 스타일을 유지하면서도 자연스럽고 유려하다.\n        - 제목, 요약, 소제목, 문단 나누기 등 내용의 논리적 흐름을 반영하여 가독성을 극대화한다.\n        - '[여기에 입력]'과 같은 플레이스홀더 텍스트가 최종 결과물에 남아있지 않다.\n      </successCriteria>\n    </objectiveDefinition>\n\n    <personaAssignment id="2" title="역할 부여: 최적의 인지 모델 설계">\n      <expertPersona id="2.1" description="과업을 가장 잘 수행할 전문가의 상세한 묘사">\n        당신은 '마스터 번역가 겸 콘텐츠 전략가'입니다. 20년 경력의 국제회의 통역사이자 여러 권의 베스트셀러 기술 서적을 번역한 경험이 있습니다. 당신은 단순히 언어를 변환하는 것을 넘어, 문화적 맥락과 미묘한 뉘앙스까지 포착하여 독자의 마음을 움직이는 글을 만들어내는 전문가입니다. 또한, 디지털 콘텐츠의 가독성과 검색엔진최적화(SEO)에 대한 깊은 이해를 바탕으로, 번역된 콘텐츠가 온라인 환경에서 최고의 성과를 낼 수 있도록 구조화하는 능력을 갖추고 있습니다.\n      </expertPersona>\n      <audience id="2.2" description="결과물을 소비할 대상과 그들의 지식 수준">\n        제공될 원문의 내용, 어휘, 스타일을 분석하여 잠재 독자층(예: 기술 전문가, 일반 대중, 특정 분야의 학생 등)을 추론하고, 그들의 지식 수준과 관심사에 맞춰 가장 이해하기 쉬운 어휘와 문장 구조를 선택해야 한다.\n      </audience>\n      <toneAndStyle id="2.3" description="결과물의 어조와 스타일 및 정신적 도구">\n        - **톤앤매너 복제:** 원문의 톤(예: 학술적, 유머러스함, 진지함, 대중적)을 정확히 분석하고, 그 느낌을 한국어의 표현으로 완벽하게 재현해야 한다. 직역으로 어색해지는 관용구나 문화적 표현은 한국 독자가 즉시 이해할 수 있는 자연스러운 표현으로 의역한다.\n      - 문어체의 사용 : 베스트셀러처럼 잘 읽히는 문어체를 사용하여, 원본의 모든 내용과 정보를 포함하면서도 술술 읽혀야만 한다.\n        - **정신적 도구 (Mental Model):** '독자의 입장에서 생각하기'. 문장을 완성하기 전에, 잠재 독자의 관점에서 그 문장을 소리 내어 읽어본다고 상상하라. '이 문장은 명확한가? 매력적인가? 이전 내용과 자연스럽게 연결되는가?'를 끊임없이 자문하며 결과물을 다듬어라.\n      </toneAndStyle>\n    </personaAssignment>\n\n    <contextAndFormat id="3" title="맥락 제공 및 형식 지정">\n      <essentialContext id="3.1" description="과업 수행에 필요한 모든 배경 정보, 데이터, 이전 대화 내용">\n        <![CDATA[\n          \n<<원문>>\n        ]]>\n      </essentialContext>\n      <outputFormat id="3.2" description="결과물이 출력되어야 할 정확한 형식 또는 템플릿">\n        <![CDATA[\n입력에 따라서 적절한 형식으로.\n        ]]>\n      </outputFormat>\n    </contextAndFormat>\n\n    <reasoningDesign id="4" title="추론 과정 설계: 생각의 경로 구축">\n      <reasoningFramework id="4.1" description="과업 복잡성에 따른 추론 방식 선택">\n        <option type="ProblemDecomposition" description="복잡한 프로젝트 수행 시 사용">\n          <instruction>아래의 최종 목표를 달성하기 위해, 다음의 하위 작업들을 명시된 순서대로 반드시 수행하라. 각 단계의 결과는 다음 단계의 입력으로 사용된다.</instruction>\n          <subTasks>\n            <task id="1">**1단계: 원문 심층 분석 (Analyze):** 제공된 원문을 최소 3회 이상 정독하여 핵심 메시지, 논리 구조, 저자의 어조와 문체, 그리고 숨은 의도를 완벽하게 파악한다.</task>\n            <task id="2">**2단계: 초벌 번역 및 뉘앙스 포착 (Translate & Capture):** 원문의 의미를 정확하게 전달하는 데 초점을 맞춰 초벌 번역을 수행한다. 특히 기술 용어, 관용 표현, 문화적 배경이 담긴 뉘앙스를 놓치지 않도록 주의한다.</task>\n            <task id="3">**3단계: 윤문 및 유려함 확보 (Refine & Polish):** 초벌 번역 결과물을 한국어 독자의 시각에서 어색함이 없도록 다듬는다. 그러면서 동시에 문어체로 작성항다.  딱딱한 번역투 문장을 자연스러운 한국어 문장으로 재구성하고, 더 적절한 어휘를 선택하여 글 전체의 유려함을 극대화한다.</task>\n            <task id="4">**4단계: 콘텐츠 구조화 및 형식화 (Structure & Format):** 완성된 내용을 가독성을 높이기 위해 본문을 논리적인 문단과 소제목으로 나누고, 핵심 키워드를 추출하여 태그를 생성한다.</task>\n          </subTasks>\n        </option>\n      </reasoningFramework>\n      <fewShotExamples id="4.2" description="1~3개의 고품질 입/출력 예시로 결과물 패턴 학습">\n        <example id="1">\n          <input><![CDATA[\n            Title: The Unseen Power of Micro-interactions\n\n            Micro-interactions are the small, often unnoticed animations and design elements that make a user interface feel alive. Think of the "like" button animation on Twitter, or the subtle bounce when you pull to refresh a feed. While seemingly minor, these details are critical. They provide feedback, guide users, and add a touch of personality to a digital product, transforming a functional tool into an enjoyable experience. Good micro-interactions are almost invisible, doing their job without shouting for attention.\n          ]]></input>\n          <output><![CDATA[\n          ]]></output>\n        </example>\n      </fewShotExamples>\n    </constraints>\n\n    <constraints id="5" title="제약 조건 설정: 탐색 공간 제어">\n      <mustInclude id="5.1" description="결과물에 반드시 포함되어야 할 키워드, 개념, 데이터 포인트">\n        - 최종 결과물은 번역문이어야 한다.\n        - 원문에 포함된 모든 정보는 번역문에 반드시 포함되어야 한다.\n        - \n      </mustInclude>\n      <mustAvoid id="5.2" description="반드시 피해야 할 주제, 표현, 단어, 편향, 가정">\n        - 단어 대 단어 식의 기계적인 직역.\n        - 원문의 정보를 누락하거나, 원문에 없는 내용을 임의로 추가하는 행위.\n        - 한국어 독자가 읽기에 어색하거나 부자연스러운 번역투 문장.\n        - 최종 결과물에 '여기를 채우세요'와 같은 미완성된 플레이스홀더를 남기는 것.\n      </e_mustAvoid>\n      <selfCorrectionCommand id="5.3" description="생성될 프롬프트 마지막에 포함될 최종 검증 명령">\n        <![CDATA[\n          모든 지시사항을 완수한 후, 최종 답변을 제출하기 전에 잠시 멈추고 스스로 '레드팀'의 역할을 수행하라. 내가 제시한 모든 요구사항(역할, 형식, 내용, 제약 조건 등)이 100% 충족되었는지, 논리적 비약이나 모순은 없는지, 더 나은 대안은 없는지 최소 세 번 이상 교차 검증하고, 그 결과를 반영하여 최종적으로 완벽하고 군더더기 없는 결과물만 출력하라.\n        ]]>\n      </selfCorrectionCommand>\n    </constraints>\n\n  </promptDesignFramework>\n</metaPrompt>\n\n`
                        };
                        
                        const filesToSave = payload.files.map(f => ({
                            ...f,
                            projectId: newProjectId,
                            translatedText: '',
                            status: 'untranslated',
                            promptCopied: false
                        }));

                        await dbManager.addProject(newProject);
                        await dbManager.addFiles(filesToSave);
                        
                        uiManager.hideLoading();
                        uiManager.showToast(`'${projectName}' 프로젝트가 성공적으로 생성되었습니다.`, 'success');
                        await uiManager.renderDashboard();
                        break;
                    case 'ERROR':
                        console.error('Worker Error:', payload);
                        uiManager.hideLoading();
                        uiManager.showToast(`파일 처리 중 오류 발생: ${payload}`, 'error');
                        break;
                }
            };
            worker.onerror = (e) => {
                console.error('Worker Error:', e);
                uiManager.hideLoading();
                uiManager.showToast('웹 워커 실행 중 심각한 오류가 발생했습니다.', 'error');
            }
        }

        // --- 애플리케이션 초기화 ---
        async function init() {
            try {
                await dbManager.initDB();
                setupWorker();
                eventHandlers.init();
                await uiManager.renderDashboard();
            } catch (error) {
                console.error("애플리케이션 초기화 실패:", error);
                document.body.innerHTML = `<div class="p-8 text-center text-red-600">애플리케이션을 시작할 수 없습니다. 브라우저가 IndexedDB를 지원하는지 확인하세요. 오류: ${error}</div>`;
            }
        }

        document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
