<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>통합 학습 및 저작 시스템 v3.16 (UX 개선)</title>
    
    <!-- Core Dependencies -->
    <script src="https://cdn.tailwindcss.com" defer></script>
    <!-- ▼▼▼ [수정] Heroicons v2 CDN 스크립트는 JavaScript 내에서 직접 로드하도록 변경되어 삭제합니다. ▼▼▼ -->
    <!-- ▲▲▲ [수정] Heroicons v2 CDN 스크립트는 JavaScript 내에서 직접 로드하도록 변경되어 삭제합니다. ▲▲▲ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" defer></script>
    <script src="https://unpkg.com/turndown/dist/turndown.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/morphdom@2.7.0/dist/morphdom-umd.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js" defer></script>

    <!-- Feather Icons CDN for icon rendering -->
    <!-- Feather Icons provides a global `feather` object with SVG icons accessible via `feather.icons[iconName].toSvg()` -->
    <script src="https://cdn.jsdelivr.net/npm/feather-icons@4.29.2/dist/feather.min.js" defer></script>
    
    <!-- KaTeX for Math Rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="document.dispatchEvent(new Event('katex-loaded'))" defer></script>

    <style>
        /* ▼▼▼ [1단계] 나눔고딕, 나눔명조 및 기본 글꼴 웹 폰트 불러오기 ▼▼▼ */
        @import url('https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700;800&family=Nanum+Myeongjo:wght@400;700;800&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap');
    
        :root {
            --bg-primary: #ffffff; --bg-secondary: #f8fafc; --bg-tertiary: #f1f5f9;
            --bg-hover: #eef2ff; --text-primary: #0f172a; --text-secondary: #475569;
            --text-tertiary: #64748b; --border-color: #e2e8f0; --accent-primary: #4f46e5;
            --accent-primary-hover: #4338ca; --accent-danger: #ef4444; --sidebar-width: 280px;
            --header-height: 64px; --radius-sm: 0.25rem; --radius-md: 0.5rem; --radius-lg: 0.75rem;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        
        html { scroll-behavior: smooth; }
        body { font-family: 'Inter', 'Noto Sans KR', sans-serif; background-color: var(--bg-secondary); color: var(--text-primary); display: flex; height: 100vh; overflow: hidden; }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .btn { background-color: var(--accent-primary); color: white; border: none; padding: 0.625rem 1rem; border-radius: var(--radius-md); cursor: pointer; display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; font-size: 0.875rem; font-weight: 500; transition: background-color 0.2s, transform 0.1s; }
        .btn:hover { background-color: var(--accent-primary-hover); transform: translateY(-1px); }
        .btn:active { transform: translateY(0); }
        .btn-secondary { background-color: var(--bg-tertiary); color: var(--text-primary); }
        .btn-secondary:hover { background-color: #e2e8f0; }
        
        .sidebar { width: var(--sidebar-width); background-color: var(--bg-primary); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; flex-shrink: 0; height: 100%; transition: transform 0.3s ease-in-out, width 0.3s ease-in-out, padding 0.3s ease-in-out, border 0.3s ease-in-out; z-index: 100; }
        .sidebar-header { padding: 1rem; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .sidebar-header .logo { font-size: 1.25rem; font-weight: 700; color: var(--accent-primary); display: flex; align-items: center; gap: 0.5rem; }
        .sidebar-content { flex-grow: 1; overflow-y: auto; padding: 1rem 0.5rem; }
        .sidebar-footer { padding: 1rem; border-top: 1px solid var(--border-color); flex-shrink: 0; }
        .nav-section-title { font-size: 0.75rem; font-weight: 600; color: var(--text-tertiary); text-transform: uppercase; letter-spacing: 0.05em; padding: 0 0.5rem; margin-bottom: 0.5rem; }
        .nav-list { list-style: none; padding-left: 0; }
        .nav-item a { display: flex; align-items: center; gap: 0.75rem; padding: 0.625rem 0.5rem; color: var(--text-secondary); text-decoration: none; border-radius: var(--radius-md); font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: background-color 0.2s, color 0.2s; position: relative; }
        .nav-item a:hover { background-color: var(--bg-tertiary); color: var(--text-primary); }
        .nav-item.active a { background-color: var(--bg-hover); color: var(--accent-primary); font-weight: 600; }
        .nav-item.active a::before { content: ''; position: absolute; left: -0.5rem; top: 0; bottom: 0; width: 4px; background-color: var(--accent-primary); border-top-right-radius: 4px; border-bottom-right-radius: 4px; }
        .nav-item .icon { width: 1.25rem; height: 1.25rem; }
        .tag-count { margin-left: auto; font-size: 0.75rem; background-color: var(--bg-tertiary); color: var(--text-secondary); padding: 0.125rem 0.5rem; border-radius: var(--radius-sm); }
        
        .main-content { flex-grow: 1; display: flex; flex-direction: column; min-width: 0; }
        .main-header { display: flex; align-items: center; padding: 0 1.5rem; height: var(--header-height); flex-shrink: 0; border-bottom: 1px solid var(--border-color); background-color: var(--bg-primary); z-index: 10; }
        .header-title { font-size: 1.25rem; font-weight: 600; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .search-input { background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: 0.5rem 2.5rem 0.5rem 0.75rem; font-size: 0.875rem; width: 280px; }
        .content-view { flex-grow: 1; overflow-y: auto; padding: 1.5rem; }
        
        .project-card { background-color: var(--bg-primary); border-radius: var(--radius-lg); border: 1px solid var(--border-color); padding: 1.5rem; box-shadow: var(--shadow-sm); transition: box-shadow 0.2s, transform 0.2s; }
        .project-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-md); }
        
        .modal-overlay { position: fixed; inset: 0; background-color: rgba(15, 23, 42, 0.6); display: flex; justify-content: center; align-items: center; z-index: 2000; opacity: 0; visibility: hidden; transition: opacity .3s; backdrop-filter: blur(4px); }
        .modal-overlay.show { opacity: 1; visibility: visible; }
        .modal-container { background-color: var(--bg-primary); border-radius: var(--radius-lg); width: 90%; max-width: 600px; box-shadow: var(--shadow-md); z-index: 2001; transform: scale(0.95); transition: transform 0.3s; }
        .modal-overlay.show .modal-container { transform: scale(1); }
        
        .xp-bar-inner { background: linear-gradient(90deg, #4f46e5, #818cf8); transition: width 0.5s ease-out; }
        .toc-item.active > div > a { background-color: var(--bg-hover); color: var(--accent-primary); font-weight: 600; }
        .toc-item.active > div > a::before { content: ''; position: absolute; left: -0.5rem; top: 0; bottom: 0; width: 4px; background-color: var(--accent-primary); border-top-right-radius: 4px; border-bottom-right-radius: 4px; }
        
        /* ▼▼▼ [2단계] '보기' 패널의 최대 너비 수정 ▼▼▼ */
        .prose-readable {
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            font-size: 24px; 
            line-height: 1.8;
        }
    
        @media (min-width: 768px) {
            .prose-readable {
                font-size: 25px;
                line-height: 1.7;
            }
        }
        .drop-zone { border: 2px dashed #d1d5db; transition: all 0.2s ease-in-out; }
        .drop-zone.drag-over { background-color: #eef2ff; border-color: #6366f1; }
        
        .toc-drop-indicator-before { border-top: 2px solid var(--accent-primary); }
        .toc-drop-indicator-after { border-bottom: 2px solid var(--accent-primary); }
        .toc-drop-indicator-inside { background-color: var(--bg-hover); outline: 2px solid var(--accent-primary); }
    
        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltip-text { visibility: hidden; width: 250px; background-color: #334155; color: #fff; text-align: left; border-radius: 6px; padding: 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -125px; opacity: 0; transition: opacity 0.3s; font-size: 0.75rem; line-height: 1.5; }
        .tooltip:hover .tooltip-text { visibility: visible; opacity: 1; }
        
        @media (max-width: 1024px) {
            .sidebar { position: fixed; transform: translateX(-100%); }
            .sidebar.open { transform: translateX(0); box-shadow: 0 0 40px rgba(0,0,0,0.1); }
            .sidebar-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 99; transition: opacity 0.3s; }
            .sidebar-overlay:not(.show) { opacity: 0; pointer-events: none; }
        }
    
        /* ================================================================== */
        /* ▼▼▼ [3단계] 가독성 향상을 위한 커스텀 타이포그래피 스타일 ▼▼▼ */
        /* ================================================================== */
    
        .prose-readable h1,
        .prose-readable h2,
        .prose-readable h3,
        .prose-readable h4 {
            font-family: 'Nanum Gothic', sans-serif;
            color: #1f2937;
            margin-bottom: 0.8em;
            margin-top: 1.6em;
        }
    
        .prose-readable h1 {
            font-size: 2em;
            font-weight: 700;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0.3em;
        }
    
        .prose-readable h2 {
            font-size: 1.6em;
            font-weight: 700;
            border-bottom: 1px solid #e5e7eb;
            padding-bottom: 0.3em;
        }
    
        .prose-readable h3 {
            font-size: 1.3em;
            font-weight: 600;
        }
    
        .prose-readable p {
            font-family: 'Nanum Myeongjo', serif;
            color: #374151;
            line-height: 1.8;
        }
    
        .prose-readable strong {
            color: #111827;
            font-weight: 600;
        }
    
        .prose-readable a {
            color: var(--accent-primary);
            text-decoration: underline;
            font-weight: 500;
        }
        .prose-readable a:hover {
            color: var(--accent-primary-hover);
        }
    
        .prose-readable blockquote {
            border-left: 4px solid var(--accent-primary);
            padding-left: 1rem;
            color: #4b5563;
            font-style: italic;
            margin-left: 0;
            margin-right: 0;
        }
    
        .prose-readable code {
            background-color: #f3f4f6;
            color: #4b5563;
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            border-radius: 6px;
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>
<body>
    <div id="app-container" class="flex h-screen w-full"></div>
    <div id="modal-root"></div>
    <div id="toast-root"></div>

    <script type="module">
        // ===================================================================================
 // 통합 학습 및 저작 시스템 v3.16 (UX 개선)
 // - v3.16: 빈 프로젝트 생성 기능, 스크롤 위치 기억 기능 추가 및 UX 개선
 // ===================================================================================
 const CONFIG = {
     DB_NAME: 'ILS_V3_DB',
     DB_VERSION: 1,
     STORES: {
         PROJECTS: 'projects',
         CONTENTS: 'contents',
         CATEGORIES: 'categories',
         USER_PROFILE: 'userProfile'
     },
     EXPORT_TYPE_ID: 'ILS_PROJECT_EXPORT_V2',
     LEVEL_THRESHOLDS: [0, 1000, 2500, 5000, 10000, 20000, 40000, 80000, 160000, 320000],
     QUIZ_TYPE: {
         MULTIPLE_CHOICE: 'multiple_choice',
         SHORT_ANSWER: 'short_answer',
         SUBJECTIVE: 'subjective',
         CASE_BASED: 'case_based'
     },
     DEFAULT_PROJECT_SETTINGS: {}
 };

 /**
  * ▼▼▼ [수정] Heroicons 렌더링 및 캐싱 유틸리티 (비동기 로딩 방식 적용) ▼▼▼
  */
const Heroicons = {
    /**
     * Cache rendered SVG strings for performance. The key is the original
     * Heroicons name and the optional class.
     */
    _cache: new Map(),
    /**
     * Mapping from Heroicons names used throughout this application to the
     * equivalent Feather icon names. If a name is not present, the same
     * name will be used directly. Update this map when adding new icons.
     */
    _nameMap: {
        // General actions
        'bars-3': 'menu',
        'bars-3-bottom-left': 'menu',
        'cog-6-tooth': 'settings',
        'academic-cap': 'book-open',
        'arrow-down-tray': 'download',
        'cloud-arrow-up': 'upload-cloud',
        'sparkles': 'star',
        'arrow-left-on-rectangle': 'log-out',
        'arrow-right-on-rectangle': 'log-in',
        'folder': 'folder',
        'trash': 'trash',
        'tag': 'tag',
        'check-circle': 'check-circle',
        'exclamation-triangle': 'alert-triangle',
        'x-mark': 'x',
        'arrow-turn-down-right': 'corner-right-down',
        'user': 'user',
        'plus': 'plus',
        'plus-circle': 'plus-circle',
        'minus': 'minus',
        'minus-circle': 'minus-circle',
        'pencil-square': 'edit',
        'magnifying-glass': 'search',
        'bookmark': 'bookmark',
        'bookmark-square': 'bookmark',
        'paper-airplane': 'send',
        'arrow-up-right': 'arrow-up-right',
        'arrow-left': 'arrow-left',
        'arrow-right': 'arrow-right',
        'ellipsis-vertical': 'more-vertical',
        'ellipsis-horizontal': 'more-horizontal',
        'square-3-stack-3d': 'layers',
        'arrow-down-left': 'arrow-down-left',
        'arrow-path': 'repeat',
        'arrows-right-left': 'repeat',
        'arrows-up-down-left-right': 'move',
        'arrow-up': 'arrow-up',
        'arrow-down': 'arrow-down',
        'arrow-long-right': 'arrow-right',
        'information-circle': 'info',
        'microchip': 'cpu',
        'clock': 'clock',
        'question-mark-circle': 'help-circle',
        'chat-bubble-left': 'message-circle',
        'check-badge': 'check-circle',
        'arrow-long-left': 'arrow-left',
        'circle-stack': 'layers',
        'document': 'file-text',
        'document-text': 'file-text',
        'document-plus': 'file-plus',
        'document-duplicate': 'copy',
        'arrow-long-up': 'arrow-up',
        'arrow-long-down': 'arrow-down',
        'arrow-small-right': 'arrow-right',
        'arrow-small-left': 'arrow-left'
        ,
        'flag': 'flag',
        'arrow-right-circle': 'arrow-right-circle'
        ,
        'clipboard-document': 'file-text',
        'folder-plus': 'folder-plus',
        'exclamation-circle': 'alert-circle',
        'light-bulb': 'sun',
        'squares-2x2': 'grid',
        'x-circle': 'x-circle'
    },
    /**
     * Wait until the Feather icons script has been loaded. Because the
     * Feather script is loaded with defer in the head, it should be
     * available by the time module scripts run, but this method guards
     * against race conditions.
     */
    async load() {
        if (window.feather && window.feather.icons) return;
        return new Promise(resolve => {
            const timer = setInterval(() => {
                if (window.feather && window.feather.icons) {
                    clearInterval(timer);
                    resolve();
                }
            }, 20);
        });
    },
    /**
     * Render a named icon. Accepts an optional `class` property in the
     * options to apply classes to the <svg> element. Other options like
     * `style` from the original Heroicons API are ignored because Feather
     * only provides a single style for each icon.
     *
     * @param {string} name - The Heroicons name used in the application.
     * @param {object} options - Rendering options; only `class` is used.
     * @returns {string} An SVG string representing the icon, or an empty
     * string if the icon cannot be found.
     */
    render(name, options = {}) {
        const { class: className = '' } = options;
        const cacheKey = `${name}-${className}`;
        if (this._cache.has(cacheKey)) {
            return this._cache.get(cacheKey);
        }
        const featherName = this._nameMap[name] || name;
        // If the Feather library or the specific icon is unavailable, return an empty string.
        if (!window.feather || !window.feather.icons || !window.feather.icons[featherName]) {
            return '';
        }
        let svgString = window.feather.icons[featherName].toSvg();
        if (className) {
            svgString = svgString.replace('<svg', `<svg class="${className}"`);
        }
        this._cache.set(cacheKey, svgString);
        return svgString;
    }
};

 const state = {
     currentView: 'dashboard',
     projects: [],
     categories: [],
     tags: [],
     userProfile: {
         id: 'main',
         level: 1,
         xp: 0
     },
     activeProjectId: null,
     activeProject: null,
     activeChapterPath: null,
     activeChapterContent: null,
     activeContentsMap: new Map(),
     workspaceMode: 'view',
     quizState: null,
     tocCollapseState: {},
     currentFilter: {
         type: 'dashboard',
         id: null
     },
     currentSortOrder: 'updatedAt_desc',
     isLoading: true,
     isSidebarOpen: true,
     isMobileSidebarOpen: false,
     toasts: [],
     isKaTeXLoaded: false,
     searchResults: null,
     sidebarCollapseState: {
         categories: false,
         tags: false
     },
     saveStatus: 'idle',
     saveTimestamp: null,
     workspaceLayout: 'split',
     viewPanelDisplayMode: 'auto',
     quizResultFilter: 'all',
     scrollPositions: {},
     contextMenu: {
         isOpen: false,
         x: 0,
         y: 0,
         selectedText: ''
     },
 };

 let fuse = null;

 const DB = {
     db: null,
     init() {
         return new Promise((resolve, reject) => {
             const request = indexedDB.open(CONFIG.DB_NAME, CONFIG.DB_VERSION);
             request.onerror = (e) => reject("IndexedDB error: " + e.target.error);
             request.onsuccess = (e) => {
                 this.db = e.target.result;
                 resolve(this.db);
             };
             request.onupgradeneeded = (e) => {
                 const db = e.target.result;
                 Object.values(CONFIG.STORES).forEach(name => {
                     if (!db.objectStoreNames.contains(name)) db.createObjectStore(name, {
                         keyPath: 'id'
                     });
                 });
             };
         });
     },
     async get(storeName, key) {
         return new Promise((resolve, reject) => {
             const req = this.db.transaction(storeName).objectStore(storeName).get(key);
             req.onsuccess = () => resolve(req.result);
             req.onerror = () => reject(req.error);
         });
     },
     async getAll(storeName) {
         return new Promise((resolve, reject) => {
             const req = this.db.transaction(storeName).objectStore(storeName).getAll();
             req.onsuccess = () => resolve(req.result);
             req.onerror = () => reject(req.error);
         });
     },
     async put(storeName, data) {
         return new Promise((resolve, reject) => {
             const req = this.db.transaction(storeName, 'readwrite').objectStore(storeName).put(data);
             req.onsuccess = () => resolve(req.result);
             req.onerror = () => reject(req.error);
         });
     },
     async delete(storeName, key) {
         return new Promise((resolve, reject) => {
             const req = this.db.transaction(storeName, 'readwrite').objectStore(storeName).delete(key);
             req.onsuccess = () => resolve(true);
             req.onerror = () => reject(req.error);
         });
     },
     async getProjectContents(projectId) {
         return new Promise((resolve, reject) => {
             const range = IDBKeyRange.bound(`${projectId}_`, `${projectId}_\uffff`);
             const req = this.db.transaction(CONFIG.STORES.CONTENTS).objectStore(CONFIG.STORES.CONTENTS).getAll(range);
             req.onsuccess = () => resolve(req.result);
             req.onerror = () => reject(req.error);
         });
     },
     async deleteProjectAndContents(projectId) {
         const contents = await this.getProjectContents(projectId);
         const deletePromises = contents.map(c => this.delete(CONFIG.STORES.CONTENTS, c.id));
         deletePromises.push(this.delete(CONFIG.STORES.PROJECTS, projectId));
         await Promise.all(deletePromises);
     }
 };

 const Utils = {
     generateId: (prefix) => `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
     debounce: (func, delay) => {
         let timeout;
         return (...args) => {
             clearTimeout(timeout);
             timeout = setTimeout(() => func.apply(this, args), delay);
         };
     },
     naturalSort: (a, b) => {
         const re = /(\d+)/g;
         const ax = String(a).split(re);
         const bx = String(b).split(re);
         for (let i = 0; i < Math.min(ax.length, bx.length); i++) {
             const aPart = ax[i];
             const bPart = bx[i];
             if (i % 2 === 1) {
                 const aNum = parseInt(aPart, 10);
                 const bNum = parseInt(bPart, 10);
                 if (aNum !== bNum) return aNum - bNum;
             } else {
                 if (aPart !== bPart) return aPart.localeCompare(bPart);
             }
         }
         return ax.length - bx.length;
     },
     formatTitle: (name) => name.replace(/\.(zip|json|html?|txt)$/i, '').replace(/^Chapter_(\d+)_/, 'Chapter $1: ').replace(/_/g, ' '),
     getAllNodePaths: (tocNode, path = []) => {
         if (!tocNode || !tocNode.children) return [];
         let paths = [];
         tocNode.children.forEach((child, index) => {
             const currentPath = [...path, index];
             paths.push({
                 path: currentPath.join('.'),
                 node: child
             });
             if (child.children && child.children.length > 0) {
                 paths = paths.concat(Utils.getAllNodePaths(child, currentPath));
             }
         });
         return paths;
     },
     getFlatToc: (tocNode) => Utils.getAllNodePaths(tocNode),
     getNodeByPath: (toc, path) => {
         if (path === null || path === undefined) return null;
         const parts = path.split('.').map(Number);
         let node = toc;
         for (const part of parts) {
             if (node && node.children && node.children[part]) {
                 node = node.children[part];
             } else {
                 return null;
             }
         }
         return node;
     },
     getParentNodeAndIndexByPath: (toc, path) => {
         if (!path) return {
             parent: null,
             index: -1
         };
         const parts = path.split('.').map(Number);
         if (parts.length === 1) return {
             parent: toc,
             index: parts[0]
         };
         const parentPath = parts.slice(0, -1).join('.');
         const parent = Utils.getNodeByPath(toc, parentPath);
         const index = parts[parts.length - 1];
         return {
             parent,
             index
         };
     },
     normalizeTocNode: (node) => {
         if (!node) return;
         if (!node.children) {
             node.children = [];
         }
         if (node.children.length > 0) {
             node.children.forEach(Utils.normalizeTocNode);
         }
     },
     generateTocText: (node, level = 0, currentPath = '', activePath = '') => {
         let text = '';
         if (node && node.children) {
             node.children.forEach((child, index) => {
                 const path = currentPath ? `${currentPath}.${index}` : `${index}`;
                 const isActive = path === activePath;
                 const prefix = '  '.repeat(level);
                 const indicator = isActive ? '▶ ' : (child.children && child.children.length > 0 ? '+ ' : '- ');
                 text += `${prefix}${indicator}${child.title}\n`;
                 if (child.children && child.children.length > 0) {
                     text += Utils.generateTocText(child, level + 1, path, activePath);
                 }
             });
         }
         return text;
     },
     customBoldParser: (text) => {
         if (!text || typeof text !== 'string') return '';
         const parts = text.split('**');
         const processedParts = parts.map((part, index) => {
             if (index % 2 === 1) {
                 return `<strong>${part}</strong>`;
             }
             return part;
         });
         return processedParts.join('');
     },
 };

 const ModalManager = {
     el: document.getElementById('modal-root'),
     isOpen: false,
     type: '',
     data: {},
     renderFunctions: {},

     init() {
         this.renderFunctions = {
             'newProject': this.renderNewProjectModal,
             'confirm': this.renderConfirmModal,
             'settings': this.renderSettingsModal,
             'apiKey': this.renderApiKeyModal,
             'manageQuiz': this.renderManageQuizModal,
             'manageToc': this.renderManageTocModal,
             'splitChapter': this.renderSplitChapterModal,
         };
     },

     open(type, data = {}) {
         if (window.innerWidth <= 1024) Controller.closeSidebar();
         this.isOpen = true;
         this.type = type;
         this.data = data;
         this.render();
     },

     close() {
         this.isOpen = false;
         this.type = '';
         this.data = {};
         this.render();
     },

     render() {
         if (!this.isOpen) {
             this.el.innerHTML = '';
             return;
         }
         const renderer = this.renderFunctions[this.type];
         if (typeof renderer === 'function') {
             const contentHtml = renderer.call(this);
             this.el.innerHTML = `<div class="modal-overlay show" data-action="close-modal-overlay"><div class="modal-container">${contentHtml}</div></div>`;
         } else {
             this.el.innerHTML = '';
             console.error(`Modal type "${this.type}" not found.`);
         }
         Controller.bindDynamicEventListeners();
     },

     renderNewProjectModal() {
         const {
             activeTab = 'blank', isLoading = false, loadingMessage = '', error = ''
         } = this.data;
         if (isLoading) {
             return `<div class="p-8">${View.renderSpinner(loadingMessage)}</div>`;
         }

         const tabButton = (id, label) => `<button type="button" data-action="switch-modal-tab" data-tab="${id}" class="px-3 py-2 text-sm font-medium rounded-md ${activeTab === id ? 'bg-indigo-100 text-indigo-700' : 'text-slate-500 hover:bg-slate-100'}">${label}</button>`;
         const fileInputTemplate = (id, accept, labelId, description) => `<p class="text-sm text-slate-600 mb-2">${description}</p><label for="${id}" class="cursor-pointer"><div data-dropzone-for="${id}" class="drop-zone w-full p-8 rounded-lg text-center bg-slate-50 hover:bg-slate-100"><div class="flex flex-col items-center justify-center space-y-2 pointer-events-none">${Heroicons.render('cloud-arrow-up', { class: 'w-12 h-12 text-slate-400' })}<p class="text-slate-700 font-medium">파일을 드래그하거나 <span class="text-indigo-600">클릭하여 선택</span>하세요</p><p id="${labelId}" class="text-sm text-slate-500 truncate max-w-full" title="선택된 파일 없음">선택된 파일 없음</p></div><input type="file" id="${id}" accept="${accept}" class="hidden" data-target-label="${labelId}"/></div></label>`;
         const tabContent = () => {
             switch (activeTab) {
                 case 'blank':
                     return `<p class="text-sm text-slate-600 mb-2">새로운 빈 프로젝트를 시작합니다.</p>
                                <div>
                                    <label for="blank-project-name" class="block text-sm font-medium text-slate-700">프로젝트 이름</label>
                                    <input type="text" id="blank-project-name" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm" required>
                                </div>
                                <div class="mt-4">
                                    <label for="blank-project-category" class="block text-sm font-medium text-slate-700">카테고리 (선택)</label>
                                    <select id="blank-project-category" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm">
                                        <option value="">미분류</option>
                                        ${state.categories.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                                    </select>
                                </div>`;
                 case 'zip':
                     return fileInputTemplate('zip-upload', '.zip', 'zip-file-label', 'HTML 또는 TXT 파일들이 포함된 ZIP 파일을 업로드하세요.');
                 case 'jsonFile':
                     return fileInputTemplate('json-upload', '.json', 'json-file-label', '이전에 내보냈던 프로젝트(.json) 파일을 가져옵니다.');
                 case 'jsonText':
                     return `<p class="text-sm text-slate-600 mb-2">프로젝트 내보내기(.json) 파일의 텍스트를 붙여넣으세요.</p><textarea id="json-text-input" placeholder='{"type": "ILS_PROJECT_EXPORT_V2", ...}' class="w-full h-40 p-2 border rounded-md font-mono text-sm"></textarea>${error ? `<p class="text-red-500 text-sm mt-2">${error}</p>` : ''}`;
                 case 'tocJson':
                     return `<p class="text-sm text-slate-600 mb-2">책의 목차 구조를 나타내는 JSON 텍스트를 붙여넣으세요.</p><textarea id="toc-json-input" placeholder='{"title": "책 제목", "children": [...] }' class="w-full h-40 p-2 border rounded-md font-mono text-sm"></textarea>${error ? `<p class="text-red-500 text-sm mt-2">${error}</p>` : ''}`;
             }
         };
         return `<form data-action="submit-new-project"><div class="p-6"><div class="flex justify-between items-start"><h3 class="text-xl font-semibold text-slate-900 mb-4">새 프로젝트 생성</h3><button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button></div><div class="border-b border-gray-200"><div class="p-1 mb-4 inline-flex space-x-1 bg-slate-100 rounded-lg">${tabButton('blank', '빈 프로젝트')}${tabButton('zip', 'ZIP')}${tabButton('tocJson', '목차 JSON')}${tabButton('jsonFile', '파일(.json)')}${tabButton('jsonText', '텍스트(.json)')}</div></div><div class="mt-4">${tabContent()}</div></div><div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg"><button type="button" data-action="close-modal" class="btn btn-secondary">취소</button><button type="submit" class="btn">생성</button></div></form>`;
     },

     renderConfirmModal() {
         const {
             title,
             message,
             confirmText
         } = this.data;
         return `<div class="p-6"><div class="sm:flex sm:items-start"><div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100 sm:mx-0 sm:h-10 sm:w-10">${Heroicons.render('exclamation-triangle', { class: 'h-6 w-6 text-red-600' })}</div><div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left"><h3 class="text-lg leading-6 font-medium text-gray-900">${title}</h3><div class="mt-2"><p class="text-sm text-gray-500">${message}</p></div></div></div></div><div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg"><button type="button" data-action="close-modal" class="btn btn-secondary">취소</button><button type="button" data-action="confirm-action" class="btn bg-red-600 hover:bg-red-700">${confirmText}</button></div>`;
     },

     renderSettingsModal() {
         const activeTab = this.data.activeTab || 'general';
         const tabButton = (id, label) => `<button type="button" data-action="switch-settings-tab" data-tab="${id}" class="px-4 py-2 text-sm font-medium rounded-md ${activeTab === id ? 'bg-indigo-600 text-white' : 'text-slate-500 hover:bg-slate-100'}">${label}</button>`;

         const renderTabContent = () => {
             switch (activeTab) {
                 case 'general':
                     return this.renderSettingsGeneralTab();
                 case 'prompts':
                     return this.renderSettingsPromptsTab();
                 case 'customButtons':
                     return this.renderSettingsCustomItemsTab('prompt');
                 case 'contextMenus':
                     return this.renderSettingsCustomItemsTab('contextMenu');
                 default:
                     return '';
             }
         };

         return `<form data-action="save-settings"><div class="p-6"><div class="flex justify-between items-start"><h3 class="text-xl font-semibold text-slate-900 mb-4">프로젝트 설정</h3><button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button></div><div class="p-1 mb-4 inline-flex space-x-1 bg-slate-100 rounded-lg">${tabButton('general', '일반')}${tabButton('prompts', '기본 프롬프트')}${tabButton('customButtons', '커스텀 버튼')}${tabButton('contextMenus', '컨텍스트 메뉴')}</div><div class="max-h-[60vh] overflow-y-auto pr-2 pt-4">${renderTabContent()}</div></div><div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg"><button type="button" data-action="close-modal" class="btn btn-secondary">취소</button><button type="submit" class="btn">저장</button></div></form>`;
     },

     renderSettingsGeneralTab() {
         const categoryOptions = state.categories.map(c => `<option value="${c.id}" ${c.id === this.data.categoryId ? 'selected' : ''}>${c.name}</option>`).join('');
         const tagPills = (this.data.projectTags || []).map(tag => `<span class="inline-flex items-center gap-x-0.5 rounded-md bg-indigo-50 px-2 py-1 text-xs font-medium text-indigo-700">${tag}<button type="button" data-action="remove-tag" data-tag="${tag}" class="group relative -mr-1 h-3.5 w-3.5 rounded-sm hover:bg-indigo-500/20">${Heroicons.render('x-mark', { class: 'h-3.5 w-3.5 text-indigo-600 hover:text-indigo-700' })}</button></span>`).join('');
         const fields = [{
                 id: 'name',
                 label: '프로젝트 이름',
                 value: this.data.name,
                 type: 'text'
             },
             {
                 id: 'categoryId',
                 label: '카테고리',
                 type: 'select',
                 options: categoryOptions
             },
             {
                 id: 'tags',
                 label: '태그',
                 type: 'tags',
                 pills: tagPills
             }
         ];
         return fields.map(f => {
             let fieldHtml = '';
             let fieldId = `setting-${f.id}`;
             switch (f.type) {
                 case 'select':
                     fieldHtml = `<select id="${fieldId}" data-setting-key="${f.id}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm"><option value="">미분류</option>${f.options}</select>`;
                     break;
                 case 'tags':
                     fieldId = 'setting-tags-input';
                     fieldHtml = `<div class="relative"><input type="text" id="${fieldId}" autocomplete="off" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm" placeholder="태그 입력 후 Enter..."><div id="tag-suggestions" class="absolute z-10 w-full bg-white border border-slate-300 rounded-md shadow-lg mt-1 hidden"></div><div id="tag-pills-container" class="mt-2 flex flex-wrap gap-2">${f.pills}</div></div>`;
                     break;
                 default:
                     fieldHtml = `<input type="${f.type}" id="${fieldId}" data-setting-key="${f.id}" value="${DOMPurify.sanitize(f.value || '')}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm">`;
             }
             return `<div class="mb-4"><label for="${fieldId}" class="block text-sm font-medium text-slate-700">${f.label}</label>${fieldHtml}</div>`;
         }).join('');
     },

     renderSettingsPromptsTab() {
         const fields = [{
                 id: 'writingGenre',
                 label: '글쓰기 - 장르',
                 value: this.data.writingGenre,
                 type: 'text'
             },
             {
                 id: 'writingAudience',
                 label: '글쓰기 - 목표 독자',
                 value: this.data.writingAudience,
                 type: 'text'
             },
             {
                 id: 'writingAgeGroup',
                 label: '글쓰기 - 대상 연령층',
                 value: this.data.writingAgeGroup,
                 type: 'text'
             },
             {
                 id: 'writingStyle',
                 label: '글쓰기 - 스타일',
                 value: this.data.writingStyle,
                 type: 'textarea'
             },
             {
                 id: 'writingReferences',
                 label: '글쓰기 - 자료',
                 value: this.data.writingReferences,
                 type: 'textarea'
             },
             {
                 id: 'writingPrompt',
                 label: '글쓰기 프롬프트 - 전체 템플릿',
                 value: this.data.writingPrompt,
                 type: 'textarea'
             },
             {
                 id: 'quizQuestionCount',
                 label: '퀴즈 - 생성 개수',
                 value: this.data.quizQuestionCount,
                 type: 'number'
             },
             {
                 id: 'quizTaskDescription',
                 label: '퀴즈 프롬프트 - 과업 설명 (Task)',
                 value: this.data.quizTaskDescription,
                 type: 'textarea'
             },
             {
                 id: 'quizOutputFormatInstruction',
                 label: '퀴즈 프롬프트 - 출력 형식 (Output)',
                 value: this.data.quizOutputFormatInstruction,
                 type: 'textarea'
             },
             {
                 id: 'quizPromptTemplate',
                 label: '퀴즈 프롬프트 - 전체 템플릿',
                 value: this.data.quizPromptTemplate,
                 type: 'textarea'
             },
         ];
         return fields.map(f => {
             const fieldValue = f.value || '';
             const fieldHtml = f.type === 'textarea' ? `<textarea id="setting-${f.id}" data-setting-key="${f.id}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm h-32 font-mono text-xs">${fieldValue}</textarea>` : `<input type="${f.type}" id="setting-${f.id}" data-setting-key="${f.id}" value="${DOMPurify.sanitize(fieldValue)}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm">`;
             return `<div class="mb-4"><label for="setting-${f.id}" class="block text-sm font-medium text-slate-700">${f.label}</label>${fieldHtml}</div>`;
         }).join('');
     },

     renderSettingsCustomItemsTab(type) {
         const isPrompt = type === 'prompt';
         const title = isPrompt ? '커스텀 버튼' : '컨텍스트 메뉴';
         const items = (isPrompt ? this.data.customPrompts : this.data.contextMenuItems) || [];
         const addAction = isPrompt ? 'add-custom-prompt' : 'add-custom-context-menu';
         const removeAction = isPrompt ? 'remove-custom-prompt' : 'remove-custom-context-menu';
         const nameId = `new-${type}-name`;
         const templateId = `new-${type}-template`;
         const helpText = isPrompt ?
             `<ul class="list-disc list-inside space-y-1"><li><code class="bg-slate-200 px-1 rounded">{{bookTitle}}</code>, <code class="bg-slate-200 px-1 rounded">{{chapterTitle}}</code>, <code class="bg-slate-200 px-1 rounded">{{manuscript}}</code> 등 모든 변수 사용 가능</li></ul>` :
             `<ul class="list-disc list-inside space-y-1"><li><code class="bg-slate-200 px-1 rounded">{{selected_text}}</code>: 사용자가 선택한 텍스트로 치환됩니다.</li><li>이제 <code class="bg-slate-200 px-1 rounded">{{chapterTitle}}</code> 등 모든 변수도 함께 사용 가능합니다.</li></ul>`;

         const existingItemsHtml = items.map(item => `
                    <div class="p-3 border rounded-lg flex justify-between items-center bg-white">
                        <div class="flex-1 min-w-0">
                            <p class="text-sm font-semibold text-slate-800 truncate">${item.name}</p>
                            <p class="text-xs text-slate-500 truncate mt-1 font-mono">${item.template}</p>
                        </div>
                        <button type="button" data-action="${removeAction}" data-id="${item.id}" class="p-2 rounded-full hover:bg-red-100 text-red-500 ml-4">
                            ${Heroicons.render('trash', { class: 'w-4 h-4' })}
                        </button>
                    </div>
                `).join('');

         return `<div class="space-y-4"><div class="p-4 border border-slate-300 rounded-lg bg-slate-50"><h4 class="text-md font-semibold text-slate-800 mb-3">새 ${title} 추가</h4><div class="space-y-3"><div><label for="${nameId}" class="block text-xs font-medium text-slate-600">이름</label><input type="text" id="${nameId}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm" placeholder="${title} 이름"></div><div><label for="${templateId}" class="block text-xs font-medium text-slate-600">프롬프트 템플릿</label><textarea id="${templateId}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm h-24 font-mono text-xs" placeholder="프롬프트 템플릿 입력..."></textarea></div></div><button type="button" data-action="${addAction}" class="btn w-full justify-center mt-4">${Heroicons.render('plus', { class: 'w-4 h-4 mr-2' })} 목록에 추가</button></div><div class="space-y-3"><h4 class="text-md font-semibold text-slate-800">기존 ${title} 목록 (${items.length}개)</h4>${items.length > 0 ? existingItemsHtml : `<p class="text-sm text-slate-500 text-center py-4">추가된 항목이 없습니다.</p>`}</div><div class="mt-4 text-xs text-slate-500 p-3 bg-slate-100 rounded-md"><p class="font-semibold mb-1">사용 가능한 변수:</p>${helpText}</div></div>`;
     },

     renderApiKeyModal() {
         return `<form data-action="submit-api-key"><div class="p-6"><div class="flex items-start"><div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-indigo-100 sm:mx-0 sm:h-10 sm:w-10">${Heroicons.render('key', { style: 'solid', class: 'h-6 w-6 text-indigo-600' })}</div><div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left"><h3 class="text-lg leading-6 font-medium text-gray-900">Google AI API 키 입력</h3><div class="mt-2"><p class="text-sm text-gray-500">퀴즈 생성을 위해 Google AI Studio에서 발급받은 API 키를 입력해주세요.</p><input type="password" id="api-key-input" class="mt-2 block w-full rounded-md border-slate-300" placeholder="API 키를 여기에 붙여넣으세요"></div></div></div></div><div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg"><button type="button" data-action="close-modal" class="btn btn-secondary">취소</button><button type="submit" class="btn">확인</button></div></form>`;
     },

     renderManageQuizModal() {
         const questions = state.activeChapterContent.questions || [];
         const questionsHtml = questions.map((q, index) => `<div class="p-3 my-2 border rounded-md bg-slate-50 flex justify-between items-center group"><p class="text-sm text-slate-800 truncate pr-4">${index + 1}. ${q.questionText}</p><button type="button" data-action="delete-quiz-question" data-index="${index}" class="p-1 text-slate-500 hover:text-red-600 rounded-full hover:bg-red-100 opacity-0 group-hover:opacity-100 transition-opacity">${Heroicons.render('trash', { class: 'w-4 h-4' })}</button></div>`).join('');
         return `<div class="p-6"><div class="flex justify-between items-start"><h3 class="text-xl font-semibold text-slate-900 mb-4">퀴즈 관리</h3><button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button></div><div class="max-h-[30vh] overflow-y-auto border rounded-lg p-2 bg-white mb-4">${questions.length > 0 ? questionsHtml : '<p class="text-sm text-slate-500 text-center py-4">생성된 문제가 없습니다.</p>'}</div><h4 class="text-lg font-semibold text-slate-800 border-t pt-4 mb-3">AI 프롬프트를 사용하여 문제 추가</h4><p class="text-sm text-slate-600 mb-2">1. 아래 버튼으로 프롬프트를 복사하여 AI 도구(예: Google AI Studio)에 붙여넣고 결과를 생성하세요.</p><button data-action="copy-quiz-prompt" class="btn w-full justify-center">${Heroicons.render('clipboard-document', { class: 'w-4 h-4 mr-2' })}AI 생성 프롬프트 복사</button><form data-action="add-questions-from-json" class="mt-4"><label for="quiz-json-paste" class="text-sm text-slate-600 mb-2 block">2. AI가 생성한 JSON 배열을 아래에 붙여넣고 '추가' 버튼을 누르세요.</label><textarea id="quiz-json-paste" name="jsonContent" class="w-full h-24 p-2 border rounded-md font-mono text-xs" placeholder="[ { ... } ]" required></textarea><div class="bg-slate-50 -mx-6 -mb-6 px-6 py-4 mt-6 flex justify-end space-x-3 rounded-b-lg"><button type="button" data-action="close-modal" class="btn btn-secondary">닫기</button><button type="submit" class="btn bg-emerald-600 hover:bg-emerald-700">JSON에서 문제 추가</button></div></form></div>`;
     },

     renderManageTocModal() {
         const renderNode = (node, path) => {
             const hasChildren = node.children && node.children.length > 0;
             const childrenHtml = hasChildren ? `<ul class="pl-4 border-l border-slate-200">${node.children.map((child, index) => renderNode(child, `${path}.${index}`)).join('')}</ul>` : '';
             const iconName = hasChildren ? 'folder' : 'document-text';
             return `<li draggable="true" data-path="${path}" class="my-1 group toc-drag-item"><div class="flex items-center p-2 rounded-md hover:bg-slate-100">${Heroicons.render(iconName, { class: 'w-4 h-4 mr-2 text-slate-500 flex-shrink-0' })}<input type="text" value="${DOMPurify.sanitize(node.title)}" data-action="toc-edit-title" data-path="${path}" class="flex-grow bg-transparent focus:bg-white focus:ring-1 focus:ring-indigo-500 rounded-md px-1 py-0.5 text-sm"><div class="flex items-center space-x-1 ml-2 opacity-0 group-hover:opacity-100 transition-opacity"><button data-action="toc-add-child" data-path="${path}" title="하위 항목 추가" class="p-1 rounded hover:bg-slate-200">${Heroicons.render('arrow-turn-down-right', { class: 'w-4 h-4 text-slate-600' })}</button><button data-action="toc-delete" data-path="${path}" title="삭제" class="p-1 rounded hover:bg-red-100">${Heroicons.render('trash', { class: 'w-4 h-4 text-red-500' })}</button></div></div>${childrenHtml}</li>`;
         };
         const editableToc = this.data.editableToc;
         if (!editableToc || !editableToc.children) return '<div>목차를 불러올 수 없습니다.</div>';
         const tocHtml = `<ul id="toc-editor-list" class="space-y-1">${editableToc.children.map((child, index) => renderNode(child, String(index))).join('')}</ul>`;
         return `<div class="p-6"><div class="flex justify-between items-start"><h3 class="text-xl font-semibold text-slate-900 mb-4">목차 관리</h3><button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button></div><div class="max-h-[60vh] overflow-y-auto pr-2 border rounded-lg p-2 bg-slate-50 mb-4">${tocHtml}</div><div class="text-right"><button data-action="toc-add-root-item" class="btn btn-secondary">${Heroicons.render('plus', { class: 'w-4 h-4 mr-2' })}최상위 항목 추가</button></div></div><div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg"><button type="button" data-action="close-modal" class="btn btn-secondary">취소</button><button type="button" data-action="save-toc" class="btn">변경사항 저장</button></div>`;
     },

     renderSplitChapterModal() {
         const chapterNode = Utils.getNodeByPath(state.activeProject.toc, state.activeChapterPath);
         const {
             sourceToSplit = 'manuscript'
         } = this.data;
         const hasManuscript = state.activeChapterContent.manuscript?.trim();
         const hasTranslation = state.activeChapterContent.translation?.trim();

         const header = `<div class="p-6 border-b"><div class="flex justify-between items-start"><h3 class="text-xl font-semibold text-slate-900">챕터 분할 및 하위 챕터 생성</h3><button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button></div><p class="text-sm text-slate-500 mt-1">'${chapterNode.title}' 노트를 여러 개의 하위 노트로 분할합니다.</p></div>`;

         const content = `<form data-action="submit-split-chapter"><div class="p-6"><div class="mb-4"><label class="block text-sm font-medium text-slate-700 mb-2">1. 분할할 대상 선택</label><div class="flex items-center space-x-4 p-2 bg-slate-100 rounded-md" data-action="regenerate-split-prompt"><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="split-source" value="manuscript" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500" ${sourceToSplit === 'manuscript' ? 'checked' : ''} ${!hasManuscript ? 'disabled' : ''}><span>원고</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="split-source" value="translation" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500" ${sourceToSplit === 'translation' ? 'checked' : ''} ${!hasTranslation ? 'disabled' : ''}><span>번역문</span></label></div><p class="text-xs text-slate-500 mt-2">대상을 선택하면 AI 프롬프트가 클립보드에 자동으로 복사됩니다.</p></div><label for="split-json-paste" class="text-sm text-slate-600 mb-2 block">2. AI가 생성한 JSON 응답 붙여넣기</label><textarea id="split-json-paste" name="jsonContent" class="w-full h-40 p-2 border rounded-md font-mono text-xs" placeholder="[ { ... } ]" required></textarea></div><div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg"><button type="button" data-action="close-modal" class="btn btn-secondary">닫기</button><button type="submit" class="btn bg-emerald-600 hover:bg-emerald-700">${Heroicons.render('check-circle', { class: 'w-4 h-4 mr-2' })}하위 챕터 생성 실행</button></div></form>`;
         return header + content;
     },
 };

 const View = {
         appContainerEl: document.getElementById('app-container'),
         modalEl: document.getElementById('modal-root'),
         toastEl: document.getElementById('toast-root'),
         render() {
             const appHtml = this.renderAppLayout();
             morphdom(this.appContainerEl, `<div>${appHtml}</div>`, {
                 childrenOnly: true,
                 onNodeAdded: (node) => {
                     if (node.nodeType === 1) {
                         if (state.isKaTeXLoaded) Controller.applyPostRenderEffects();
                     }
                     return node;
                 }
             });
             this.toastEl.innerHTML = this.renderToasts();
             const contextMenuContainer = document.getElementById('context-menu-root') || (() => {
                 const el = document.createElement('div');
                 el.id = 'context-menu-root';
                 document.body.appendChild(el);
                 return el;
             })();
             contextMenuContainer.innerHTML = this.renderContextMenu();
             Controller.applyPostRenderEffects();
             Controller.bindDynamicEventListeners();
         },
         renderAppLayout() {
             if (state.isLoading) return this.renderSpinner("시스템 로딩 중...");
             if (['quiz', 'quizResult'].includes(state.currentView)) return this.renderCurrentView();
            return `<aside class="sidebar ${state.isSidebarOpen ? '' : 'w-0 overflow-hidden !p-0 !border-0'} ${state.isMobileSidebarOpen ? 'open' : ''}" id="sidebar"> ${this.renderSidebar()} </aside><div class="sidebar-overlay ${state.isMobileSidebarOpen ? 'show' : ''}" id="sidebar-overlay" data-action="close-sidebar"></div><main class="main-content">${this.renderMainHeader()}<div class="content-view" id="content-view"> ${this.renderCurrentView()} </div></main>`;
         },
         renderSidebar() {
             if (state.activeProjectId && state.activeProject) return this.renderProjectSidebar();
             return this.renderLibrarySidebar();
         },
         renderLibrarySidebar() {
             const {
                 type,
                 id
             } = state.currentFilter;
             const categoryListHtml = state.categories.map(c => `<li class="nav-item ${type === 'category' && id === c.id ? 'active' : ''}" data-action="filter" data-filter-type="category" data-id="${c.id}"><a>${Heroicons.render('folder', { class: 'icon' })} ${c.name}</a></li>`).join('');
             const tagListHtml = state.tags.map(t => `<li class="nav-item ${type === 'tag' && id === t.name ? 'active' : ''}" data-action="filter" data-filter-type="tag" data-id="${t.name}"><a>${Heroicons.render('tag', { class: 'icon' })} ${t.name} <span class="tag-count">${t.count}</span></a></li>`).join('');
             return `<div class="sidebar-header"><a href="#" data-action="go-dashboard" class="logo">${Heroicons.render('academic-cap', { style: 'solid' })} 학습 & 저작 v3.16</a></div><div class="sidebar-content"><div class="nav-section"><button class="btn" data-action="new-project" style="width: 100%;">${Heroicons.render('plus')} 새 프로젝트</button></div><nav class="sidebar-nav"><div class="nav-section"><h3 class="nav-section-title">라이브러리</h3><ul class="nav-list" id="library-list"><li class="nav-item ${type === 'dashboard' ? 'active' : ''}" data-action="filter" data-filter-type="dashboard"><a>${Heroicons.render('squares-2x2', { class: 'icon' })} 대시보드</a></li><li class="nav-item ${type === 'all' ? 'active' : ''}" data-action="filter" data-filter-type="all"><a>${Heroicons.render('document-duplicate', { class: 'icon' })} 모든 프로젝트</a></li></ul></div><div class="nav-section"><div class="flex justify-between items-center p-2"><h3 class="nav-section-title mb-0">카테고리</h3><button data-action="toggle-sidebar-section" data-section="categories" title="카테고리 접기/펴기" class="text-slate-400 hover:text-slate-600">${Heroicons.render(state.sidebarCollapseState.categories ? 'chevron-right' : 'chevron-down', { class: 'w-4 h-4' })}</button></div>${!state.sidebarCollapseState.categories ? `<ul class="nav-list" id="category-list">${categoryListHtml}</ul>` : ''}</div><div class="nav-section"><div class="flex justify-between items-center p-2"><h3 class="nav-section-title mb-0">태그</h3><button data-action="toggle-sidebar-section" data-section="tags" title="태그 접기/펴기" class="text-slate-400 hover:text-slate-600">${Heroicons.render(state.sidebarCollapseState.tags ? 'chevron-right' : 'chevron-down', { class: 'w-4 h-4' })}</button></div>${!state.sidebarCollapseState.tags ? `<ul class="nav-list" id="tag-list">${tagListHtml}</ul>` : ''}</div></nav></div><div class="sidebar-footer">${this.renderUserProfile()}</div>`;
         },
         renderProjectSidebar() {
             const tocControls = `<div class="flex justify-end gap-2 px-2 pb-2"><button class="btn btn-secondary btn-sm text-xs" data-action="toggle-toc-all" data-mode="expand">전체 펼치기</button><button class="btn btn-secondary btn-sm text-xs" data-action="toggle-toc-all" data-mode="collapse">전체 접기</button></div>`;
             return `<div class="sidebar-header"><button data-action="go-dashboard" class="btn btn-secondary w-full text-sm">${Heroicons.render('arrow-left', { class: 'w-4 h-4 mr-2' })} 라이브러리로 돌아가기</button></div><div class="sidebar-content"><h3 class="nav-section-title">${state.activeProject.name} 목차</h3>${tocControls}${this.renderToc(state.activeProject.toc)}</div><div class="sidebar-footer">${this.renderUserProfile()}</div>`;
         },
         renderUserProfile() {
             const {
                 level,
                 xp
             } = state.userProfile;
             const currentLevelXP = CONFIG.LEVEL_THRESHOLDS[level - 1] || 0;
             const nextLevelXP = CONFIG.LEVEL_THRESHOLDS[level] || xp;
             const xpForLevel = nextLevelXP - currentLevelXP;
             const currentXPInLevel = xp - currentLevelXP;
             const progress = xpForLevel > 0 ? Math.round((currentXPInLevel / xpForLevel) * 100) : 100;
             return `<div class="flex items-center space-x-4"><div class="font-semibold text-sm text-slate-600">LV. <span class="text-indigo-600 font-bold text-base">${level}</span></div><div class="w-full" title="${xp} XP"><div class="bg-slate-200 rounded-full h-2.5"><div class="xp-bar-inner h-2.5 rounded-full" style="width: ${progress}%"></div></div></div></div>`;
         },
         renderMainHeader() {
             const title = this.getHeaderTitle();
             const isProjectListView = state.currentView === 'project_list';
             const workspaceControls = state.currentView === 'workspace' && state.activeProjectId ? `<button data-action="manage-toc" class="btn btn-secondary btn-sm" title="목차 관리">${Heroicons.render('bars-3-bottom-left', { class: 'w-4 h-4' })}</button><button data-action="open-settings" class="btn btn-secondary btn-sm" title="설정">${Heroicons.render('cog-6-tooth', { class: 'w-4 h-4' })}</button>` : '';

             let saveStatusIndicator = '';
             if (state.saveStatus === 'saving') {
                 saveStatusIndicator = `<div class="flex items-center gap-2 text-sm text-slate-500"><div class="w-4 h-4 border-2 border-slate-400 border-t-transparent rounded-full animate-spin"></div> 저장 중...</div>`;
             } else if (state.saveStatus === 'saved' && state.saveTimestamp) {
                 saveStatusIndicator = `<div class="flex items-center gap-2 text-sm text-green-600">${Heroicons.render('check', { class: 'w-4 h-4' })} 마지막 저장: ${state.saveTimestamp.toLocaleTimeString()}</div>`;
             }

            // Render a slightly larger menu icon for better visibility
            const sidebarIcon = Heroicons.render('bars-3', { class: 'w-6 h-6' });
            return `<header class="main-header"><button id="sidebar-toggle" class="mr-4" data-action="toggle-sidebar">${sidebarIcon}</button><h1 class="header-title">${title}</h1><div class="flex items-center gap-4">${saveStatusIndicator}<div class="relative"><input type="text" class="search-input" id="search-input" placeholder="프로젝트 검색..." value="${state.searchResults ? document.getElementById('search-input')?.value || '' : ''}"><div class="absolute right-3 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-400">${Heroicons.render('magnifying-glass')}</div></div><div class="header-controls" style="${isProjectListView ? '' : 'display:none;'}"><select id="sort-select" data-action="sort-projects" class="btn btn-secondary btn-sm"><option value="updatedAt_desc" ${state.currentSortOrder === 'updatedAt_desc' ? 'selected' : ''}>최근 수정순</option><option value="createdAt_desc" ${state.currentSortOrder === 'createdAt_desc' ? 'selected' : ''}>최신 생성순</option><option value="name_asc" ${state.currentSortOrder === 'name_asc' ? 'selected' : ''}>이름 (가나다순)</option></select></div>${workspaceControls}</div></header>`;
         },
         getHeaderTitle() {
             if (state.currentView === 'workspace' && state.activeProject) return state.activeProject.name;
             const {
                 type,
                 id
             } = state.currentFilter;
             if (type === 'dashboard') return '대시보드';
             if (type === 'all' || state.searchResults) return '모든 프로젝트';
             if (type === 'category') return state.categories.find(c => c.id === id)?.name || '카테고리';
             if (type === 'tag') return `#${id}`;
             return '학습 및 저작 시스템';
         },
         renderCurrentView() {
             switch (state.currentView) {
                 case 'dashboard':
                     return this.renderDashboard();
                 case 'project_list':
                     return this.renderProjectList();
                 case 'workspace':
                     return this.renderWorkspace();
                 case 'quiz':
                     return this.renderQuizView();
                 case 'quizResult':
                     return this.renderQuizResultView();
                 default:
                     return `<div class="text-center p-8 text-slate-500">뷰를 로드하는 중...</div>`;
             }
         },
         renderDashboard() {
             const recentProjects = [...state.projects].sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0)).slice(0, 5);
             const statItem = (value, label, filterType, id = null) => `
                    <a href="#" class="text-center block hover:bg-slate-50 p-2 rounded-lg" data-action="filter" data-filter-type="${filterType}" ${id ? `data-id="${id}"` : ''}>
                        <div class="text-3xl font-bold">${value}</div>
                        <div class="text-sm text-slate-500">${label}</div>
                    </a>
                `;
             return `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"><div class="p-6 bg-white rounded-lg shadow-sm"><div class="flex justify-between items-center mb-4"><h3 class="text-lg font-semibold">빠른 작업</h3></div><div class="grid grid-cols-2 gap-4"><button class="btn" data-action="new-project">${Heroicons.render('plus')} 새 프로젝트</button><button class="btn btn-secondary" data-action="new-category">${Heroicons.render('folder-plus')} 새 카테고리</button></div></div><div class="p-6 bg-white rounded-lg shadow-sm"><div class="flex justify-between items-center mb-4"><h3 class="text-lg font-semibold">개요</h3></div><div class="flex justify-around">${statItem(state.projects.length, '프로젝트', 'all')}${statItem(state.categories.length, '카테고리', 'category')}${statItem(state.tags.length, '태그', 'tag')}</div></div><div class="p-6 bg-white rounded-lg shadow-sm md:col-span-2 lg:col-span-1"><div class="flex justify-between items-center mb-4"><h3 class="text-lg font-semibold">최근 프로젝트</h3></div><ul class="divide-y divide-slate-100">${recentProjects.map(p => `<li class="py-2 flex justify-between items-center hover:bg-slate-50 rounded-md"><a href="#" data-action="open-project" data-id="${p.id}" class="flex-grow min-w-0"><p class="font-medium truncate">${p.name}</p><p class="text-xs text-slate-500">${new Date(p.updatedAt || p.createdAt).toLocaleString()}</p></a><button data-action="open-project" data-id="${p.id}">${Heroicons.render('chevron-right', { class: 'w-4 h-4 text-slate-400' })}</button></li>`).join('') || '<li class="p-4 text-center text-slate-500">최근 프로젝트가 없습니다.</li>'}</ul></div></div>`;
         },
         renderProjectList() {
             let filtered = Controller.getFilteredAndSortedProjects();
             if (filtered.length === 0) {
                 return `<div class="text-center p-8 text-slate-500">표시할 프로젝트가 없습니다.</div>`;
             }
             return `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">${filtered.map(p => this.getProjectCardHTML(p)).join('')}</div>`;
         },
         getProjectCardHTML(p) {
             const category = p.categoryId ? state.categories.find(c => c.id === p.categoryId) : null;
             const noteCount = p.toc && p.toc.children ? Utils.getAllNodePaths(p.toc).length : 0;
             return `<div class="project-card flex flex-col"><div class="project-card-content flex-grow" data-action="open-project" data-id="${p.id}"><p class="text-sm text-indigo-600 font-semibold">${category ? category.name : '미분류'}</p><h3 class="mt-1 text-lg leading-tight font-bold text-black">${p.name}</h3><div class="mt-2 flex flex-wrap gap-2">${(p.tags || []).map(tag => `<span class="inline-block bg-slate-200 text-slate-600 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">#${tag}</span>`).join('')}</div></div><div class="border-t mt-4 pt-4 flex justify-between items-center"><p class="text-sm text-slate-500">${noteCount}개의 노트</p><div class="flex space-x-2"><button data-action="export-project" data-id="${p.id}" title="내보내기" class="p-2 text-slate-500 hover:bg-slate-200 rounded-full">${Heroicons.render('arrow-down-tray', { class: 'w-4 h-4' })}</button><button data-action="delete-project-confirm" data-id="${p.id}" title="삭제" class="p-2 text-slate-500 hover:bg-red-100 rounded-full">${Heroicons.render('trash', { class: 'w-4 h-4 text-red-500' })}</button></div></div></div>`;
         },
         renderWorkspace() {
             if (!state.activeProject) return this.renderSpinner("프로젝트 로딩 중...");
             const allNodes = Utils.getFlatToc(state.activeProject.toc);
             const currentIndex = allNodes.findIndex(c => c.path === state.activeChapterPath);
             const hasPrev = currentIndex > 0;
             const hasNext = currentIndex !== -1 && currentIndex < allNodes.length - 1;
             const navButton = (action, icon, disabled) => `<button data-action="${action}" class="p-2 rounded-full hover:bg-slate-200 disabled:opacity-30 disabled:cursor-not-allowed" ${disabled ? 'disabled' : ''}>${Heroicons.render(icon, { class: 'w-5 h-5 text-slate-600' })}</button>`;

             return `<div>
                    <div class="flex items-center gap-2 mb-4">
                        ${navButton('prev-chapter', 'chevron-left', !hasPrev)}
                        <div class="flex-grow">${this.renderBreadcrumbs()}</div>
                        ${navButton('next-chapter', 'chevron-right', !hasNext)}
                    </div>
                    <div class="bg-white rounded-lg shadow-sm">
                        <div class="border-b border-slate-200">
                            <nav class="-mb-px flex space-x-2 sm:space-x-8 px-4 sm:px-6 overflow-x-auto" aria-label="Tabs">
                                ${this.renderModeTab('write', 'pencil-square', 'AI 글쓰기')}
                                ${this.renderModeTab('view', 'eye', '보기')}
                                ${this.renderModeTab('learn', 'academic-cap', '학습')}
                                ${this.renderModeTab('translate', 'language', '번역')}
                                ${this.renderModeTab('custom', 'sparkles', '커스텀 버튼')}
                            </nav>
                        </div>
                        <div id="workspace-main-content" class="p-4 sm:p-6 min-h-[70vh] overflow-y-auto">${this.renderWorkspacePanel()}</div>
                    </div>
                </div>`;
         },
         renderBreadcrumbs() {
             if (!state.activeChapterPath) return '<div class="bg-slate-100 rounded-lg p-2.5 h-[44px] flex items-center"><span class="text-sm text-slate-500">노트를 선택하세요.</span></div>';
             const breadcrumbs = [];
             let currentPath = '';
             let currentNode = state.activeProject.toc;
             state.activeChapterPath.split('.').forEach((part) => {
                 currentNode = currentNode.children[part];
                 currentPath = currentPath ? `${currentPath}.${part}` : `${part}`;
                 breadcrumbs.push({
                     title: currentNode.title,
                     path: currentPath
                 });
             });
             const items = breadcrumbs.map((crumb, index) => {
                 const isLast = index === breadcrumbs.length - 1;
                 const textColor = isLast ? 'text-slate-700 font-semibold' : 'text-slate-500 hover:text-indigo-600';
                 const chevron = !isLast ? Heroicons.render('chevron-right', { class: 'h-4 w-4 text-slate-400 mx-1' }) : '';
                 return `<li class="flex items-center"><a href="#" data-action="select-chapter" data-path="${crumb.path}" class="text-sm ${textColor}">${crumb.title}</a>${chevron}</li>`;
             }).join('');
             return `<nav class="bg-slate-100 rounded-lg p-2.5"><ol class="flex items-center flex-wrap">${items}</ol></nav>`;
         },
         renderToc(toc, level = 0, pathPrefix = '') {
             if (!toc?.children?.length) return level === 0 ? `<p class="text-sm text-slate-500 p-2">목차가 비어있습니다.</p>` : '';
             const items = toc.children.map((item, index) => {
                 const currentPath = pathPrefix ? `${pathPrefix}.${index}` : `${index}`;
                 const hasChildren = item.children && item.children.length > 0;
                 const isCollapsed = state.tocCollapseState[currentPath];
                 const content = state.activeContentsMap.get(`${state.activeProjectId}_${currentPath}`);
                 let statusIndicator = '';
                 if (content?.status && content.status !== 'empty') {
                     const colorMap = {
                         'prompt-copied': 'bg-blue-400',
                         'manuscript-done': 'bg-yellow-400',
                         'quiz-done': 'bg-green-400'
                     };
                     if (colorMap[content.status]) statusIndicator = `<span class="w-2 h-2 rounded-full ${colorMap[content.status]} mr-2 flex-shrink-0" title="상태: ${content.status}"></span>`;
                 }
                 const collapseIcon = hasChildren ? `<button data-action="toggle-toc-collapse" data-path="${currentPath}" class="p-1 rounded-md hover:bg-slate-200 flex-shrink-0 mr-1">${Heroicons.render(isCollapsed ? 'chevron-right' : 'chevron-down', { class: 'w-4 h-4 text-slate-500' })}</button>` : `<span class="w-6 mr-1"></span>`;
                 return `<li class="my-1 toc-item ${state.activeChapterPath === currentPath ? 'active' : ''}"><div class="flex items-center" style="padding-left: ${level * 1}rem;"><a href="#" data-action="select-chapter" data-path="${currentPath}" class="flex-grow flex items-center p-2 rounded-md text-sm text-slate-700 hover:bg-slate-100 relative w-full">${collapseIcon}${statusIndicator} <span class="truncate">${item.title}</span></a></div>${hasChildren && !isCollapsed ? `<ul class="mt-1">${this.renderToc(item, level + 1, currentPath)}</ul>` : ''}</li>`;
             }).join('');
             return `<ul class="nav-list">${items}</ul>`;
         },
         renderModeTab: (mode, icon, label) => {
             const isActive = state.workspaceMode === mode;
             const iconClass = `${isActive ? 'text-indigo-500' : 'text-slate-400 group-hover:text-slate-500'} -ml-0.5 mr-2 h-5 w-5`;
             return `<button data-action="switch-mode" data-mode="${mode}" class="${isActive ? 'border-indigo-500 text-indigo-600' : 'border-transparent text-slate-500 hover:text-slate-700 hover:border-slate-300'} group inline-flex items-center py-4 px-1 border-b-2 font-medium text-sm flex-shrink-0">${Heroicons.render(icon, { class: iconClass })}<span>${label}</span></button>`;
         },
         renderWorkspacePanel() {
             if (!state.activeChapterPath) {
                 return `<div class="flex flex-col items-center justify-center h-full min-h-[60vh] text-center p-4">${Heroicons.render('document-text', { class: 'h-16 w-16 text-slate-300' })}<h3 class="mt-4 text-xl font-semibold text-slate-800">노트를 선택하세요</h3><p class="mt-1 text-slate-500">좌측 목차에서 작업할 노트를 선택해주세요.</p></div>`;
             }
             if (!state.activeChapterContent) {
                 return this.renderSpinner("노트 내용 로딩 중...");
             }
             switch (state.workspaceMode) {
                 case 'view':
                     return this.renderViewPanel();
                 case 'write':
                     return this.renderWritePanel();
                 case 'learn':
                     return this.renderLearnPanel();
                 case 'translate':
                     return this.renderTranslatePanel();
                 case 'custom':
                     return this.renderCustomButtonPanel();
                 default:
                     return `<div>알 수 없는 모드입니다.</div>`;
             }
         },
         renderViewPanel() {
             const content = state.activeChapterContent;
             const hasManuscript = content.manuscript && content.manuscript.trim();
             const hasTranslation = content.translation && content.translation.trim();

             let effectiveMode = state.viewPanelDisplayMode;
             if (effectiveMode === 'auto') {
                 effectiveMode = hasTranslation ? 'translation' : 'manuscript';
             }

             const layoutButton = (mode, icon, label) => {
                 const isActive = effectiveMode === mode;
                 const isDisabled = (mode === 'manuscript' && !hasManuscript) || (mode === 'translation' && !hasTranslation) || (mode === 'both' && (!hasManuscript || !hasTranslation));
                 return `<button data-action="set-view-panel-mode" data-mode="${mode}" title="${label}" class="px-3 py-1 text-sm font-medium ${isActive ? 'bg-indigo-100 text-indigo-700' : 'bg-white'} border border-slate-300 first:rounded-l-md last:rounded-r-md hover:bg-slate-50 disabled:opacity-50 disabled:cursor-not-allowed" ${isDisabled ? 'disabled' : ''}>${Heroicons.render(icon, { class: 'w-4 h-4' })}</button>`;
             };

             const controls = `<div class="flex justify-end mb-4"><div class="inline-flex rounded-md shadow-sm">${layoutButton('manuscript', 'document-text', '원문만 보기')}${layoutButton('translation', 'language', '번역문만 보기')}${layoutButton('both', 'rectangle-group', '모두 보기')}</div></div>`;

             const allowedTagsConfig = {
                 ALLOWED_TAGS: ['strong', 'b', 'em', 'i', 'p', 'br', 'ul', 'ol', 'li', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'a', 'img', 'code', 'pre', 'blockquote']
             };
             let finalHtml = '';

             const processContent = (textContent) => {
                 const boldProcessed = Utils.customBoldParser(textContent);
                 const markdownProcessed = marked.parse(boldProcessed);
                 return DOMPurify.sanitize(markdownProcessed, allowedTagsConfig);
             };

             if ((effectiveMode === 'manuscript' || effectiveMode === 'both') && hasManuscript) {
                 finalHtml += `<h3 class="text-xl font-semibold mb-4 text-slate-800 border-b pb-2">원문 보기</h3><div class="prose prose-custom prose-readable max-w-full">${processContent(content.manuscript)}</div>`;
             }

             if ((effectiveMode === 'translation' || effectiveMode === 'both') && hasTranslation) {
                 finalHtml += `<h3 class="text-xl font-semibold mb-4 ${hasManuscript && effectiveMode === 'both' ? 'mt-8' : ''} text-slate-800 border-b pb-2">번역문 보기</h3><div class="prose prose-custom prose-readable max-w-full">${processContent(content.translation)}</div>`;
             }

             if (!finalHtml.trim()) {
                 finalHtml = `<div class="text-center text-slate-500 py-16"><p>표시할 원문 또는 번역문 내용이 없습니다.</p></div>`;
             }

             return `<div>${controls}${finalHtml}</div>`;
         },
         renderWritePanel() {
             const content = state.activeChapterContent;
             return `
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div class="h-[70vh] flex flex-col">
                            <div class="flex justify-between items-center mb-2">
                                <h3 class="text-lg font-semibold text-slate-800">원고 작성</h3>
                                <button data-action="copy-writing-prompt" class="btn btn-secondary btn-sm">
                                    ${Heroicons.render('clipboard-document', { class: 'w-4 h-4 mr-2' })}프롬프트 복사
                                </button>
                            </div>
                            <textarea id="manuscript" data-field="manuscript" class="w-full flex-grow p-4 border border-slate-300 rounded-md shadow-sm">${content.manuscript || ''}</textarea>
                        </div>
                        <div class="h-[70vh] flex flex-col">
                            <h3 class="text-lg font-semibold mb-2 text-slate-800">챕터 목표 및 메모</h3>
                            <textarea id="notes" data-field="notes" class="w-full flex-grow p-4 border border-slate-300 rounded-md shadow-sm bg-yellow-50">${content.notes || ''}</textarea>
                        </div>
                    </div>
                `;
         },
         renderLearnPanel() {
             const hasQuestions = state.activeChapterContent?.questions?.length > 0;
             return `<div class="flex flex-col items-center justify-center h-full text-center min-h-[60vh]">${Heroicons.render('light-bulb', { class: 'h-12 w-12 text-slate-400' })}<h4 class="mt-4 text-lg font-semibold text-slate-700">지식을 테스트해보세요</h4><p class="mt-1 text-sm text-slate-500">학습한 내용을 기반으로 퀴즈를 풀어보세요.</p><div class="mt-6 flex flex-col space-y-3 w-full max-w-xs"><button data-action="start-quiz" class="btn w-full justify-center" ${!hasQuestions ? 'disabled' : ''}>퀴즈 시작 (${hasQuestions ? state.activeChapterContent.questions.length : 0}문제)</button><button data-action="manage-quiz" class="btn btn-secondary w-full justify-center">퀴즈 관리</button><button data-action="generate-quiz" class="btn btn-secondary w-full justify-center">${Heroicons.render('sparkles', { class: 'w-5 h-5 mr-2' })}AI로 문제 추가</button></div>${!hasQuestions ? '<p class="mt-2 text-xs text-slate-400">퀴즈를 진행하려면 문제를 먼저 추가해주세요.</p>' : ''}</div>`;
         },
         renderTranslatePanel() {
             const content = state.activeChapterContent;
             const layout = state.workspaceLayout;
             const sourceText = content.manuscript ? marked.parse(content.manuscript) : '<p>번역할 원문이 없습니다.</p>';
             const leftClasses = (layout === 'right') ? 'hidden' : '';
             const rightClasses = (layout === 'left') ? 'hidden' : '';
             const gridClasses = (layout === 'split') ? 'lg:grid-cols-2' : 'lg:grid-cols-1';

             const controls = `
                    <div class="flex justify-between items-center mb-4">
                        <button data-action="open-split-chapter-modal" class="btn btn-secondary p-2" title="번역문 분할">${Heroicons.render('arrows-right-left', { class: 'w-5 h-5' })}</button>
                        <div class="flex-grow flex justify-center">
                            <div class="inline-flex rounded-md shadow-sm">
                                <button data-action="set-workspace-layout" data-layout="left" title="원문만 보기" class="px-3 py-1 text-sm font-medium ${layout === 'left' ? 'bg-indigo-100 text-indigo-700' : 'bg-white'} border border-slate-300 rounded-l-md hover:bg-slate-50">${Heroicons.render('arrow-left-on-rectangle', { class: 'w-4 h-4' })}</button>
                                <button data-action="set-workspace-layout" data-layout="split" title="양쪽 보기" class="px-3 py-1 text-sm font-medium ${layout === 'split' ? 'bg-indigo-100 text-indigo-700' : 'bg-white'} border-t border-b border-slate-300 hover:bg-slate-50">${Heroicons.render('squares-2x2', { class: 'w-4 h-4' })}</button>
                                <button data-action="set-workspace-layout" data-layout="right" title="번역문만 보기" class="px-3 py-1 text-sm font-medium ${layout === 'right' ? 'bg-indigo-100 text-indigo-700' : 'bg-white'} border border-slate-300 rounded-r-md hover:bg-slate-50">${Heroicons.render('arrow-right-on-rectangle', { class: 'w-4 h-4' })}</button>
                            </div>
                        </div>
                        <button data-action="copy-translation-prompt" class="btn btn-secondary p-2" title="번역 프롬프트 복사">${Heroicons.render('clipboard', { class: 'w-5 h-5' })}</button>
                    </div>`;

             return `<div>${controls}<div class="grid grid-cols-1 ${gridClasses} gap-6"><div class="${leftClasses} h-[60vh] flex flex-col"><h3 class="text-lg font-semibold mb-2 text-slate-800">원문</h3><div class="prose prose-custom flex-grow overflow-y-auto p-4 border rounded-md bg-slate-50">${sourceText}</div></div><div class="${rightClasses} h-[60vh] flex flex-col"><h3 class="text-lg font-semibold mb-2 text-slate-800">번역문</h3><textarea id="translation" data-field="translation" class="w-full flex-grow p-4 border border-slate-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500">${content.translation || ''}</textarea></div></div></div>`;
         },
         renderCustomButtonPanel() {
             const customPrompts = state.activeProject.settings.customPrompts || [];
             if (customPrompts.length === 0) {
                 return `<div class="flex flex-col items-center justify-center h-full min-h-[60vh] text-center p-4">
                        ${Heroicons.render('sparkles', { class: 'h-16 w-16 text-slate-300' })}
                        <h3 class="mt-4 text-xl font-semibold text-slate-800">커스텀 버튼이 없습니다</h3>
                        <p class="mt-1 text-slate-500">프로젝트 설정에서 자주 사용하는 커스텀 프롬프트 버튼을 추가해보세요.</p>
                        <button class="btn mt-6" data-action="open-settings">${Heroicons.render('cog-6-tooth', { class: 'w-4 h-4 mr-2' })}설정으로 이동</button>
                    </div>`;
             }
             const buttonsHtml = customPrompts.map((prompt, index) => {
                 return `<button class="btn btn-secondary" data-action="copy-custom-prompt" data-index="${index}">
                        ${Heroicons.render('clipboard', { class: 'w-4 h-4 mr-2' })}
                        <span>${DOMPurify.sanitize(prompt.name)}</span>
                    </button>`;
             }).join('');
             return `<div class="p-4">
                    <h3 class="text-xl font-semibold mb-4 text-slate-800 border-b pb-2">커스텀 프롬프트 버튼</h3>
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                        ${buttonsHtml}
                    </div>
                </div>`;
         },
         renderSpinner: (message) => `<div class="flex items-center justify-center h-full"><div class="text-center"><svg class="mx-auto h-12 w-12 text-slate-400 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><h2 class="mt-4 text-lg font-medium text-slate-900">${message}</h2></div></div>`,
         renderContextMenu() {
             const {
                 isOpen,
                 x,
                 y
             } = state.contextMenu;
             if (!isOpen) return '';

             const menuItems = state.activeProject?.settings?.contextMenuItems || [];
             if (menuItems.length === 0) return '';

             const itemsHtml = menuItems.map((item, index) =>
                 `<button data-action="execute-context-menu" data-index="${index}" class="block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 hover:text-slate-900">${DOMPurify.sanitize(item.name)}</button>`
             ).join('');

             return `
                    <div id="context-menu" class="fixed z-[2500] w-56 mt-2 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none" style="top: ${y}px; left: ${x}px;">
                        <div class="py-1" role="menu" aria-orientation="vertical">
                            ${itemsHtml}
                        </div>
                    </div>
                `;
         },
         renderToasts() {
             return `<div class="fixed bottom-4 right-4 space-y-3 z-[3000]">${state.toasts.map(toast => {
                let icon = '';
                if (toast.type === 'success') icon = Heroicons.render('check-circle', { class: 'h-6 w-6 text-green-400' });
                if (toast.type === 'error') icon = Heroicons.render('exclamation-circle', { class: 'h-6 w-6 text-red-400' });
                if (toast.type === 'info') icon = Heroicons.render('information-circle', { class: 'h-6 w-6 text-blue-400' });
                return `<div id="toast-${toast.id}" class="max-w-sm w-full bg-white shadow-lg rounded-lg pointer-events-auto ring-1 ring-black ring-opacity-5 overflow-hidden"><div class="p-4"><div class="flex items-start"><div class="flex-shrink-0">${icon}</div><div class="ml-3 w-0 flex-1 pt-0.5"><p class="text-sm font-medium text-gray-900">${toast.message}</p></div><div class="ml-4 flex-shrink-0 flex"><button data-action="dismiss-toast" data-id="${toast.id}" class="bg-white rounded-md inline-flex text-gray-400 hover:text-gray-500">${Heroicons.render('x-mark', { class: 'h-5 w-5' })}</button></div></div></div></div>`
            }).join('')}</div>`;
         },
         renderQuizView() {
             const {
                 quizState
             } = state;
             if (!quizState || !quizState.questions[quizState.currentIndex]) return this.renderSpinner('퀴즈 로딩 중...');
             const q = quizState.questions[quizState.currentIndex];
             const isAnswered = quizState.answers[quizState.currentIndex] !== undefined;
             const renderAnswerComponent = () => {
                 switch (q.type) {
                     case CONFIG.QUIZ_TYPE.MULTIPLE_CHOICE:
                         const userAnswerIndex = quizState.answers[quizState.currentIndex]?.selectedIndex;
                         return `<div class="grid grid-cols-1 sm:grid-cols-2 gap-4 w-full">${q.options.map((opt, index) => { let classes = 'border-slate-300 hover:border-indigo-500 hover:bg-indigo-50'; if (isAnswered) { if (index === q.answerIndex) classes = 'bg-emerald-100 border-emerald-500 text-emerald-800'; else if (index === userAnswerIndex) classes = 'bg-red-100 border-red-500 text-red-800'; } return ` < button data - action = "submit-answer"
                         data - index = "${index}"
                         class = "w-full text-left p-4 border rounded-lg transition-colors ${classes}"
                         $ {
                             isAnswered ? 'disabled' : ''
                         } > $ {
                             opt
                         } < /button>` }).join('')}</div > `; default: return ` < form data - action = "submit-text-answer"
                         class = "w-full max-w-md text-center" > < textarea id = "answer-input"
                         name = "answer-input"
                         rows = "4"
                         class = "w-full text-lg border-2 p-2 bg-transparent border-slate-300 rounded-md focus:outline-none focus:border-indigo-500 transition-colors"
                         placeholder = "답안을 입력하세요..."
                         $ {
                             isAnswered ? 'disabled' : 'autofocus'
                         } > < /textarea><button type="submit" class="mt-8 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-12 rounded-lg text-lg transition-colors shadow hover:shadow-md" ${isAnswered ? 'disabled' : ''}>제출하고 정답 확인</button > < /form>`; } }; const renderFeedback = () => { if (!isAnswered) return `<div class="min-h-[148px]"></div > `; const { isCorrect } = quizState.answers[quizState.currentIndex]; const feedbackClass = isCorrect ? 'bg-emerald-50 text-emerald-700' : 'bg-red-50 text-red-700'; const icon = isCorrect ? Heroicons.render('check-circle', { class: 'w-5 h-5' }) : Heroicons.render('x-circle', { class: 'w-5 h-5' }); const isLastQuestion = quizState.currentIndex + 1 >= quizState.questions.length; const nextButtonText = isLastQuestion ? '결과 보기' : '다음 문제'; const nextButtonIcon = isLastQuestion ? 'flag' : 'arrow-right-circle'; let correctDisplay = ''; if (!isCorrect) correctDisplay = q.type === 'multiple_choice' ? q.options[q.answerIndex] : q.answer; return ` < div class = "p-4 rounded-lg mt-8 w-full max-w-3xl ${feedbackClass}" > < p class = "font-bold flex items-center gap-2" > $ {
                             icon
                         }
                         $ {
                             isCorrect ? '정답입니다!' : '오답입니다.'
                         } < /p>${!isCorrect ? `<p class="text-sm mt-2"><span class="font-semibold">모범 답안:</span > $ {
                             correctDisplay
                         } < /p>` : ''}<p class="text-sm mt-2"><span class="font-semibold">해설:</span > $ {
                             q.explanation
                         } < /p><div class="mt-4 flex justify-end"><button data-action="next-question" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg flex items-center gap-2">${nextButtonText} ${Heroicons.render(nextButtonIcon, { class: 'w-5 h-5' })} < /button></div > < /div>`; }; const questionTypeMap = { [CONFIG.QUIZ_TYPE.MULTIPLE_CHOICE]: '객관식', [CONFIG.QUIZ_TYPE.SHORT_ANSWER]: '단답형', [CONFIG.QUIZ_TYPE.SUBJECTIVE]: '서술형', [CONFIG.QUIZ_TYPE.CASE_BASED]: '사례형' }; return `<div class="fixed inset-0 bg-slate-50 flex flex-col z-[1000]"><header class="bg-white shadow-sm p-4 sticky top-0 z-10"><div class="flex items-center justify-between gap-4 max-w-5xl mx-auto"><div class="font-bold text-lg w-24">${quizState.currentIndex + 1} /
                         $ {
                             quizState.questions.length
                         } < /div><div class="w-full bg-slate-200 rounded-full h-4 overflow-hidden"><div class="bg-indigo-500 h-4 rounded-full transition-all duration-300" style="width: ${((quizState.currentIndex) /
                         quizState.questions.length) * 100
             } % "></div></div><button data-action="
             exit - quiz " class="
             p - 2 rounded - full hover: bg - slate - 200 " title="
             퀴즈 나가기 ">${Heroicons.render('x-mark')}</button></div></header><main class="
             flex - 1 flex flex - col items - center justify - center p - 6 text - center overflow - y - auto "><div class="
             w - full max - w - 3 xl "><p class="
             text - slate - 500 text - sm mb - 2 ">${questionTypeMap[q.type] || '문제'}</p><h2 class="
             text - 2 xl md: text - 3 xl font - bold leading - tight ">${q.questionText}</h2></div><div class="
             mt - 12 w - full flex justify - center ">${renderAnswerComponent()}</div>${renderFeedback()}</main></div>`; },
             renderQuizResultView() {
                 const {
                     questions,
                     answers
                 } = state.quizState;
                 const totalQuestions = questions.length;
                 const correctCount = answers.filter(a => a.isCorrect).length;
                 const score = totalQuestions > 0 ? Math.round((correctCount / totalQuestions) * 100) : 0;

                 const filterControls = `
                    <div class="flex justify-center gap-4 mb-6">
                        <button data-action="set-quiz-result-filter" data-filter="all" class="btn btn-sm ${state.quizResultFilter === 'all' ? '' : 'btn-secondary'}">전체 보기</button>
                        <button data-action="set-quiz-result-filter" data-filter="incorrect" class="btn btn-sm ${state.quizResultFilter === 'incorrect' ? '' : 'btn-secondary'}">틀린 문항만 보기</button>
                    </div>
                `;

                 const summaryHtml = `<div class="bg-white rounded-xl shadow-lg p-6 sm:p-8 text-center mb-8"><h2 class="text-3xl font-bold text-slate-800">퀴즈 결과</h2><p class="text-slate-600 mt-2">학습 내용을 성공적으로 검토했습니다!</p><div class="mt-6"><span class="text-5xl font-bold text-indigo-600">${score}</span><span class="text-xl font-medium text-slate-500">점</span></div><p class="mt-2 font-medium text-slate-700">총 ${totalQuestions}문항 중 ${correctCount}문항 정답</p><div class="mt-8"><button data-action="back-to-workspace" class="w-full sm:w-auto inline-flex justify-center items-center px-6 py-3 border border-transparent text-base font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700">작업실로 돌아가기</button></div></div>`;

                 const filteredQuestions = state.quizResultFilter === 'incorrect' ?
                     questions.filter((q, index) => !answers[index].isCorrect) :
                     questions;

                 const questionCardsHtml = filteredQuestions.map((q, index) => {
                     const originalIndex = state.quizResultFilter === 'incorrect' ? questions.findIndex(origQ => origQ.questionText === q.questionText) : index;
                     const userAnswerData = answers[originalIndex];
                     const isCorrect = userAnswerData.isCorrect;
                     const cardClass = isCorrect ? 'border-l-4 border-green-500' : 'border-l-4 border-red-500';
                     let answerFeedbackHtml = '';
                     if (q.type === CONFIG.QUIZ_TYPE.MULTIPLE_CHOICE) {
                         answerFeedbackHtml = q.options.map((option, optIndex) => {
                             const isUserAnswer = optIndex === userAnswerData.selectedIndex;
                             const isCorrectAnswer = optIndex === q.answerIndex;
                             let classes = 'border-slate-200 bg-slate-50';
                             let icon = '';
                             if (isUserAnswer && !isCorrect) {
                                 classes = 'border-red-300 bg-red-50 text-red-800';
                                 icon = Heroicons.render('x-circle', { class: 'w-5 h-5 text-red-500 mr-2 flex-shrink-0' });
                             }
                             if (isCorrectAnswer) {
                                 classes = 'border-green-300 bg-green-50 text-green-800 font-semibold';
                                 icon = Heroicons.render('check-circle', { class: 'w-5 h-5 text-green-500 mr-2 flex-shrink-0' });
                             }
                             return `<div class="flex items-center p-3 mt-2 border rounded-md ${classes}">${icon}<span>${option}</span></div>`;
                         }).join('');
                     } else {
                         const userAnswerHtml = `<div class="flex items-start p-3 mt-2 border rounded-md border-red-300 bg-red-50 text-red-800">${Heroicons.render('x-circle', { class: 'w-5 h-5 text-red-500 mr-2 mt-1 flex-shrink-0' })}<p>${userAnswerData.userAnswer || '<i>답변 없음</i>'}</p></div>`;
                         const correctAnswerHtml = `<div class="flex items-start p-3 mt-2 border rounded-md border-green-300 bg-green-50 text-green-800">${Heroicons.render('check-circle', { class: 'w-5 h-5 text-green-500 mr-2 mt-1 flex-shrink-0' })}<p>${q.answer}</p></div>`;
                         if (isCorrect) {
                             answerFeedbackHtml = correctAnswerHtml;
                         } else {
                             answerFeedbackHtml = `<div><p class="text-sm font-semibold text-slate-600">제출한 답:</p>${userAnswerHtml}<p class="text-sm font-semibold text-slate-600 mt-3">모범 답안:</p>${correctAnswerHtml}</div>`;
                         }
                     }
                     return `<div class="bg-white rounded-lg shadow p-6 mb-6 ${cardClass}"><p class="font-semibold text-slate-800">${originalIndex + 1}. ${q.questionText}</p><div class="mt-4">${answerFeedbackHtml}</div><div class="mt-4 p-3 bg-slate-100 rounded-md text-sm text-slate-700"><p><span class="font-bold">해설:</span> ${q.explanation}</p></div></div>`;
                 }).join('');

                 return `<div class="fixed inset-0 bg-slate-50 flex flex-col z-[1000] overflow-y-auto"><header class="bg-white shadow-sm p-4 sticky top-0 z-10"><div class="max-w-4xl mx-auto text-center text-2xl font-bold">퀴즈 결과</div></header><main class="flex-grow w-full max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">${summaryHtml}<h3 class="text-2xl font-bold text-slate-800 mb-6 border-b pb-3">문항별 다시보기</h3>${filterControls}${questionCardsHtml}</main></div>`;
             },
         };

         const Controller = {
             async init() {
                // ▼▼▼ [수정] 앱 초기화 시 Heroicons를 먼저 불러옵니다. ▼▼▼
                await Heroicons.load(); 
                // ▲▲▲ [수정] 앱 초기화 시 Heroicons를 먼저 불러옵니다. ▲▲▲
                 this.initializeConfig();
                 ModalManager.init(); // ModalManager 초기화
                 marked.setOptions({
                     gfm: true,
                     breaks: true
                 });
                 this.bindGlobalEventListeners();
                 await DB.init();
                 const [projects, categories, userProfile] = await Promise.all([DB.getAll(CONFIG.STORES.PROJECTS), DB.getAll(CONFIG.STORES.CATEGORIES), DB.get(CONFIG.STORES.USER_PROFILE, 'main')]);
                 state.projects = projects;
                 state.categories = categories.sort((a, b) => a.name.localeCompare(b.name));
                 state.userProfile = userProfile || {
                     id: 'main',
                     level: 1,
                     xp: 0
                 };
                 if (!userProfile) await DB.put(CONFIG.STORES.USER_PROFILE, state.userProfile);
                 this.updateTags();
                 this.buildSearchIndex();
                 state.isLoading = false;
                 View.render();
             },
             bindGlobalEventListeners() {
                 document.body.addEventListener('click', e => {
                     const trigger = e.target.closest('[data-action]');
                     if (!trigger || trigger.matches('form[data-action]')) return;
                     const action = trigger.dataset.action;
                     const handler = this.ACTION_HANDLERS[action];
                     if (handler) {
                         e.preventDefault();
                         handler(trigger, e);
                     }
                 });
                 document.body.addEventListener('submit', e => {
                     const form = e.target.closest('form[data-action]');
                     if (!form) return;
                     e.preventDefault();
                     const action = form.dataset.action;
                     const handler = this.ACTION_HANDLERS[action];
                     if (handler) handler(form, e);
                 });
                 document.body.addEventListener('change', e => {
                     const trigger = e.target;
                     if (trigger.matches('input[type="file"]')) {
                         this.handleFileSelection(trigger);
                         return
                     }
                     if (trigger.hasAttribute('data-action') && !trigger.matches('form[data-action]')) {
                        const handler = this.ACTION_HANDLERS[trigger.dataset.action];
                        if (handler) handler(trigger, e);
                     }
                 });
                 document.body.addEventListener('input', Utils.debounce(async e => {
                     if (e.target.matches('#search-input')) {
                         this.handleSearch(e.target.value);
                     } else if (e.target.matches('[data-action="toc-edit-title"]')) {
                         this.handleTocTitleEdit(e.target);
                     } else if (e.target.matches('#manuscript, #notes, #translation, [data-setting-key], [data-custom-prompt-key]')) {
                         await this.handleContentChange(e);
                     } else if (e.target.matches('#setting-tags-input')) {
                         this.handleTagInput(e.target);
                     }
                 }, 500));
                 document.addEventListener('keydown', e => {
                     if (e.key === 'Escape' && ModalManager.isOpen) {
                         console.log('[디버그] 모달 닫힘: "ESC 키" 누름');
                         ModalManager.close();
                     }
                 });
                 document.addEventListener('katex-loaded', () => {
                     state.isKaTeXLoaded = true;
                     this.applyPostRenderEffects();
                 });
                 document.addEventListener('keydown', e => {
                     const isInputActive = ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);
                     if (!isInputActive && state.currentView === 'workspace') {
                         if (e.key === 'ArrowLeft') {
                             e.preventDefault();
                             this.navigateChapter(-1);
                         } else if (e.key === 'ArrowRight') {
                             e.preventDefault();
                             this.navigateChapter(1);
                         }
                     }
                 });
                 document.body.addEventListener('mouseup', e => {
                     // 모달이 열려있거나 컨텍스트 메뉴 내부를 클릭했다면 아무 작업도 하지 않음
                     if (ModalManager.isOpen || e.target.closest('#context-menu')) {
                         return;
                     }

                     const selection = window.getSelection();
                     const selectedText = selection.toString().trim();
                     const viewPanel = document.querySelector('#workspace-main-content .prose-readable');

                     if (state.currentView === 'workspace' && state.workspaceMode === 'view' && selectedText && viewPanel && selection.rangeCount > 0 && viewPanel.contains(selection.getRangeAt(0).commonAncestorContainer)) {
                         state.contextMenu = {
                             isOpen: true,
                             x: e.pageX,
                             y: e.pageY,
                             selectedText: selectedText
                         };
                     } else {
                         state.contextMenu.isOpen = false;
                     }
                     View.render();
                 });
             },
             bindDynamicEventListeners() {
                 if (ModalManager.type === 'manageToc') {
                     const list = document.getElementById('toc-editor-list');
                     if (list) {
                         list.addEventListener('dragstart', this.handleTocDragStart);
                         list.addEventListener('dragover', this.handleTocDragOver);
                         list.addEventListener('dragleave', this.handleTocDragLeave);
                         list.addEventListener('drop', this.handleTocDrop);
                     }
                 }
                 if (ModalManager.type === 'settings') {
                     const tagInput = document.getElementById('setting-tags-input');
                     if (tagInput) {
                         tagInput.addEventListener('keydown', this.handleTagInputKeydown);
                     }

                     // ✅ START: Enter 키 오작동 방지 코드 추가
                     const settingsForm = document.querySelector('form[data-action="save-settings"]');
                    if (settingsForm) {
                        settingsForm.addEventListener('keydown', (e) => {
                            // 폼 내부의 텍스트 입력 필드에서 Enter 키를 누를 때
                            if (e.key === 'Enter' && e.target.tagName === 'INPUT' && e.target.type === 'text') {
                                // 기본 동작인 폼 제출을 무조건 막습니다.
                                e.preventDefault();

                                // 만약 '새 항목 추가' 관련 이름 입력 필드에서 Enter를 눌렀다면,
                                // '목록에 추가' 버튼을 대신 클릭해주는 편리한 기능을 추가합니다.
                                if (e.target.id === 'new-prompt-name' || e.target.id === 'new-contextMenu-name') {
                                    const addButton = e.target.closest('.p-4.border').querySelector('button[data-action^="add-custom-"]');
                                    if (addButton) {
                                        addButton.click();
                                    }
                                }
                            }
                        });
                    }
                     // ✅ END: Enter 키 오작동 방지 코드 추가
                 }
             },
             initializeConfig() {
                 CONFIG.DEFAULT_PROJECT_SETTINGS = {
                     writingGenre: "전문 분석 보고서",
                     writingAudience: "해당 분야를 배우기 갈망하는 사람",
                     writingAgeGroup: "성인",
                     writingStyle: "천천히 천천히 심혈을 기울여 작성한, 최대한의 정보를 학술적 정확성과 함께 담아낸 객관적이고 명료하며, 논리적인 문체",
                     writingReferences: "핵심 참고자료 (세계관, 인물, 용어 등)를 여기에 입력하세요.",
                     writingPrompt: `Have a break and then...
<?xml version="1.0" encoding="UTF-8"?>
<metaPrompt>
    <purpose>
        주어진 모든 맥락 정보를 종합적으로 분석하여, 특정 장(Chapter)에 해당하는 전문가 수준의 원고 초안을 천천히 심혈을 기울여서 차근차근 생성하는 것. 최대한 길고 자세하며, 주어진 목표를 완벽하게 달성해야 한다.
    </purpose>
    <promptDesignFramework>
        <objectiveDefinition id="1" title="목표 정의: 과업의 제1원칙">
            <finalDeliverable id="1.1" description="프롬프트를 통해 얻고자 하는 최종 결과물">
                '{{chapterTitle}}' 장에 대한 완성도 높은 원고 초안을, 체계적인 소제목을 포함하여 최대한 길게 생성한다. 이 원고는 별도의 서문이나 요약 없이, 즉시 본문에 삽입할 수 있는 마크다운(Markdown) 형식이어야 한다.
            </finalDeliverable>
            <coreTask id="1.2" description="LLM이 수행해야 할 핵심적인 동사">
                제시된 모든 맥락과 제약 조건을 엄격히 준수하여, '{{chapterTitle}}' 장의 원고를 **집필하라**.
            </coreTask>
            <successCriteria id="1.3" description="결과물이 '성공'이라고 판단할 객관적인 기준">
                1. 생성된 원고가 '{{chapterDescription}}'에 명시된 목표와 내용을 충실히 반영하는가?
                2. 원고가 전체 목차('{{fullToc}}')의 흐름 속에서 현재 장의 역할을 정확히 수행하는가?
                3. 프로젝트 설정('{{projectGenre}}', '{{projectAudience}}', '{{projectStyleExample}}')에 부합하는 문체와 어조를 일관되게 유지하는가?
                4. 'references'에 제공된 설정(인물, 배경, 용어 등)을 정확하게 활용하였는가?
                5. 결과물이 서문, 요약, 반복 등 불필요한 내용 없이 오직 원고 본문만으로 구성되었는가?
                6. 생성된 원고가 허용된 최대 토큰 길이를 활용하여 최대한 상세하게 작성되었는가?
            </successCriteria>
        </objectiveDefinition>
        <personaAssignment id="2" title="역할 부여: 최적의 인지 모델 설계">
            <expertPersona id="2.1" description="과업을 가장 잘 수행할 전문가의 상세한 묘사">
                당신은 **'{{projectGenre}}' 장르의 베테랑 작가**이자, 해당 분야의 깊이 있는 지식을 갖춘 전문가다. 당신의 임무는 단순한 텍스트 생성이 아니라, 작품 전체의 유기적인 흐름과 깊이를 더하는 한 부분을 완성하는 것이다. 당신은 프로젝트의 총괄 편집자로서, 모든 세부 설정과 이야기의 큰 그림을 완벽하게 이해하고 있다.
            </expertPersona>
            <audience id="2.2" description="결과물을 소비할 대상과 그들의 지식 수준">
                이 글의 핵심 독자는 **'{{projectAudience}}'**이며, 대상 연령층은 **'{{projectAgeGroup}}'**이다. 이들의 지적 호기심과 기대 수준을 고려하여 전문적이면서도 이해하기 쉽게 집필해야 한다.
            </audience>
            <toneAndStyle id="2.3" description="결과물의 어조와 스타일">
                글의 전체적인 톤앤매너와 문체는 다음 예시를 따른다: **'{{projectStyleExample}}'**. 이를 바탕으로 일관성 있는 작풍을 유지하라.
            </toneAndStyle>
        </personaAssignment>
        <contextAndFormat id="3" title="맥락 제공 및 형식 지정">
            <essentialContext id="3.1" description="과업 수행에 필요한 모든 배경 정보, 데이터, 이전 대화 내용"><![CDATA[
### 프로젝트 전체 개요
- **책 전체 제목**: {{bookTitle}}
- **장르 및 대상**: {{projectGenre}}, {{projectAgeGroup}} {{projectAudience}}
- **핵심 참고자료 (세계관, 인물, 용어 등)**:
{{references}}

### 집필할 장(Chapter)의 위치와 목표
- **현재 파트(Part)**: {{partTitle}} ({{partDescription}})
- **집필 대상 장(Chapter)**: **{{chapterTitle}}**
- **이번 장의 핵심 목표**: {{chapterDescription}}

### 전체 목차 구조 (현재 위치 표시: ▶)
{{fullToc}}

### 현재 파트의 목차 구조 (현재 위치 표시: ▶)
{{partToc}}
            ]]></essentialContext>
            <outputFormat id="3.2" description="결과물이 출력되어야 할 정확한 형식 또는 템플릿"><![CDATA[
## 최종 출력물 형식 (매우 중요)
- **오직 원고 본문만 출력한다.**
- **원고 내용에 적절한 소제목 목차를 포함하고, 목차의 최상위 제목은 '##'으로 시작해야 한다.**
- Markdown 문법을 사용하여 문단을 나누고, 필요시 강조 등을 표현한다.
- "결과물:", "원고:", "다음은 요청하신 원고입니다." 와 같은 서두를 절대로 사용하지 마라.
- 프롬프트의 내용을 요약하거나 되풀이하지 마라.
            ]]></outputFormat>
        </contextAndFormat>
        <reasoningDesign id="4" title="추론 과정 설계: 생각의 경로 구축">
            <reasoningFramework id="4.1" description="과업 복잡성에 따른 추론 방식 선택">
                <option type="DirectResponse" description="단순 정보 요청 시 사용">
                    <task>위의 모든 정보를 바탕으로, '{{chapterTitle}}' 장의 원고를 즉시 집필하라.</task>
                </option>
            </reasoningFramework>
        </reasoningDesign>
        <constraints id="5" title="제약 조건 설정: 탐색 공간 제어">
            <mustInclude id="5.1" description="결과물에 반드시 포함되어야 할 키워드, 개념, 데이터 포인트">
                - 원고 내용은 '{{chapterDescription}}'의 목표를 직접적으로 달성해야 한다.
                - 'references'의 설정과 충돌이 없어야 한다.
            </mustInclude>
            <mustAvoid id="5.2" description="반드시 피해야 할 주제, 표현, 단어, 편향, 가정">
                - 집필 과업에 대한 자기 평가나 소감, 요약, 변명, 추가 설명을 포함하지 마라.
                - 작가(AI)가 독자에게 직접 말을 거는 듯한 '메타적 서술'을 피하라. (예: "이제부터 ~에 대해 알아보겠습니다.")
                - 전체 이야기의 결말을 암시하거나 단정 짓는 서술을 피하라. 현재 장의 역할에만 집중하라.
            </mustAvoid>
            <selfCorrectionCommand id="5.3" description="생성될 프롬프트 마지막에 포함될 최종 검증 명령"><![CDATA[
모든 지시사항을 완수한 후, 최종 답변을 제출하기 전에 잠시 멈추고 스스로 '레드팀'의 역할을 수행하라. 내가 제시한 모든 요구사항(역할, 형식, 내용, 제약 조건 등)이 100% 충족되었는지, 논리적 비약이나 설정 충돌은 없는지, 더 나은 대안은 없는지 최소 세 번 이상 교차 검증하고, 그 결과를 반영하여 최종적으로 완벽하고 군더더기 없는 원고 초안만 출력하라.
            ]]></selfCorrectionCommand>
            <supplementaryDirectives title="Author's Internal Checklist">
                <directive id="A" title="독자의 그림자: 끊임없는 질문에 답하기">
                    <description>
                        글을 쓰는 내내, 당신의 어깨너머로 회의적이지만 지적인 독자가 함께 읽고 있다고 상상하라. 그 독자는 매 문단이 끝날 때마다 다음과 같이 질문할 것이다: "그래서 이게 왜 중요한데(So What)?", "이 주장의 근거는 무엇이지?", "더 쉬운 설명은 없나?" 당신의 글은 이러한 독자의 잠재적 질문을 미리 예측하고, 그에 대한 답을 본문 안에 자연스럽게 녹여내야 한다. 독자의 의문이 싹트기 전에 해소시켜라.
                    </description>
                </directive>
                <directive id="B" title="정보적 투자수익률(ROI) 원칙: 독자의 노력을 보상하기">
                    <description>
                        독자가 한 문장을 읽는 데 사용하는 인지적 노력은 '투자'다. 당신은 그 투자에 대해 최대한의 '수익(지적 깨달음, 감정적 동요, 실용적 가치)'으로 보상할 의무가 있다. 모든 문장이 정보적 가치를 지니는지, 불필요한 미사여구나 군더더기는 없는지 끊임없이 점검하라. 문장이 길어진다면, 그 길이만큼의 가치를 담고 있는지 증명해야 한다.
                    </description>
                </directive>
                <directive id="C" title="논리적 연결의 미학: 문단과 문단을 엮는 힘">
                    <description>
                        문단을 독립된 정보의 섬으로 취급하지 마라. 뛰어난 글은 각 문단이 서로 맞물려 돌아가는 정교한 기계와 같다. 한 문단의 마지막 문장은 다음 문단의 첫 문장을 자연스럽게 호출하는 '갈고리' 역할을 해야 한다. 논리의 흐름이 끊기지 않고, 독자가 물 흐르듯 다음 내용으로 넘어갈 수 있도록 문단 사이의 논리적 인장력을 최대화하라.
                    </description>
                </directive>
                <directive id="D" title="구성의 교향곡: 요소들의 조화로운 배치">
                    <description>
                        하나의 장(Chapter)은 단일한 음색의 연주가 아닌, 다양한 악기가 조화를 이루는 교향곡이어야 한다. '이론 제시', '사례 분석', '서사적 묘사', '데이터 인용', '성찰적 질문' 등 다양한 구성 요소를 단조롭지 않게 배치하라. 예를 들어, 무거운 이론을 제시했다면 곧바로 흥미로운 일화를 통해 독자의 이해를 돕고 환기시키는 지혜가 필요하다.
                    </description>
                </directive>
                <directive id="E" title="지적 정직성의 프레임: 경계와 복잡성의 인정">
                    <description>
                        당신의 주장이 적용되는 범위와 한계를 명확히 하라. 모든 것을 설명할 수 있는 것처럼 과장하거나, 복잡한 문제를 단순하게 양분하지 마라. 특히 비문학 분야에서는 반대 의견이나 대안적 해석을 공정하게 소개하고, 왜 당신의 관점이 더 설득력 있는지 논증하라. 이러한 지적 정직성은 글의 신뢰도를 극적으로 높인다. 소설의 경우, 이는 세상을 선과 악으로만 나누지 않는 입체적인 세계관 구축으로 이어진다.
                    </description>
                </directive>
            </supplementaryDirectives>
        </constraints>
    </promptDesignFramework>
</metaPrompt>`,
                     translationPrompt: `Have a break and then...
<?xml version="2.0" encoding="UTF-8"?>
<metaPrompt>
    <purpose>
        천천히 심혈을 기울여, 'essentialContext'에 제공된 원문을 분석한다. 원문의 톤앤매너와 핵심 정보를 완벽하게 보존하면서, 가장 유려하고 자연스러운 문어체 한국어로 번역한다. 최종 결과물은 즉시 출판 가능한 수준의 가독성, 학문적 정확성, 의미 전달의 명확성을 갖춰야 한다.
    </purpose>
    <promptDesignFramework>
        <objectiveDefinition id="1" title="목표 정의: 과업의 제1원칙">
            <finalDeliverable id="1.1" description="프롬프트를 통해 얻고자 하는 최종 결과물">
                사용자가 제공한 원문을 전문가 수준으로 번역하고 다듬어, 즉시 출판하여 베스트셀러가 될 수 있는 상태의 완벽한 한국어 문어체 원고.
            </finalDeliverable>
            <coreTask id="1.2" description="LLM이 수행해야 할 핵심적인 동사">
                **번역(Translate), 교정(Refine), 그리고 형식화(Format)하라.** 단순한 단어 대체를 넘어, 전문 편집자로서 원문의 의미와 뉘앙스를 한국어 독자에게 최적화된 콘텐츠로 재창조하라.
            </coreTask>
            <successCriteria id="1.3" description="결과물이 '성공'이라고 판단할 객관적인 기준">
                - 번역문은 원문의 핵심 의미, 세부 뉘앙스, 그리고 저자의 의도를 100% 보존한다.
                - 한국어 문장은 문법적으로 완벽하며, 원문의 어조와 스타일을 유지하면서도 자연스럽고 유려하다.
                - 모든 문장이 누락 없이 번역되었으며, 일관된 문체를 유지한다.
                - 제목, 소제목, 문단 나누기 등 원문의 논리적 구조를 정확히 반영하여 가독성을 극대화한다.
                - '[여기에 입력]'과 같은 플레이스홀더 텍스트가 최종 결과물에 남아있지 않다.
            </successCriteria>
        </objectiveDefinition>
        <personaAssignment id="2" title="역할 부여: 최적의 인지 모델 설계">
            <expertPersona id="2.1" description="과업을 가장 잘 수행할 전문가의 상세한 묘사">
                당신은 **'20년 경력의 마스터 번역가 겸 콘텐츠 전략가'**다. 국제회의 통역사이자 여러 베스트셀러 기술 서적을 번역한 경험을 바탕으로, 단순한 언어 변환을 넘어 문화적 맥락과 미묘한 뉘앙스까지 포착한다. 당신은 독자의 마음을 움직이는 글을 만들어내는 전문가이며, 디지털 콘텐츠의 가독성까지 고려하여 번역 결과를 구조화한다.
            </expertPersona>
            <audience id="2.2" description="결과물을 소비할 대상과 그들의 지식 수준">
                제공된 원문의 내용, 어휘, 스타일을 분석하여 잠재 독자층(예: 기술 전문가, 일반 대중, 학생 등)을 추론하고, 그들의 지식 수준과 관심사에 맞춰 가장 이해하기 쉬운 어휘와 문장 구조를 선택해야 한다.
            </audience>
            <toneAndStyle id="2.3" description="결과물의 어조와 스타일 및 정신적 도구">
                - **톤앤매너 복제:** 원문의 어조(예: 학술적, 유머러스함, 진지함, 대중적)를 정확히 분석하고, 그 느낌을 한국어 표현으로 완벽하게 재현해야 한다. 직역으로 어색해지는 관용구나 문화적 표현은 한국 독자가 즉시 이해할 수 있는 자연스러운 표현으로 의역한다.
                - **문어체 사용:** 베스트셀러처럼 잘 읽히는 문어체를 사용하여, 원본의 모든 내용과 정보를 포함하면서도 술술 읽혀야만 한다.
                - **정신적 도구 (Mental Model):** '독자의 입장에서 생각하기'. 문장을 완성하기 전에, 잠재 독자의 관점에서 그 문장을 소리 내어 읽어본다고 상상하라. '이 문장은 명확한가? 매력적인가? 이전 내용과 자연스럽게 연결되는가?'를 끊임없이 자문하며 결과물을 다듬어라.
            </toneAndStyle>
        </personaAssignment>
        <contextAndFormat id="3" title="맥락 제공 및 형식 지정">
            <essentialContext id="3.1" description="과업 수행에 필요한 모든 배경 정보, 데이터, 이전 대화 내용"><![CDATA[
{{text}}
            ]]></essentialContext>
            <outputFormat id="3.2" description="결과물이 출력되어야 할 정확한 형식 또는 템플릿"><![CDATA[
입력된 원문의 형식에 맞춰 가장 적절하고 가독성 높은 형식으로 출력한다.
            ]]></outputFormat>
        </contextAndFormat>
        <reasoningDesign id="4" title="추론 과정 설계: 생각의 경로 구축">
            <reasoningFramework id="4.1" description="과업 복잡성에 따른 추론 방식 선택">
                <option type="ProblemDecomposition" description="복잡한 프로젝트 수행 시 사용">
                    <instruction>
                        아래의 최종 목표를 달성하기 위해, 다음의 하위 작업들을 명시된 순서대로 반드시 수행하라. 각 단계의 결과는 다음 단계의 입력으로 사용된다.
                    </instruction>
                    <subTasks>
                        <task id="1">**1단계: 원문 심층 분석 (Analyze):** 제공된 원문을 최소 3회 이상 정독하여 핵심 메시지, 논리 구조, 저자의 어조와 문체, 그리고 숨은 의도를 완벽하게 파악한다.</task>
                        <task id="2">**2단계: 초벌 번역 및 뉘앙스 포착 (Translate & Capture):** 원문의 의미를 정확하게 전달하는 데 초점을 맞춰 초벌 번역을 수행한다. 특히 기술 용어, 관용 표현, 문화적 배경이 담긴 뉘앙스를 놓치지 않도록 주의한다.</task>
                        <task id="3">**3단계: 윤문 및 유려함 확보 (Refine & Polish):** 초벌 번역 결과물을 한국어 독자의 시각에서 어색함이 없도록 다듬는다. 딱딱한 번역투 문장을 자연스러운 한국어 문장으로 재구성하고, 더 적절한 어휘를 선택하여 글 전체의 유려함을 극대화한다.</task>
                        <task id="4">**4단계: 콘텐츠 구조화 및 형식화 (Structure & Format):** 완성된 내용을 가독성을 높이기 위해 본문을 논리적인 문단과 소제목으로 나누고, 원문의 구조를 충실히 따른다.</task>
                    </subTasks>
                </option>
            </reasoningFramework>
            <fewShotExamples id="4.2" description="1~3개의 고품질 입/출력 예시로 결과물 패턴 학습">
                <example id="1">
                    <input><![CDATA[
Title: The Unseen Power of Micro-interactions

Micro-interactions are the small, often unnoticed animations and design elements that make a user interface feel alive. Think of the "like" button animation on Twitter, or the subtle bounce when you pull to refresh a feed. While seemingly minor, these details are critical. They provide feedback, guide users, and add a touch of personality to a digital product, transforming a functional tool into an enjoyable experience. Good micro-interactions are almost invisible, doing their job without shouting for attention.
                    ]]></input>
                    <output><![CDATA[]]></output>
                </example>
            </fewShotExamples>
        </constraints>
        <constraints id="5" title="제약 조건 설정: 탐색 공간 제어">
            <mustInclude id="5.1" description="결과물에 반드시 포함되어야 할 키워드, 개념, 데이터 포인트">
                - 최종 결과물은 완벽한 한국어 번역문이어야 한다.
                - 원문에 포함된 모든 정보는 번역문에 반드시 포함되어야 한다.
            </mustInclude>
            <mustAvoid id="5.2" description="반드시 피해야 할 주제, 표현, 단어, 편향, 가정">
                - 단어 대 단어 식의 기계적인 직역.
                - 원문의 정보를 누락하거나, 원문에 없는 내용을 임의로 추가하는 행위.
                - 한국어 독자가 읽기에 어색하거나 부자연스러운 번역투 문장.
                - 최종 결과물에 '여기를 채우세요'와 같은 미완성된 플레이스홀더를 남기는 것.
            </mustAvoid>
            <selfCorrectionCommand id="5.3" description="생성될 프롬프트 마지막에 포함될 최종 검증 명령"><![CDATA[
모든 지시사항을 완수한 후, 최종 답변을 제출하기 전에 잠시 멈추고 스스로 '레드팀'의 역할을 수행하라. 내가 제시한 모든 요구사항(역할, 형식, 내용, 제약 조건 등)이 100% 충족되었는지, 논리적 비약이나 모순은 없는지, 더 나은 대안은 없는지 최소 세 번 이상 교차 검증하고, 그 결과를 반영하여 최종적으로 완벽하고 군더더기 없는 결과물만 출력하라.
            ]]></selfCorrectionCommand>
        </constraints>
    </promptDesignFramework>
</metaPrompt>`,
                     quizQuestionCount: 5,
                     quizTaskDescription: `You are an expert educator and instructional designer. Your task is to create a comprehensive and in-depth learning quiz based on the provided text. The quiz must thoroughly test the user's understanding of all key concepts, facts, and nuances within the text.`,
                     quizOutputFormatInstruction: `Respond ONLY with a valid JSON array of question objects inside a <json_response> tag. Do not include any other text or explanations outside this tag.`,
                     quizPromptTemplate: `Have a break and then...
<?xml version="1.0" encoding="UTF-8"?>
<metaPrompt>
    <purpose>
        주어진 텍스트 내용을 바탕으로, 학습자의 이해도를 다각도로 평가할 수 있는 고품질의 학습 퀴즈를 생성한다. 단순 정보 확인을 넘어, 핵심 개념의 적용 및 비판적 사고를 유도하는 것을 목표로 한다.
    </purpose>
    <promptDesignFramework>
        <objectiveDefinition id="1" title="목표 정의: 과업의 제1원칙">
            <finalDeliverable id="1.1" description="프롬프트를 통해 얻고자 하는 최종 결과물">
                엄격한 JSON 형식 스키마를 준수하는, {{questionCount}}개의 질문 객체로 구성된 유효한 JSON 배열. 각 질문은 교육적으로 가치가 높고, 명확한 정답과 상세한 해설을 포함해야 한다.
            </finalDeliverable>
            <coreTask id="1.2" description="LLM이 수행해야 할 핵심적인 동사">
                제시된 텍스트를 분석하고, 이를 바탕으로 교육 목표에 부합하는 학습 퀴즈를 **설계하고 생성하라(Design and Generate)**.
            </coreTask>
            <successCriteria id="1.3" description="결과물이 '성공'이라고 판단할 객관적인 기준">
                1. 정확히 {{questionCount}}개의 질문이 생성되었는가?
                2. 'multiple_choice', 'short_answer', 'subjective', 'case_based' 등 다양한 유형의 질문이 혼합되었는가?
                3. 각 질문이 원본 텍스트의 핵심 개념, 사실, 뉘앙스를 효과적으로 평가하는가?
                4. 모든 질문의 정답이 정확하고, 해설이 명확하며 교육적인가?
                5. 최종 결과물이 지정된 JSON 형식과 스키마를 100% 준수하며, 오류 없이 파싱되는가?
                6. 질문의 언어가 한국어로 명확하고 자연스럽게 작성되었는가?
            </successCriteria>
        </objectiveDefinition>
        <personaAssignment id="2" title="역할 부여: 최적의 인지 모델 설계">
            <expertPersona id="2.1" description="과업을 가장 잘 수행할 전문가의 상세한 묘사">
                당신은 **'전문 교육자이자 교육과정 설계자(Expert Educator and Instructional Designer)'**이다. 당신은 텍스트의 핵심을 꿰뚫어 보고, 학습 목표에 맞춰 이해도를 효과적으로 측정하는 문항을 개발하는 데 매우 능숙하다. 당신의 임무는 단순한 퀴즈 생성이 아니라, 학습자가 스스로의 이해도를 점검하고 더 깊은 학습으로 나아가도록 돕는 교육적 도구를 만드는 것이다.
            </expertPersona>
            <audience id="2.2" description="결과물을 소비할 대상과 그들의 지식 수준">
                이 퀴즈의 사용자는 제공된 텍스트를 방금 학습한 학습자다. 이들은 내용을 기억하고 있지만, 핵심 개념에 대한 이해를 확고히 하고 중요한 부분을 다시 한번 상기할 필요가 있다.
            </audience>
            <toneAndStyle id="2.3" description="결과물의 어조와 스타일">
                - **어조**: 교육적이고 전문적이며, 신뢰감을 주는 어조를 사용한다.
                - **스타일**: 질문은 명확하고 간결하며, 오해의 소지가 없도록 작성한다. 해설은 친절하고 상세하게 제공하여 추가 학습이 가능하도록 한다.
            </toneAndStyle>
        </personaAssignment>
        <contextAndFormat id="3" title="맥락 제공 및 형식 지정">
            <essentialContext id="3.1" description="과업 수행에 필요한 모든 배경 정보"><![CDATA[
- **퀴즈 문항 수**: {{questionCount}}
- **퀴즈 출제 언어**: 한국어
- **퀴즈 출제 기반 원본 텍스트**:
{{text}}
            ]]></essentialContext>
            <outputFormat id="3.2" description="결과물이 출력되어야 할 정확한 형식 또는 템플릿"><![CDATA[
{{outputFormatInstruction}}

### JSON 객체 스키마:
- **questionText**: [String] 질문 내용.
- **type**: [String] 질문 유형 ('multiple_choice', 'short_answer', 'subjective', 'case_based' 중 하나).
- **options**: [Array of Strings] 'multiple_choice' 유형일 경우 4개의 선택지 배열. 다른 유형은 null.
- **answer**: [String] 정답. 'multiple_choice'는 정답 선택지의 텍스트, 'short_answer'는 간결한 정답 용어, 'subjective' 및 'case_based'는 상세한 모범 답안.
- **explanation**: [String] 정답이 왜 정답인지에 대한 명확하고 상세한 해설. 가능한 경우 원본 텍스트를 참조하여 설명.
            ]]></outputFormat>
        </contextAndFormat>
        <reasoningDesign id="4" title="추론 과정 설계: 생각의 경로 구축">
            <reasoningFramework id="4.1" description="과업 복잡성에 따른 추론 방식 선택">
                <option type="ProblemDecomposition" description="복잡한 프로젝트 수행 시 사용">
                    <instruction>아래의 최종 목표를 달성하기 위해, 다음의 하위 작업들을 명시된 순서대로 반드시 수행하라.</instruction>
                    <subTasks>
                        <task id="1">**1단계: 원본 텍스트 심층 분석:** 제공된 텍스트를 정독하여 핵심 주제, 주요 개념, 핵심 사실, 그리고 학습자가 반드시 이해해야 할 미묘한 뉘앙스를 파악한다.</task>
                        <task id="2">**2단계: 문항 설계:** 분석된 핵심 내용을 바탕으로, 다양한 질문 유형을 활용하여 {{questionCount}}개의 문항을 설계한다. 단순 암기 확인을 넘어, 이해와 적용을 평가할 수 있는 질문을 포함시킨다.</task>
                        <task id="3">**3단계: 정답 및 해설 작성:** 각 문항에 대한 명확하고 정확한 정답을 작성한다. 왜 그것이 정답인지, 그리고 관련 오답이 왜 틀렸는지를 상세하고 친절하게 설명하는 해설을 추가한다.</task>
                        <task id="4">**4단계: JSON 형식화 및 검증:** 완성된 퀴즈 내용을 지정된 JSON 스키마에 따라 정확하게 형식화한다. 최종 결과물이 유효한 JSON 배열인지 반드시 검증한다.</task>
                    </subTasks>
                </option>
            </reasoningFramework>
        </reasoningDesign>
        <constraints id="5" title="제약 조건 설정: 탐색 공간 제어">
            <mustInclude id="5.1" description="결과물에 반드시 포함되어야 할 요소">
                - 반드시 {{questionCount}}개의 질문 객체를 포함해야 한다.
                - 반드시 지정된 JSON 스키마를 따라야 한다.
                - 모든 질문, 선택지, 해설은 한국어로 작성되어야 한다.
            </mustInclude>
            <mustAvoid id="5.2" description="반드시 피해야 할 주제, 표현, 단어">
                - 원본 텍스트에 근거하지 않은 정보를 질문이나 해설에 포함하는 행위.
                - 질문이나 선택지가 모호하거나 중의적으로 해석될 수 있는 표현.
                - JSON 형식을 벗어난 서문, 결론, 또는 기타 불필요한 텍스트.
            </mustAvoid>
            <selfCorrectionCommand id="5.3" description="생성될 프롬프트 마지막에 포함될 최종 검증 명령"><![CDATA[
모든 지시사항을 완수한 후, 최종 답변을 제출하기 전에 잠시 멈추고 스스로 '레드팀'의 역할을 수행하라. 내가 제시한 모든 요구사항(역할, 형식, 내용, 제약 조건 등)이 100% 충족되었는지, JSON 구조에 오류는 없는지, 더 나은 대안은 없는지 최소 세 번 이상 교차 검증하고, 그 결과를 반영하여 최종적으로 완벽하고 군더더기 없는 JSON 결과물만 출력하라.
            ]]></selfCorrectionCommand>
        </constraints>
    </promptDesignFramework>
</metaPrompt>`,
                     customPrompts: [
                         {
                             id: Utils.generateId('cp'),
                             name: "핵심 요약",
                             template: `다음은 "{{chapterTitle}}" 챕터의 원고입니다. 이 내용을 바탕으로 핵심 주제와 주요 논거를 3~5문장으로 요약해 주세요.\n\n# 원고\n{{manuscript}}`
                         },
                         {
                            id: Utils.generateId('lll'),
                            name: "도표만들기",
                            template: `<?xml version="1.0" encoding="UTF-8"?>

<metaPrompt>

<purpose>

주어진 자료를 분석하여, 모든 자료를 최대한 복잡한 내용의 논리를 다 담아낼 수 있을 정도로, 그 어떤 정보도 빠짐없이 포함한 시각적으로 이해되는 인포그래픽을 생성한다.

주어진 모든 유형의 자료(텍스트, 데이터 등)가 가진 내재적 구조를, 사용자가 명시한 분석 체계(DataStructureFramework)와 시각적 스토리텔링 원칙에 따라 정밀하게 분해하고, 그 핵심 과정을 하나의 유기적이고 설득력 있는, 컴팩트하게 모든 요소가 오밀조밀하게 배치된 인포그래픽으로 천천히, 차근차근 단계적으로 계획을 세워 아래 각 지시사항에 따라 성실하게 생성한다.

</purpose>

<promptDesignFramework>

<objectiveDefinition id="1" title="목표 정의: 과업의 제1원칙">

<finalDeliverable id="1.1" description="프롬프트를 통해 얻고자 하는 최종 결과물">

하나의 독립적이고 재사용 가능한 반응형 React 상세 분석 보고서(.jsx 파일). 각 분석 단계는 펼치거나 접을 수 있는 섹션으로 구성하여, 사용자가 정보의 깊이를 조절할 수 있게 해야 한다. 다만, 결과물은 전체적으로 구조적이고 체계적이면서 디자인 원칙에 맞아야 한다.

</finalDeliverable>

<coreTask id="1.2" description="LLM이 수행해야 할 핵심적인 동사">

구조적으로 분석(Analyze Structurally), 시각적 논증 설계(Design Visual Argument), 순서도형 인포그래픽 구현(Implement Flowchart Infographic)

</coreTask>

<successCriteria id="1.3" description="결과물이 '성공'이라고 판단할 객관적인 기준">

1.  단일 컴포넌트 및 독립성: 모든 로직, 스타일, 구조가 하나의 .jsx 파일 안에 완벽하게 캡슐화되어야 한다.
2.  **자체 발견 논리 구조:** 인포그래픽의 구조가 주어진 데이터의 고유한 이야기 흐름(예: 연대기, 원인과 결과, 문제와 해결 등)을 설득력 있게 반영해야 한다.
3.  통합된 포스터 미학 및 가독성: 모든 시각 요소는 분리된 느낌 없이 하나의 통일된 배경 안에서 조화를 이루어야 한다.
4.  최대 밀도 레이아웃: 각 정보 카드를 크기와 형태가 다른 '모자이크 타일' 또는 '테트리스 블록'으로 간주하여, 논리적 흐름을 해치지 않는 선에서 전체 캔버스의 빈 공간을 최소화하도록 오밀조밀하게 배치한다.
5.  **데이터 충실도:** 원문의 핵심 데이터, 인용문, 논리 구조가 단순 요약이 아닌, 충분한 깊이로 명확하게 드러나야 한다. 모든 내용을 빠뜨리지 않고 담고 있어, 원문을 읽지 않더라도 모든 정보를 흡수할 수 있다.
6.  원천적인 겹침 방지 구조 (Collision-Free Architecture): 모든 요소의 배치는 CSS Grid와 같은 구조화된 시스템의 규칙을 따라야 하며, position: absolute의 남용으로 인한 겹침이 발생해서는 안 된다.
7.  각 컴포넌트는 내부 스크롤 없이 한눈에 모든 요소가 표시되어야 한다.
8. 필요하다면 막대 차트, 선 차트, 영역 차트, 방사형 차트, 히스토그램, 박스 플롯, 밀도 플롯, 바이올린 플롯, 파이 차트, 도넛 차트, 트리맵, 누적 막대 차트, 누적 영역 차트, 산점도, 버블 차트, 히트맵, 생키 다이어그램, 간트 차트, 덴드로그램, 네트워크 다이어그램 등을 적극적으로 활용한다. 신뢰할만한 정보를 탐색하여 자료룰 보충할 수 있다.

    
    </successCriteria>
    
    </objectiveDefinition>
    
    <personaAssignment id="2" title="역할 부여: 최적의 인지 모델 설계">
    
    <expertPersona id="2.1" description="과업을 가장 잘 수행할 전문가의 상세한 묘사">
    
    당신은 **'정보 시각화 아키텍트(Information Visualization Architect)'**이다. 당신은 단순한 디자이너가 아니라, 복잡한 텍스트의 논리적 뼈대를 발라내는 분석가이자, 그 구조를 가장 직관적인 시각 언어로 재구성하는 건축가다. 당신은 어떤 정보든 그 안에 숨겨진 구조(배경, 문제, 해결책, 결과 등)를 꿰뚫어 보고, 각 요소의 관계를 설득력 있는 시각적 내러티브로 엮어내는 데 최고의 전문성을 지녔다.
    
    </expertPersona>
    
    </personaAssignment>
    
    <contextAndFormat id="3" title="맥락 제공 및 형식 지정">
    
    <essentialContext id="3.1" description="과업 수행에 필요한 모든 배경 정보, 데이터, 이전 대화 내용">
    
    <![CDATA[
    
    <Role>
    
    당신은 '정보 시각화 아키텍트'로서, <DataSource>의 정보를 **스스로 발견하고 정의한 분석 체계**에 따라 체계적으로 분석하고, 그 결과를 바탕으로 하나의 완성된 '순서도형 인포그래픽'을 창조하는 임무를 받았다.

    </Role>
    

<Goal>

<DataSource>의 텍스트를 <DataStructureFramework>에 따라 구조화하고, 이를 기반으로 발표 자료의 핵심 슬라이드로 즉시 사용 가능한, 예술성과 가독성을 겸비한 반응형 인포그래픽을 생성한다.

</Goal>

<!-- [핵심 변경사항] 이 부분에 분석하고자 하는 데이터의 구조를 직접 정의합니다. -->

<!-- 아래는 예시이며, 어떤 구조든 자유롭게 정의할 수 있습니다. -->

<DataStructureFramework name="자율적 구조 발견 프로세스">
  <Phase id="1" name="핵심 논리 흐름 식별 (Identify Core Logic)" description="전체 텍스트를 분석하여 그 안에 내재된 이야기나 논증의 흐름을 발견합니다. (예: 문제-해결, 원인-결과, 연대기적 여정, 주제별 탐구 등)"/>
  <Phase id="2" name="구조적 노드 정의 (Define Structural Nodes)" description="식별된 핵심 흐름에 따라, 인포그래픽의 주요 '장(Chapter)' 또는 '단계(Milestone)'를 정의합니다. 이 노드들의 이름은 템플릿이 아닌, 내용 자체에서 비롯되어야 합니다."/>
  <Phase id="3" name="콘텐츠 매핑 (Map Content to Nodes)" description="정의된 각 구조적 노드에 원문의 핵심 개념, 인용문, 논거들을 할당합니다. 모든 중요 정보가 적절한 위치에 배치되도록 합니다."/>
</DataStructureFramework>

<DataSource>

{{menuscript}}

</DataSource>

<DesignSystem name="Corporate_Blue_Theme">

<ColorPalette description="정보에 신뢰감과 전문성을 부여하는 색상 시스템입니다. 각 색상은 의미론적 역할을 가집니다.">

<Color name="Background-Primary" hex="#F8F9FA" description="전체 인포그래픽의 주 배경색. 부드럽고 눈이 편안한 연한 회색."/>

<Color name="Background-Secondary" hex="#FFFFFF" description="개별 카드(정보 블록)의 배경색으로, 내용에 집중할 수 있게 합니다."/>

<Color name="Text-Primary" hex="#212529" description="가장 중요한 텍스트(제목, 핵심 본문)에 사용되는 기본 색상으로, 가독성을 최우선으로 합니다."/>

<Color name="Text-Secondary" hex="#495057" description="보조적인 텍스트, 설명 등에 사용하여 정보의 위계를 구분합니다."/>

<Color name="Border-Subtle" hex="#E9ECEF" description="카드 테두리 등 시각적 구분을 위한 부드러운 경계선 색상입니다."/>

<Color name="Accent-Primary" hex="#1971C2" description="긍정적/중립적 결론, 해결책 등을 강조하는 데 사용되는 신뢰감 있는 파란색입니다."/>

<Color name="Accent-Warning" hex="#E67700" description="주의가 필요한 '문제점', '쟁점' 등을 환기시키는 데 사용되는 주황색 계열입니다."/>

<Color name="Accent-Highlight" hex="#FCC419" description="카드 내 특별 강조 블록(노란 배경)의 테두리에 사용되는 색상입니다."/>

<Color name="Accent-Success" hex="#2F9E44" description="최종 결론(Conclusion), 기대 효과(Benefit) 카드에 사용되어 긍정적이고 확정적인 느낌을 주는 녹색입니다."/>

</ColorPalette>

\`\`\`
<TypographyHierarchy description="정보의 위계를 명확히 전달하고 **발표 상황에서 멀리서도 잘 읽히도록** 설계된 타이포그래피 규칙입니다.">
    <Rule priority="1" target="인포그래픽 전체 제목" style="Font-size: 1.5rem, Font-weight: 800, Color: Text-Primary"/>
    <Rule priority="2" target="최종 결론 텍스트" style="Font-size: 1rem, Font-weight: 800, Color: Accent-Success의 어두운 톤"/>
    <Rule priority="3" target="각 카드의 제목" style="Font-size: 0.7rem, Font-weight: 700, Color: Text-Primary"/>
    <Rule priority="4" target="본문 텍스트" style="Font-size: 0.7rem, Line-height: 1.5, Color: Text-Secondary, 최대 너비를 제한하여 가독성 확보"/>
    <Rule priority="5" target="카드 내 하이라이트/결론 텍스트" style="Font-size: 0.7rem, Font-weight: 600, Color: Accent-Primary 또는 Accent-Warning"/>
</TypographyHierarchy>

<ComponentStyles description="UI 컴포넌트의 구체적인 시각적 스타일을 정의하여 일관성을 부여합니다.">
    <Style target="Card" description="모든 정보 카드의 기본 스타일입니다.">
        <Property name="border-radius" value="16px" description="부드럽고 현대적인 인상을 주는 둥근 모서리입니다."/>
        <Property name="box-shadow" value="0 4px 12px rgba(0,0,0,0.05)" description="카드에 깊이감을 부여하여 배경과 시각적으로 분리하는 은은한 그림자 효과입니다."/>
        <Property name="border" value="1px solid var(--Border-Subtle)" description="카드의 경계를 명확히 하는 얇은 테두리입니다."/>
        <Property name="padding" value="1rem" description="컴팩트한 배치를 위해 내부 여백을 기본 1rem(16px)으로 제한합니다."/>
        <Property name="transition" value="transform 0.3s ease, box-shadow 0.3s ease" description="마우스 호버 등 인터랙션 시 부드러운 시각적 변화를 위함입니다."/>
    </Style>
    <Style target="Icon" description="각 카드의 아이콘 스타일입니다.">
        <Property name="size" value="24px" description="일관된 아이콘 크기를 유지합니다."/>
        <Property name="stroke-width" value="2" description="너무 두껍거나 얇지 않은 적절한 선 두께입니다."/>
        <Property name="color" value="해당 카드의 Accent 색상 또는 Text-Secondary" description="아이콘 색상은 카드의 목적에 따라 동적으로 변합니다."/>
<Property name="color" value="Font Awesome, Bootstrap Icons, Material Icons, Boxicons, Remix Icon, Feather Icons, Heroicons, Devicon.
등 외부 라이브러리를 사용합니다."/>
    </Style>
</ComponentStyles>

<VisualNarrativeArchitecture description="단순한 카드 나열을 넘어, 하나의 완성된 시각적 논증을 구축하기 위한 구조적 설계 원칙입니다.">
    <Principle name="MaximalDensityLayout (최대 밀도 레이아웃)" description="전체 캔버스를 하나의 신문 지면으로 간주한다. 각 정보 카드는 크기가 다른 기사 블록처럼 취급하여, 수직/수평으로 빈틈없이 배치한다. 이를 위해 각 카드의 크기는 내용의 중요도와 양에 비례하여 가변적으로 설정되어야 하며, 불필요한 내부 여백을 줄여야 한다."/>
    <Principle name="FlowchartLayout" description="전체 인포그래픽은 명확한 시작점에서 종착점으로 이어지는 '순서도'의 형태를 가져야 합니다. 데스크톱에서는 2열 기반의 자유로운 흐름을, 모바일에서는 단일 수직 흐름을 유지합니다."/>
    <Principle name="MetaphoricalCore (은유적 핵심)" description="가장 복잡한 논증이 담긴 분석(Analysis) 부분은 인포그래픽의 시각적으로 가장 중요한 부분 입니다. 이곳에 텍스트 이상의 설득력을 부여해야 합니다."/>
    <Principle name="UnifiedCanvas (통합된 캔버스)" description="모든 요소는 하나의 통일된 배경 또는 프레임 위에 배치되어, 분리된 컴포넌트가 아닌 '한 장의 포스터'라는 인식을 주어야 합니다."/>
    <Principle name="ContentDrivenSizing (콘텐츠 기반 크기 조절)" description="각 정보 카드의 크기와 내부 레이아웃은 포함된 정보의 양과 복잡성에 따라 가변적으로 결정되어야 한다. 단순 요약이 아닌, 상세한 설명과 직접 인용구를 충분히 담을 수 있도록 공간을 확보해야 한다."/>
    <Principle name="MaximalDensityLayout (최대 밀도 레이아웃)" description="전체 캔버스를 하나의 신문 지면으로 간주한다. 각 정보 카드는 크기가 다른 기사 블록처럼 취급하여, 수직/수평으로 빈틈없이 배치한다. **이를 위해 각 카드의 내부 \`padding\`을 최소화하고(\`1rem\` 내외), 본문 텍스트의 \`line-height\`를 \`1.5\` 수준으로 줄여 내부의 불필요한 빈 공간을 압축해야 한다.**"/>
</VisualNarrativeArchitecture>

\`\`\`

</DesignSystem>

]]>

</essentialContext>

<outputFormat id="3.2" description="결과물이 출력되어야 할 정확한 형식 또는 템플릿">

<![CDATA[

### 1. 데이터 분석 및 인포그래픽 스토리보드

- **구조적 분석:** [여기에 <DataSource>의 내용을 <DataStructureFramework>에 따라 어떻게 분석하고 구조화했는지 기술. 각 노드(Node)의 핵심 요약 포함]
    
- **인포그래픽 아키텍처:** [구조화된 각 정보 요소를 <VisualNarrativeArchitecture> 원칙에 따라 어떻게 배치하여 하나의 완성된 인포그래픽을 구성했는지 설명. 특히 핵심적인 시각적 은유와 '순서도' 흐름을 어떻게 구현할 것인지 명시.]
    
- **컴포넌트 API 설계:** [생성될 컴포넌트의 이름과 props 구조를 명확하게 정의.]
    

### 2. React 컴포넌트 코드 (InfographicComponent.jsx)

\`\`\`
// 파일명: InfographicComponent.jsx
// 설명: 주어진 데이터의 구조를 분석하여 발표 자료 수준의 반응형 순서도형 인포그래픽으로 시각화하는 컴포넌트.
// ... React 코드 ...
\`\`\`

]]>

</outputFormat>

</contextAndFormat>

<constraints id="5" title="제약 조건 설정: 탐색 공간 제어">

<mustInclude id="5.1" description="결과물에 반드시 포함되어야 할 키워드, 개념, 데이터 포인트">

- **사용자 정의 분석 체계(<DataStructureFramework>)에 명시된 구조에 따른** 내용 분류
    
- 순서도(Flowchart) 형태의 레이아웃
    
    
- 정보의 관계를 표현하는 적절한 시각적 은유
    
- **가독성 높은 큰 글씨 크기**

- 인포그래픽 전체를 이미지 파일(.png)로 저장하는 '다운로드 버튼' 기능*
    

</mustInclude>

<mustAvoid id="5.2" description="반드시 피해야 할 주제, 표현, 단어, 편향, 가정">

- **사용자가 정의한 <DataStructureFramework>를 무시한** 자의적인 내용 분류
    
- 논리적 연결 없는 단순한 그리드(Grid) 카드 나열
    
- 추상적 개념을 텍스트로만 설명하는 디자인
    
- **논리적 구체성을 확보하기 위한 핵심 내용까지 생략할 정도로 과도하게 요약된 텍스트 블록.**
    
- 가독성을 해치지 않는 선에서, 발표 상황에 부적합한 너무 작거나 빽빽한 텍스트 블록. **단, 논리의 구체성을 위해 원문의 핵심 문구를 직접 인용하는 것은 허용한다.**
    
- 구조 없는 절대 위치 지정 남용: CSS Grid와 같은 상위 레이아웃 시스템의 제어 없이, 단순히 top, left 퍼센트 값만으로 위치를 지정하여 요소 간의 겹침을 유발하는 position: absolute의 무분별한 사용. (드래그 인터랙션의 시각적 표현을 위해 일시적으로 사용하는 것은 허용되나, 드롭 시에는 반드시 그리드에 맞춰 위치가 재조정되어야 함)
    
    </mustAvoid>
    
    <constraint id="5.1.1" name="데이터 충실도 원칙 (Principle of Data Fidelity)">
    
    결과물에 포함되는 모든 텍스트, 숫자, 날짜, 인용 등 구체적인 정보는 오직 &lt;DataSource&gt;에 명시적으로 제공된 내용에만 100% 근거해야 한다. 만약 &lt;DataSource&gt;에 특정 정보가 없다면, 해당 정보는 결과물에서 생략하거나 '제공되지 않음'으로 명시해야 한다. 절대로 외부 지식을 활용하여 정보를 추론하거나 창작해서는 안 된다.
    
    </constraint>
    
    <selfCorrectionCommand id="5.3" description="생성될 프롬프트 마지막에 포함될 최종 검증 명령">
    
    <![CDATA[
    
    모든 지시사항을 완수한 후, 최종 답변을 제출하기 전에 잠시 멈추고 '최고 디자인 책임자(CDO)'의 관점에서 스스로를 검토하라.
    
    ]]>
    
    </selfCorrectionCommand>
<constraint id="5.4" name="상세함 우선 원칙">
시각적 간결성보다 정보의 구체성과 완전성을 최우선으로 한다. 필요하다면 결과물의 길이가 길어져 스크롤이 발생하더라도, 원문의 핵심 논증과 직접 인용문을 최대한 포함해야 한다.
</constraint>
    
    </constraints>
    
    <caution>
    
- 모든 시각적 요소는 서로 설득력이 있어야 하고, 각각 연결관계가 정확해야만 한다.
    
    </caution>
    
    <sample code desc="아래는 데이터를 시각화했을 때의 구현 예시입니다. 입력되는 데이터와 구조에 따라 내용은 완전히 달라져야 합니다.">
 \`\`\`
import React, { useState, useRef, useEffect } from 'react';

// html2canvas 라이브러리는 아래 코드를 통해 동적으로 로드됩니다.
// <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

// --- 아이콘 컴포넌트들 (인라인 SVG) ---
const IconBrainCircuit = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2a10 10 0 0 0-10 10c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.89 1.52 2.34 1.08 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.94 0-1.1.39-1.99 1.03-2.69a3.6 3.6 0 0 1 .1-2.64s.84-.27 2.75 1.02a9.58 9.58 0 0 1 5 0c1.91-1.29 2.75-1.02 2.75-1.02.55 1.37.2 2.4.1 2.64.64.7 1.03 1.6 1.03 2.69 0 3.84-2.34 4.68-4.57 4.93.36.31.68.92.68 1.85v2.72c0 .27.16.58.67.5A10 10 0 0 0 22 12 10 10 0 0 0 12 2Z"/><path d="M12 9.5v-1.5a2.5 2.5 0 0 1 5 0v1.5"/><path d="M12 14.5v-1.5a2.5 2.5 0 0 0-5 0v1.5"/><path d="M5 14.5a2.5 2.5 0 0 0-2.5-2.5h-1"/><path d="M19 14.5a2.5 2.5 0 0 1 2.5-2.5h1"/><path d="m9 12-1-1"/><path d="m15 12 1-1"/><path d="m12 9-1-1"/><path d="m12 9 1-1"/></svg>
);
const IconAtom = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="1"/><path d="M20.2 20.2c2.04-2.04 2.04-5.36 0-7.4s-5.36-2.04-7.4 0"/><path d="M3.8 3.8c-2.04 2.04-2.04 5.36 0 7.4s5.36 2.04 7.4 0"/><path d="M20.2 3.8c-2.04-2.04-5.36-2.04-7.4 0s-2.04 5.36 0 7.4"/><path d="M3.8 20.2c2.04 2.04 5.36 2.04 7.4 0s2.04-5.36 0-7.4"/></svg>
);
const IconBinary = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M6 20h4"/><path d="M9 16v4"/><path d="M6 14h2v2h-2z"/><path d="M14 20h4"/><path d="M17 16v4"/><path d="M14 10h2v2h-2z"/><path d="M6 8h2v2H6z"/><path d="M14 14h2v2h-2z"/><path d="m6 4 3 3 3-3"/><path d="m14 4 3 3 3-3"/></svg>
);
const IconListChecks = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m3 17 2 2 4-4"/><path d="m3 7 2 2 4-4"/><path d="M13 6h8"/><path d="M13 12h8"/><path d="M13 18h8"/></svg>
);
const IconBalance = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 16h3a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1h-3a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1Z"/><path d="M5 16h3a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1Z"/><path d="M12 2v20"/><path d="M4 12h16"/></svg>
);
const IconMessageCircleQuestion = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9.1 9a3 3 0 0 1 5.82 1c0 2-3 3-3 3"/><path d="M12 17h.01"/><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h11a2 2 0 0 1 2 2z"/></svg>
);
const IconBookText = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/><path d="M8 7h6"/><path d="M8 11h8"/></svg>
);
const IconLanguages = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m5 8 6 6"/><path d="m4 14 6-6 2-3"/><path d="M2 5h12"/><path d="M7 2h1"/><path d="m22 22-5-10-5 10"/><path d="M14 18h6"/></svg>
);
const IconShieldCheck = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10"/><path d="m9 12 2 2 4-4"/></svg>
);
const IconSiren = () => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M7 12a5 5 0 0 1 5-5v0a5 5 0 0 1 5 5v0a5 5 0 0 1-5 5v0a5 5 0 0 1-5-5Z"/><path d="M12 12a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"/><path d="M20.9 13.9a9 9 0 0 1-17.8 0"/><path d="M6 12a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"/><path d="M18 12a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"/></svg>
);
const IconSparkles = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m12 3-1.9 1.9-1.9-1.9-1.9 1.9-1.9-1.9L2.5 5l1.9 1.9-1.9 1.9 1.9 1.9-1.9 1.9 1.9 1.9L6 21.5l1.9-1.9 1.9 1.9 1.9-1.9 1.9 1.9 1.9-1.9 1.9 1.9 1.9-1.9-1.9-1.9 1.9-1.9-1.9-1.9 1.9-1.9-1.9-1.9L18 3l-1.9 1.9-1.9-1.9-1.9 1.9Z"/></svg>
);
const IconDownload = () => (
  <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>
);

// --- 맞춤 다이어그램 컴포넌트들 ---
const DiagramDuality = () => (
    <svg width="100%" height="60" viewBox="0 0 200 40">
      <defs><marker id="arrow2" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" fill="var(--Accent-Primary)" /></marker></defs>
      <rect x="10" y="5" width="70" height="30" rx="5" fill="#e7f5ff" stroke="var(--Accent-Primary)" />
      <text x="45" y="25" textAnchor="middle" fontSize="10">경험 (현상)</text>
      <path d="M 85 20 H 115" stroke="var(--Accent-Primary)" strokeWidth="2" fill="none" markerEnd="url(#arrow2)" />
      <rect x="120" y="5" width="70" height="30" rx="5" fill="#d0ebff" stroke="var(--Accent-Primary)" />
      <text x="155" y="25" textAnchor="middle" fontSize="10">이론 (원리)</text>
    </svg>
);
const DiagramDiscourse = () => (
     <svg width="100%" height="80" viewBox="0 0 250 50">
        <defs><marker id="arrow3" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="5" markerHeight="5" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" fill="var(--Purple-Light)" /></marker></defs>
        <g>
            <rect x="5" y="10" width="45" height="30" rx="5" fill="#f3f0ff" stroke="var(--Purple-Light)" />
            <text x="27.5" y="30" textAnchor="middle" fontSize="9">지적</text>
        </g>
        <path d="M 52 25 H 73" stroke="var(--Purple-Light)" strokeWidth="1.5" fill="none" markerEnd="url(#arrow3)" />
        <g>
            <rect x="75" y="10" width="45" height="30" rx="5" fill="#f3f0ff" stroke="var(--Purple-Light)" />
            <text x="97.5" y="25" textAnchor="middle" fontSize="9">동요</text>
            <text x="97.5" y="37" textAnchor="middle" fontSize="7" fill="var(--Text-Secondary)">(해체)</text>
        </g>
        <path d="M 122 25 H 143" stroke="var(--Purple-Light)" strokeWidth="1.5" fill="none" markerEnd="url(#arrow3)" />
        <g>
            <rect x="145" y="10" width="45" height="30" rx="5" fill="#f3f0ff" stroke="var(--Purple-Light)" />
            <text x="167.5" y="25" textAnchor="middle" fontSize="9">달램</text>
            <text x="167.5" y="37" textAnchor="middle" fontSize="7" fill="var(--Text-Secondary)">(재구성)</text>
        </g>
        <path d="M 192 25 H 213" stroke="var(--Purple-Light)" strokeWidth="1.5" fill="none" markerEnd="url(#arrow3)" />
        <g>
            <rect x="215" y="10" width="45" height="30" rx="5" fill="#f3f0ff" stroke="var(--Purple-Light)" />
            <text x="237.5" y="30" textAnchor="middle" fontSize="9">수용</text>
        </g>
    </svg>
);


const infographicData = [
    {
        id: 1,
        title: "Node 1: 철학적 배경 - 극단 회피",
        icon: <IconBrainCircuit />,
        color: "var(--Accent-Warning)",
        gridArea: "1 / 1 / 15 / 5",
        content: \`붓다의 사상은 기존 사상의 <strong>극단들을 피하려는 시도</strong>에서 출발합니다. 그는 <u>영원한 자아(브라만교)</u>, <u>결정론적 자연(유물론)</u>, <u>절대적 회의론</u> 등 형이상학적 관념들을 모두 배척하고, '<mark>중도(Middle Way)</mark>'를 모색해야 했습니다.\`,
        quote: "그의 교리는 영원한 존재론과 허무주의적인 비존재론... 두 극단을 모두 벗어나야 했다.",
    },
     {
        id: 2,
        title: "Node 2: 핵심 원리 - 연기",
        icon: <IconAtom />,
        color: "var(--Accent-Primary)",
        gridArea: "15 / 1 / 26 / 5",
        content: "중도의 핵심은 '<strong>연기(緣起)</strong>'입니다. 이는 '<mark>의존하여 발생함</mark>'을 의미하며, 현상 세계의 본질을 설명하는 단일 원리입니다.",
    },
    {
        id: 3,
        title: "Node 3: 연기의 이중적 본질",
        icon: <IconBinary />,
        color: "var(--Accent-Primary)",
        gridArea: "26 / 1 / 38 / 5",
        content: \`<strong>연기</strong>는 <u>구체적 경험</u>('<mark>연기된 현상</mark>')과, 여기서 추상화된 <u>일반 원리</u>('<mark>연기</mark>')라는 두 측면을 가집니다.\`,
        customDiagram: <DiagramDuality />
    },
    {
        id: 5,
        title: "Node 5: 연기 공식과 중도",
        icon: <IconBalance />,
        color: "var(--Accent-Primary-Light)",
        gridArea: "1 / 5 / 26 / 13",
        content: \`연기 원리는 '<strong>존재</strong>'와 '<strong>비존재</strong>'의 양극단을 피하는 '<mark>중도</mark>'입니다. <u>세상의 발생을 보면 '비존재' 관념이 없고, 세상의 소멸을 보면 '존재' 관념이 없습니다.</u> 이 관계는 시간성을 포함하는 <strong>처격 절대 구문</strong>으로 표현되어 경험론을 만족시킵니다.\`,
        quote: "\"이것이 있으면(Imasmiṃ sati), 저것이 생겨난다; 이것이 발생함에 따라(imassa uppādā), 저것이 발생한다. ...\"",
        isCore: true,
    },
    {
        id: 6,
        title: "Node 6: 소통의 과제",
        icon: <IconMessageCircleQuestion />,
        color: "var(--Accent-Warning)",
        gridArea: "26 / 5 / 38 / 9",
        content: \`연기 원리는 심오하지만, <strong>집착(ālaya)</strong>에 익숙한 일반인들에게는 '<mark>인식하기 어렵습니다(duddasa)</mark>'. 따라서 이 깊은 진리를 어떻게 효과적으로 전달할 것인가라는 <u>새로운 과제</u>가 등장합니다.\`,
    },
     {
        id: 7,
        title: "Node 7: 소통의 매체 - 담마",
        icon: <IconBookText />,
        color: "var(--Purple)",
        gridArea: "26 / 9 / 38 / 13",
        content: \`소통의 해답은 '<strong>담마(Dhamma)</strong>'입니다. 담마는 다층적이며, <mark>네 가지 유형의 질문</mark>에 따라 유연하게 제시되어 맥락적이고 실용적인 가르침임을 보여줍니다.\`,
    },
    {
        id: 4,
        title: "Node 4: 연기 원리의 4가지 특성",
        icon: <IconListChecks />,
        color: "var(--Accent-Primary)",
        gridArea: "38 / 1 / 61 / 7",
        content: "연기 원리는 <strong>네 가지 주요 특성</strong>을 통해 그 철학적 깊이를 드러냅니다. 또한 원리의 타당성은 절대적이지 않고, 과거분사 <strong>ṭhita</strong>(존재해왔다)를 사용하여 경험에 근거한 제한적 주장을 펼칩니다.",
        details: [
            { term: "1. 객관성 (tathatā)", desc: "경험된 사건과 그 설명 원리 사이에 괴리가 없는 '그러함'." },
            { term: "2. 필연성 (avitathatā)", desc: "'<u>따로-떨어져-있지-않음</u>'. 사건들이 임의적이지 않음." },
            { term: "3. 불변성 (anaññathatā)", desc: "'<u>그렇지-않음-ness</u>'. 절제된 불변성." },
            { term: "4. 조건성 (idappaccayatā)", desc: "'<u>이-조건-성</u>'. 가장 중요한 특성, 상호의존 관계." },
        ]
    },
    {
        id: 8,
        title: "Node 8: 언어의 본질",
        icon: <IconLanguages />,
        color: "var(--Purple)",
        gridArea: "38 / 7 / 50 / 13",
        content: \`언어는 불변의 실체가 아닌, 끊임없이 변하는 '<u>세상의 약속(loka-sammuti)</u>'입니다. 붓다는 언어에 대한 <strong>엄격한 집착</strong>과 통용어를 <strong>위반</strong>하는 것 사이의 중도적 입장을 취할 것을 권했습니다.\`,
        quote: "'그는 한 나라의 방언에 엄격히 집착해서도 안 되고, 일반적인 통용어를 위반해서도 안 된다'"
    },
     {
        id: 9,
        title: "Node 9: 가르침의 진정성 확보",
        icon: <IconShieldCheck />,
        color: "var(--Purple-Light)",
        gridArea: "50 / 7 / 61 / 13",
        content: \`가르침의 왜곡을 막기 위해, 4가지 '<strong>주요 지표(mahāpadesa)</strong>'를 제시했습니다. 어떤 말이 붓다의 말씀인지 확인하려면, <u>경전(sutta)</u> 및 <u>계율(vinaya)</u>과 부합하는지 <mark>반드시 검증</mark>해야 합니다.\`,
    },
    {
        id: 10,
        title: "Node 10: 담화의 4단계 방법론",
        icon: <IconSiren />,
        color: "var(--Purple-Light)",
        gridArea: "61 / 1 / 73 / 7",
        content: "붓다는 청자의 상태에 맞춰 '<strong>방편(skill in means)</strong>'을 사용했습니다. 이는 <mark>4단계로 이루어진 소통 방법론</mark>으로, 깨달음으로 이끄는 과정입니다.",
        customDiagram: <DiagramDiscourse />
    },
    {
        id: 11,
        title: "Node 11: 최종 목표 - 평화와 고귀함",
        icon: <IconSparkles />,
        color: "var(--Accent-Success)",
        gridArea: "61 / 7 / 73 / 13",
        content: \`연기의 원리를 통해 세상을 '<strong>있는 그대로(yathābhūta)</strong>' 보고, 어떠한 숨겨진 <u>신비(kiñcana)도 찾지 않을 때(akiñcana)</u>, 인간은 불안(dukkha)에서 벗어나 <mark>마음의 평화(santa)</mark>와 <mark>고귀함(paṇīta)</mark>을 성취하게 됩니다. 이것이 붓다 가르침의 <strong>궁극적인 목표</strong>입니다.\`,
    }
];

const FlowLines = () => (
    <svg style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%', zIndex: 0, pointerEvents: 'none' }} className="flow-lines"
        viewBox="0 0 100 100" preserveAspectRatio="none">
        <defs>
            <linearGradient id="flowGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stopColor="var(--Accent-Primary)" />
                <stop offset="50%" stopColor="var(--Purple)" />
                <stop offset="100%" stopColor="var(--Accent-Success)" />
            </linearGradient>
            <marker id="arrowhead" markerWidth="4" markerHeight="3" refX="2" refY="1.5" orient="auto">
                <polygon points="0 0, 4 1.5, 0 3" fill="url(#flowGradient)" />
            </marker>
        </defs>
        
        {/* Paths - (x1 y1) to (x2 y2) */}
        <path d="M 37 8 C 45 8, 45 1, 45 1" stroke="url(#flowGradient)" strokeWidth="0.5" fill="none" transform="rotate(180 50 50) translate(0, -100)" />
        <path d="M 16 20 V 28" stroke="url(#flowGradient)" strokeWidth="0.5" fill="none" markerEnd="url(#arrowhead)"/>
        <path d="M 16 34 V 49" stroke="url(#flowGradient)" strokeWidth="0.5" fill="none" markerEnd="url(#arrowhead)"/>
        <path d="M 37 20 H 42" stroke="url(#flowGradient)" strokeWidth="0.5" fill="none" markerEnd="url(#arrowhead)"/>
        <path d="M 50 34 C 50 38, 54 38, 54 44" stroke="url(#flowGradient)" strokeWidth="0.5" fill="none" markerEnd="url(#arrowhead)"/>
        <path d="M 79 34 H 71" stroke="url(#flowGradient)" strokeWidth="0.5" fill="none" markerEnd="url(#arrowhead)"/>
        <path d="M 54 55 H 42" stroke="url(#flowGradient)" strokeWidth="0.5" fill="none" markerEnd="url(#arrowhead)"/>
        <path d="M 79 55 V 67" stroke="url(#flowGradient)" strokeWidth="0.5" fill="none" markerEnd="url(#arrowhead)"/>
        <path d="M 54 73 V 67" stroke="url(#flowGradient)" strokeWidth="0.5" fill="none" markerEnd="url(#arrowhead)"/>

    </svg>
);


const BuddhistPhilosophyInfographic = () => {
    const infographicRef = useRef(null);
    const [isLoading, setIsLoading] = useState(false);
    const [isScriptReady, setIsScriptReady] = useState(false);

    useEffect(() => {
        const scriptId = 'html2canvas-script';
        const existingScript = document.getElementById(scriptId);

        const handleScriptLoad = () => {
            setIsScriptReady(true);
        };

        const handleScriptError = () => {
            console.error("html2canvas 스크립트 로딩에 실패했습니다.");
            setIsScriptReady(false);
        };

        if (existingScript) {
            if (window.html2canvas) {
                handleScriptLoad();
            } else {
                existingScript.addEventListener('load', handleScriptLoad);
                existingScript.addEventListener('error', handleScriptError);
            }
        } else {
            const script = document.createElement('script');
            script.id = scriptId;
            script.src = "https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js";
            script.async = true;
            script.onload = handleScriptLoad;
            script.onerror = handleScriptError;
            document.body.appendChild(script);
        }

        return () => {
            if (existingScript) {
                existingScript.removeEventListener('load', handleScriptLoad);
                existingScript.removeEventListener('error', handleScriptError);
            }
        };
    }, []);

    const handleDownload = () => {
        if (infographicRef.current && isScriptReady && typeof window.html2canvas !== 'undefined') {
            setIsLoading(true);
            const cards = infographicRef.current.querySelectorAll('.infographic-card');
            cards.forEach(card => card.classList.add('no-hover'));

            window.html2canvas(infographicRef.current, {
                backgroundColor: '#F8F9FA',
                scale: 2.5,
                useCORS: true,
                windowWidth: infographicRef.current.scrollWidth,
                windowHeight: infographicRef.current.scrollHeight
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = 'buddhist-philosophy-infographic.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
                setIsLoading(false);
                cards.forEach(card => card.classList.remove('no-hover'));
            }).catch(err => {
                console.error("oops, something went wrong!", err);
                setIsLoading(false);
                 cards.forEach(card => card.classList.remove('no-hover'));
            });
        } else {
            console.error("html2canvas is not ready or ref is not available.");
        }
    };

    return (
        <>
            <style>{\`
                :root {
                    --Background-Primary: #F8F9FA;
                    --Background-Secondary: #FFFFFF;
                    --Text-Primary: #212529;
                    --Text-Secondary: #495057;
                    --Border-Subtle: #E9ECEF;
                    --Accent-Primary: #1971C2;
                    --Accent-Primary-Light: #4DABF7;
                    --Accent-Warning: #E67700;
                    --Accent-Highlight: #FCC419;
                    --Accent-Success: #2F9E44;
                    --Purple: #7048E8;
                    --Purple-Light: #9775FA;
                }
                .infographic-body {
                    font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                    background-color: var(--Background-Primary);
                    background-image: radial-gradient(circle at top center, #e9ecef 0%, var(--Background-Primary) 70%);
                    color: var(--Text-Primary);
                    padding: 2rem;
                }
                .infographic-outer-container {
                    max-width: 1400px;
                    margin: auto;
                    position: relative;
                }
                .infographic-container-wrapper {
                  position: relative;
                }
                .infographic-container {
                    display: grid;
                    grid-template-columns: repeat(12, 1fr);
                    grid-auto-rows: 20px;
                    gap: 0.85rem;
                    position: relative;
                    z-index: 1;
                }
                .infographic-card {
                    background-color: var(--Background-Secondary);
                    border-radius: 16px;
                    border: 1px solid var(--Border-Subtle);
                    box-shadow: 0 6px 15px rgba(0,0,0,0.06);
                    padding: 1rem;
                    display: flex;
                    flex-direction: column;
                    gap: 0.5rem;
                    transition: transform 0.3s ease, box-shadow 0.3s ease;
                    z-index: 1;
                    overflow: hidden;
                }
                 .infographic-card.no-hover {
                    transform: none !important;
                    box-shadow: 0 6px 15px rgba(0,0,0,0.06) !important;
                }
                .infographic-card.is-core {
                    background-color: #f8f0ff;
                    border-color: var(--Purple-Light);
                }
                .infographic-card:hover {
                    transform: translateY(-6px) scale(1.015);
                    box-shadow: 0 10px 25px rgba(0,0,0,0.1);
                }
                .card-header {
                    display: flex;
                    align-items: center;
                    gap: 0.6rem;
                }
                .card-title {
                    font-size: 0.95rem;
                    font-weight: 700;
                    color: var(--Text-Primary);
                }
                .card-content {
                    font-size: 0.85rem;
                    line-height: 1.6;
                    color: var(--Text-Secondary);
                }
                .card-content strong { color: var(--Text-Primary); font-weight: 600; }
                .card-content u { text-decoration-color: var(--Accent-Primary-Light); text-decoration-thickness: 2px; text-underline-offset: 3px;}
                .card-content mark { background-color: #fff3bf; padding: 2px 4px; border-radius: 4px; }
                .card-quote {
                    font-style: italic;
                    font-size: 0.8rem;
                    line-height: 1.5;
                    color: var(--Text-Primary);
                    padding: 0.7rem 1rem;
                    background-color: #f1f3f5;
                    border-left: 4px solid var(--Accent-Highlight);
                    border-radius: 0 8px 8px 0;
                    margin-top: auto;
                }
                .detail-item { margin-top: 0.5rem; }
                .detail-term { font-weight: 700; font-size: 0.8rem; color: var(--Text-Primary); }
                .detail-desc { font-size: 0.8rem; color: var(--Text-Secondary); margin-left: 1rem; }
                .custom-diagram-container { margin-top: auto; padding-top: 0.5rem; }
                @media (max-width: 1024px) {
                    .infographic-container { grid-template-columns: 1fr; gap: 1.2rem; grid-auto-rows: auto; }
                    .infographic-card { grid-column: 1 / -1 !important; grid-row: auto !important; }
                    .flow-lines { display: none; }
                }
                .download-button { position: fixed; bottom: 2rem; right: 2rem; background-color: var(--Accent-Primary); color: white; border: none; border-radius: 50%; width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(0,0,0,0.15); cursor: pointer; transition: all 0.3s ease; z-index: 1000; }
                .download-button:hover { background-color: #1864ab; transform: scale(1.1); }
                .download-button:disabled { background-color: #ced4da; cursor: not-allowed; }
            \`}</style>
            <div className="infographic-body">
                 <div style={{textAlign: 'center', marginBottom: '3rem'}}>
                    <h1 style={{fontSize: '2.5rem', fontWeight: 800, color: 'var(--Text-Primary)', letterSpacing: '-0.5px'}}>붓다의 연기론과 소통 철학 분석</h1>
                    <p style={{fontSize: '1.2rem', color: 'var(--Text-Secondary)', marginTop: '0.5rem'}}>경험과 이론, 그리고 언어와 소통의 관계에 대한 심층 탐구</p>
                </div>

                <div className="infographic-outer-container">
                  <div id="infographic-container" ref={infographicRef}>
                      <div className="infographic-container-wrapper">
                          <FlowLines />
                          <div className="infographic-container">
                              {infographicData.map(item => (
                                  <div key={item.id} className={\`infographic-card ${item.isCore ? 'is-core' : ''}\`} style={{ gridArea: item.gridArea, borderTop: \`6px solid ${item.color}\` }}>
                                      <div className="card-header">
                                          <span style={{ color: item.color }}>{item.icon}</span>
                                          <h3 className="card-title">{item.title}</h3>
                                      </div>
                                      <p className="card-content" dangerouslySetInnerHTML={{ __html: item.content }}></p>
                                      {item.details && (
                                          <div className="card-details">
                                              {item.details.map((detail, index) => (
                                                  <div key={index} className="detail-item">
                                                      <p className="detail-term">{detail.term}</p>
                                                      <p className="detail-desc" dangerouslySetInnerHTML={{ __html: detail.desc }}></p>
                                                  </div>
                                              ))}
                                          </div>
                                      )}
                                      {item.customDiagram && <div className="custom-diagram-container">{item.customDiagram}</div>}
                                      {item.quote && <p className="card-quote">"{item.quote}"</p>}
                                  </div>
                              ))}
                          </div>
                      </div>
                    </div>
                </div>

                <button onClick={handleDownload} className="download-button" disabled={isLoading || !isScriptReady}>
                    {isLoading ? 
                        <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="white"><path d="M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z" opacity=".25"/><path d="M10.72,19.9a8,8,0,0,1-6.5-9.79A7.77,7.77,0,0,1,10.4,4.16a8,8,0,0,1,9.49,6.52A1.54,1.54,0,0,0,21.38,12h.13a1.37,1.37,0,0,0,1.38-1.54,11,11,0,1,0-12.7,12.39A1.54,1.54,0,0,0,12,21.34h0A1.47,1.47,0,0,0,10.72,19.9Z"><animateTransform attributeName="transform" type="rotate" dur="0.75s" values="0 12 12;360 12 12" repeatCount="indefinite"/></path></svg> 
                        : <IconDownload />}
                </button>
            </div>
        </>
    );
};

export default BuddhistPhilosophyInfographic;


\`\`\`

</sample code>

</promptDesignFramework>

</metaPrompt>
                            `
                         }
                     ],
                     contextMenuItems: [
                         {
                             id: Utils.generateId('cmi'),
                             name: "문장 해설 요청",
                             template: `<?xml version="1.0" encoding="UTF-8"?>
<prompt>
    <persona>
        <role>고전 문헌 분석가 및 언어학자 (Classical Text Analyst and Linguist)</role>
        <description>
            당신은 특정 문장의 표면적 의미를 넘어, 해당 문장이 사용된 시대의 언어적 특성, 문화적 배경, 그리고 문헌 전체의 맥락을 종합적으로 분석하는 전문가입니다. 당신의 분석은 항상 제공된 자료에 근거하며, 논리적이고 체계적인 방식으로 구성됩니다. 복잡한 개념도 비전문가가 이해할 수 있도록 명확하게 설명합니다.
        </description>
    </persona>

    <context>
        <data id="text_to_analyze" language="ko-Hanja">
            <label>분석 대상 문장</label>
            <content>{{selected_text}}</content>
        </data>
        <data id="source_manuscript" language="ko-Hanja">
            <label>출전 원문</label>
            <content>{{manuscript}}</content>
        </data>
        <data id="reference_translation" language="ko">
            <label>참고용 현대어 번역</label>
            <content>{{translation}}</content>
        </data>
    </context>

    <task>
        <objective>제공된 \`<context>\`의 모든 자료를 종합적으로 활용하여, 사용자가 이해하지 못하는 `<text_to_analyze>` 문장을 심층적으로 해설하시오.</objective>
        <steps>
            <step n="1">
                <instruction>어휘 및 문법 분석 (Lexical &amp; Grammatical Analysis)</instruction>
                <details>
                    - 문장에 사용된 주요 어휘(한자 포함)의 원형과 본래 의미를 분석하십시오.
                    - 문장의 문법적 구조(예: 주어, 서술어, 목적어 관계)를 파악하고, 고전 문법의 특이점이 있다면 설명하십시오.
                </details>
            </step>
            <step n="2">
                <instruction>문맥적 의미 분석 (Contextual Analysis)</instruction>
                <details>
                    - \`<source_manuscript>\` 전체의 흐름 속에서 해당 문장이 가지는 역할과 함축적 의미를 설명하십시오.
                    - 문장의 앞뒤 내용과 어떻게 논리적으로 연결되는지 분석하십시오.
                </details>
            </step>
            <step n="3">
                <instruction>비교 분석 (Comparative Analysis)</instruction>
                <details>
                    - \`<reference_translation>\`과 원문을 비교하여, 번역이 원문의 뉘앙스를 얼마나 잘 살렸는지 평가하십시오.
                    - 번역 과정에서 의미의 손실이나 변화가 발생했다면 그 이유를 설명하십시오.
                </details>
            </step>
            <step n="4">
                <instruction>종합 해설 (Synthesized Explanation)</instruction>
                <details>
                    - 위의 1, 2, 3단계 분석 결과를 종합하여, 질문의 핵심 원인이 무엇인지 파악하고, 비전문가인 사용자가 문장의 의미를 완벽하게 이해할 수 있도록 명확하고 논리적인 최종 해설을 작성하십시오.
                </details>
            </step>
        </steps>
    </task>

    <output_constraints>
        <format>Markdown</format>
        <structure>
            - 각 분석 단계(어휘 및 문법, 문맥, 비교, 종합)를 명확한 제목(e.g., ## 1. 어휘 및 문법 분석)으로 구분하여 서술하십시오.
            - 핵심 용어나 개념은 **볼드체**로 강조하여 가독성을 높이십시오.
        </structure>
        <tone>학술적이고 객관적이면서도, 독자가 이해하기 쉬운 명료한 어조를 사용하십시오.</tone>
        <rules>
            - 모든 주장은 반드시 \`<context>\`에 제공된 자료에 근거해야 합니다.
            - 근거 없는 추측이나 주관적인 해석은 엄격히 배제하십시오.
            - 최종 결과물은 서론이나 부연 설명 없이, 요청된 분석 내용만으로 구성되어야 합니다.
        </rules>
    </output_constraints>
</prompt>
                             
                             `
                         }
                     ],
                 };
             },
             updateTags() {
                 const tagCounts = {};
                 state.projects.forEach(p => {
                     (p.tags || []).forEach(tag => {
                         tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                     });
                 });
                 state.tags = Object.entries(tagCounts).map(([name, count]) => ({
                     name,
                     count
                 })).sort((a, b) => a.name.localeCompare(b.name, 'ko'));
             },
             buildSearchIndex() {
                 fuse = new Fuse(state.projects, {
                     keys: ['name', 'tags'],
                     includeScore: true,
                     threshold: 0.3
                 });
             },
             handleSearch(query) {
                 if (query.trim() === '') {
                     state.searchResults = null;
                 } else {
                     state.searchResults = fuse.search(query).map(result => result.item);
                 }
                 state.currentView = 'project_list';
                 state.currentFilter = {
                     type: 'all',
                     id: null
                 };
                 View.render();
             },
             handleNavFilter(target) {
                 if (!target) return;
                 const type = target.dataset.filterType;
                 const id = target.dataset.id || null;
                 if (type === 'category' && state.categories.length === 0) return;
                 if (type === 'tag' && state.tags.length === 0) return;
                 state.currentFilter = {
                     type,
                     id
                 };
                 state.searchResults = null;
                 const searchInput = document.getElementById('search-input');
                 if (searchInput) searchInput.value = '';
                 state.currentView = (type === 'dashboard') ? 'dashboard' : 'project_list';
                 if (type === 'category' && !id) {
                     state.sidebarCollapseState.categories = false;
                 } else if (type === 'tag' && !id) {
                     state.sidebarCollapseState.tags = false;
                 }
                 View.render();
                 if (window.innerWidth <= 1024) this.closeSidebar();
             },
             getFilteredAndSortedProjects() {
                 let filtered = state.searchResults ? state.searchResults : state.projects;
                 if (!state.searchResults) {
                     const {
                         type,
                         id
                     } = state.currentFilter;
                     if (type === 'category' && id) filtered = filtered.filter(p => p.categoryId === id);
                     else if (type === 'tag' && id) filtered = filtered.filter(p => p.tags?.includes(id));
                 }
                 const [field, direction] = state.currentSortOrder.split('_');
                 return [...filtered].sort((a, b) => {
                     let valA = a[field] || 0;
                     let valB = b[field] || 0;
                     if (field === 'name') return direction === 'asc' ? valA.localeCompare(valB, 'ko') : valB.localeCompare(valA, 'ko');
                     valA = new Date(valA).getTime() || 0;
                     valB = new Date(valB).getTime() || 0;
                     return direction === 'asc' ? valA - valB : valB - valA;
                 });
             },
             async openProject(id) {
                 state.isLoading = true;
                 View.render();
                 try {
                     const project = await DB.get(CONFIG.STORES.PROJECTS, id);
                     if (project) {
                         project.settings = {
                             ...CONFIG.DEFAULT_PROJECT_SETTINGS,
                             ...(project.settings || {})
                         };
                         Utils.normalizeTocNode(project.toc);
                         const allNodes = Utils.getAllNodePaths(project.toc);
                         const contents = await DB.getProjectContents(id);
                         state.activeContentsMap = new Map(contents.map(c => [c.id, c]));
                         const creationPromises = allNodes.map(nodeInfo => {
                             const contentId = `${id}_${nodeInfo.path}`;
                             if (!state.activeContentsMap.has(contentId)) {
                                 const newContent = {
                                     id: contentId,
                                     manuscript: '',
                                     notes: '',
                                     translation: '',
                                     questions: [],
                                     status: 'empty'
                                 };
                                 state.activeContentsMap.set(contentId, newContent);
                                 return DB.put(CONFIG.STORES.CONTENTS, newContent);
                             }
                             return Promise.resolve();
                         });
                         await Promise.all(creationPromises);
                         state.activeProjectId = id;
                         state.activeProject = project;
                         state.currentView = 'workspace';
                         const allNodePaths = new Set(allNodes.map(n => n.path));
                         let pathToSelect = null;
                         if (project.lastChapterPath && allNodePaths.has(project.lastChapterPath)) {
                             pathToSelect = project.lastChapterPath;
                         } else if (allNodes.length > 0) {
                             pathToSelect = allNodes[0].path;
                         }
                         if (pathToSelect) await this.selectChapter(pathToSelect, false);
                         else {
                             state.activeChapterPath = null;
                             state.activeChapterContent = null;
                         }
                     }
                 } catch (error) {
                     console.error("Failed to open project:", error);
                 } finally {
                     state.isLoading = false;
                     View.render();
                 }
             },
             async selectChapter(path, shouldRender = true) {
                 this.saveScrollPosition();
                 if (state.activeChapterPath === path && shouldRender) return;
                 state.activeChapterPath = path;
                 if (state.activeProject && state.activeProject.lastChapterPath !== path) {
                     state.activeProject.lastChapterPath = path;
                     state.activeProject.updatedAt = new Date().toISOString();
                     await DB.put(CONFIG.STORES.PROJECTS, state.activeProject);
                 }
                 state.quizState = null;
                 state.viewPanelDisplayMode = 'auto';
                 state.activeChapterContent = state.activeContentsMap.get(`${state.activeProjectId}_${path}`);
                 if (shouldRender) View.render();
                 if (state.isMobileSidebarOpen) this.closeSidebar();
             },
             async handleContentChange(event) {
                 const {
                     field,
                     settingKey
                 } = event.target.dataset;
                 const value = event.target.value;

                 if (state.activeChapterContent && field) {
                     state.saveStatus = 'saving';
                     View.render();
                     const content = state.activeChapterContent;
                     content[field] = value;
                     if (field === 'manuscript' && value.trim() && (content.status === 'empty' || content.status === 'prompt-copied')) {
                         content.status = 'manuscript-done';
                     }
                     await DB.put(CONFIG.STORES.CONTENTS, content);
                     state.saveStatus = 'saved';
                     state.saveTimestamp = new Date();
                     View.render();
                     setTimeout(() => {
                         state.saveStatus = 'idle';
                         View.render();
                     }, 2000);
                 } else if (ModalManager.isOpen && ModalManager.type === 'settings' && settingKey) {
                     ModalManager.data[settingKey] = value;
                 }
             },
             showToast(message, type = 'info', duration = 3000) {
                 const id = Utils.generateId('toast');
                 state.toasts.push({
                     id,
                     message,
                     type
                 });
                 View.render();
                 setTimeout(() => Controller.dismissToast(id), duration);
             },
             dismissToast(id) {
                 const toastEl = document.getElementById(`toast-${id}`);
                 if (toastEl) {
                     toastEl.style.transition = 'opacity 0.5s ease';
                     toastEl.style.opacity = 0;
                     setTimeout(() => {
                         state.toasts = state.toasts.filter(t => t.id !== id);
                         View.render();
                     }, 500);
                 } else {
                     state.toasts = state.toasts.filter(t => t.id !== id);
                 }
             },
             applyPostRenderEffects() {
                 if (state.currentView === 'workspace' && state.workspaceMode === 'view' && state.isKaTeXLoaded && window.renderMathInElement) {
                     const viewPanel = document.querySelector('.prose.prose-readable');
                     if (viewPanel) {
                         try {
                             renderMathInElement(viewPanel, {
                                 delimiters: [{
                                     left: '$',
                                     right: '$',
                                     display: true
                                 }, {
                                     left: '\\(',
                                     right: '\\)',
                                     display: false
                                 }, {
                                     left: '\\[',
                                     right: '\\]',
                                     display: true
                                 }]
                             });
                         } catch (e) {
                             console.error("KaTeX rendering failed:", e);
                         }
                     }
                 }
                 if (state.activeChapterPath) {
                     const keyPrefix = `${state.activeProjectId}_${state.activeChapterPath}`;
                     const elementsToRestore = ['manuscript', 'notes', 'translation'];
                     elementsToRestore.forEach(id => {
                         const el = document.getElementById(id);
                         const savedPosition = state.scrollPositions[`${keyPrefix}_${id}`];
                         if (el && savedPosition !== undefined) {
                             el.scrollTop = savedPosition;
                         }
                     });
                 }
             },
             async submitNewProject(form) {
                 const activeTab = ModalManager.data.activeTab || 'blank';
                 try {
                     let projectData, contentsData;
                     if (['jsonText', 'tocJson'].includes(activeTab)) {
                         const textarea = form.querySelector('textarea');
                         try {
                             JSON.parse(textarea.value);
                             ModalManager.data.error = '';
                         } catch (e) {
                             ModalManager.data.error = `JSON 형식이 올바르지 않습니다: ${e.message}`;
                             ModalManager.render();
                             return;
                         }
                     }
                     ModalManager.data.isLoading = true;
                     ModalManager.data.loadingMessage = '프로젝트 생성 중...';
                     ModalManager.render();
                     if (activeTab === 'blank') {
                         const projectName = form.querySelector('#blank-project-name').value.trim();
                         const categoryId = form.querySelector('#blank-project-category').value;
                         if (!projectName) throw new Error("프로젝트 이름을 입력해주세요.");
                         ({
                             project: projectData,
                             contents: contentsData
                         } = this.processBlankProject(projectName, categoryId));
                     } else if (activeTab === 'zip') {
                         ModalManager.data.loadingMessage = 'ZIP 파일 분석 중...';
                         ModalManager.render();
                         const fileInput = form.querySelector('#zip-upload');
                         if (!fileInput.files[0]) throw new Error("ZIP 파일을 선택해주세요.");
                         ({
                             project: projectData,
                             contents: contentsData
                         } = await this.processZipFile(fileInput.files[0]));
                     } else if (activeTab === 'jsonFile') {
                         const fileInput = form.querySelector('#json-upload');
                         if (!fileInput.files[0]) throw new Error("JSON 파일을 선택해주세요.");
                         if (fileInput.files[0].type.includes('zip') || fileInput.files[0].name.toLowerCase().endsWith('.zip')) {
                             throw new Error("ZIP 파일은 'ZIP' 탭에서 업로드해야 합니다.");
                         }
                         ({
                             project: projectData,
                             contents: contentsData
                         } = this.processJsonData(JSON.parse(await fileInput.files[0].text())));
                     } else if (activeTab === 'jsonText') {
                         const jsonTextInput = form.querySelector('#json-text-input');
                         ({
                             project: projectData,
                             contents: contentsData
                         } = this.processJsonData(JSON.parse(jsonTextInput.value)));
                     } else if (activeTab === 'tocJson') {
                         const tocJsonInput = form.querySelector('#toc-json-input');
                         ({
                             project: projectData,
                             contents: contentsData
                         } = this.processTocJson(JSON.parse(tocJsonInput.value)));
                     } else {
                         throw new Error("알 수 없는 생성 방식입니다.");
                     }

                     ModalManager.data.loadingMessage = '데이터베이스에 저장 중...';
                     ModalManager.render();
                     await DB.put(CONFIG.STORES.PROJECTS, projectData);
                     if (contentsData && contentsData.length > 0) {
                         await Promise.all(contentsData.map(c => DB.put(CONFIG.STORES.CONTENTS, c)));
                     }

                     state.projects.unshift(projectData);
                     this.updateTags();
                     this.buildSearchIndex();
                     this.showToast(`'${projectData.name}' 프로젝트가 생성되었습니다.`, 'success');
                     ModalManager.close();
                 } catch (error) {
                     console.error("Project creation failed:", error);
                     this.showToast(`프로젝트 생성 실패: ${error.message}`, 'error');
                     ModalManager.data.isLoading = false;
                 } finally {
                     state.isLoading = false;
                     View.render();
                 }
             },
             processBlankProject(name, categoryId) {
                 const projectId = Utils.generateId('proj');
                 const project = {
                     id: projectId,
                     name,
                     categoryId: categoryId || null,
                     createdAt: new Date().toISOString(),
                     updatedAt: new Date().toISOString(),
                     toc: {
                         title: name,
                         children: []
                     },
                     settings: {
                         ...CONFIG.DEFAULT_PROJECT_SETTINGS,
                         customPrompts: []
                     }
                 };
                 return {
                     project,
                     contents: []
                 };
             },
             handleFileSelection(input) {
                 const label = document.getElementById(input.dataset.targetLabel);
                 if (label) {
                     const fileName = input.files[0] ? input.files[0].name : '선택된 파일 없음';
                     label.textContent = fileName;
                     label.title = fileName;
                 }
             },
             async processZipFile(file) {
                 const turndownService = new TurndownService();
                 const zip = await JSZip.loadAsync(file);
                 const allEntries = [];

                 zip.forEach((relPath, entry) => {
                     const normPath = relPath.replace(/\/$/, '').replace(/\\/g, '/');
                     if (normPath && !normPath.startsWith('__MACOSX')) {
                         allEntries.push({
                             path: normPath,
                             isDir: entry.dir,
                             entry
                         });
                     }
                 });

                 allEntries.sort((a, b) => Utils.naturalSort(a.path, b.path));
                 const projectToc = {
                     title: Utils.formatTitle(file.name),
                     children: []
                 };
                 const pathMap = new Map();

                 for (const {
                         path
                     }
                     of allEntries) {
                     let currentNode = projectToc;
                     let currentPath = '';
                     path.split('/').forEach((part) => {
                         currentPath = currentPath ? `${currentPath}/${part}` : part;
                         let childNode = pathMap.get(currentPath);
                         if (!childNode) {
                             childNode = {
                                 title: Utils.formatTitle(part),
                                 originalPath: path
                             };
                             currentNode.children.push(childNode);
                             pathMap.set(currentPath, childNode);
                         }
                         currentNode = childNode;
                     });
                 }

                 Utils.normalizeTocNode(projectToc);
                 const projectId = Utils.generateId('proj');
                 const project = {
                     id: projectId,
                     name: projectToc.title,
                     createdAt: new Date().toISOString(),
                     updatedAt: new Date().toISOString(),
                     toc: projectToc,
                     settings: {
                         ...CONFIG.DEFAULT_PROJECT_SETTINGS
                     }
                 };

                 const contents = (await Promise.all(Utils.getAllNodePaths(projectToc).map(async ({
                     path,
                     node
                 }) => {
                     const fileEntry = allEntries.find(f => f.path === node.originalPath)?.entry;
                     let manuscript = '';
                     if (fileEntry && !fileEntry.dir) {
                         if (/\.html?$/i.test(fileEntry.name)) {
                             const rawHtml = await fileEntry.async('string');
                             const bodyMatch = rawHtml.match(/<body[^>]*>([\s\S]*)<\/body>/i);
                             manuscript = turndownService.turndown(DOMPurify.sanitize(bodyMatch ? bodyMatch[1] : ''));
                         } else {
                             manuscript = await fileEntry.async('string');
                         }
                     }
                     return {
                         id: `${projectId}_${path}`,
                         manuscript,
                         notes: '',
                         translation: '',
                         questions: [],
                         status: manuscript.trim() ? 'manuscript-done' : 'empty'
                     };
                 }))).filter(Boolean);

                 return {
                     project,
                     contents
                 };
             },
             processJsonData(data) {
                 if (data.type !== CONFIG.EXPORT_TYPE_ID) throw new Error("유효하지 않은 프로젝트 파일 형식입니다.");
                 const newId = Utils.generateId('proj');
                 const newProject = {
                     ...data.project,
                     id: newId,
                     createdAt: new Date().toISOString(),
                     updatedAt: new Date().toISOString()
                 };

                 // [BUGFIX] Ensure settings object exists on imported project.
                 newProject.settings = {
                     ...CONFIG.DEFAULT_PROJECT_SETTINGS,
                     ...(newProject.settings || {})
                 };

                 Utils.normalizeTocNode(newProject.toc);
                 const allNodes = Utils.getAllNodePaths(newProject.toc);
                 const contentMap = new Map(data.contents.map(c => [c.path, c]));
                 const newContents = allNodes.map(nodeInfo => {
                     const originalContent = contentMap.get(nodeInfo.path) || {};
                     const {
                         path,
                         ...rest
                     } = originalContent;
                     return {
                         id: `${newId}_${nodeInfo.path}`,
                         manuscript: '',
                         notes: '',
                         translation: '',
                         questions: [],
                         status: 'empty',
                         ...rest
                     };
                 });
                 return {
                     project: newProject,
                     contents: newContents
                 };
             },
             processTocJson(tocData) {
                 if (!tocData.title || !Array.isArray(tocData.children)) {
                     throw new Error("유효하지 않은 목차 JSON 형식입니다. 최상위 객체에 'title'과 'children' 속성이 필요합니다.");
                 }
                 const projectId = Utils.generateId('proj');
                 const finalToc = {
                     title: tocData.title,
                     children: tocData.children
                 };
                 Utils.normalizeTocNode(finalToc);
                 const project = {
                     id: projectId,
                     name: finalToc.title,
                     createdAt: new Date().toISOString(),
                     updatedAt: new Date().toISOString(),
                     toc: finalToc,
                     settings: {
                         ...CONFIG.DEFAULT_PROJECT_SETTINGS
                     }
                 };
                 const contents = Utils.getAllNodePaths(finalToc).map(({
                     path,
                     node
                 }) => ({
                     id: `${projectId}_${path}`,
                     manuscript: '',
                     notes: node.description || '',
                     translation: '',
                     questions: [],
                     status: 'empty'
                 }));
                 return {
                     project,
                     contents
                 };
             },
             copyToClipboard(text) {
                 const textArea = document.createElement("textarea");
                 textArea.value = text;
                 textArea.style.position = "fixed";
                 textArea.style.top = "-9999px";
                 document.body.appendChild(textArea);
                 textArea.focus();
                 textArea.select();
                 try {
                     const successful = document.execCommand('copy');
                     if (successful) {
                         this.showToast('클립보드에 복사되었습니다.', 'success');
                     } else {
                         throw new Error('Copy command failed');
                     }
                 } catch (err) {
                     console.error("Clipboard copy failed:", err);
                     this.showToast('클립보드 복사에 실패했습니다.', 'error');
                 }
                 document.body.removeChild(textArea);
             },
             copyPromptForCurrentChapter() {
                 if (!state.activeProject || !state.activeChapterPath) return;
                 const {
                     settings,
                     toc
                 } = state.activeProject;
                 const chapterNode = Utils.getNodeByPath(toc, state.activeChapterPath);
                 if (!chapterNode) return;
                 const pathParts = state.activeChapterPath.split('.').map(Number);
                 const partNode = toc.children?.[pathParts[0]];
                 const fullTocText = Utils.generateTocText(toc, 0, '', state.activeChapterPath);
                 const partTocText = partNode ? Utils.generateTocText(partNode, 0, '', pathParts.slice(1).join('.')) : '';
                 const chapterDescription = state.activeChapterContent.notes || chapterNode.description || '';
                 let prompt = settings.writingPrompt || CONFIG.DEFAULT_PROJECT_SETTINGS.writingPrompt;
                 prompt = prompt.replace(/{{bookTitle}}/g, toc.title).replace(/{{projectGenre}}/g, settings.writingGenre).replace(/{{projectAgeGroup}}/g, settings.writingAgeGroup).replace(/{{projectAudience}}/g, settings.writingAudience).replace(/{{references}}/g, settings.writingReferences).replace(/{{partTitle}}/g, partNode?.title).replace(/{{partDescription}}/g, partNode?.description || '').replace(/{{chapterTitle}}/g, chapterNode.title).replace(/{{chapterDescription}}/g, chapterDescription).replace(/{{fullToc}}/g, fullTocText).replace(/{{partToc}}/g, partTocText).replace(/{{projectStyleExample}}/g, settings.writingStyle);
                 this.copyToClipboard(prompt);
             },
             copyTranslationPrompt() {
                 if (!state.activeChapterContent?.manuscript) return this.showToast('번역할 내용이 없습니다.', 'error');
                 let prompt = state.activeProject.settings.translationPrompt || CONFIG.DEFAULT_PROJECT_SETTINGS.translationPrompt;
                 prompt = prompt.replace('{{text}}', state.activeChapterContent.manuscript);
                 this.copyToClipboard(prompt);
             },
             buildQuizPrompt() {
                 const turndownService = new TurndownService();
                 if (!state.activeChapterContent?.manuscript) return null;
                 const sourceHtml = marked.parse(state.activeChapterContent.manuscript);
                 const sourceText = turndownService.turndown(sourceHtml);
                 if (!sourceText.trim()) return null;
                 const settings = state.activeProject.settings;
                 const template = settings.quizPromptTemplate || CONFIG.DEFAULT_PROJECT_SETTINGS.quizPromptTemplate;
                 return template.replace('{{taskDescription}}', settings.quizTaskDescription).replace('{{outputFormatInstruction}}', settings.quizOutputFormatInstruction).replace('{{questionCount}}', settings.quizQuestionCount).replace('{{text}}', sourceText.substring(0, 15000));
             },
             async generateQuiz() {
                 let apiKey = localStorage.getItem('googleApiKey');
                 if (!apiKey) {
                    ModalManager.open('apiKey');
                    return;
                }
                 const prompt = this.buildQuizPrompt();
                 if (!prompt) {
                     this.showToast('퀴즈를 생성할 학습 내용이 없습니다.', 'error');
                     return;
                 }
                 this.showToast('AI가 문제를 생성하고 있습니다...', 'info');
                 const spinnerEl = document.querySelector('[data-action="generate-quiz"]');
                 if (spinnerEl) spinnerEl.innerHTML = `<div class="w-5 h-5 border-2 border-slate-500 border-t-transparent rounded-full animate-spin"></div>`;
                 
                 try {
                     const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {
                         method: 'POST',
                         headers: {
                             'Content-Type': 'application/json'
                         },
                         body: JSON.stringify({
                             contents: [{
                                 parts: [{
                                     text: prompt
                                 }]
                             }]
                         })
                     });
                     if (!response.ok) throw new Error(`API 요청 실패: ${response.statusText}`);
                     const result = await response.json();
                     const responseText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                     if (!responseText) throw new Error("AI로부터 빈 응답을 받았습니다.");
                     
                     const jsonMatch = responseText.match(/<json_response>([\s\S]*?)<\/json_response>/);
                     const jsonText = jsonMatch ? jsonMatch[1].trim() : responseText.match(/\[[\s\S]*\]/)?.[0] || responseText.trim();
                     
                     const questions = JSON.parse(jsonText);
                     const content = state.activeChapterContent;
                     content.questions = [...(content.questions || []), ...questions];
                     content.status = 'quiz-done';
                     await DB.put(CONFIG.STORES.CONTENTS, content);
                     this.showToast(`${questions.length}개의 문제가 추가되었습니다.`, 'success');
                     View.render();
                 } catch (error) {
                     console.error("Quiz generation failed:", error);
                     this.showToast(`문제 생성 실패: ${error.message}`, 'error');
                 } finally {
                     if (spinnerEl) spinnerEl.innerHTML = `${Heroicons.render('sparkles', { class: 'w-5 h-5 mr-2' })}AI로 문제 추가`;
                 }
             },
             startQuiz() {
                 const questions = state.activeChapterContent.questions;
                 if (!questions?.length) return;
                 const processed = JSON.parse(JSON.stringify(questions)).map(q => {
                     if (q.type === CONFIG.QUIZ_TYPE.MULTIPLE_CHOICE) q.answerIndex = q.options.findIndex(opt => opt === q.answer);
                     return q;
                 });
                 state.quizState = {
                     questions: [...processed].sort(() => Math.random() - 0.5),
                     currentIndex: 0,
                     answers: []
                 };
                 state.currentView = 'quiz';
                 View.render();
             },
             async finishQuiz() {
                 const correctAnswers = state.quizState.answers.filter(a => a.isCorrect).length;
                 const xpGained = correctAnswers * 100;
                 if (xpGained > 0) {
                     const newXp = state.userProfile.xp + xpGained;
                     let newLevel = state.userProfile.level;
                     while (CONFIG.LEVEL_THRESHOLDS[newLevel] !== undefined && newXp >= CONFIG.LEVEL_THRESHOLDS[newLevel]) {
                         newLevel++;
                     }
                     if (newLevel > state.userProfile.level) {
                         this.showToast(`레벨 업! LV.${newLevel} 달성!`, 'success');
                     }
                     state.userProfile.xp = newXp;
                     state.userProfile.level = newLevel;
                     await DB.put(CONFIG.STORES.USER_PROFILE, state.userProfile);
                 }
                 state.currentView = 'quizResult';
                 this.showToast(`퀴즈 완료! +${xpGained} XP`, 'success');
                 View.render();
             },
             handleTocTitleEdit(input) {
                 const node = Utils.getNodeByPath(ModalManager.data.editableToc, input.dataset.path);
                 if (node) node.title = input.value;
             },
             async saveToc() {
                 const originalToc = state.activeProject.toc;
                 const modifiedToc = ModalManager.data.editableToc;
                 state.isLoading = true;
                 ModalManager.close();
                 View.render();
                 try {
                     const projectId = state.activeProjectId;
                     const oldPaths = new Set(Utils.getAllNodePaths(originalToc).map(c => c.path));
                     const newPaths = new Set(Utils.getAllNodePaths(modifiedToc).map(c => c.path));
                     const addedNodes = Utils.getAllNodePaths(modifiedToc).filter(c => !oldPaths.has(c.path));
                     const deletedNodes = Utils.getAllNodePaths(originalToc).filter(c => !newPaths.has(c.path));
                     const promises = [];
                     for (const node of deletedNodes) {
                         const contentId = `${projectId}_${node.path}`;
                         promises.push(DB.delete(CONFIG.STORES.CONTENTS, contentId));
                         state.activeContentsMap.delete(contentId);
                     }
                     for (const node of addedNodes) {
                         const contentId = `${projectId}_${node.path}`;
                         const newContent = {
                             id: contentId,
                             manuscript: '',
                             notes: '',
                             translation: '',
                             questions: [],
                             status: 'empty'
                         };
                         promises.push(DB.put(CONFIG.STORES.CONTENTS, newContent));
                         state.activeContentsMap.set(contentId, newContent);
                     }
                     if (state.activeChapterPath && !newPaths.has(state.activeChapterPath)) {
                         state.activeChapterPath = null;
                         state.activeChapterContent = null;
                     }
                     state.activeProject.toc = modifiedToc;
                     state.activeProject.updatedAt = new Date().toISOString();
                     promises.push(DB.put(CONFIG.STORES.PROJECTS, state.activeProject));
                     await Promise.all(promises);
                     this.showToast('목차가 업데이트되었습니다.', 'success');
                 } catch (error) {
                     console.error("Failed to save TOC:", error);
                     this.showToast(`목차 저장 실패: ${error.message}`, 'error');
                 } finally {
                     state.isLoading = false;
                     View.render();
                 }
             },
             buildSplitChapterPrompt(sourceType) { // 'manuscript' 또는 'translation'
                 const sourceText = state.activeChapterContent[sourceType];
                 const sourceLabel = sourceType === 'manuscript' ? '원문' : '번역문';

                 if (!sourceText?.trim()) {
                     this.showToast(`분할할 ${sourceLabel}이 없습니다.`, 'error');
                     return null;
                 }
                 const paragraphs = sourceText.split(/\n{2,}/).map(p => p.trim()).filter(Boolean);
                 if (paragraphs.length < 2) {
                     this.showToast(`${sourceLabel}의 내용이 분할하기에 충분하지 않습니다.`, 'error');
                     return null;
                 }

                 const totalParagraphs = paragraphs.length;
                 const totalCharacters = sourceText.replace(/\s/g, '').length;
                 const avgCharactersPerParagraph = Math.round(totalCharacters / totalParagraphs);

                 const numberedContent = paragraphs.map((p, i) => `[Paragraph ${i + 1}] ${p}`).join('\n\n');

                 const prompt = `<Prime_Directive>Analyze the provided text, which is broken into numbered paragraphs, and identify logical division points to create sub-chapters.
                <Statistics>
                    <total_paragraphs>${totalParagraphs}</total_paragraphs>
                    <total_characters>${totalCharacters}</total_characters>
                    <avg_characters_per_paragraph>${avgCharactersPerParagraph}</avg_characters_per_paragraph>
                </Statistics>
                </Prime_Directive><purpose>
                    **1. First, count the total number of paragraphs in the provided text and state it clearly.**
                    **2. Analyze the ENTIRE provided text from beginning to end to understand its structure and flow.**
                    **3. Divide the content into an appropriate number of sub-chapters. Each sub-chapter's content should be approximately 20KB in size (around 6800 Korean characters). The number of chapters should be determined by this size constraint, not a fixed number.**
                    4. Each sub-chapter should represent a distinct sub-topic or section of the main text.
                    5. The sub-chapters MUST collectively cover the entire document's content. The start points of the sub-chapters should be distributed throughout the text.
                    6. Your output MUST be a valid JSON array of objects following the specified schema. Do not add any explanation or commentary outside the JSON markup.
                </purpose><Output_Specification><Format>JSON Array</Format><Schema>[ { "sub_chapter_title": "A descriptive title for the first sub-topic.", "start_paragraph": 1 }, { "sub_chapter_title": "Title for the second sub-topic.", "start_paragraph": ... } ]</Schema><interaction_language>Korean</interaction_language></Output_Specification><data content="formatted_content">--- START OF DATA ---${numberedContent}--- END OF DATA ---</data>`;

                 return prompt.trim();
             },
             async handleSplitChapterSubmit(form) {
                 const jsonContent = new FormData(form).get('jsonContent');
                 if (!jsonContent) return;

                 const sourceType = ModalManager.data.sourceToSplit || 'manuscript';
                 const sourceLabel = sourceType === 'manuscript' ? '원문' : '번역문';

                 state.isLoading = true;
                 ModalManager.close();
                 View.render();
                 try {
                     const subChaptersData = JSON.parse(jsonContent.trim().match(/\[[\s\S]*\]/)?.[0] || '[]');
                     if (!Array.isArray(subChaptersData) || !subChaptersData.every(i => i.sub_chapter_title && i.start_paragraph)) throw new Error('Invalid JSON format.');

                     const sourceText = state.activeChapterContent[sourceType];
                     const paragraphs = sourceText.split(/\n{2,}/).map(p => p.trim()).filter(Boolean);

                     const projectId = state.activeProjectId;
                     const parentPath = state.activeChapterPath;
                     const parentNode = Utils.getNodeByPath(state.activeProject.toc, parentPath);
                     const initialChildCount = parentNode.children.length;
                     const creationPromises = [];
                     subChaptersData.sort((a, b) => a.start_paragraph - b.start_paragraph);

                     for (let i = 0; i < subChaptersData.length; i++) {
                         const start = subChaptersData[i].start_paragraph - 1;
                         const end = (i < subChaptersData.length - 1) ? subChaptersData[i + 1].start_paragraph - 1 : paragraphs.length;
                         const content = paragraphs.slice(start, end).join('\n\n');
                         const newChildNode = {
                             title: subChaptersData[i].sub_chapter_title,
                             children: []
                         };
                         parentNode.children.push(newChildNode);
                         const newChildPath = `${parentPath}.${initialChildCount + i}`;

                         const newContent = {
                             id: `${projectId}_${newChildPath}`,
                             manuscript: '',
                             notes: `Original content from '${parentNode.title}'.`,
                             translation: '',
                             questions: [],
                             status: 'manuscript-done'
                         };
                         newContent[sourceType] = content;

                         state.activeContentsMap.set(newContent.id, newContent);
                         creationPromises.push(DB.put(CONFIG.STORES.CONTENTS, newContent));
                     }

                     state.activeChapterContent[sourceType] = `[${sourceLabel}이(가) ${subChaptersData.length}개의 하위 노트로 분할되었습니다.]`;
                     creationPromises.push(DB.put(CONFIG.STORES.CONTENTS, state.activeChapterContent));

                     state.activeProject.updatedAt = new Date().toISOString();
                     creationPromises.push(DB.put(CONFIG.STORES.PROJECTS, state.activeProject));

                     await Promise.all(creationPromises);
                     this.showToast(`${sourceLabel} 분할 및 하위 챕터 생성이 완료되었습니다.`, 'success');
                 } catch (error) {
                     console.error("Chapter split failed:", error);
                     this.showToast(`챕터 분할 실패: ${error.message}`, 'error');
                 } finally {
                     state.isLoading = false;
                     View.render();
                 }
             },
             navigateChapter(direction) {
                 if (!state.activeProject || !state.activeChapterPath) return;
                 const allNodes = Utils.getFlatToc(state.activeProject.toc);
                 const currentIndex = allNodes.findIndex(node => node.path === state.activeChapterPath);
                 if (currentIndex === -1) return;
                 const nextIndex = currentIndex + direction;
                 if (nextIndex >= 0 && nextIndex < allNodes.length) {
                     const nextChapterPath = allNodes[nextIndex].path;
                     this.selectChapter(nextChapterPath);
                 }
             },
             toggleSidebar() {
                 if (window.innerWidth <= 1024) {
                     state.isMobileSidebarOpen = !state.isMobileSidebarOpen;
                 } else {
                     state.isSidebarOpen = !state.isSidebarOpen;
                 }
                 View.render();
             },
             closeSidebar() {
                 if (state.isMobileSidebarOpen) {
                     state.isMobileSidebarOpen = false;
                     View.render();
                 }
             },
             handleTocDragStart(e) {
                 const item = e.target.closest('.toc-drag-item');
                 if (item) {
                     ModalManager.data.draggedPath = item.dataset.path;
                     e.dataTransfer.effectAllowed = 'move';
                     e.dataTransfer.setData('text/plain', item.dataset.path);
                 }
             },
             handleTocDragOver(e) {
                 e.preventDefault();
                 const targetItem = e.target.closest('.toc-drag-item');
                 document.querySelectorAll('.toc-drop-indicator-before, .toc-drop-indicator-after, .toc-drop-indicator-inside').forEach(el => el.classList.remove('toc-drop-indicator-before', 'toc-drop-indicator-after', 'toc-drop-indicator-inside'));
                 if (targetItem) {
                     const rect = targetItem.getBoundingClientRect();
                     const dropZoneHeight = rect.height / 3;
                     if (e.clientY < rect.top + dropZoneHeight) {
                         targetItem.classList.add('toc-drop-indicator-before');
                         ModalManager.data.dropTarget = {
                             path: targetItem.dataset.path,
                             position: 'before'
                         };
                     } else if (e.clientY > rect.bottom - dropZoneHeight) {
                         targetItem.classList.add('toc-drop-indicator-after');
                         ModalManager.data.dropTarget = {
                             path: targetItem.dataset.path,
                             position: 'after'
                         };
                     } else {
                         targetItem.classList.add('toc-drop-indicator-inside');
                         ModalManager.data.dropTarget = {
                             path: targetItem.dataset.path,
                             position: 'inside'
                         };
                     }
                 }
             },
             handleTocDragLeave(e) {
                 document.querySelectorAll('.toc-drop-indicator-before, .toc-drop-indicator-after, .toc-drop-indicator-inside').forEach(el => el.classList.remove('toc-drop-indicator-before', 'toc-drop-indicator-after', 'toc-drop-indicator-inside'));
             },
             handleTocDrop(e) {
                 e.preventDefault();
                 document.querySelectorAll('.toc-drop-indicator-before, .toc-drop-indicator-after, .toc-drop-indicator-inside').forEach(el => el.classList.remove('toc-drop-indicator-before', 'toc-drop-indicator-after', 'toc-drop-indicator-inside'));
                 const draggedPath = ModalManager.data.draggedPath;
                 const dropTarget = ModalManager.data.dropTarget;
                 if (!draggedPath || !dropTarget || dropTarget.path === draggedPath || dropTarget.path.startsWith(draggedPath + '.')) return;
                 const toc = ModalManager.data.editableToc;
                 const {
                     parent: draggedParent,
                     index: draggedIndex
                 } = Utils.getParentNodeAndIndexByPath(toc, draggedPath);
                 if (!draggedParent) return;
                 const [draggedNode] = draggedParent.children.splice(draggedIndex, 1);
                 if (dropTarget.position === 'inside') {
                     const newParentNode = Utils.getNodeByPath(toc, dropTarget.path);
                     if (newParentNode) {
                         if (!newParentNode.children) newParentNode.children = [];
                         newParentNode.children.push(draggedNode);
                     }
                 } else {
                     const {
                         parent: targetParent,
                         index: targetIndex
                     } = Utils.getParentNodeAndIndexByPath(toc, dropTarget.path);
                     if (!targetParent) return;
                     const insertIndex = dropTarget.position === 'before' ? targetIndex : targetIndex + 1;
                     targetParent.children.splice(insertIndex, 0, draggedNode);
                 }
                 ModalManager.data.draggedPath = null;
                 ModalManager.data.dropTarget = null;
                 ModalManager.render();
             },
             handleTagInput(input) {
                 const value = input.value.toLowerCase();
                 const suggestionsContainer = document.getElementById('tag-suggestions');
                 if (!value) {
                     suggestionsContainer.classList.add('hidden');
                     return;
                 }
                 const existingTags = ModalManager.data.projectTags || [];
                 const availableTags = state.tags.map(t => t.name).filter(t => !existingTags.includes(t));
                 const filtered = availableTags.filter(tag => tag.toLowerCase().includes(value));
                 if (filtered.length > 0) {
                     suggestionsContainer.innerHTML = filtered.map(tag => `<div class="p-2 hover:bg-slate-100 cursor-pointer" data-action="select-tag-suggestion" data-tag="${tag}">${tag}</div>`).join('');
                     suggestionsContainer.classList.remove('hidden');
                 } else {
                     suggestionsContainer.classList.add('hidden');
                 }
             },
             handleTagInputKeydown(e) {
                 if (e.key === 'Enter') {
                     e.preventDefault();
                     const tag = e.target.value.trim();
                     if (tag) {
                         Controller.addTagToProject(tag);
                         e.target.value = '';
                         document.getElementById('tag-suggestions').classList.add('hidden');
                     }
                 }
             },
             addTagToProject(tag) {
                 if (!ModalManager.data.projectTags) {
                     ModalManager.data.projectTags = [];
                 }
                 if (!ModalManager.data.projectTags.includes(tag)) {
                     ModalManager.data.projectTags.push(tag);
                     ModalManager.render();
                 }
             },
             saveScrollPosition() {
                 if (!state.activeChapterPath) return;
                 const keyPrefix = `${state.activeProjectId}_${state.activeChapterPath}`;
                 const elementsToSave = ['manuscript', 'notes', 'translation'];
                 elementsToSave.forEach(id => {
                     const el = document.getElementById(id);
                     if (el) {
                         state.scrollPositions[`${keyPrefix}_${id}`] = el.scrollTop;
                     }
                 });
             },
             ACTION_HANDLERS: {
                 'toggle-sidebar': () => Controller.toggleSidebar(),
                 'close-sidebar': () => Controller.closeSidebar(),
                 'go-dashboard': () => {
                     state.currentView = 'dashboard';
                     state.currentFilter = {
                         type: 'dashboard',
                         id: null
                     };
                     state.activeProjectId = null;
                     state.activeProject = null;
                     View.render();
                 },
                 'prev-chapter': () => Controller.navigateChapter(-1),
                 'next-chapter': () => Controller.navigateChapter(1),
                 'filter': (el) => Controller.handleNavFilter(el),
                 'new-category': async () => {
                     const name = prompt('새 카테고리 이름을 입력하세요:');
                     if (name?.trim()) {
                         const newCategory = {
                             id: Utils.generateId('cat'),
                             name: name.trim()
                         };
                         await DB.put(CONFIG.STORES.CATEGORIES, newCategory);
                         state.categories.push(newCategory);
                         state.categories.sort((a, b) => a.name.localeCompare(b.name));
                         View.render();
                     }
                 },
                 'sort-projects': (select) => {
                     state.currentSortOrder = select.value;
                     View.render();
                 },
                 'new-project': () => ModalManager.open('newProject', {
                     activeTab: 'blank'
                 }),
                 'open-project': (el) => Controller.openProject(el.dataset.id),
                 'export-project': (el) => {
                     Controller.exportProject(el.dataset.id)
                 },
                 'delete-project-confirm': (el) => {
                     const project = state.projects.find(p => p.id === el.dataset.id);
                     if (!project) return;
                     ModalManager.open('confirm', {
                         title: '프로젝트 삭제 확인',
                         message: `'${project.name}' 프로젝트와 모든 관련 데이터를 영구적으로 삭제하시겠습니까?`,
                         confirmText: '삭제',
                         onConfirm: async () => {
                             await DB.deleteProjectAndContents(project.id);
                             state.projects = state.projects.filter(p => p.id !== project.id);
                             Controller.updateTags();
                             Controller.buildSearchIndex();
                             Controller.showToast('프로젝트가 삭제되었습니다.', 'success');
                             if (state.currentView !== 'dashboard' && state.currentFilter.type !== 'all') {
                                 Controller.ACTION_HANDLERS['go-dashboard']();
                             } else {
                                 View.render();
                             }
                         }
                     });
                 },
                 'close-modal': () => ModalManager.close(),
                 'close-modal-overlay': (el, e) => {
                     if (e.target === el) ModalManager.close();
                 },
                 'confirm-action': () => {
                     const onConfirm = ModalManager.data.onConfirm;
                     if (typeof onConfirm === 'function') onConfirm();
                     ModalManager.close();
                 },
                 'switch-mode': (el) => {
                     Controller.saveScrollPosition();
                     state.workspaceMode = el.dataset.mode;
                     View.render();
                 },
                 'select-chapter': (el) => Controller.selectChapter(el.dataset.path),
                 'toggle-toc-collapse': (el) => {
                     const path = el.dataset.path;
                     state.tocCollapseState[path] = !state.tocCollapseState[path];
                     View.render();
                 },
                 'submit-new-project': (form) => Controller.submitNewProject(form),
                 'switch-modal-tab': (el) => {
                     ModalManager.data.activeTab = el.dataset.tab;
                     ModalManager.render();
                 },
                 'open-settings': () => {
                     if (!state.activeProject) {
                         Controller.showToast('활성화된 프로젝트가 없어 설정을 열 수 없습니다.', 'error');
                         return;
                     }
                     const s = JSON.parse(JSON.stringify(state.activeProject.settings || {}));
                     ModalManager.open('settings', {
                         activeTab: 'general',
                         name: state.activeProject.name,
                         categoryId: state.activeProject.categoryId,
                         projectTags: [...(state.activeProject.tags || [])],
                         ...CONFIG.DEFAULT_PROJECT_SETTINGS,
                         ...s,
                         customPrompts: s.customPrompts || CONFIG.DEFAULT_PROJECT_SETTINGS.customPrompts,
                         contextMenuItems: s.contextMenuItems || CONFIG.DEFAULT_PROJECT_SETTINGS.contextMenuItems,
                     });
                 },
                 'switch-settings-tab': (el) => {
                     ModalManager.data.activeTab = el.dataset.tab;
                     ModalManager.render();
                 },
                 'save-settings': async (form) => {
                     const data = ModalManager.data;
                     const name = data.name || state.activeProject.name;
                     const categoryId = data.categoryId;
                     const projectTags = data.projectTags || [];

                     const settingsToSave = {};
                     form.querySelectorAll('[data-setting-key]').forEach(input => {
                         const key = input.dataset.settingKey;
                         settingsToSave[key] = input.type === 'number' ? Number(input.value) : input.value;
                     });

                     Object.assign(state.activeProject.settings, settingsToSave);

                     state.activeProject.name = name;
                     state.activeProject.categoryId = categoryId;
                     state.activeProject.tags = projectTags;
                     state.activeProject.settings.customPrompts = (data.customPrompts || []).filter(p => p.name && p.template);
                     state.activeProject.settings.contextMenuItems = (data.contextMenuItems || []).filter(p => p.name && p.template);

                     state.activeProject.updatedAt = new Date().toISOString();
                     await DB.put(CONFIG.STORES.PROJECTS, state.activeProject);

                     Controller.updateTags();
                     Controller.buildSearchIndex();
                     Controller.showToast('설정이 성공적으로 저장되었습니다.', 'success');

                     ModalManager.close();
                     View.render();
                 },
                 'add-custom-prompt': () => {
                     const nameInput = document.getElementById('new-prompt-name');
                     const templateInput = document.getElementById('new-prompt-template');
                     const name = nameInput.value.trim();
                     const template = templateInput.value.trim();
                     if (!name || !template) return Controller.showToast('이름과 템플릿을 모두 입력해야 합니다.', 'error');
                     if (!ModalManager.data.customPrompts) ModalManager.data.customPrompts = [];
                     ModalManager.data.customPrompts.push({
                         id: Utils.generateId('cp'),
                         name,
                         template
                     });
                     nameInput.value = '';
                     templateInput.value = '';
                     ModalManager.render();
                 },
                 'remove-custom-prompt': (el) => {
                     const idToRemove = el.dataset.id;
                     ModalManager.data.customPrompts = ModalManager.data.customPrompts.filter(p => p.id !== idToRemove);
                     ModalManager.render();
                 },
                 'add-custom-context-menu': () => {
                     const nameInput = document.getElementById('new-contextMenu-name');
                     const templateInput = document.getElementById('new-contextMenu-template');
                     const name = nameInput.value.trim();
                     const template = templateInput.value.trim();
                     if (!name || !template) return Controller.showToast('이름과 템플릿을 모두 입력해야 합니다.', 'error');
                     if (!ModalManager.data.contextMenuItems) ModalManager.data.contextMenuItems = [];
                     ModalManager.data.contextMenuItems.push({
                         id: Utils.generateId('cmi'),
                         name,
                         template
                     });
                     nameInput.value = '';
                     templateInput.value = '';
                     ModalManager.render();
                 },
                 'remove-custom-context-menu': (el) => {
                     const idToRemove = el.dataset.id;
                     ModalManager.data.contextMenuItems = ModalManager.data.contextMenuItems.filter(p => p.id !== idToRemove);
                     ModalManager.render();
                 },
                 'copy-custom-prompt': (el) => {
                     const index = parseInt(el.dataset.index, 10);
                     const customPrompts = state.activeProject.settings.customPrompts || [];
                     const promptToCopy = customPrompts[index];

                     if (!promptToCopy || !promptToCopy.template) {
                         return Controller.showToast('프롬프트 템플릿이 비어있습니다.', 'error');
                     }

                     const {
                         settings,
                         toc
                     } = state.activeProject;
                     const chapterNode = Utils.getNodeByPath(toc, state.activeChapterPath);
                     if (!chapterNode) {
                         return Controller.showToast('프롬프트를 생성하려면 먼저 챕터를 선택해야 합니다.', 'error');
                     }

                     const pathParts = state.activeChapterPath.split('.').map(Number);
                     const partNode = toc.children?.[pathParts[0]];
                     const fullTocText = Utils.generateTocText(toc, 0, '', state.activeChapterPath);
                     const partTocText = partNode ? Utils.generateTocText(partNode, 0, '', pathParts.slice(1).join('.')) : '';
                     const chapterDescription = state.activeChapterContent.notes || chapterNode.description || '';
                     const manuscript = state.activeChapterContent.manuscript || '';
                     const translation = state.activeChapterContent.translation || '';
                     const notes = state.activeChapterContent.notes || '';


                     let prompt = promptToCopy.template;
                     const replacements = {
                         '{{bookTitle}}': toc.title,
                         '{{projectGenre}}': settings.writingGenre,
                         '{{projectAgeGroup}}': settings.writingAgeGroup,
                         '{{projectAudience}}': settings.writingAudience,
                         '{{references}}': settings.writingReferences,
                         '{{partTitle}}': partNode?.title || '',
                         '{{partDescription}}': partNode?.description || '',
                         '{{chapterTitle}}': chapterNode.title,
                         '{{chapterDescription}}': chapterDescription,
                         '{{fullToc}}': fullTocText,
                         '{{partToc}}': partTocText,
                         '{{projectStyleExample}}': settings.writingStyle,
                         '{{manuscript}}': manuscript,
                         '{{translation}}': translation,
                         '{{notes}}': notes,
                     };

                     for (const [key, value] of Object.entries(replacements)) {
                         const placeholder = key.replace(/{{/g, '{{\\s*').replace(/}}/g, '\\s*}}');
                         prompt = prompt.replace(new RegExp(placeholder, 'g'), value || '');
                     }

                     Controller.copyToClipboard(prompt);
                 },
                 'execute-context-menu': (el) => {
                     const index = parseInt(el.dataset.index, 10);
                     const menuItem = state.activeProject.settings.contextMenuItems[index];

                     if (menuItem && state.contextMenu.selectedText) {
                         const {
                             settings,
                             toc
                         } = state.activeProject;
                         const chapterNode = Utils.getNodeByPath(toc, state.activeChapterPath);
                         if (!chapterNode) {
                             return Controller.showToast('변수 확장을 위해 먼저 챕터를 선택해야 합니다.', 'error');
                         }

                         const pathParts = state.activeChapterPath.split('.').map(Number);
                         const partNode = toc.children?.[pathParts[0]];
                         const fullTocText = Utils.generateTocText(toc, 0, '', state.activeChapterPath);
                         const partTocText = partNode ? Utils.generateTocText(partNode, 0, '', pathParts.slice(1).join('.')) : '';
                         const chapterDescription = state.activeChapterContent.notes || chapterNode.description || '';
                         const manuscript = state.activeChapterContent.manuscript || '';
                         const translation = state.activeChapterContent.translation || '';
                         const notes = state.activeChapterContent.notes || '';

                         let prompt = menuItem.template;
                         const replacements = {
                             '{{selected_text}}': state.contextMenu.selectedText,
                             '{{bookTitle}}': toc.title,
                             '{{projectGenre}}': settings.writingGenre,
                             '{{projectAgeGroup}}': settings.writingAgeGroup,
                             '{{projectAudience}}': settings.writingAudience,
                             '{{references}}': settings.writingReferences,
                             '{{partTitle}}': partNode?.title || '',
                             '{{partDescription}}': partNode?.description || '',
                             '{{chapterTitle}}': chapterNode.title,
                             '{{chapterDescription}}': chapterDescription,
                             '{{fullToc}}': fullTocText,
                             '{{partToc}}': partTocText,
                             '{{projectStyleExample}}': settings.writingStyle,
                             '{{manuscript}}': manuscript,
                             '{{translation}}': translation,
                             '{{notes}}': notes,
                         };

                         for (const [key, value] of Object.entries(replacements)) {
                             const placeholder = key.replace(/{{/g, '{{\\s*').replace(/}}/g, '\\s*}}');
                             prompt = prompt.replace(new RegExp(placeholder, 'g'), value || '');
                         }

                         Controller.copyToClipboard(prompt);
                         window.open('https://gemini.google.com', '_blank');
                     }

                     state.contextMenu.isOpen = false;
                     View.render();
                 },
                 'copy-writing-prompt': () => Controller.copyPromptForCurrentChapter(),
                 'copy-translation-prompt': () => Controller.copyTranslationPrompt(),
                 'manage-quiz': () => ModalManager.open('manageQuiz'),
                 'generate-quiz': () => Controller.generateQuiz(),
                 'submit-api-key': (form) => {
                     const key = form.querySelector('#api-key-input').value;
                     if (key) {
                         localStorage.setItem('googleApiKey', key);
                         ModalManager.close();
                     }
                 },
                 'copy-quiz-prompt': () => {
                     const prompt = Controller.buildQuizPrompt();
                     if (prompt) Controller.copyToClipboard(prompt);
                     else Controller.showToast('퀴즈 생성을 위한 내용이 부족합니다.', 'error');
                 },
                 'add-questions-from-json': async (form) => {
                     const jsonContent = new FormData(form).get('jsonContent');
                     try {
                         const questions = JSON.parse(jsonContent.trim().match(/\[[\s\S]*\]/)?.[0] || '[]');
                         const content = state.activeChapterContent;
                         content.questions = [...(content.questions || []), ...questions];
                         content.status = 'quiz-done';
                         await DB.put(CONFIG.STORES.CONTENTS, content);
                         state.activeContentsMap.set(content.id, content);
                         Controller.showToast(`${questions.length}개의 문제가 추가되었습니다.`, 'success');
                         ModalManager.render();
                     } catch (e) {
                         Controller.showToast(`유효하지 않은 JSON입니다: ${e.message}`, 'error');
                     }
                 },
                 'delete-quiz-question': async (el) => {
                     state.activeChapterContent.questions.splice(parseInt(el.dataset.index, 10), 1);
                     await DB.put(CONFIG.STORES.CONTENTS, state.activeChapterContent);
                     state.activeContentsMap.set(state.activeChapterContent.id, state.activeChapterContent);
                     ModalManager.render();
                 },
                 'start-quiz': () => Controller.startQuiz(),
                 'exit-quiz': () => ModalManager.open('confirm', {
                     title: '퀴즈 나가기',
                     message: '퀴즈를 중단하시겠습니까?',
                     confirmText: '나가기',
                     onConfirm: () => {
                         state.quizState = null;
                         state.currentView = 'workspace';
                         View.render();
                     }
                 }),
                 'submit-answer': (el) => {
                     const q = state.quizState.questions[state.quizState.currentIndex];
                     const selectedIndex = parseInt(el.dataset.index, 10);
                     state.quizState.answers[state.quizState.currentIndex] = {
                         selectedIndex,
                         isCorrect: selectedIndex === q.answerIndex
                     };
                     View.render();
                 },
                 'submit-text-answer': (form) => {
                     const userAnswer = new FormData(form).get('answer-input') || '';
                     const q = state.quizState.questions[state.quizState.currentIndex];
                     state.quizState.answers[state.quizState.currentIndex] = {
                         userAnswer,
                         isCorrect: userAnswer.trim().toLowerCase() === q.answer.trim().toLowerCase()
                     };
                     View.render();
                 },
                 'next-question': () => {
                     if (state.quizState.currentIndex < state.quizState.questions.length - 1) {
                         state.quizState.currentIndex++;
                     } else {
                         Controller.finishQuiz();
                     }
                     View.render();
                 },
                 'back-to-workspace': () => {
                     state.quizState = null;
                     state.currentView = 'workspace';
                     View.render();
                 },
                 'manage-toc': () => ModalManager.open('manageToc', {
                     editableToc: JSON.parse(JSON.stringify(state.activeProject.toc))
                 }),
                 'toc-add-child': (el) => {
                     const parentNode = Utils.getNodeByPath(ModalManager.data.editableToc, el.dataset.path);
                     parentNode.children.push({
                         title: "새 항목",
                         children: []
                     });
                     ModalManager.render();
                 },
                 'toc-add-root-item': () => {
                     ModalManager.data.editableToc.children.push({
                         title: "새 최상위 항목",
                         children: []
                     });
                     ModalManager.render();
                 },
                 'toc-delete': (el) => {
                     const {
                         parent,
                         index
                     } = Utils.getParentNodeAndIndexByPath(ModalManager.data.editableToc, el.dataset.path);
                     if (parent?.children) {
                         parent.children.splice(index, 1);
                         ModalManager.render();
                     }
                 },
                 'save-toc': () => Controller.saveToc(),
                 'open-split-chapter-modal': () => {
                     const defaultSource = state.activeChapterContent.translation?.trim() ? 'translation' : 'manuscript';
                     const prompt = Controller.buildSplitChapterPrompt(defaultSource);
                     if (prompt) {
                         Controller.copyToClipboard(prompt);
                         ModalManager.open('splitChapter', {
                             sourceToSplit: defaultSource
                         });
                     }
                 },
                 'regenerate-split-prompt': (el, e) => {
                     if (e.target.tagName === 'INPUT') {
                         const newSource = e.target.value;
                         ModalManager.data.sourceToSplit = newSource;
                         const prompt = Controller.buildSplitChapterPrompt(newSource);
                         if (prompt) {
                             Controller.copyToClipboard(prompt);
                         }
                         ModalManager.render();
                     }
                 },
                 'submit-split-chapter': (form) => Controller.handleSplitChapterSubmit(form),
                 'dismiss-toast': (el) => Controller.dismissToast(el.dataset.id),
                 'remove-tag': (el) => {
                     const tagToRemove = el.dataset.tag;
                     ModalManager.data.projectTags = ModalManager.data.projectTags.filter(t => t !== tagToRemove);
                     ModalManager.render();
                 },
                 'select-tag-suggestion': (el) => {
                     Controller.addTagToProject(el.dataset.tag);
                     document.getElementById('setting-tags-input').value = '';
                     document.getElementById('tag-suggestions').classList.add('hidden');
                 },
                 'toggle-sidebar-section': (el) => {
                     const section = el.dataset.section;
                     state.sidebarCollapseState[section] = !state.sidebarCollapseState[section];
                     View.render();
                 },
                 'toggle-toc-all': (el) => {
                     const mode = el.dataset.mode;
                     const allPaths = Utils.getFlatToc(state.activeProject.toc).map(item => item.path);
                     if (mode === 'collapse') {
                         allPaths.forEach(path => state.tocCollapseState[path] = true);
                     } else {
                         state.tocCollapseState = {};
                     }
                     View.render();
                 },
                 'set-workspace-layout': (el) => {
                     state.workspaceLayout = el.dataset.layout;
                     View.render();
                 },
                 'set-view-panel-mode': (el) => {
                     state.viewPanelDisplayMode = el.dataset.mode;
                     View.render();
                 },
                 'set-quiz-result-filter': (el) => {
                     state.quizResultFilter = el.dataset.filter;
                     View.render();
                 },
             },
             async exportProject(projectId) {
                 try {
                     this.showToast('프로젝트 데이터 준비 중...', 'info');

                     const project = await DB.get(CONFIG.STORES.PROJECTS, projectId);
                     if (!project) {
                         throw new Error("프로젝트를 찾을 수 없습니다.");
                     }

                     const contents = await DB.getProjectContents(projectId);

                     const portableContents = contents.map(content => {
                         const path = content.id.replace(`${projectId}_`, '');
                         const newContent = {
                             ...content,
                             path
                         };
                         delete newContent.id;
                         return newContent;
                     });

                     const exportData = {
                         type: CONFIG.EXPORT_TYPE_ID,
                         project: project,
                         contents: portableContents
                     };

                     const jsonString = JSON.stringify(exportData, null, 2);
                     const blob = new Blob([jsonString], {
                         type: 'application/json'
                     });
                     const url = URL.createObjectURL(blob);

                     const a = document.createElement('a');
                     a.href = url;
                     const safeFileName = project.name.replace(/[\/\\?%*:|"<>]/g, '-') || 'project';
                     a.download = `${safeFileName}.json`;

                     document.body.appendChild(a);
                     a.click();
                     document.body.removeChild(a);

                     URL.revokeObjectURL(url);
                     this.showToast('프로젝트 내보내기가 완료되었습니다.', 'success');

                 } catch (error) {
                     console.error("Export failed:", error);
                     this.showToast(`프로젝트 내보내기 실패: ${error.message}`, 'error');
                 }
             },
         };

         Controller.init();
     </script>
 </body>
 </html>
