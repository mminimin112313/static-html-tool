<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>통합 학습 및 저작 시스템 v3.17</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://unpkg.com/turndown/dist/turndown.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/morphdom@2.7.0/dist/morphdom-umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0/dist/fuse.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/feather-icons@4.29.2/dist/feather.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="document.dispatchEvent(new Event('katex-loaded'))" defer></script>

    <style>
/* ▼▼▼ [1단계] 나눔고딕, 나눔명조 및 기본 글꼴 웹 폰트 불러오기 ▼▼▼ */
        @import url('https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;700;800&family=Nanum+Myeongjo:wght@400;700;800&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap');
    
        :root {
            --bg-primary: #ffffff; --bg-secondary: #f8fafc; --bg-tertiary: #f1f5f9;
            --bg-hover: #eef2ff; --text-primary: #0f172a; --text-secondary: #475569;
            --text-tertiary: #64748b; --border-color: #e2e8f0; --accent-primary: #4f46e5;
            --accent-primary-hover: #4338ca; --accent-danger: #ef4444; --sidebar-width: 280px;
            --header-height: 64px; --radius-sm: 0.25rem; --radius-md: 0.5rem; --radius-lg: 0.75rem;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        /* ▼▼▼ 다크 모드 테마 변수 ▼▼▼ */
        html.dark {
            --bg-primary: #0f172a; 
            --bg-secondary: #1e293b; 
            --bg-tertiary: #334155;
            --bg-hover: #334155; 
            --text-primary: #f8fafc; 
            --text-secondary: #cbd5e1;
            --text-tertiary: #94a3b8; 
            --border-color: #334155;
        }
        /* === 모달(Modal) 다크 모드 스타일 개선 === */

/* 1. 모달 내부 섹션 배경색 구분 (배경과 구분이 안 되는 문제 해결) */
html.dark .modal-container .bg-slate-50,
html.dark .modal-container .bg-slate-100,
html.dark .modal-container .bg-white { /* 기존 항목 목록 배경 포함 */
    background-color: var(--bg-secondary) !important;
}

/* 2. 폼 입력 요소 색상 조정 (글씨 안 보이는 문제 해결) */
html.dark .modal-container input[type="text"],
html.dark .modal-container input[type="password"],
html.dark .modal-container textarea,
html.dark .modal-container select {
    background-color: var(--bg-tertiary) !important;
    color: var(--text-primary) !important;
    border-color: var(--border-color) !important;
}
/* 입력창 placeholder 텍스트 색상 */
html.dark .modal-container ::placeholder {
    color: var(--text-tertiary);
}

/* 3. 모달 내 탭 버튼 색상 조정 */
/* 비활성 탭 */
html.dark .modal-container button[class*="text-slate-500"] {
    color: var(--text-secondary) !important;
}
html.dark .modal-container button[class*="hover:bg-slate-100"]:hover {
    background-color: var(--bg-tertiary) !important;
}
/* 활성 탭 */
html.dark .modal-container button.bg-indigo-100,
html.dark .modal-container button.bg-indigo-600 {
    background-color: var(--accent-primary) !important;
    color: white !important;
}

/* 4. 태그 알약(pills) 및 기타 색상 조정 */
html.dark .modal-container .bg-indigo-50 {
    background-color: var(--bg-tertiary) !important;
}
html.dark .modal-container [class*="text-indigo-"] { /* 모든 indigo 계열 텍스트 */
    color: #a5b4fc !important; /* 다크모드에 어울리는 밝은 인디고 색상 */
}
html.dark .modal-container .hover\:bg-indigo-500\/20:hover {
    background-color: rgba(99, 102, 241, 0.2) !important;
}
        /* === 토스트 메시지 스타일 (다크모드 지원 및 너비 수정) === */
        .toast-panel {
            background-color: var(--bg-primary);
        }
        .toast-text {
            color: var(--text-primary);
        }
        .toast-close-button {
            background-color: transparent;
            color: var(--text-tertiary);
        }
        .toast-close-button:hover {
            color: var(--text-secondary);
        }

        /* 다크 모드에서 아이콘 색상 가독성 확보 */
        html.dark .text-green-500 { color: #4ade80; } /* Tailwind green-400 */
        html.dark .text-red-500 { color: #f87171; } /* Tailwind red-400 */
        html.dark .text-blue-500 { color: #60a5fa; } /* Tailwind blue-400 */
        /* 1. 패널 기본 배경색을 CSS 변수로 지정 */
        .bg-panel {
            background-color: var(--bg-primary);
        }

        /* 2. 다크 모드일 때 하드코딩된 다른 색상들을 덮어쓰기 */
        html.dark .bg-slate-50 { background-color: var(--bg-tertiary) !important; }
        html.dark .bg-slate-100 { background-color: var(--bg-tertiary) !important; }
        html.dark .bg-yellow-50 { background-color: #4a3a1a !important; }

        /* 테두리 색상 조정 */
        html.dark .border-slate-200,
        html.dark .border-slate-300,
        html.dark .border-gray-200 { 
            border-color: var(--border-color) !important; 
        }

        /* 기본 텍스트 색상 조정 */
        html.dark .text-slate-800,
        html.dark .text-slate-900,
        html.dark .text-gray-900,
        html.dark .text-black {
            color: var(--text-primary) !important;
        }

        /* 보조 텍스트 색상 조정 */
        html.dark .text-slate-600,
        html.dark .text-gray-500 {
            color: var(--text-secondary) !important;
        }
        /* === 다크 모드 UI 버그 수정 === */

        /* 1. 번역 패널의 텍스트 입력창(textarea) 스타일 */
        textarea {
            background-color: var(--bg-primary);
            color: var(--text-secondary);
            border-color: var(--border-color);
        }
        html.dark textarea {
            background-color: var(--bg-secondary); /* 다크모드에서는 살짝 다른 배경색 */
            color: var(--text-primary);
            border-color: var(--border-color);
        }
        html.dark .btn-secondary:hover {
            background-color: #475569; /* btn-secondary 호버 효과 수정 */
        }
        /* ▼▼▼ [추가] 위험/삭제 및 비활성화 버튼 스타일 ▼▼▼ */
        .btn-danger {
            background-color: var(--accent-danger);
            color: white;
        }
        .btn-danger:hover:not(:disabled) {
            background-color: #dc2626; /* Tailwind red-600 */
        }
        .btn-danger:disabled {
            background-color: #fca5a5; /* Tailwind red-300 */
            cursor: not-allowed;
        }
        /* ▲▲▲ [추가 완료] ▲▲▲ */
        /* ▼▼▼ [추가] 설정 모달 커스텀 아이템 탭 레이아웃 ▼▼▼ */
        /* learning.html */
        .custom-items-layout {
            display: flex;
            flex-direction: column;
        }

        .custom-items-list-wrapper {
            flex-grow: 1; /* 남는 공간을 모두 차지 */
            min-height: 0; /* flex 자식 요소의 높이 계산 오류 방지 */
            overflow-y: auto; /* 내용이 많으면 이 부분만 스크롤 */
            padding: 0.75rem; /* 12px */
            margin-top: 1rem;
            margin-bottom: 1rem;
            border-radius: 0.5rem; /* 8px */
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
        }
        /* === 퀴즈 UI 스타일 (데이터 기반, 다크모드 지원) V2 === */
.quiz-container { background-color: var(--bg-secondary); }
.quiz-header { background-color: var(--bg-primary); border-bottom-color: var(--border-color); }
.quiz-progress-bar-bg { background-color: var(--bg-tertiary); }
.quiz-progress-bar-fill { background-color: var(--accent-primary); }

/* 텍스트 색상 */
.quiz-text-primary { color: var(--text-primary); }
.quiz-text-secondary { color: var(--text-secondary); }
.quiz-text-tertiary { color: var(--text-tertiary); }

/* 선택지 버튼 기본 스타일 */
.quiz-option-button {
    border: 1px solid var(--border-color);
    background-color: var(--bg-primary);
    color: var(--text-secondary);
}
.quiz-option-button:not([disabled]):hover {
    border-color: var(--accent-primary);
    background-color: var(--bg-hover);
}

/* 선택지 상태별 스타일 */
.quiz-option-button[data-answer-status="correct"] {
    background-color: #f0fdf4; border-color: #22c55e; color: #15803d; font-weight: 600;
}
.quiz-option-button[data-answer-status="incorrect"] {
    background-color: #fef2f2; border-color: #ef4444; color: #b91c1c;
}
html.dark .quiz-option-button[data-answer-status="correct"] {
    background-color: rgba(74, 222, 128, 0.1); border-color: #4ade80; color: #bbf7d0;
}
html.dark .quiz-option-button[data-answer-status="incorrect"] {
    background-color: rgba(248, 113, 113, 0.1); border-color: #f87171; color: #fecaca;
}

/* 피드백 패널 스타일 */
.quiz-feedback-panel {
    border-left-width: 4px;
}
.quiz-feedback-panel[data-answer-status="correct"] {
    background-color: #f0fdf4; border-color: #22c55e; color: #166534;
}
.quiz-feedback-panel[data-answer-status="incorrect"] {
    background-color: #fef2f2; border-color: #ef4444; color: #991b1b;
}
html.dark .quiz-feedback-panel[data-answer-status="correct"] {
    background-color: rgba(74, 222, 128, 0.1); color: #a7f3d0;
}
html.dark .quiz-feedback-panel[data-answer-status="incorrect"] {
    background-color: rgba(248, 113, 113, 0.1); color: #fca5a5;
}

/* 주관식 답안 비교 UI 스타일 */
.subjective-answer-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1rem;
}
@media (min-width: 768px) {
    .subjective-answer-grid { grid-template-columns: 1fr 1fr; }
}
.subjective-answer-box {
    padding: 1rem;
    border-radius: var(--radius-md);
    background-color: var(--bg-tertiary);
}
/* white-space: pre-wrap 으로 개행 문자를 올바르게 렌더링 */
.subjective-answer-box .prose {
    white-space: pre-wrap;
    word-break: break-word;
}
.subjective-answer-box h4 {
    display: flex; align-items: center; gap: 0.5rem;
    font-size: 0.875rem; font-weight: 600; color: var(--text-secondary); margin-bottom: 0.5rem;
}
html.dark .subjective-answer-box { background-color: var(--bg-secondary); }

/* 결과 화면 점수 텍스트 */
html.dark .quiz-result-score {
    color: #a5b4fc; /* text-indigo-400 equivalent for dark */
}

        /* 2. 목차(TOC) 텍스트 색상 정의 */
        .toc-item > div > a {
            color: var(--text-secondary); /* 기본 텍스트 색상 */
            transition: background-color 0.2s, color 0.2s;
        }
        .toc-item.active > div > a {
            color: var(--accent-primary); /* 활성화된 텍스트 색상 */
            font-weight: 600;
        }
        .toc-item > div > a:hover {
            color: var(--text-primary); /* 호버 시 텍스트 색상 */
        }
        html { scroll-behavior: smooth; }
        /*
         * The body acts as a flex container housing the sidebar and the main content area.  Originally the
         * height was fixed at 100dvh and overflow was hidden.  On mobile browsers, especially Android,
         * the address bar and navigation controls shrink and expand as you scroll.  When the body is
         *  rained to a fixed height and overflow is clipped, the dynamic viewport changes can push
         * the footer out of view.  To accommodate dynamic viewport units and allow vertical scrolling
         * when necessary, the body now uses a minimum height based on the dynamic viewport (`dvh`) and
         * WebKit's `-webkit-fill-available` for Safari.  Overflow on the Y‑axis is enabled so that
         * additional content (like the footer) remains reachable on smaller screens.
         */
       body {
            font-family: 'Inter', 'Noto Sans KR', sans-serif;
            background-color: var(--bg-secondary); color: var(--text-primary);
            display: flex; 
            /* ▼▼▼ [핵심 수정] height 속성을 min-height로 변경합니다 ▼▼▼ */
            min-height: 100dvh; 
            min-height: -webkit-fill-available;
            /* ▲▲▲ [수정 완료] ▲▲▲ */
            overflow: hidden; /* body 자체의 스크롤을 완전히 막습니다. */
        }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #f1f5f9; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .btn { background-color: var(--accent-primary); color: white; border: none; padding: 0.625rem 1rem; border-radius: var(--radius-md); cursor: pointer; display: inline-flex; align-items: center; justify-content: center; gap: 0.5rem; font-size: 0.875rem; font-weight: 500; transition: background-color 0.2s, transform 0.1s; }
        .btn:hover { background-color: var(--accent-primary-hover); transform: translateY(-1px); }
        .btn:active { transform: translateY(0); }
        .btn-secondary { background-color: var(--bg-tertiary); color: var(--text-primary); }
        .btn-secondary:hover { background-color: #e2e8f0; }
        
        .sidebar { width: var(--sidebar-width); background-color: var(--bg-primary); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; flex-shrink: 0; height: 100%; transition: transform 0.3s ease-in-out, width 0.3s ease-in-out, padding 0.3s ease-in-out, border 0.3s ease-in-out; z-index: 100; }
        .sidebar-header { padding: 1rem; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .sidebar-header .logo { font-size: 1.25rem; font-weight: 700; color: var(--accent-primary); display: flex; align-items: center; gap: 0.5rem; }
        .sidebar-content { flex-grow: 1; overflow-y: auto; padding: 1rem 0.5rem; }
        .sidebar-footer { padding: 1rem; border-top: 1px solid var(--border-color); flex-shrink: 0; }
        .nav-section-title { font-size: 0.75rem; font-weight: 600; color: var(--text-tertiary); text-transform: uppercase; letter-spacing: 0.05em; padding: 0 0.5rem; margin-bottom: 0.5rem; }
        .nav-list { list-style: none; padding-left: 0; }
        .nav-item a { display: flex; align-items: center; gap: 0.75rem; padding: 0.625rem 0.5rem; color: var(--text-secondary); text-decoration: none; border-radius: var(--radius-md); font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: background-color 0.2s, color 0.2s; position: relative; }
        .nav-item a:hover { background-color: var(--bg-tertiary); color: var(--text-primary); }
        .nav-item.active a { background-color: var(--bg-hover); color: var(--accent-primary); font-weight: 600; }
        .nav-item.active a::before { content: ''; position: absolute; left: -0.5rem; top: 0; bottom: 0; width: 4px; background-color: var(--accent-primary); border-top-right-radius: 4px; border-bottom-right-radius: 4px; }
        .nav-item .icon { width: 1.25rem; height: 1.25rem; }
        .tag-count { margin-left: auto; font-size: 0.75rem; background-color: var(--bg-tertiary); color: var(--text-secondary); padding: 0.125rem 0.5rem; border-radius: var(--radius-sm); }
        
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow-y: auto; /* 이 컨테이너가 스크롤을 담당하도록 변경 */
            position: relative; /* 자식 sticky 요소의 기준점 */
        }
        .main-content.reader-mode .main-header,
        .main-content.reader-mode .sidebar,
        .main-content.reader-mode .sidebar-overlay,
        .main-content.reader-mode .main-footer {
            display: none !important;
        }
        .main-content.reader-mode .prose-readable {
            max-width: 800px; /* 리더 모드에서도 적절한 너비 유지 */
        }
        .main-header {
            display: flex;
            align-items: center;
            /* Maintain horizontal padding while making room for any device safe-area at the top.
               We use env(safe-area-inset-top) with a fallback of 0 so that, on devices with notches
               or dynamic browser UI (e.g. Android address bar), the header's contents are pushed
               below those areas rather than being overlapped. */
            padding: calc(env(safe-area-inset-top, 0px)) 1.5rem 0 1.5rem;
            /* Increase the height by the safe-area inset so that the visible header area remains
               consistent even when additional padding has been applied. */
            height: calc(var(--header-height) + env(safe-area-inset-top, 0px));
            flex-shrink: 0;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-primary);
            z-index: 10;
            /* Keep the header pinned to the top of the viewport even when the page scrolls.  Using
               `position: sticky` instead of `fixed` preserves the element's space in the layout while
               allowing it to stick to the top when scrolling.  The top offset also accounts for
               the safe-area inset to ensure the header itself isn't hidden under the browser UI. */
            position: sticky;
            top: env(safe-area-inset-top, 0px);
            /* Ensure that padding contributes to the element's total height */
            box-sizing: border-box;
        }
        .header-title { font-size: 1.25rem; font-weight: 600; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .search-input { background-color: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: 0.5rem 2.5rem 0.5rem 0.75rem; font-size: 0.875rem; width: 280px; }
        .content-view { 
            padding: 1.5rem;
            padding-bottom: 200px;
            flex-grow: 1; 
            
        }
        
        .project-card { background-color: var(--bg-primary); border-radius: var(--radius-lg); border: 1px solid var(--border-color); padding: 1.5rem; box-shadow: var(--shadow-sm); transition: box-shadow 0.2s, transform 0.2s; }
        .project-card:hover { transform: translateY(-2px); box-shadow: var(--shadow-md); }
        
        .modal-overlay { position: fixed; inset: 0; background-color: rgba(15, 23, 42, 0.6); display: flex; justify-content: center; align-items: center; z-index: 2000; opacity: 0; visibility: hidden; transition: opacity .3s; backdrop-filter: blur(4px); }
        .modal-overlay.show { opacity: 1; visibility: visible; }
        .modal-container { background-color: var(--bg-primary); border-radius: var(--radius-lg); width: 90%; max-width: 600px; box-shadow: var(--shadow-md); z-index: 2001; transform: scale(0.95); transition: transform 0.3s; }
        .modal-container.modal-container-large {
            max-width: 1024px; /* 설정 모달에 적합한 넓은 최대 너비 지정 */
        }
        .modal-overlay.show .modal-container { transform: scale(1); }

        #workspace-main-content {
            transition: opacity 0.2s ease-in-out;
        }
        #workspace-main-content.content-transitioning {
            opacity: 0;
        }
        /* 보기 패널 레이아웃 토글 버튼 스타일 */
        .layout-toggle-button {
            background-color: var(--bg-primary);
            color: var(--text-secondary);
            padding: 0.25rem 0.75rem; /* 4px 12px */
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }
        .layout-toggle-button:first-of-type { border-radius: var(--radius-md) 0 0 var(--radius-md); }
        .layout-toggle-button:last-of-type { border-radius: 0 var(--radius-md) var(--radius-md) 0; }
        .layout-toggle-button:not(:first-of-type) { border-left-width: 0; }

        .layout-toggle-button:hover:not(.active) {
            background-color: var(--bg-tertiary);
        }

        .layout-toggle-button.active {
            background-color: var(--bg-hover);
            color: var(--accent-primary);
            border-color: var(--accent-primary);
            z-index: 10;
        }

        .layout-toggle-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .xp-bar-inner { background: linear-gradient(90deg, #4f46e5, #818cf8); transition: width 0.5s ease-out; }
        /* Context Menu Styles */
#toc-context-menu {
    position: fixed;
    z-index: 3000; /* Ensure it's above the modal overlay */
    background-color: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-md);
    box-shadow: var(--shadow-md);
    min-width: 180px;
    padding: 0.5rem 0;
}
#toc-context-menu button {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    width: 100%;
    padding: 0.5rem 1rem;
    font-size: 0.875rem;
    text-align: left;
    background: none;
    border: none;
    color: var(--text-secondary);
    cursor: pointer;
}
#toc-context-menu button:hover {
    background-color: var(--bg-hover);
    color: var(--text-primary);
}
#toc-context-menu hr {
    border-top: 1px solid var(--border-color);
    margin: 0.5rem 0;
}
.context-menu-unselectable {
    -webkit-user-select: none; /* Safari */
    -moz-user-select: none;    /* Firefox */
    -ms-user-select: none;     /* IE10+/Edge */
    user-select: none;         /* Standard */
}
        .toc-item ul {
            position: relative;
            padding-left: 1rem; /* 선이 그려질 공간 확보 */
        }
        .toc-item ul::before {
            content: '';
            position: absolute;
            left: 0;
            top: -0.5rem; /* 아이콘과 연결되도록 조정 */
            bottom: 0.5rem;
            width: 1px;
            background-color: var(--border-color);
            transition: background-color 0.2s;
        }
        .toc-item.active > div > a,
        .toc-item > div > a:hover {
            background-color: var(--bg-hover);
        }
        /* ▼▼▼ [2단계] '보기' 패널의 최대 너비 수정 ▼▼▼ */
        .prose-readable {
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            font-size: 24px; 
            line-height: 1.8;
        }
    
        @media (min-width: 768px) {
            .prose-readable {
                font-size: 25px;
                line-height: 1.7;
            }
        }

        /* === 브레드크럼프 UI 및 다크 모드 개선 === */
        .bg-breadcrumb {
            background-color: var(--bg-tertiary);
        }
        .breadcrumb-text-primary {
            color: var(--text-primary);
        }
        .breadcrumb-text-secondary {
            color: var(--text-secondary);
        }
        .hover\:breadcrumb-text-hover:hover {
            color: var(--accent-primary);
        }
        
        .drop-zone { border: 2px dashed #d1d5db; transition: all 0.2s ease-in-out; }
        .drop-zone.drag-over { background-color: #eef2ff; border-color: #6366f1; }
        
        .toc-drop-indicator-before { border-top: 2px solid var(--accent-primary); }
        .toc-drop-indicator-after { border-bottom: 2px solid var(--accent-primary); }
        .toc-drop-indicator-inside { background-color: var(--bg-hover); outline: 2px solid var(--accent-primary); }
    
        .tooltip { position: relative; display: inline-block; }
        .tooltip .tooltip-text { visibility: hidden; width: 250px; background-color: #334155; color: #fff; text-align: left; border-radius: 6px; padding: 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -125px; opacity: 0; transition: opacity 0.3s; font-size: 0.75rem; line-height: 1.5; }
        .tooltip:hover .tooltip-text { visibility: visible; opacity: 1; }
        .app-tooltip.show {
            opacity: 1;
            pointer-events: auto;
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        @media (max-width: 1024px) {
            .sidebar { position: fixed; transform: translateX(-100%); }
            .sidebar.open { transform: translateX(0); box-shadow: 0 0 40px rgba(0,0,0,0.1); }
            .sidebar-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 99; transition: opacity 0.3s; }
            .sidebar-overlay:not(.show) { opacity: 0; pointer-events: none; }
        }
    
       /* ================================================================== */
/* ▼▼▼ [수정] 집착적으로 조정한 타이포그래피 스타일 (다크모드 지원) ▼▼▼ */
/* ================================================================== */

/* --- 전체적인 텍스트 렌더링 최적화 --- */
.prose-readable {
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    font-feature-settings: "kern" on, "liga" on;
    text-rendering: optimizeLegibility;
}

/* --- 제목 (Headings) --- */
.prose-readable h1,
.prose-readable h2,
.prose-readable h3,
.prose-readable h4 {
    font-family: 'Nanum Gothic', sans-serif;
    color: var(--text-primary); /* [수정] 하드코딩된 색상 -> 변수 */
    margin-top: 2em;
    margin-bottom: 0.7em;
    letter-spacing: -0.025em;
    word-break: keep-all;
}

.prose-readable h1 {
    font-size: 2.2em;
    font-weight: 800;
    padding-bottom: 0.4em;
    border-bottom: 2px solid var(--border-color); /* [수정] */
}

.prose-readable h2 {
    font-size: 1.7em;
    font-weight: 700;
    padding-bottom: 0.4em;
    border-bottom: 1px solid var(--border-color); /* [수정] */
}

.prose-readable h3 {
    font-size: 1.4em;
    font-weight: 700;
    border: none;
}

.prose-readable h4 {
    font-size: 1.2em;
    font-weight: 700;
    color: var(--text-secondary); /* [수정] */
}

/* --- 본문 (Paragraphs) --- */
.prose-readable p {
    font-family: 'Nanum Myeongjo', serif;
    color: var(--text-secondary); /* [수정] "너무 흐린 문제"의 핵심 원인 해결 */
    font-size: 1.05em;
    line-height: 1.85;
    letter-spacing: -0.015em;
    word-spacing: 0.05em;
    text-align: justify;
    word-break: keep-all;
    margin-bottom: 1.2em;
}

/* --- 강조 (Strong) --- */
.prose-readable strong {
    color: var(--text-primary); /* [수정] */
    font-weight: 700;
}

/* --- 링크 (Links) --- */
.prose-readable a {
    color: var(--accent-primary);
    text-decoration: none;
    border-bottom: 1px solid var(--accent-primary);
    font-weight: 600;
    transition: all 0.2s ease-in-out;
}
.prose-readable a:hover {
    color: white;
    background-color: var(--accent-primary-hover);
    border-bottom-color: transparent;
}

/* --- 인용문 (Blockquotes) --- */
.prose-readable blockquote {
    border-left: 3px solid var(--accent-primary);
    padding: 0.5em 1.2em;
    margin: 1.5em 0;
    color: var(--text-tertiary); /* [수정] */
    background-color: var(--bg-tertiary); /* [수정] */
    font-style: normal;
}

.prose-readable blockquote p {
    font-size: 1em;
    line-height: 1.7;
}

/* --- 코드 (Code) & 테이블 (Table) --- */
.prose-readable code {
    background-color: var(--bg-hover); /* [수정] */
    color: var(--accent-primary); /* [수정] */
    padding: 0.2em 0.5em;
    margin: 0 0.1em;
    font-size: 85%;
    border-radius: 6px;
    font-family: 'D2Coding', 'Courier New', Courier, monospace;
}

.prose-readable table {
    width: 100%;
    border-collapse: collapse;
    margin: 2em 0;
    font-size: 0.9em;
    border: 1px solid var(--border-color); /* [수정] */
}
.prose-readable th,
.prose-readable td {
    border: 1px solid var(--border-color); /* [수정] */
    padding: 0.8em 1em;
    text-align: left;
}
.prose-readable th {
    font-family: 'Nanum Gothic', sans-serif;
    font-weight: 700;
    background-color: var(--bg-tertiary); /* [수정] */
}

.prose-readable ul,
.prose-readable ol {
    list-style-position: outside; /* 마커(블릿, 숫자)를 텍스트 바깥쪽에 배치하여 정렬을 깔끔하게 합니다. */
    padding-left: 2em; /* 목록 전체를 들여쓰기하여 본문과 구분합니다. */
    margin-bottom: 1.2em; /* 목록 아래에 적절한 여백을 추가합니다. */
}

.prose-readable ul {
    list-style-type: disc; /* 채워진 원형 블릿을 사용합니다. */
}

.prose-readable ol {
    list-style-type: decimal; /* 1, 2, 3... 숫자를 사용합니다. */
}

.prose-readable li {
    margin-bottom: 0.8em; /* 각 항목(li) 사이에 일관된 간격을 부여합니다. */
    padding-left: 0.5em; /* 마커와 텍스트 사이에 약간의 공간을 줍니다. */
}

/* [핵심] li 태그 안의 p 태그가 불필요한 추가 여백을 만드는 문제 해결 */
.prose-readable li > p {
    margin-top: 0;
    margin-bottom: 0; /* 단락의 기본 여백을 제거하여 li의 여백과 중첩되지 않게 합니다. */
}

/* 중첩된 목록의 상단 여백을 조정하여 부모 항목과 시각적으로 구분 */
.prose-readable li ul,
.prose-readable li ol {
    margin-top: 0.8em;
}
        
        
        /* === 푸터(Footer) 전체 스타일 (모바일 가로 스크롤 적용) === */

        /* --- 1. 푸터 기본 컨테이너 & 레이아웃 --- */
        .main-footer {
            flex-shrink: 0;
            background-color: var(--bg-primary);
            border-top: 1px solid var(--border-color);
            /* 상하 패딩에 safe-area-inset-bottom을 추가하여 모바일 브라우저 UI가 푸터를 가리지 않도록 합니다. */
            padding: 0.25rem 1.5rem;
            padding-bottom: calc(0.25rem + env(safe-area-inset-bottom, 0px));
            font-size: 0.75rem;
            color: var(--text-secondary);
            transition: background-color 0.2s;
            position: sticky;
            /* bottom 값을 safe-area-inset-bottom으로 이동하여 아이폰 등의 하단 홈바 영역을 피합니다. */
            bottom: env(safe-area-inset-bottom, 0px);
            z-index: 5;
        }

        .main-footer > div {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            gap: 1rem;
            flex-wrap: nowrap; 
        }

         /* --- 2. 푸터 각 섹션별 레이아웃 스타일 --- */
        .main-footer > div {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            gap: 0.75rem; /* [수정] 1rem -> 0.75rem */
            flex-wrap: nowrap; 
        }

        .main-footer .footer-nav {
            display: flex;
            align-items: center;
            gap: 0.25rem; /* [수정] 0.5rem -> 0.25rem */
            flex-shrink: 1;
            min-width: 0; 
        }

        .footer-controls-group {
            display: flex;
            align-items: center;
            gap: 0.75rem; /* [수정] 1rem -> 0.75rem */
            flex-shrink: 0;
        }

        .main-footer .footer-modes-wrapper,
        .main-footer .footer-right-actions {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        /* --- 3. 푸터 내부 개별 요소 스타일 --- */
        .footer-breadcrumb-path {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: var(--text-primary);
            font-weight: 500;
        }

        .footer-stats, 
        .footer-stats + .border-l {
            transition: all 0.2s ease-in-out;
        }

        .footer-stats span {
            margin: 0 0.5rem;
            display: inline-flex;
            align-items: center;
            color: var(--text-tertiary);
            font-size: 0.7rem;
        }

        .footer-nav button,
        .footer-actions button,
        .footer-mode-button {
            background: none; border: none;
            color: var(--text-secondary);
            padding: 0.2rem 0.4rem;
            border-radius: var(--radius-md);
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.3rem;
            transition: all 0.2s ease-in-out;
            height: 24px; /* [수정] 28px -> 24px */
            flex-shrink: 0;
        }

        /* --- (생략) 호버, 비활성화 스타일은 기존과 동일 --- */
        .footer-nav button:hover,
        .footer-actions button:hover,
        .footer-mode-button:hover { background-color: var(--bg-hover); color: var(--accent-primary); }
        .footer-nav button:disabled,
        .footer-actions button:disabled,
        .footer-mode-button:disabled { opacity: 0.4; cursor: not-allowed; background-color: transparent !important; color: var(--text-secondary) !important; }


        /* --- 4. 반응형 우선순위 스타일 --- */
        @media (max-width: 1280px) {
            .footer-stats, 
            .footer-stats + .border-l { display: none; }
        }

        @media (max-width: 960px) {
            .footer-actions button[data-action="go-dashboard"],
            .footer-actions button[data-action="export-project"] { display: none; }
        }

        /* ▼▼▼ [핵심 수정] 모바일 화면에서 가로 스크롤 UI로 전환합니다. ▼▼▼ */
        @media (max-width: 768px) {
            .main-footer {
                padding-left: 0;
                padding-right: 0;
            }

            .main-footer > div {
                flex-direction: column;
                gap: 0.25rem; /* 그룹 간 간격 최소화 */
                padding: 0.5rem 0;
            }

            .main-footer .footer-nav {
                width: 100%;
                justify-content: center;
                padding: 0 1rem;
            }

            /* 컨트롤 버튼 그룹을 가로 스크롤 컨테이너로 만듭니다. */
            .footer-controls-group {
                width: 100%;
                overflow-x: auto; /* 가로 스크롤 활성화 */
                padding: 0.25rem 1rem; /* 좌우 여백을 주어 잘리지 않게 함 */
                
                /* 스크롤바 숨기기 (터치로만 스크롤) */
                -ms-overflow-style: none;  /* IE and Edge */
                scrollbar-width: none;  /* Firefox */
            }
            .footer-controls-group::-webkit-scrollbar {
                display: none; /* Chrome, Safari, etc. */
            }
            
            /* 숨겼던 모든 요소를 스크롤 영역 내에서 다시 보여줍니다. */
            .footer-stats,
            .footer-stats + .border-l,
            .footer-actions button[data-action="go-dashboard"],
            .footer-actions button[data-action="export-project"] {
                display: inline-flex;
            }
        }

        html {
            scrollbar-width: thin;
            scrollbar-color: #a8a29e var(--bg-tertiary); /* 스크롤바 색상(막대, 트랙) */
        }

        /* Webkit 기반 브라우저(크롬, 엣지, 사파리)를 위한 스타일 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        /* 스크롤바가 지나가는 배경(트랙) */
        ::-webkit-scrollbar-track {
            background-color: var(--bg-tertiary);
        }

        /* 스크롤바 막대(thumb) */
        ::-webkit-scrollbar-thumb {
            background-color: #a8a29e; /* 기본 막대 색상 (은은한 갈색빛 회색) */
            border-radius: 10px;
            border: 2px solid var(--bg-tertiary); /* 막대 주변에 여백 효과 */
            background-clip: content-box;
        }

        /* 스크롤바 막대에 마우스를 올렸을 때 */
        ::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-primary); /* 앱의 테마 색상으로 변경 */
        }
        /* ▲▲▲ [개선] 전체 스크롤바 스타일 ▲▲▲ */
        /* === 키보드 접근성 및 포커스 스타일 향상 === */
        :focus-visible {
            outline: 2px solid var(--accent-primary) !important;
            outline-offset: 2px;
            border-radius: var(--radius-sm);
        }

        /* 일부 기본 스타일이 outline을 제거하는 것을 방지 */
        .btn:focus, 
        .nav-item a:focus,
        .search-input:focus {
            outline: none; /* :focus-visible이 대신 처리하도록 함 */
        }
        /* 사이드바 프로젝트 정보 블록 스타일 */
        .project-info p {
            white-space: normal; /* [핵심] 텍스트가 자동으로 줄바꿈되도록 설정 */
            word-break: break-all; /* 긴 영어 단어나 경로가 있을 경우 강제로 줄바꿈 */
            line-height: 1.5;
        }
        

/* === 퀵 액션 레일 (Tool Palette) 스타일 V5: JS 툴팁 시스템 === */
.workspace-wrapper {
    position: relative;
    width: 100%;
}
.workspace-main {
    transition: margin-right 0.3s ease-in-out;
}

/* --- 데스크톱 (Tool Palette) --- */
@media (min-width: 1025px) {
    /* .workspace-main의 오른쪽 여백이 더 이상 필요 없으므로 삭제합니다. */
    /*
    .workspace-main {
        margin-right: 52px;
    }
    */
    .action-rail {
        position: sticky; 
        top: 84px;
        align-self: flex-start;
        /* right 속성은 이제 필요 없습니다. flex gap으로 간격이 조절됩니다. */
        width: 44px;
        flex-shrink: 0; /* [핵심 추가] 창이 줄어들 때 줄어들지 않도록 설정 */
        /* height 속성은 삭제하여 내용에 따라 유연하게 조절되도록 합니다. */
        background-color: var(--bg-primary);
        border: 1px solid var(--border-color);
        /* ... 이하 동일 ... */
    }
    .action-rail-toggle-btn, .action-rail-overlay {
        display: none;
    }
    .action-rail-label {
        display: none;
    }
}

/* --- 공통 스타일 --- */
.action-rail-content {
    display: flex; flex-direction: column; align-items: center;
}
.action-rail-group {
    display: flex; flex-direction: column; align-items: center;
    gap: 0.25rem; padding: 0.25rem 0;
}
.action-rail-divider {
    width: 60%; border-color: var(--border-color); margin: 0.5rem 0;
}
.action-rail-button {
    display: flex; align-items: center; justify-content: center;
    width: 36px; height: 36px; border-radius: var(--radius-md);
    background-color: transparent; border: none;
    color: var(--text-secondary); cursor: pointer;
    transition: all 0.2s ease-in-out;
}
.action-rail-button:hover {
    background-color: var(--bg-hover); color: var(--accent-primary);
}

/* ▼▼▼ 새로운 코드 ▼▼▼ */
.app-tooltip {
    position: fixed;
    background-color: #334155;
    color: white;
    padding: 0.5rem 0.8rem; /* 패딩 살짝 증가 */
    border-radius: var(--radius-md);
    font-size: 0.8rem;
    font-weight: 500;
    white-space: pre-line;
    width: 250px; /* 최대 너비 증가 */
    z-index: 9999;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease-in-out;
    text-align: left; /* [추가] 텍스트 좌측 정렬 */
}
.app-tooltip code {
    background-color: rgba(255, 255, 255, 0.2);
    color: #a5b4fc;
    padding: 0.1em 0.3em;
    border-radius: 4px;
    font-size: 0.9em;
}
.app-tooltip ul {
    list-style-type: none;
    padding: 0;
    margin: 0;
}
.app-tooltip li:not(:last-child) {
    margin-bottom: 0.5rem;
}
/* --- ▲▲▲ [수정 완료] ▲▲▲ --- */


/* --- 모바일 & 태블릿 (반응형 사이드바) --- */
/* --- 모바일 & 태블릿 (반응형 사이드바) --- */
@media (max-width: 1024px) {
    .action-rail-button[data-tooltip]::after {
        display: none;
    }
    .action-rail {
        position: fixed; top: 0; right: 0; width: 240px; height: 100%;
        background-color: var(--bg-secondary);
        border-left: 1px solid var(--border-color);
        box-shadow: -10px 0 20px rgba(0,0,0,0.05);
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
        z-index: 100; padding-top: calc(var(--header-height) + 1rem);
        overflow-y: auto;
    }
    .action-rail.open {
        transform: translateX(0);
    }
    .action-rail-content {
        align-items: stretch; padding: 0 0.75rem;
    }
    .action-rail-group {
        gap: 0.5rem;
    }
    .action-rail-button {
        width: 100%;
        justify-content: flex-start;
        padding: 0.625rem;
        gap: 0.75rem;
    }
    .action-rail-label {
        display: block;
        font-size: 0.875rem;
        font-weight: 500;
        color: var(--text-secondary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .action-rail-button:hover {
        background-color: var(--bg-tertiary);
    }
    .action-rail-button:hover .action-rail-label {
        color: var(--text-primary);
    }
    .action-rail-toggle-btn {
        position: fixed;
        
        /* [수정] 우측 중앙으로 위치 변경 */
        top: 50%;
        right: 0;
        transform: translateY(-50%);
        
        z-index: 101;
        
        /* [수정] 탭 형태 및 크기 조정 */
        width: 20px;
        height: 40px;
        border-radius: 8px 0 0 8px; /* 왼쪽 모서리만 둥글게 */

        background-color: var(--accent-primary);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: -2px 2px 10px rgba(0,0,0,0.1);
        border: none;
        cursor: pointer;
        transition: all 0.2s;
    }
    .action-rail-toggle-btn:active {
        transform: scale(0.95);
    }
    .action-rail-overlay {
        position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 99;
        transition: opacity 0.3s; opacity: 0; pointer-events: none;
    }
    .action-rail-overlay.show {
        opacity: 1; pointer-events: auto;
    }
}
/* ================================================================== */
/* ▼▼▼ [추가] 하이라이트 및 각주 스타일 (다크모드 지원) ▼▼▼ */
/* ================================================================== */

/* --- 하이라이트 (Highlights) --- */
.prose-readable mark {
    background-color: rgba(250, 204, 21, 0.4); /* Tailwind yellow-300 with transparency */
    /* padding, margin, border-radius 속성을 제거하여 레이아웃 변경을 방지합니다. */
    color: inherit;
}
html.dark .prose-readable mark {
    background-color: rgba(234, 179, 8, 0.5); /* Tailwind yellow-500 with transparency for dark mode */
}

/* --- 각주 (Footnotes) --- */
/* 각주 참조 링크 (예: [1]) */
.prose-readable .footnote-ref {
    font-size: 0.8em;
    vertical-align: super;
    line-height: 0;
}
.prose-readable .footnote-ref a {
    /* 기존 스타일 초기화 */
    border: none !important;
    background-color: transparent !important;
    text-decoration: none !important;
    font-weight: normal; /* 일반 텍스트와 굵기 통일 */
    
    /* [핵심 수정] 시각적 구분을 위한 스타일 */
    color: var(--accent-primary); /* 테마 색상으로 눈에 띄게 */
    padding: 0.1em 0.2em;
    margin: 0 0.1em;
    border-radius: 4px;
    cursor: help;
    transition: background-color 0.2s, color 0.2s;
}
.prose-readable .footnote-ref a:hover {
    background-color: var(--accent-primary-hover) !important;
    color: white !important;
}
/* 각주 목록 구분선 */
.prose-readable .footnote-divider {
    margin-top: 4em;
    border-color: var(--border-color);
}

/* 각주 목록 전체 */
.prose-readable .footnotes {
    margin-top: 2em;
    font-size: 0.9em;
    color: var(--text-tertiary);
}

/* 각주 목록의 각 항목 */
.prose-readable .footnotes li {
    display: flex; /* [수정] flex 레이아웃으로 변경 */
    align-items: baseline; /* [수정] 기준선 정렬 */
    margin-bottom: 0.8em;
    line-height: 1.6;
}
.prose-readable .footnotes li p {
    font-size: 1em;
    line-height: inherit;
    display: inline; /* p 태그가 줄바꿈을 만들지 않도록 함 */
}

/* 본문으로 돌아가는 링크 (↩) */
.prose-readable .footnote-backref {
    font-size: 1.1em;
    text-decoration: none;
    margin-left: 0.5em;
    border: none !important;
    background: none !important;
    padding: 0 4px;
}
.prose-readable .footnote-backref:hover {
    background-color: var(--bg-hover) !important;
    border-radius: 4px;
}

.highlight-delete-btn {
    position: absolute;
    transform: translate(-50%, -100%); /* 버튼의 중앙 상단이 커서 위치에 오도록 조정 */
    z-index: 2600; /* 컨텍스트 메뉴보다 위에 표시 */
    background-color: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 9999px; /* 원형 버튼 */
    width: 28px;
    height: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: var(--shadow-md);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}
.highlight-delete-btn:hover {
    transform: translate(-50%, -100%) scale(1.1);
    background-color: #fef2f2; /* red-50 */
    color: var(--accent-danger);
}
html.dark .highlight-delete-btn:hover {
    background-color: rgba(239, 68, 68, 0.2);
}

/* 하이라이트 삭제 버튼을 담을 컨테이너 */
#highlight-menu-root {
    position: fixed;
    top: 0;
    left: 0;
    width: 0;
    height: 0;
    z-index: 2550;
}

    </style>
</head>
<body>
    <div id="app-container" class="flex h-screen w-full"></div>
    <div id="modal-root"></div>
    <div id="toast-root"></div>
    <div id="app-tooltip" class="app-tooltip"></div>
    <div id="highlight-menu-root"></div>
    <script type="module">
        // ===================================================================================
// 통합 학습 및 저작 시스템 v3.16 (UX 개선)
// - v3.16: 빈 프로젝트 생성 기능, 스크롤 위치 기억 기능 추가 및 UX 개선
// ===================================================================================
const APP_VERSION = '3.17.2'; // [핵심] 현재 애플리케이션 버전을 명시합니다.


const CONFIG = {
    DB_NAME: 'ILS_V3_DB',
    DB_VERSION: 3.17,
    STORES: {
        PROJECTS: 'projects',
        CONTENTS: 'contents',
        CATEGORIES: 'categories',
        USER_PROFILE: 'userProfile'
    },
    EXPORT_TYPE_ID: 'ILS_PROJECT_EXPORT_V2',
    LEVEL_THRESHOLDS: [0, 1000, 2500, 5000, 10000, 20000, 40000, 80000, 160000, 320000],
    QUIZ_TYPE: {
        MULTIPLE_CHOICE: 'multiple_choice',
        SHORT_ANSWER: 'short_answer',
        SUBJECTIVE: 'subjective',
        CASE_BASED: 'case_based'
    },
    // Enumerations for common view names to avoid magic strings scattered throughout the code.  
    VIEW_NAMES: {
        DASHBOARD: 'dashboard',
        PROJECT_LIST: 'project_list',
        WORKSPACE: 'workspace',
        QUIZ: 'quiz',
        QUIZ_RESULT: 'quizResult',
        // 새 전역 검색 뷰를 추가합니다.
        GLOBAL_SEARCH: 'global_search'
    },
    // Enumerations for save status indicators.
    SAVE_STATUS: {
        IDLE: 'idle',
        SAVING: 'saving',
        SAVED: 'saved'
    },
    // Centralized action names to avoid magic strings scattered in HTML and JS.
    ACTIONS: {
        OPEN_PROJECT: 'open-project',
        EXPORT_PROJECT: 'export-project',
        DELETE_PROJECT_CONFIRM: 'delete-project-confirm',
        SAVE_TOC: 'save-toc',
        ADD_ROOT_CHAPTER: 'toc-add-root-item',
        DELETE_CHAPTER: 'toc-delete',
        EDIT_CHAPTER_TITLE: 'toc-edit-title'
        // Extend this list as needed for other actions
    },
    DEFAULT_PROJECT_SETTINGS: {},
    HISTORY_MAX_ITEMS: 20, // 저장할 최대 이력 개수
    HISTORY_AUTOSAVE_DELAY: 5000, // 자동 저장 딜레이 (ms)
    SNAPSHOT_TYPE: {
        MANUAL: 'manual',
        AUTO: 'auto',
    },
};

/**
 * ▼▼▼ [수정] Heroicons 렌더링 및 캐싱 유틸리티 (비동기 로딩 방식 적용) ▼▼▼
 */
const Heroicons = {
    /**
     * Cache rendered SVG strings for performance. The key is the original
     * Heroicons name and the optional class.
     */
    _cache: new Map(),
    /**
     * Mapping from Heroicons names used throughout this application to the
     * equivalent Feather icon names. If a name is not present, the same
     * name will be used directly. Update this map when adding new icons.
     */
    _nameMap: {
        // General actions
        'bars-3': 'menu',
        'bars-3-bottom-left': 'menu',
        'cog-6-tooth': 'settings',
        'academic-cap': 'book-open',
        'arrow-down-tray': 'download',
        'cloud-arrow-up': 'upload-cloud',
        'sparkles': 'star',
        'arrow-left-on-rectangle': 'log-out',
        'arrow-right-on-rectangle': 'log-in',
        'language': 'globe',
        'folder': 'folder',
        'trash': 'trash',
        'photo': 'image', // image 모드 탭 아이콘 추가
        'arrow-left-on-rectangle': 'log-out', // 번역 패널 레이아웃 아이콘
        'arrow-right-on-rectangle': 'log-in', // 번역 패널 레이아웃 아이콘
        'rectangle-group': 'layout', // 번역 패널 레이아웃 아이콘
        'tag': 'tag',
        'check-circle': 'check-circle',
        'exclamation-triangle': 'alert-triangle',
        'x-mark': 'x',
        'arrow-turn-down-right': 'corner-right-down',
        'user': 'user',
        'plus': 'plus',
        'plus-circle': 'plus-circle',
        'minus': 'minus',
        'minus-circle': 'minus-circle',
        'pencil-square': 'edit',
        'magnifying-glass': 'search',
        'bookmark': 'bookmark',
        'bookmark-square': 'bookmark',
        'paper-airplane': 'send',
        'arrow-up-right': 'arrow-up-right',
        'arrow-left': 'arrow-left',
        'arrow-right': 'arrow-right',
        'ellipsis-vertical': 'more-vertical',
        'ellipsis-horizontal': 'more-horizontal',
        'square-3-stack-3d': 'layers',
        'arrow-down-left': 'arrow-down-left',
        'arrow-path': 'repeat',
        'arrows-right-left': 'repeat',
        'arrows-up-down-left-right': 'move',
        'arrow-up': 'arrow-up',
        'arrow-down': 'arrow-down',
        'arrow-long-right': 'arrow-right',
        'information-circle': 'info',
        'microchip': 'cpu',
        'clock': 'clock',
        'question-mark-circle': 'help-circle',
        'chat-bubble-left': 'message-circle',
        'check-badge': 'check-circle',
        'arrow-long-left': 'arrow-left',
        'circle-stack': 'layers',
        'document': 'file-text',
        'document-text': 'file-text',
        'document-plus': 'file-plus',
        'document-duplicate': 'copy',
        'arrow-long-up': 'arrow-up',
        'arrow-long-down': 'arrow-down',
        'arrow-small-right': 'arrow-right',
        'arrow-small-left': 'arrow-left',
        'flag': 'flag',
        'arrow-right-circle': 'arrow-right-circle',
        'clipboard-document': 'file-text',
        'folder-plus': 'folder-plus',
        'exclamation-circle': 'alert-circle',
        'light-bulb': 'sun',
        'squares-2x2': 'grid',
        'x-circle': 'x-circle'
    },
    /**
     * Wait until the Feather icons script has been loaded. Because the
     * Feather script is loaded with defer in the head, it should be
     * available by the time module scripts run, but this method guards
     * against race conditions.
     */
    load() {
        return new Promise((resolve, reject) => {
            // 1. 이미 로드되었는지 먼저 확인
            if (window.feather && window.feather.icons) {
                resolve();
                return;
            }
            // 2. 5초의 타임아웃을 설정하여 무한 로딩 방지
            const timeout = setTimeout(() => {
                reject(new Error("아이콘 라이브러리(Feather) 로딩 시간 초과."));
            }, 5000);

            // 3. DOM이 준비되면 아이콘 객체가 있는지 확인
            document.addEventListener('DOMContentLoaded', () => {
                const timer = setInterval(() => {
                    if (window.feather && window.feather.icons) {
                        clearInterval(timer);
                        clearTimeout(timeout);
                        resolve();
                    }
                }, 50);
            });
        });
    },
    /**
     * Render a named icon. Accepts an optional `class` property in the
     * options to apply classes to the <svg> element. Other options like
     * `style` from the original Heroicons API are ignored because Feather
     * only provides a single style for each icon.
     *
     * @param {string} name - The Heroicons name used in the application.
     * @param {object} options - Rendering options; only `class` is used.
     * @returns {string} An SVG string representing the icon, or an empty
     * string if the icon cannot be found.
     */
    render(name, options = {}) {
        const {
            class: className = ''
        } = options;
        const cacheKey = `${name}-${className}`;
        if (this._cache.has(cacheKey)) {
            return this._cache.get(cacheKey);
        }
        const featherName = this._nameMap[name] || name;
        // If the Feather library or the specific icon is unavailable, return an empty string.
        if (!window.feather || !window.feather.icons || !window.feather.icons[featherName]) {
            return '';
        }
        let svgString = window.feather.icons[featherName].toSvg();
        if (className) {
            svgString = svgString.replace('<svg', `<svg class="${className}"`);
        }
        this._cache.set(cacheKey, svgString);
        return svgString;
    }
};

const state = {
    currentView: 'dashboard',
    projects: [],
    categories: [],
    tags: [],
    userProfile: {
        id: 'main',
        level: 1,
        xp: 0
    },
    activeProjectId: null,
    activeProject: null,
    activeChapterPath: null,
    activeChapterContent: null,
    activeContentsMap: new Map(),
    workspaceMode: 'view',
    quizState: null,
    tocCollapseState: {},
    currentFilter: {
        type: 'dashboard',
        id: null
    },
    currentSortOrder: 'updatedAt_desc',
    isLoading: true,
    isSidebarOpen: true,
    isMobileSidebarOpen: false,
    toasts: [],
    isKaTeXLoaded: false,
    searchResults: null,
    searchQuery: '',
    // 전역 검색용 상태 필드
    globalSearchQuery: '',
    globalSearchResults: null,
    // 전역 검색 결과 표시 개수: 기본 30개씩 보여주고 더보기 버튼으로 확장합니다.
    globalSearchVisibleCount: 30,
    // 전역 검색 전 상태를 복원하기 위한 이전 뷰 기억
    previousView: null,
    sidebarCollapseState: {
        categories: false,
        tags: false
    },
    saveStatus: 'idle',
    saveTimestamp: null,
    workspaceLayout: 'split',
    viewPanelDisplayMode: 'auto',
    quizResultFilter: 'all',
    scrollPositions: {},
    isActionRailOpen: false,
    contextMenu: {
        isOpen: false,
        x: 0,
        y: 0,
        selectedText: '',
        openedAt: 0
    },
     tocContextMenu: {
        isOpen: false,
        x: 0, 
        y: 0,
        path: null // Tracks which item was right-clicked
    },
};

// -----------------------------------------------------------------------------------
// State listeners and subscription API
//
// To decouple the rendering logic from the logic that mutates state, we provide a
// simple publish/subscribe mechanism. Components can register listeners that will
// be invoked whenever the state changes via `setState`. This ensures a single
// centralized location for state updates and allows for future extensibility
// (e.g., logging, undo stack, etc.).
const stateListeners = [];

/**
 * Subscribe to state updates. The provided callback will be called with the
 * updated state whenever `setState` is invoked.
 *
 * @param {Function} listener - A callback function receiving the new state.
 */
function addStateListener(listener) {
    if (typeof listener === 'function') {
        stateListeners.push(listener);
    }
}

/**
 * Unsubscribe a previously registered state listener.
 *
 * @param {Function} listener - The previously registered callback.
 */
function removeStateListener(listener) {
    const idx = stateListeners.indexOf(listener);
    if (idx !== -1) stateListeners.splice(idx, 1);
}

// Centralized state update helper. It merges the provided updates into the global state
// and triggers a re-render. This reduces scattered direct assignments and keeps state
// transitions predictable. Over time, existing code should be refactored to use
// this helper instead of directly mutating the `state` object followed by
// explicit calls to View.render().
function setState(updates) {
    // Only accept objects for updates; ignore falsy or non-object values.
    if (!updates || typeof updates !== 'object') return;
    // Create a new state object by shallow merging the current state and updates.
    // This encourages immutability: components should treat the state as if it were
    // immutable, even though the underlying object is updated in place for simplicity.
    const newState = { ...state, ...updates };
    Object.assign(state, newState);
    // Notify all subscribers of the new state. Each listener decides how to react
    // (e.g., re-rendering a view). This decouples state updates from view logic.
    for (const listener of stateListeners) {
        try {
            listener(state);
        } catch (err) {
            console.error('State listener error:', err);
        }
    }
}

let fuse = null;
// Fuse 인스턴스: 프로젝트 검색과 별개로 전역 검색 인덱스를 유지하기 위한 전역 변수입니다.
let globalFuse = null;

const DB = {
    db: null,
    init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(CONFIG.DB_NAME, CONFIG.DB_VERSION);
            request.onerror = (e) => {
                console.error("IndexedDB error:", e.target.error);
                reject("데이터베이스 초기화 실패. 웹 브라우저의 로컬 파일(file://) 보안 정책으로 인해 발생할 수 있습니다. 정상적인 사용을 위해서는 로컬 웹 서버(예: Live Server)를 통해 접속하거나, 크롬 개발자 도구의 'LocalOverides' 기능을 사용해 보세요.");
            };
            request.onsuccess = (e) => {
                this.db = e.target.result;
                resolve(this.db);
            };
            request.onupgradeneeded = (e) => {
                const db = e.target.result;
                Object.values(CONFIG.STORES).forEach(name => {
                    if (!db.objectStoreNames.contains(name)) db.createObjectStore(name, {
                        keyPath: 'id'
                    });
                });
            };
        });
    },
    async get(storeName, key) {
        return new Promise((resolve, reject) => {
            const req = this.db.transaction(storeName).objectStore(storeName).get(key);
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    },
    async getAll(storeName) {
        return new Promise((resolve, reject) => {
            const req = this.db.transaction(storeName).objectStore(storeName).getAll();
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        });
    },
    // DB.put 메서드 수정
    async put(storeName, data) {
        return new Promise((resolve, reject) => {
            const req = this.db.transaction(storeName, 'readwrite').objectStore(storeName).put(data);
            req.onsuccess = () => {
                // [수정] 성공 시 변경 사실을 방송합니다.
                SyncManager.broadcastUpdate({ storeName, key: data.id });
                resolve(req.result);
            };
            req.onerror = () => reject(req.error);
        });
    },

    // DB.delete 메서드 수정
    async delete(storeName, key) {
        return new Promise((resolve, reject) => {
            const req = this.db.transaction(storeName, 'readwrite').objectStore(storeName).delete(key);
            req.onsuccess = () => {
                // [수정] 성공 시 변경 사실을 방송합니다.
                SyncManager.broadcastUpdate({ storeName, key });
                resolve(true);
            };
            req.onerror = () => reject(req.error);
        });
    },
    async getProjectContents(projectId) {
        return new Promise((resolve, reject) => {
            try {
                const tx = this.db.transaction(CONFIG.STORES.CONTENTS);
                const store = tx.objectStore(CONFIG.STORES.CONTENTS);
                const index = store.index('project_fk_idx');
                const req = index.getAll(projectId);
                req.onsuccess = () => {
                    const result = req.result;
                    // If no contents were found via the projectId index, fall back to scanning
                    // by the ID prefix. This supports older imports that do not include the
                    // projectId property on their content records.
                    if (result && result.length > 0) {
                        resolve(result);
                    } else {
                        // Use IDBKeyRange to fetch all keys with the `${projectId}_` prefix
                        const range = IDBKeyRange.bound(`${projectId}_`, `${projectId}_\uffff`);
                        const altReq = this.db.transaction(CONFIG.STORES.CONTENTS).objectStore(CONFIG.STORES.CONTENTS).getAll(range);
                        altReq.onsuccess = () => resolve(altReq.result);
                        altReq.onerror = () => reject(altReq.error);
                    }
                };
                req.onerror = () => reject(req.error);
            } catch (error) {
                // Fallback to full scan if index is not available
                const range = IDBKeyRange.bound(`${projectId}_`, `${projectId}_\uffff`);
                const req = this.db.transaction(CONFIG.STORES.CONTENTS).objectStore(CONFIG.STORES.CONTENTS).getAll(range);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            }
        });
    },
    async deleteProjectAndContents(projectId) {
        const contents = await this.getProjectContents(projectId);
        const deletePromises = contents.map(c => this.delete(CONFIG.STORES.CONTENTS, c.id));
        deletePromises.push(this.delete(CONFIG.STORES.PROJECTS, projectId));
        await Promise.all(deletePromises);
    }
};

const Utils = {
    generateId: (prefix) => `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    debounce: (func, delay) => {
        let timeout;
        return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), delay);
        };
    },
    mergeCustomItems(savedItems = [], defaultItems = []) {
        const savedItemMap = new Map(savedItems.map(item => [item.id, item]));
        const mergedItems = [...savedItems];

        // 기본 아이템 목록을 순회하며, 저장된 목록에 없는 아이템만 추가합니다.
        defaultItems.forEach(defaultItem => {
            if (!savedItemMap.has(defaultItem.id)) {
                mergedItems.push(JSON.parse(JSON.stringify(defaultItem))); // 원본 수정을 막기 위해 복사본 추가
            }
        });

        return mergedItems;
    },
    naturalSort: (a, b) => {
        const re = /(\d+)/g;
        const ax = String(a).split(re);
        const bx = String(b).split(re);
        for (let i = 0; i < Math.min(ax.length, bx.length); i++) {
            const aPart = ax[i];
            const bPart = bx[i];
            if (i % 2 === 1) {
                const aNum = parseInt(aPart, 10);
                const bNum = parseInt(bPart, 10);
                if (aNum !== bNum) return aNum - bNum;
            } else {
                if (aPart !== bPart) return aPart.localeCompare(bPart);
            }
        }
        return ax.length - bx.length;
    },
    createTocNode(title) {
        return {
            title: title,
            contentId: Utils.generateId('content'), // 고유 콘텐츠 ID 생성
            children: []
        };
    },
    formatTitle: (name) => name.replace(/\.(zip|json|html?|txt)$/i, '').replace(/^Chapter_(\d+)_/, 'Chapter $1: ').replace(/_/g, ' '),
    getAllNodePaths: (tocNode, path = []) => {
        if (!tocNode || !tocNode.children) return [];
        let paths = [];
        tocNode.children.forEach((child, index) => {
            const currentPath = [...path, index];
            paths.push({
                path: currentPath.join('.'),
                node: child
            });
            if (child.children && child.children.length > 0) {
                paths = paths.concat(Utils.getAllNodePaths(child, currentPath));
            }
        });
        return paths;
    },
    getFlatToc: (tocNode) => Utils.getAllNodePaths(tocNode),
    getNodeByPath: (toc, path) => {
        if (path === null || path === undefined) return null;
        const parts = path.split('.').map(Number);
        let node = toc;
        for (const part of parts) {
            if (node && node.children && node.children[part]) {
                node = node.children[part];
            } else {
                return null;
            }
        }
        return node;
    },
    getParentNodeAndIndexByPath: (toc, path) => {
        if (!path) return {
            parent: null,
            index: -1
        };
        const parts = path.split('.').map(Number);
        if (parts.length === 1) return {
            parent: toc,
            index: parts[0]
        };
        const parentPath = parts.slice(0, -1).join('.');
        const parent = Utils.getNodeByPath(toc, parentPath);
        const index = parts[parts.length - 1];
        return {
            parent,
            index
        };
    },
    normalizeTocNode: (node) => {
        if (!node) return;
        if (!node.children) {
            node.children = [];
        }
        if (node.children.length > 0) {
            node.children.forEach(Utils.normalizeTocNode);
        }
    },
    generateTocText: (node, level = 0, currentPath = '', activePath = '') => {
        let text = '';
        if (node && node.children) {
            node.children.forEach((child, index) => {
                const path = currentPath ? `${currentPath}.${index}` : `${index}`;
                const isActive = path === activePath;
                const prefix = '  '.repeat(level);
                const indicator = isActive ? '▶ ' : (child.children && child.children.length > 0 ? '+ ' : '- ');
                text += `${prefix}${indicator}${child.title}\n`;
                if (child.children && child.children.length > 0) {
                    text += Utils.generateTocText(child, level + 1, path, activePath);
                }
            });
        }
        return text;
    },
    customBoldParser: (text) => {
            if (!text || typeof text !== 'string') return '';
            
            // 정규식을 사용하여 **로 둘러싸인 텍스트('**' 사이의 모든 문자)를 찾아
            // <strong> 태그로 감싸줍니다.
            // (.*?)는 가장 가까운 다음 '**'까지의 내용만 선택(non-greedy)하도록 합니다.
            // 'g' 플래그는 문자열 전체에서 일치하는 모든 부분을 찾아서 바꿉니다.
            return text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
        },
    parseEmojiAndLabel(name) {
            if (!name) return { emoji: null, label: '' };
            // 복잡한 유니코드 이모티콘을 처리하기 위한 정규식
            const emojiRegex = /^(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff]|[\u0023-\u0039]\ufe0f?\u20e3|\u3299|\u3297|\u303d|\u3030|\u24c2|\ud83c[\udd70-\udd71]|\ud83c[\udd7e-\udd7f]|\ud83c\udd8e|\ud83c[\udd91-\udd9a]|\ud83c[\udde6-\uddff]|\ud83c[\ude01-\ude02]|\ud83c\ude1a|\ud83c\ude2f|\ud83c[\ude32-\ude3a]|\ud83c[\ude50-\ude51]|\u203c|\u2049|[\u25aa-\u25ab]|\u25b6|\u25c0|[\u25fb-\u25fe]|\u00a9|\u00ae|\u2122|\u2139|\ud83c\udc04|[\u2600-\u26ff]|\u2b05|\u2b06|\u2b07|\u2b1b|\u2b1c|\u2b50|\u2b55|\u231a|\u231b|\u2328|\u23cf|[\u23e9-\u23f3]|[\u23f8-\u23fa]|\ud83c\udccf|\u2934|\u2935|[\u2190-\u21ff])/;
            const match = name.match(emojiRegex);
            if (match) {
                return {
                    emoji: match[0],
                    label: name.substring(match[0].length).trim()
                };
            }
            return { emoji: null, label: name };
        },
    formatCount(num) {
            if (num < 1000) {
                return num.toLocaleString();
            }
            const thousands = num / 1000;
            // .replace(/\.0$/, '')는 '2.0k'를 '2k'로 만들어줍니다.
            return thousands.toFixed(1).replace(/\.0$/, '') + 'k';
    },
};

const SyncManager = {
    channel: null,
    tabId: Utils.generateId('tab'), // 각 탭을 식별하기 위한 고유 ID
    reloadHandler: null,

    init(handler) {
        // BroadcastChannel을 지원하는지 확인
        if ('BroadcastChannel' in window) {
            this.reloadHandler = handler;
            this.channel = new BroadcastChannel('ILS_SYNC_CHANNEL');
            this.channel.onmessage = (event) => {
                // 자신이 보낸 메시지는 무시하여 무한 루프 방지
                if (event.data.sourceTabId === this.tabId) {
                    return;
                }
                
                console.log(`[SyncManager] 다른 탭(${event.data.sourceTabId})으로부터 상태 변경 알림 수신`, event.data);
                
                // 등록된 핸들러(데이터 새로고침 및 UI 렌더링)를 실행
                if (typeof this.reloadHandler === 'function') {
                    this.reloadHandler(event.data.payload);
                }
            };
            console.log(`[SyncManager] 채널에 참여했습니다. (탭 ID: ${this.tabId})`);
        } else {
            console.warn('이 브라우저는 BroadcastChannel API를 지원하지 않아 탭 간 실시간 동기화가 비활성화됩니다.');
        }
    },

    broadcastUpdate(payload = {}) {
        // 채널이 열려있으면 메시지를 방송
        if (this.channel) {
            this.channel.postMessage({
                sourceTabId: this.tabId,
                payload: payload
            });
        }
    }
};

const ModalManager = {
    el: document.getElementById('modal-root'),
    isOpen: false,
    type: '',
    data: {},
    renderFunctions: {},

    init() {
        this.renderFunctions = {
            'newProject': this.renderNewProjectModal,
            'confirm': this.renderConfirmModal,
            'settings': this.renderSettingsModal,
            'apiKey': this.renderApiKeyModal,
            'manageQuiz': this.renderManageQuizModal,
            'manageToc': this.renderManageTocModal,
            'splitChapter': this.renderSplitChapterModal,
            'promptVariables': this.renderPromptVariablesModal,
            'manageHistory': this.renderManageHistoryModal,
            // Generic input prompt modal registration. This key maps to a modal used for collecting user input.
            'inputPrompt': this.renderInputPromptModal,
            'addFootnote': this.renderAddFootnoteModal,
        };
    },
    // ModalManager 객체 내부에 아래 5개 함수를 추가/교체하세요.
    renderAddFootnoteModal() {
        return `
            <form data-action="submit-add-footnote">
                <div class="p-6">
                    <div class="flex justify-between items-start">
                        <h3 class="text-xl font-semibold text-slate-900 mb-4">각주 추가</h3>
                        <button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button>
                    </div>
                    
                    <div class="space-y-4">
                        <div>
                            <label for="footnote-key-input" class="block text-sm font-medium text-slate-700">각주 키 (선택 사항)</label>
                            <input type="text" id="footnote-key-input" name="footnote-key-input"
                                class="mt-1 block w-full rounded-md border-slate-300 shadow-sm"
                                placeholder="비워두면 자동으로 번호 부여 (예: 1, 2, 3...)">
                        </div>
                        <div>
                            <label for="footnote-content-input" class="block text-sm font-medium text-slate-700">각주 내용</label>
                            <textarea id="footnote-content-input" name="footnote-content-input" rows="4"
                                    class="mt-1 block w-full rounded-md border-slate-300 shadow-sm"
                                    placeholder="각주에 표시될 내용을 입력하세요." required></textarea>
                        </div>
                    </div>
                </div>
                <div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg border-t">
                    <button type="button" data-action="close-modal" class="btn btn-secondary">취소</button>
                    <button type="submit" class="btn">각주 추가</button>
                </div>
            </form>
        `;
    },
    // [신규] 목차 리스트와 하단 컨트롤 영역의 HTML만 생성하는 헬퍼 함수
    renderTocModalContent() {
        // 헬퍼 함수: 재귀적으로 각 목차 노드를 HTML로 렌더링
        const renderNode = (node, path) => {
            const hasChildren = node.children && node.children.length > 0;
            const isSelected = this.data.selectedTocPaths.has(path);
            const iconName = hasChildren ? 'folder' : 'document-text';
            const selectedClasses = isSelected ? 'bg-indigo-100 border-indigo-300' : 'hover:bg-slate-100';
            const itemClasses = `toc-item my-1 group toc-drag-item ${isSelected ? 'selected' : ''}`;

            return `<li draggable="true" data-path="${path}" class="${itemClasses}">
                        <div data-action="toc-editor-click" data-path="${path}" class="flex items-center p-1.5 border border-transparent rounded-md cursor-pointer ${selectedClasses}">
                            ${Heroicons.render(iconName, { class: 'w-4 h-4 mr-2 text-slate-500 flex-shrink-0' })}
                            <input type="text" value="${DOMPurify.sanitize(node.title)}" data-path="${path}"
                                   class="flex-grow bg-transparent focus:bg-white focus:ring-1 focus:ring-indigo-500 rounded-sm px-1 py-0.5 text-sm"
                                   readonly>
                            <div class="flex items-center space-x-1 ml-2 opacity-50 group-hover:opacity-100 transition-opacity">
                                <button data-action="toc-add-child" data-path="${path}" title="하위 항목 추가" class="p-1 rounded hover:bg-slate-200">${Heroicons.render('plus', { class: 'w-4 h-4 text-slate-600' })}</button>
                            </div>
                        </div>
                        ${hasChildren ? `<ul class="pl-4 border-l border-slate-200">${node.children.map((child, index) => renderNode(child, `${path}.${index}`)).join('')}</ul>` : ''}
                    </li>`;
        };

        const editableToc = this.data.editableToc;
        if (!editableToc || !editableToc.children) return '<div>목차를 불러올 수 없습니다.</div>';
        const tocHtml = `<ul id="toc-editor-list" class="space-y-1">${editableToc.children.map((child, index) => renderNode(child, String(index))).join('')}</ul>`;
        const selectedCount = this.data.selectedTocPaths.size;

        const footerControls = `
            <div class="flex-shrink-0 pt-4 border-t flex justify-between items-center">
                <span class="text-sm text-slate-500">${selectedCount > 0 ? `${selectedCount}개 항목 선택됨` : '항목을 클릭하거나 드래그하세요.'}</span>
                <div>
                    <button data-action="toc-add-root-item" class="btn btn-secondary mr-2">${Heroicons.render('plus', { class: 'w-4 h-4 mr-2' })}최상위 항목 추가</button>
                    <button data-action="toc-context-delete" class="btn btn-danger" ${selectedCount === 0 ? 'disabled' : ''}>${Heroicons.render('trash', { class: 'w-4 h-4 mr-2' })}선택 항목 삭제</button>
                </div>
            </div>`;
        
        return `<div class="flex-grow min-h-0 overflow-y-auto pr-2 border rounded-lg p-2 bg-slate-50 mb-4" id="toc-scroll-container">
                    ${tocHtml}
                </div>
                ${footerControls}`;
    },

    // [신규] 스크롤 점프 현상을 막기 위한 부분 업데이트 함수
    updateTocView() {
        const target = document.getElementById('toc-modal-content');
        if (target) {
            // safeMorphdom을 사용해 변경된 부분만 지능적으로 업데이트
            safeMorphdom(target, this.renderTocModalContent());
        }
    },
    
    // [수정] renderManageTocModal: 부분 렌더링을 위한 컨테이너 ID 추가
    renderManageTocModal() {
        return `<div class="p-6 flex flex-col h-[80vh]">
                    <div class="flex-shrink-0 flex justify-between items-start mb-4">
                        <h3 class="text-xl font-semibold text-slate-900">목차 관리</h3>
                        <button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button>
                    </div>
                    <div id="toc-modal-content" class="flex-grow min-h-0 flex flex-col">
                        ${this.renderTocModalContent()}
                    </div>
                </div>
                <div class="flex-shrink-0 bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg border-t">
                    <button type="button" data-action="close-modal" class="btn btn-secondary">취소</button>
                    <button type="button" data-action="save-toc" class="btn">변경사항 저장</button>
                </div>`;
    },
    renderSettingsResetTab() {
            return `
                <div>
                    <h2 class="text-xl font-bold text-slate-800">설정 초기화</h2>
                    <p class="text-sm text-slate-500 mt-1">프로젝트의 모든 설정을 기본값으로 되돌립니다. 이 작업은 되돌릴 수 없습니다.</p>

                    <div class="mt-8 p-6 border-l-4 border-red-400 bg-red-50 rounded-md">
                        <div class="flex">
                            <div class="flex-shrink-0">
                                ${Heroicons.render('exclamation-triangle', { class: 'h-5 w-5 text-red-500' })}
                            </div>
                            <div class="ml-3">
                                <h3 class="text-md font-semibold text-red-800">위험 영역</h3>
                                <div class="mt-2 text-sm text-red-700">
                                    <p>이 작업을 계속하면 현재 프로젝트의 모든 프롬프트, 커스텀 버튼, 컨텍스트 메뉴 설정이 영구적으로 삭제되고 시스템 기본값으로 대체됩니다. 일반 설정(이름, 카테고리 등)은 영향을 받지 않습니다.</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="mt-6">
                        <label for="reset-confirmation" class="block text-sm font-medium text-slate-700">계속하려면 "초기화"를 입력하세요.</label>
                        <input type="text" id="reset-confirmation" 
                               data-action="handle-reset-confirmation-input"
                               class="mt-1 block w-full rounded-md border-slate-300 shadow-sm"
                               autocomplete="off">
                    </div>

                    <div class="mt-6">
                        <button id="reset-settings-btn"
                                type="button"
                                data-action="confirm-reset-settings"
                                class="btn btn-danger w-full justify-center" disabled>
                            이 프로젝트 설정 초기화
                        </button>
                    </div>
                </div>
            `;
        },
    open(type, data = {}) {
        if (window.innerWidth <= 1024) Controller.closeSidebar();
        this.isOpen = true;
        this.type = type;
        this.data = data;
        this.render();
    },

    close() {
        this.isOpen = false;
        this.type = '';
        this.data = {};
        this.render();
    },

    render() {
    if (!this.isOpen) {
        this.el.innerHTML = '';
        return;
    }
    const renderer = this.renderFunctions[this.type];
    if (typeof renderer === 'function') {
        const contentHtml = renderer.call(this);
        // [수정] 모달 타입이 'settings'일 경우 넓은 클래스를 추가합니다.
        const containerClass = this.type === 'settings' ? 'modal-container modal-container-large' : 'modal-container';
        this.el.innerHTML = `<div class="modal-overlay show" data-action="close-modal-overlay"><div class="${containerClass}">${contentHtml}</div></div>`;
    } else {
        this.el.innerHTML = '';
        console.error(`Modal type "${this.type}" not found.`);
    }
    Controller.bindDynamicEventListeners();
},
    renderManageHistoryModal() {
        const history = this.data.history || [];
        const activeContent = this.data.activeContent;
        const renderContentSummary = (content) => {
            const manuscript = content.manuscript?.substring(0, 100).replace(/\n/g, ' ') || 'No manuscript';
            const notes = content.notes?.substring(0, 50).replace(/\n/g, ' ') || 'No notes';
            const questions = content.questions?.length > 0 ? `${content.questions.length} questions` : 'No quizzes';
            return `<div class="text-xs text-slate-500 truncate">
                        <span class="font-semibold text-slate-700">원고:</span> ${manuscript}... <br>
                        <span class="font-semibold text-slate-700">메모:</span> ${notes}... <br>
                        <span class="font-semibold text-slate-700">퀴즈:</span> ${questions}
                    </div>`;
        };

        const historyHtml = history.map((h, index) => {
            const date = new Date(h.timestamp).toLocaleString();
            const isCurrent = index === 0;
            const isManual = h.type === CONFIG.SNAPSHOT_TYPE.MANUAL;
            const typeIcon = isManual ? Heroicons.render('bookmark', { class: 'w-4 h-4 text-indigo-500' }) : Heroicons.render('clock', { class: 'w-4 h-4 text-slate-500' });
            const typeLabel = isManual ? '수동 스냅샷' : '자동 스냅샷';

            return `
                <div class="p-3 my-2 border rounded-md bg-slate-50 flex flex-col sm:flex-row justify-between items-start sm:items-center">
                    <div class="flex-grow min-w-0 pr-4">
                        <p class="font-semibold text-sm text-slate-800 flex items-center gap-2">
                            ${typeIcon}
                            ${isCurrent ? '현재 버전' : `${history.length - 1 - index}번째 이전 이력`}
                            <span class="text-xs text-slate-500 ml-2">(${typeLabel})</span>
                        </p>
                        <p class="text-xs text-slate-500">${date}</p>
                        ${renderContentSummary(h.content)}
                    </div>
                    <div class="flex-shrink-0 mt-2 sm:mt-0 flex gap-2">
                        <button data-action="compare-history" data-index="${index}" class="btn btn-secondary btn-sm">
                            ${Heroicons.render('arrows-right-left', { class: 'w-4 h-4' })} 비교
                        </button>
                        ${!isCurrent ? `
                        <button data-action="revert-history" data-index="${index}" class="btn btn-danger btn-sm">
                            ${Heroicons.render('arrow-path', { class: 'w-4 h-4' })} 되돌리기
                        </button>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        return `
            <div class="p-6">
                <div class="flex justify-between items-start">
                    <h3 class="text-xl font-semibold text-slate-900 mb-4">챕터 이력 관리</h3>
                    <button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button>
                </div>
                <div class="max-h-[60vh] overflow-y-auto border rounded-lg p-2 bg-white mb-4">
                    ${history.length > 0 ? historyHtml : '<p class="text-sm text-slate-500 text-center py-4">저장된 이력이 없습니다.</p>'}
                </div>
            </div>`;
    },
    renderPromptVariablesModal() {
        const { title, variables, isLoading = false, loadingMessage = '' } = this.data;
        if (isLoading) {
            return `<div class="p-8">${View.renderSpinner(loadingMessage)}</div>`;
        }
        
        const variablesHtml = variables.map(v => `
            <div class="mb-4">
                <label for="var-${v}" class="block text-sm font-medium text-slate-700">{{${v}}}</label>
                <input type="text" id="var-${v}" name="${v}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm" placeholder="변수에 들어갈 값 입력">
            </div>
        `).join('');

        return `
            <form data-action="submit-prompt-variables">
                <div class="p-6">
                    <div class="flex justify-between items-start">
                        <h3 class="text-xl font-semibold text-slate-900 mb-4">${DOMPurify.sanitize(title)}</h3>
                        <button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button>
                    </div>
                    <p class="text-sm text-slate-600 mb-4">프롬프트에 필요한 추가 변수 값을 입력해주세요.</p>
                    <div class="max-h-[60vh] overflow-y-auto pr-2">
                        ${variablesHtml}
                    </div>
                </div>
                <div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg">
                    <button type="button" data-action="close-modal" class="btn btn-secondary">취소</button>
                    <button type="submit" class="btn">복사</button>
                </div>
            </form>
        `;
    },

    /**
     * Render a generic input prompt modal.
     * This modal consists of a title, optional description, an input box and customizable confirm button label.
     * The confirm button reuses the existing 'confirm-action' handler to trigger the provided onConfirm callback.
     */
    renderInputPromptModal() {
        const { title = '입력', message = '', placeholder = '', confirmText = '확인' } = this.data;
        return `
            <form data-action="input-prompt-form">
                <div class="p-6">
                    <div class="flex justify-between items-start">
                        <h3 class="text-xl font-semibold text-slate-900 mb-4">${DOMPurify.sanitize(title)}</h3>
                        <button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button>
                    </div>
                    ${message ? `<p class="text-sm text-slate-600 mb-4">${DOMPurify.sanitize(message)}</p>` : ''}
                    <input type="text" id="input-prompt-value" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm" placeholder="${DOMPurify.sanitize(placeholder)}" autofocus>
                </div>
                <div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg">
                    <button type="button" data-action="close-modal" class="btn btn-secondary">취소</button>
                    <button type="button" data-action="confirm-action" class="btn">${DOMPurify.sanitize(confirmText)}</button>
                </div>
            </form>
        `;
    },

    /**
     * Display an input prompt and return a promise that resolves with the trimmed user input.
     * The provided options configure the modal content. If the user cancels, the promise resolves with an empty string.
     *
     * @param {Object} options
     * @param {String} options.title - Title for the modal.
     * @param {String} options.message - Optional description.
     * @param {String} options.placeholder - Placeholder text for the input.
     * @param {String} options.confirmText - Label for the confirm button.
     */
    async showInputPrompt({ title = '입력', message = '', placeholder = '', confirmText = '확인' } = {}) {
        return new Promise(resolve => {
            this.open('inputPrompt', {
                title,
                message,
                placeholder,
                confirmText,
                onConfirm: () => {
                    const inputEl = document.getElementById('input-prompt-value');
                    resolve(inputEl ? inputEl.value.trim() : '');
                }
            });
        });
    },
    renderNewProjectModal() {
        const {
            activeTab = 'blank', isLoading = false, loadingMessage = '', error = ''
        } = this.data;
        if (isLoading) {
            return `<div class="p-8">${View.renderSpinner(loadingMessage)}</div>`;
        }

        const tabButton = (id, label) => `<button type="button" data-action="switch-modal-tab" data-tab="${id}" class="px-3 py-2 text-sm font-medium rounded-md ${activeTab === id ? 'bg-indigo-100 text-indigo-700' : 'text-slate-500 hover:bg-slate-100'}">${label}</button>`;
        const fileInputTemplate = (id, accept, labelId, description) => `<p class="text-sm text-slate-600 mb-2">${description}</p><label for="${id}" class="cursor-pointer"><div data-dropzone-for="${id}" class="drop-zone w-full p-8 rounded-lg text-center bg-slate-50 hover:bg-slate-100"><div class="flex flex-col items-center justify-center space-y-2 pointer-events-none">${Heroicons.render('cloud-arrow-up', { class: 'w-12 h-12 text-slate-400' })}<p class="text-slate-700 font-medium">파일을 드래그하거나 <span class="text-indigo-600">클릭하여 선택</span>하세요</p><p id="${labelId}" class="text-sm text-slate-500 truncate max-w-full" title="선택된 파일 없음">선택된 파일 없음</p></div><input type="file" id="${id}" accept="${accept}" class="hidden" data-target-label="${labelId}"/></div></label>`;
        const tabContent = () => {
            switch (activeTab) {
                case 'blank':
                    return `<p class="text-sm text-slate-600 mb-2">새로운 빈 프로젝트를 시작합니다.</p>
                                <div>
                                    <label for="blank-project-name" class="block text-sm font-medium text-slate-700">프로젝트 이름</label>
                                    <input type="text" id="blank-project-name" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm" required>
                                </div>
                                <div class="mt-4">
                                    <label for="blank-project-category" class="block text-sm font-medium text-slate-700">카테고리 (선택)</label>
                                    <select id="blank-project-category" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm">
                                        <option value="">미분류</option>
                                        ${state.categories.map(c => `<option value="${c.id}">${c.name}</option>`).join('')}
                                    </select>
                                </div>`;
                case 'zip':
                    return fileInputTemplate('zip-upload', '.zip', 'zip-file-label', 'HTML 또는 TXT 파일들이 포함된 ZIP 파일을 업로드하세요.');
                case 'jsonFile':
                    return fileInputTemplate('json-upload', '.json', 'json-file-label', '이전에 내보냈던 프로젝트(.json) 파일을 가져옵니다.');
                case 'jsonText':
                    return `<p class="text-sm text-slate-600 mb-2">프로젝트 내보내기(.json) 파일의 텍스트를 붙여넣으세요.</p><textarea id="json-text-input" placeholder='{"type": "ILS_PROJECT_EXPORT_V2", ...}' class="w-full h-40 p-2 border rounded-md font-mono text-sm"></textarea>${error ? `<p class="text-red-500 text-sm mt-2">${error}</p>` : ''}`;
                case 'tocJson':
                    return `<p class="text-sm text-slate-600 mb-2">책의 목차 구조를 나타내는 JSON 텍스트를 붙여넣으세요.</p><textarea id="toc-json-input" placeholder='{"title": "책 제목", "children": [...] }' class="w-full h-40 p-2 border rounded-md font-mono text-sm"></textarea>${error ? `<p class="text-red-500 text-sm mt-2">${error}</p>` : ''}`;
            }
        };
        return `<form data-action="submit-new-project"><div class="p-6"><div class="flex justify-between items-start"><h3 class="text-xl font-semibold text-slate-900 mb-4">새 프로젝트 생성</h3><button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button></div><div class="border-b border-gray-200"><div class="p-1 mb-4 inline-flex space-x-1 bg-slate-100 rounded-lg">${tabButton('blank', '빈 프로젝트')}${tabButton('zip', 'ZIP')}${tabButton('tocJson', '목차 JSON')}${tabButton('jsonFile', '파일(.json)')}${tabButton('jsonText', '텍스트(.json)')}</div></div><div class="mt-4">${tabContent()}</div></div><div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg"><button type="button" data-action="close-modal" class="btn btn-secondary">취소</button><button type="submit" class="btn">생성</button></div></form>`;
    },

    renderConfirmModal() {
        const {
            title,
            message,
            confirmText
        } = this.data;
        return `<div class="p-6"><div class="sm:flex sm:items-start"><div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-red-100 sm:mx-0 sm:h-10 sm:w-10">${Heroicons.render('exclamation-triangle', { class: 'h-6 w-6 text-red-600' })}</div><div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left"><h3 class="text-lg leading-6 font-medium text-gray-900">${title}</h3><div class="mt-2"><p class="text-sm text-gray-500">${message}</p></div></div></div></div><div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg"><button type="button" data-action="close-modal" class="btn btn-secondary">취소</button><button type="button" data-action="confirm-action" class="btn bg-red-600 hover:bg-red-700">${confirmText}</button></div>`;
    },

    renderSettingsModal() {
            const activeTab = this.data.activeTab || 'general';
            
            // 왼쪽 네비게이션 메뉴 아이템을 렌더링하는 헬퍼 함수
            const navItem = (id, icon, label) => `
                <button type="button" data-action="switch-settings-tab" data-tab="${id}" 
                        class="w-full flex items-center gap-3 px-3 py-2 text-sm rounded-md ${activeTab === id ? 'bg-slate-200 text-slate-800 font-semibold' : 'text-slate-600 hover:bg-slate-100'}">
                    ${Heroicons.render(icon, { class: 'w-5 h-5' })}
                    <span>${label}</span>
                </button>`;

            // 오른쪽 컨텐츠 영역을 렌더링하는 헬퍼 함수
            const renderTabContent = () => {
                switch (activeTab) {
                    case 'general':       return this.renderSettingsGeneralTab();
                    case 'prompts':       return this.renderSettingsPromptsTab();
                    case 'customButtons': return this.renderSettingsCustomItemsTab('prompt');
                    case 'contextMenus':  return this.renderSettingsCustomItemsTab('contextMenu');
                    case 'reset':         return this.renderSettingsResetTab(); // 초기화 탭 추가
                    default:              return '';
                }
            };
            
            // 최종 모달 HTML 구조
            return `
            <form data-action="save-settings" class="flex h-[80vh] min-h-[600px]">
                <div class="w-1/4 min-w-[200px] bg-slate-50 p-4 border-r border-slate-200 flex flex-col">
                    <h3 class="text-lg font-bold text-slate-900 mb-1">설정</h3>
                    <p class="text-xs text-slate-500 mb-6">프로젝트 '${DOMPurify.sanitize(state.activeProject.name)}'</p>
                    <nav class="space-y-1">
                        ${navItem('general', 'cog-6-tooth', '일반')}
                        ${navItem('prompts', 'document-text', '기본 프롬프트')}
                        ${navItem('customButtons', 'squares-plus', '커스텀 버튼')}
                        ${navItem('contextMenus', 'command-line', '컨텍스트 메뉴')}
                        ${navItem('reset', 'arrow-path', '초기화')}
                    </nav>
                    <div class="mt-auto">
                        <button type="button" data-action="close-modal" class="btn btn-secondary w-full">닫기</button>
                    </div>
                </div>

                <div class="w-3/4 flex flex-col">
                    <div class="flex-grow p-8 overflow-y-auto">
                        ${renderTabContent()}
                    </div>
                    <div class="bg-slate-50 px-8 py-4 border-t border-slate-200 flex justify-end">
                        <button type="submit" class="btn">변경사항 저장</button>
                    </div>
                </div>
            </form>`;
        },
    
    renderSettingsGeneralTab() {
        const categoryOptions = state.categories.map(c => `<option value="${c.id}" ${c.id === this.data.categoryId ? 'selected' : ''}>${c.name}</option>`).join('');
        const tagPills = (this.data.projectTags || []).map(tag => `<span class="inline-flex items-center gap-x-0.5 rounded-md bg-indigo-50 px-2 py-1 text-xs font-medium text-indigo-700">${tag}<button type="button" data-action="remove-tag" data-tag="${tag}" class="group relative -mr-1 h-3.5 w-3.5 rounded-sm hover:bg-indigo-500/20">${Heroicons.render('x-mark', { class: 'h-3.5 w-3.5 text-indigo-600 hover:text-indigo-700' })}</button></span>`).join('');
        const fields = [{
                id: 'name',
                label: '프로젝트 이름',
                value: this.data.name,
                type: 'text'
            },
            {
                id: 'categoryId',
                label: '카테고리',
                type: 'select',
                options: categoryOptions
            },
            {
                id: 'tags',
                label: '태그',
                type: 'tags',
                pills: tagPills
            }
        ];
        return fields.map(f => {
            let fieldHtml = '';
            let fieldId = `setting-${f.id}`;
            switch (f.type) {
                case 'select':
                    fieldHtml = `<select id="${fieldId}" data-setting-key="${f.id}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm"><option value="">미분류</option>${f.options}</select>`;
                    break;
                case 'tags':
                    fieldId = 'setting-tags-input';
                    fieldHtml = `<div class="relative"><input type="text" id="${fieldId}" autocomplete="off" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm" placeholder="태그 입력 후 Enter..."><div id="tag-suggestions" class="absolute z-10 w-full bg-white border border-slate-300 rounded-md shadow-lg mt-1 hidden"></div><div id="tag-pills-container" class="mt-2 flex flex-wrap gap-2">${f.pills}</div></div>`;
                    break;
                default:
                    fieldHtml = `<input type="${f.type}" id="${fieldId}" data-setting-key="${f.id}" value="${DOMPurify.sanitize(f.value || '')}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm">`;
            }
            return `<div class="mb-4"><label for="${fieldId}" class="block text-sm font-medium text-slate-700">${f.label}</label>${fieldHtml}</div>`;
        }).join('');
    },

    renderSettingsPromptsTab() {
            // 헬퍼: 각 설정 필드를 렌더링하는 함수
            const renderField = (f) => {
                const fieldValue = this.data[f.id] || '';
                const fieldHtml = f.type === 'textarea' ?
                    `<textarea id="setting-${f.id}" data-setting-key="${f.id}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm h-24 font-mono text-xs">${fieldValue}</textarea>` :
                    `<input type="${f.type}" id="setting-${f.id}" data-setting-key="${f.id}" value="${DOMPurify.sanitize(fieldValue)}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm">`;

                // [수정] 버튼 대신 툴팁을 사용하는 아이콘으로 변경
                const helpIconHtml = f.hasVariables ? `
                    <span class="cursor-help" data-tooltip="${View.renderTooltipContent(f.variableType)}">
                        ${Heroicons.render('information-circle', { class: 'w-4 h-4 text-slate-400 hover:text-slate-600' })}
                    </span>
                ` : '';

                return `
                    <div class="mb-4">
                        <div class="flex justify-between items-center">
                            <label for="setting-${f.id}" class="block text-sm font-medium text-slate-700">${f.label}</label>
                            ${helpIconHtml}
                        </div>
                        ${fieldHtml}
                    </div>
                `;
            };

            // 필드 정의는 유지, variableType 추가
            const writingFields = [
                { id: 'writingGenre', label: '글쓰기 - 장르', type: 'text' },
                { id: 'writingAudience', label: '글쓰기 - 목표 독자', type: 'text' },
                { id: 'writingAgeGroup', label: '글쓰기 - 대상 연령층', type: 'text' },
                { id: 'writingStyle', label: '글쓰기 - 스타일', type: 'textarea' },
                { id: 'writingReferences', label: '글쓰기 - 자료', type: 'textarea' },
                { id: 'writingPrompt', label: '글쓰기 프롬프트 - 전체 템플릿', type: 'textarea', hasVariables: true, variableType: 'writing' }
            ];
            const quizFields = [
                { id: 'quizQuestionCount', label: '퀴즈 - 생성 개수', type: 'number' },
                { id: 'quizTaskDescription', label: '퀴즈 프롬프트 - 과업 설명', type: 'textarea' },
                { id: 'quizOutputFormatInstruction', label: '퀴즈 프롬프트 - 출력 형식', type: 'textarea' },
                { id: 'quizPromptTemplate', label: '퀴즈 프롬프트 - 전체 템플릿', type: 'textarea', hasVariables: true, variableType: 'quiz' }
            ];

            // 최종 HTML 구조는 동일
            return `
                <div class="space-y-6">
                    <div class="p-4 border border-slate-200 rounded-lg bg-white shadow-sm">
                        <h4 class="flex items-center text-md font-semibold text-slate-800 mb-2">
                            ${Heroicons.render('pencil-square', { class: 'w-5 h-5 mr-2 text-indigo-600' })} 글쓰기 프롬프트 설정
                        </h4>
                        <p class="text-sm text-slate-500 mb-4">AI 원고 생성, 요약, 번역 등 글쓰기 관련 기능에 사용될 기본 프롬프트를 설정합니다.</p>
                        <div class="border-t border-slate-200 pt-4">${writingFields.map(renderField).join('')}</div>
                    </div>
                    <div class="p-4 border border-slate-200 rounded-lg bg-white shadow-sm">
                        <h4 class="flex items-center text-md font-semibold text-slate-800 mb-2">
                            ${Heroicons.render('light-bulb', { class: 'w-5 h-5 mr-2 text-amber-500' })} 퀴즈 생성 프롬프트 설정
                        </h4>
                        <p class="text-sm text-slate-500 mb-4">학습 모드에서 사용될 AI 퀴즈 문제 생성 프롬프트를 설정합니다.</p>
                        <div class="border-t border-slate-200 pt-4">${quizFields.map(renderField).join('')}</div>
                    </div>
                </div>
            `;
        },

    renderSettingsCustomItemsTab(type) {
    const isPrompt = type === 'prompt';
    const title = isPrompt ? '커스텀 버튼' : '컨텍스트 메뉴';
    const items = (isPrompt ? this.data.customPrompts : this.data.contextMenuItems) || [];
    const addAction = isPrompt ? 'add-custom-prompt' : 'add-custom-context-menu';
    const removeAction = isPrompt ? 'remove-custom-prompt' : 'remove-custom-context-menu';
    const nameId = `new-${type}-name`;
    const templateId = `new-${type}-template`;
    const helpText = isPrompt ?
        `<ul class="list-disc list-inside space-y-1"><li><code class="bg-slate-200 px-1 rounded">{{bookTitle}}</code>, <code class="bg-slate-200 px-1 rounded">{{chapterTitle}}</code>, <code class="bg-slate-200 px-1 rounded">{{manuscript}}</code> 등 모든 변수 사용 가능</li></ul>` :
        `<ul class="list-disc list-inside space-y-1"><li><code class="bg-slate-200 px-1 rounded">{{selected_text}}</code>: 사용자가 선택한 텍스트로 치환됩니다.</li><li>이제 <code class="bg-slate-200 px-1 rounded">{{chapterTitle}}</code> 등 모든 변수도 함께 사용 가능합니다.</li></ul>`;

    const availableVarsTooltip = `
        사용 가능한 시스템 변수 목록:\n
        - {{bookTitle}}: 전체 프로젝트 제목
        - {{chapterTitle}}: 현재 챕터 제목
        - {{manuscript}}: 현재 챕터 원고
        - {{translation}}: 현재 챕터 번역문
        - {{notes}}: 현재 챕터 메모
        - {{selected_text}}: 선택된 텍스트 (컨텍스트 메뉴 전용)
        - {{fullToc}}: 전체 목차 구조
        - {{projectGenre}}: 프로젝트 장르 설정
        - ... 외 다수
    `.trim().replace(/\n\s+/g, '\n');

    const existingItemsHtml = items.map(item => `
                <div class="p-3 border rounded-lg flex justify-between items-center bg-white">
                    <div class="flex-1 min-w-0">
                        <p class="text-sm font-semibold text-slate-800 truncate">${item.name}</p>
                        <p class="text-xs text-slate-500 truncate mt-1 font-mono">${item.template}</p>
                    </div>
                    <button type="button" data-action="${removeAction}" data-id="${item.id}" class="p-2 rounded-full hover:bg-red-100 text-red-500 ml-4">
                        ${Heroicons.render('trash', { class: 'w-4 h-4' })}
                    </button>
                </div>
            `).join('');

    return `<div class="custom-items-layout">
        
        <div class="p-4 border border-slate-300 rounded-lg bg-slate-50 flex-shrink-0">
            <h4 class="text-md font-semibold text-slate-800 mb-3">새 ${title} 추가</h4>
            <div class="space-y-3">
                <div>
                    <label for="${nameId}" class="block text-xs font-medium text-slate-600">이름</label>
                    <input type="text" id="${nameId}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm text-sm" placeholder="${title} 이름">
                </div>
                <div>
                    <div class="flex items-center justify-between">
                         <label for="${templateId}" class="block text-xs font-medium text-slate-600">프롬프트 템플릿</label>
                         <span data-tooltip="${availableVarsTooltip}" class="cursor-help">
                            ${Heroicons.render('information-circle', { class: 'w-4 h-4 text-slate-400' })}
                         </span>
                    </div>
                    <textarea id="${templateId}" class="mt-1 block w-full rounded-md border-slate-300 shadow-sm h-24 font-mono text-xs" placeholder="프롬프트 템플릿 입력..."></textarea>
                </div>
            </div>
            <button type="button" data-action="${addAction}" class="btn w-full justify-center mt-4">${Heroicons.render('plus', { class: 'w-4 h-4 mr-2' })} 목록에 추가</button>
        </div>

        <div class="custom-items-list-wrapper">
            <h4 class="text-md font-semibold text-slate-800 mb-2">기존 ${title} 목록 (${items.length}개)</h4>
            <div class="space-y-2">
                ${items.length > 0 ? existingItemsHtml : `<p class="text-sm text-slate-500 text-center py-4">추가된 항목이 없습니다.</p>`}
            </div>
        </div>

        <div class="text-xs text-slate-500 p-3 bg-slate-100 rounded-md flex-shrink-0">
            <p class="font-semibold mb-1">참고:</p>
            ${helpText}
        </div>
    </div>`;
},
    renderApiKeyModal() {
        return `<form data-action="submit-api-key"><div class="p-6"><div class="flex items-start"><div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-indigo-100 sm:mx-0 sm:h-10 sm:w-10">${Heroicons.render('key', { style: 'solid', class: 'h-6 w-6 text-indigo-600' })}</div><div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left"><h3 class="text-lg leading-6 font-medium text-gray-900">Google AI API 키 입력</h3><div class="mt-2"><p class="text-sm text-gray-500">퀴즈 생성을 위해 Google AI Studio에서 발급받은 API 키를 입력해주세요.</p><input type="password" id="api-key-input" class="mt-2 block w-full rounded-md border-slate-300" placeholder="API 키를 여기에 붙여넣으세요"></div></div></div></div><div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg"><button type="button" data-action="close-modal" class="btn btn-secondary">취소</button><button type="submit" class="btn">확인</button></div></form>`;
    },

    renderManageQuizModal() {
            const questions = state.activeChapterContent.questions || [];
            // [수정] 인덱스 대신 ID를 사용합니다.
            const editingId = this.data.editingQuestionId;

            const renderQuestionItem = (q, index) => {
                // [수정] 인덱스 대신 ID로 수정 모드 여부를 판단합니다.
                if (q.id === editingId) {
                    const optionsHtml = q.type === 'multiple_choice' ? q.options.map((opt, optIndex) => `
                        <div class="flex items-center gap-2">
                            <input type="radio" id="q${index}-opt${optIndex}" name="q${index}-answer" data-option-index="${optIndex}" value="${DOMPurify.sanitize(opt)}" ${q.answer === opt ? 'checked' : ''} class="h-4 w-4 text-indigo-600 border-gray-300">
                            <input type="text" value="${DOMPurify.sanitize(opt)}" class="w-full p-1 border rounded-md text-sm" data-option-index="${optIndex}">
                        </div>
                    `).join('') : '';

                    return `
                    <div class="p-4 my-2 border-2 border-indigo-500 rounded-lg bg-indigo-50" data-question-id="${q.id}">
                        <form data-action="save-quiz-question">
                            <div class="space-y-3">
                                <div>
                                    <label class="block text-xs font-semibold text-slate-600 mb-1">질문 텍스트</label>
                                    <textarea name="questionText" class="w-full p-2 border rounded-md text-sm h-24">${q.questionText}</textarea>
                                </div>
                                ${q.type === 'multiple_choice' ? `
                                <div>
                                    <label class="block text-xs font-semibold text-slate-600 mb-1">선택지 (정답 체크)</label>
                                    <div class="space-y-2" id="options-container">${optionsHtml}</div>
                                </div>
                                ` : `
                                <div>
                                    <label class="block text-xs font-semibold text-slate-600 mb-1">정답</label>
                                    <input type="text" name="answer" value="${DOMPurify.sanitize(q.answer)}" class="w-full p-2 border rounded-md text-sm">
                                </div>
                                `}
                                <div>
                                    <label class="block text-xs font-semibold text-slate-600 mb-1">해설</label>
                                    <textarea name="explanation" class="w-full p-2 border rounded-md text-sm h-20">${q.explanation}</textarea>
                                </div>
                            </div>
                            <div class="mt-4 flex justify-end gap-2">
                                <button type="button" data-action="cancel-edit-quiz" class="btn btn-sm btn-secondary">취소</button>
                                <button type="submit" class="btn btn-sm">저장</button>
                            </div>
                        </form>
                    </div>`;
                }
                
                return `
                <div class="p-3 my-2 border rounded-md bg-slate-50 flex justify-between items-center group">
                    <p class="text-sm text-slate-800 truncate pr-4">${index + 1}. ${q.questionText}</p>
                    <div class="flex items-center opacity-0 group-hover:opacity-100 transition-opacity">
                        <button type="button" data-action="edit-quiz-question" data-id="${q.id}" class="p-1 text-slate-500 hover:text-indigo-600 rounded-full hover:bg-indigo-100">
                            ${Heroicons.render('pencil-square', { class: 'w-4 h-4' })}
                        </button>
                        <button type="button" data-action="delete-quiz-question" data-id="${q.id}" class="p-1 text-slate-500 hover:text-red-600 rounded-full hover:bg-red-100">
                            ${Heroicons.render('trash', { class: 'w-4 h-4' })}
                        </button>
                    </div>
                </div>`;
            };

            const questionsHtml = questions.map(renderQuestionItem).join('');

            return `
            <div class="p-6">
                <div class="flex justify-between items-start">
                    <h3 class="text-xl font-semibold text-slate-900 mb-4">퀴즈 관리</h3>
                    <button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button>
                </div>
                <div class="max-h-[60vh] overflow-y-auto border rounded-lg p-2 bg-white mb-4">
                    ${questions.length > 0 ? questionsHtml : '<p class="text-sm text-slate-500 text-center py-4">생성된 문제가 없습니다.</p>'}
                </div>
                <h4 class="text-lg font-semibold text-slate-800 border-t pt-4 mb-3">AI 프롬프트를 사용하여 문제 추가</h4>
                <p class="text-sm text-slate-600 mb-2">1. 아래 버튼으로 프롬프트를 복사하여 AI 도구(예: Google AI Studio)에 붙여넣고 결과를 생성하세요.</p>
                <button data-action="copy-quiz-prompt" class="btn w-full justify-center">${Heroicons.render('clipboard-document', { class: 'w-4 h-4 mr-2' })}AI 생성 프롬프트 복사</button>
                <form data-action="add-questions-from-json" class="mt-4">
                    <label for="quiz-json-paste" class="text-sm text-slate-600 mb-2 block">2. AI가 생성한 JSON 배열을 아래에 붙여넣고 '추가' 버튼을 누르세요.</label>
                    <textarea id="quiz-json-paste" name="jsonContent" class="w-full h-24 p-2 border rounded-md font-mono text-xs" placeholder="[ { ... } ]" required></textarea>
                    <div class="bg-slate-50 -mx-6 -mb-6 px-6 py-4 mt-6 flex justify-end space-x-3 rounded-b-lg">
                        <button type="button" data-action="close-modal" class="btn btn-secondary">닫기</button>
                        <button type="submit" class="btn bg-emerald-600 hover:bg-emerald-700">JSON에서 문제 추가</button>
                    </div>
                </form>
            </div>`;
        },

    
    renderSplitChapterModal() {
        const chapterNode = Utils.getNodeByPath(state.activeProject.toc, state.activeChapterPath);
        const {
            sourceToSplit = 'manuscript'
        } = this.data;
        const hasManuscript = state.activeChapterContent.manuscript?.trim();
        const hasTranslation = state.activeChapterContent.translation?.trim();

        const header = `<div class="p-6 border-b"><div class="flex justify-between items-start"><h3 class="text-xl font-semibold text-slate-900">챕터 분할 및 하위 챕터 생성</h3><button type="button" data-action="close-modal" class="p-1 rounded-full hover:bg-slate-100">${Heroicons.render('x-mark', { class: 'w-5 h-5 text-slate-500' })}</button></div><p class="text-sm text-slate-500 mt-1">'${chapterNode.title}' 노트를 여러 개의 하위 노트로 분할합니다.</p></div>`;

        const content = `<form data-action="submit-split-chapter"><div class="p-6"><div class="mb-4"><label class="block text-sm font-medium text-slate-700 mb-2">1. 분할할 대상 선택</label><div class="flex items-center space-x-4 p-2 bg-slate-100 rounded-md" data-action="regenerate-split-prompt"><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="split-source" value="manuscript" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500" ${sourceToSplit === 'manuscript' ? 'checked' : ''} ${!hasManuscript ? 'disabled' : ''}><span>원고</span></label><label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="split-source" value="translation" class="h-4 w-4 text-indigo-600 border-gray-300 focus:ring-indigo-500" ${sourceToSplit === 'translation' ? 'checked' : ''} ${!hasTranslation ? 'disabled' : ''}><span>번역문</span></label></div><p class="text-xs text-slate-500 mt-2">대상을 선택하면 AI 프롬프트가 클립보드에 자동으로 복사됩니다.</p></div><label for="split-json-paste" class="text-sm text-slate-600 mb-2 block">2. AI가 생성한 JSON 응답 붙여넣기</label><textarea id="split-json-paste" name="jsonContent" class="w-full h-40 p-2 border rounded-md font-mono text-xs" placeholder="[ { ... } ]" required></textarea></div><div class="bg-slate-50 px-6 py-4 flex justify-end space-x-3 rounded-b-lg"><button type="button" data-action="close-modal" class="btn btn-secondary">닫기</button><button type="submit" class="btn bg-emerald-600 hover:bg-emerald-700">${Heroicons.render('check-circle', { class: 'w-4 h-4 mr-2' })}하위 챕터 생성 실행</button></div></form>`;
        return header + content;
    },
};

const View = {
        appContainerEl: document.getElementById('app-container'),
        modalEl: document.getElementById('modal-root'),
        toastEl: document.getElementById('toast-root'),
        // Group UI fragments into reusable components. Each component takes
        // state or props as input and returns HTML. This helps keep rendering
        // logic modular and easier to maintain. In the future these can be
        // extracted into separate files or functions.
        components: {
            /**
             * Render a single project card.
             * @param {Object} p - The project to render.
             * @returns {string} HTML for a project card.
             */
            projectCard(p) {
                const category = p.categoryId ? state.categories.find(c => c.id === p.categoryId) : null;
                const noteCount = p.toc && p.toc.children ? Utils.getAllNodePaths(p.toc).length : 0;
                return `<div class="project-card flex flex-col">
                    <div class="project-card-content flex-grow" data-action="open-project" data-id="${p.id}">
                        <p class="text-sm text-indigo-600 font-semibold">${category ? category.name : '미분류'}</p>
                        <h3 class="mt-1 text-lg leading-tight font-bold text-black">${p.name}</h3>
                        <div class="mt-2 flex flex-wrap gap-2">
                            ${(p.tags || []).map(tag => `<span class="inline-block bg-slate-200 text-slate-600 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">#${tag}</span>`).join('')}
                        </div>
                    </div>
                    <div class="border-t mt-4 pt-4 flex justify-between items-center">
                        <p class="text-sm text-slate-500">${noteCount}개의 노트</p>
                        <div class="flex space-x-2">
                            <button data-action="export-project" data-id="${p.id}" title="내보내기" class="p-2 text-slate-500 hover:bg-slate-200 rounded-full">${Heroicons.render('arrow-down-tray', { class: 'w-4 h-4' })}</button>
                            <button data-action="delete-project-confirm" data-id="${p.id}" title="삭제" class="p-2 text-slate-500 hover:bg-red-100 rounded-full">${Heroicons.render('trash', { class: 'w-4 h-4 text-red-500' })}</button>
                        </div>
                    </div>
                </div>`;
            }
        },

        render() {
            const appHtml = this.renderAppLayout();
            safeMorphdom(this.appContainerEl, `<div>${appHtml}</div>`, {
                childrenOnly: true,
                onNodeAdded: (node) => {
                    if (node.nodeType === 1) {
                        if (state.isKaTeXLoaded) Controller.applyPostRenderEffects();
                    }
                    return node;
                }
            });
            this.toastEl.innerHTML = this.renderToasts();
            // Inside the View.render function, find the line with this.renderToasts()
            this.modalEl.querySelector('.modal-container')?.insertAdjacentHTML('beforeend', this.renderTocContextMenu()); // Add this line
            const contextMenuContainer = document.getElementById('context-menu-root') || (() => {
                const el = document.createElement('div');
                el.id = 'context-menu-root';
                document.body.appendChild(el);
                return el;
            })();
            this.renderContextMenu(); // 반환값을 받지 않고 함수를 호출하기만 합니다.
            Controller.applyPostRenderEffects();
            Controller.bindDynamicEventListeners();
        },
        
        renderActionRail() {
            const actionGroups = Controller.getCombinedActions();
            if (actionGroups.length === 0) return '';

            let totalActionIndex = 0;
            const groupsHtml = actionGroups.map((group, groupIndex) => {
                const buttonsHtml = group.actions.map(action => {
                    const currentIndex = totalActionIndex++;
                    // ▼▼▼ [수정] 모바일용 <span> 라벨을 다시 추가하고, title 속성을 data-tooltip으로 변경합니다. ▼▼▼
                    // [핵심 수정] 이름에서 이모티콘과 라벨을 분리합니다.
                    const { emoji, label } = Utils.parseEmojiAndLabel(action.name);

                    // 아이콘 렌더링 로직: 이모티콘 > action.icon > 기본 아이콘 순서
                    let iconHtml = '';
                    if (emoji) {
                        iconHtml = `<span class="w-5 h-5 flex-shrink-0 flex items-center justify-center text-lg">${emoji}</span>`;
                    } else if (action.icon) {
                        iconHtml = Heroicons.render(action.icon, { class: 'w-5 h-5 flex-shrink-0' });
                    } else {
                        // 기본 아이콘 (예: 커스텀 버튼용)
                        iconHtml = Heroicons.render('sparkles', { class: 'w-5 h-5 flex-shrink-0' });
                    }

                    return `
                        <button class="action-rail-button group" 
                                data-action="copy-custom-prompt" 
                                data-index="${currentIndex}"
                                data-tooltip="${DOMPurify.sanitize(action.name)}">
                            ${iconHtml}
                            <span class="action-rail-label">
                                ${DOMPurify.sanitize(label)}
                            </span>
                        </button>
                    `;

                }).join('');
                
                const divider = groupIndex < actionGroups.length - 1 ? '<hr class="action-rail-divider" />' : '';
                return `<div class="action-rail-group">${buttonsHtml}</div>${divider}`;
            }).join('');

            return `
                <div id="action-rail" class="action-rail ${state.isActionRailOpen ? 'open' : ''}">
                    <div class="action-rail-content">
                        ${groupsHtml}
                    </div>
                </div>
                <div class="action-rail-overlay ${state.isActionRailOpen ? 'show' : ''}" data-action="toggle-action-rail"></div>
                <button class="action-rail-toggle-btn" data-action="toggle-action-rail" data-tooltip="빠른 실행 메뉴">
                    ${Heroicons.render('bolt', { class: 'w-5 h-5' })}
                </button>
            `;
        },
        
        renderAppLayout() {
            if (state.isLoading) return this.renderSpinner("시스템 로딩 중...");
            if (['quiz', 'quizResult'].includes(state.currentView)) return this.renderCurrentView();

            
            return `
                    <aside class="sidebar ${state.isSidebarOpen ? '' : 'w-0 overflow-hidden !p-0 !border-0'} ${state.isMobileSidebarOpen ? 'open' : ''}" id="sidebar"> ${this.renderSidebar()} </aside>
                    <div class="sidebar-overlay ${state.isMobileSidebarOpen ? 'show' : ''}" id="sidebar-overlay" data-action="close-sidebar"></div>
                    <main class="main-content">
                        ${this.renderMainHeader()}
                        <div class="content-view" id="content-view"> ${this.renderCurrentView()} </div>
                        ${this.renderFooter()} 
                    </main>`;
            // ▲▲▲ [수정 완료] ▲▲▲
        },
        // Inside the View object
        renderTocContextMenu() {
            const { isOpen, x, y, path } = state.tocContextMenu;
            if (!isOpen) return '';

            const isFolder = Utils.getNodeByPath(ModalManager.data.editableToc, path)?.children;

            const menuItems = [
                { action: 'toc-context-new-item', label: 'New File', icon: 'document-plus' },
                { action: 'toc-context-new-folder', label: 'New Folder', icon: 'folder-plus' },
                { type: 'separator' },
                { action: 'toc-context-rename', label: 'Rename', icon: 'pencil-square' },
                { action: 'toc-context-delete', label: 'Delete', icon: 'trash' },
            ];
            
            const itemsHtml = menuItems.map(item => {
                if (item.type === 'separator') return '<hr>';
                return `
                    <button data-action="${item.action}" data-path="${path}">
                        ${Heroicons.render(item.icon, { class: 'w-4 h-4' })}
                        <span>${item.label}</span>
                    </button>
                `;
            }).join('');

            return `<div id="toc-context-menu" style="left: ${x}px; top: ${y}px;">${itemsHtml}</div>`;
        },
        updateSaveStatusIndicator() {
            const container = document.getElementById('save-status-container');
            if (!container) return;

            let saveStatusIndicatorHtml = '';
            if (state.saveStatus === 'saving') {
                saveStatusIndicatorHtml = `<div class="flex items-center gap-2 text-sm text-slate-500"><div class="w-4 h-4 border-2 border-slate-400 border-t-transparent rounded-full animate-spin"></div> 저장 중...</div>`;
            } else if (state.saveStatus === 'saved' && state.saveTimestamp) {
                saveStatusIndicatorHtml = `<div class="flex items-center gap-2 text-sm text-green-600">${Heroicons.render('check', { class: 'w-4 h-4' })} 마지막 저장: ${state.saveTimestamp.toLocaleTimeString()}</div>`;
            }
            
            // morphdom을 사용하여 컨테이너의 내용만 효율적으로 교체합니다.
            const newContainer = container.cloneNode(false);
            newContainer.innerHTML = saveStatusIndicatorHtml;
            safeMorphdom(container, newContainer);
        },
        renderFooter() {
            if (state.currentView !== 'workspace' || !state.activeProject) {
                return '';
            }

            const allNodes = Utils.getFlatToc(state.activeProject.toc);
            const currentIndex = allNodes.findIndex(c => c.path === state.activeChapterPath);
            const hasPrev = currentIndex > 0;
            const hasNext = currentIndex !== -1 && currentIndex < allNodes.length - 1;

            let breadcrumbPath = '노트를 선택하세요.';
            if (state.activeChapterPath) {
                const breadcrumbs = [];
                let currentNode = state.activeProject.toc;
                state.activeChapterPath.split('.').forEach((part) => {
                    currentNode = currentNode.children[part];
                    breadcrumbs.push(currentNode.title);
                });
                breadcrumbPath = `📚 ${breadcrumbs.join(' > ')}`;
            }

            const manuscriptCount = state.activeChapterContent?.manuscript?.length || 0;
            const notesCount = state.activeChapterContent?.notes?.length || 0;

            const workspaceModes = [{
                    mode: 'write', icon: 'pencil-square', label: 'AI 글쓰기'
                }, {
                    mode: 'view', icon: 'eye', label: '보기'
                }, {
                    mode: 'learn', icon: 'academic-cap', label: '학습'
                }, {
                    mode: 'translate', icon: 'language', label: '번역'
                }, {
                    mode: 'custom', icon: 'sparkles', label: '커스텀 버튼'
                }, {
                    mode: 'image', icon: 'image', label: '이미지'
                }
            ];

            const modeButtonsHtml = workspaceModes.map(item => {
                const isActive = state.workspaceMode === item.mode;
                const activeClasses = isActive ? 'bg-indigo-100 text-indigo-600' : '';

                return `
                    <button data-action="switch-mode" 
                            data-mode="${item.mode}" 
                            title="${item.label}"
                            class="footer-mode-button ${activeClasses}">
                        ${Heroicons.render(item.icon, { class: 'w-3.5 h-3.5' })}
                    </button>
                `;
            }).join('');

            return `
                <footer class="main-footer">
                    <div>
                        <div class="footer-nav">
                            <button data-action="prev-chapter" title="이전 노트" ${!hasPrev ? 'disabled' : ''}>
                                ${Heroicons.render('chevron-left', { class: 'w-3.5 h-3.5' })}
                            </button>
                            <button data-action="next-chapter" title="다음 노트" ${!hasNext ? 'disabled' : ''}>
                                ${Heroicons.render('chevron-right', { class: 'w-3.5 h-3.5' })}
                            </button>
                            <span class="border-l border-slate-200 h-4"></span>
                            <span class="footer-breadcrumb-path" title="${DOMPurify.sanitize(breadcrumbPath)}">${DOMPurify.sanitize(breadcrumbPath)}</span>
                        </div>

                        <div class="footer-controls-group">
                            <div class="footer-modes-wrapper">${modeButtonsHtml}</div>
                            
                            <div class="footer-stats">
                                <span>✍️ ${Utils.formatCount(manuscriptCount)}자</span>
                                <span>📝 ${Utils.formatCount(notesCount)}자</span>
                            </div>
                            
                            <div class="border-l border-slate-200 h-4"></div>
                            
                            <div class="footer-right-actions">
                                <button data-action="go-dashboard" title="대시보드">${Heroicons.render('squares-2x2', { class: 'w-3.5 h-3.5' })}</button>
                                <button data-action="open-settings" title="설정">${Heroicons.render('cog-6-tooth', { class: 'w-3.5 h-3.5' })}</button>
                                <button data-action="export-project" title="내보내기">${Heroicons.render('arrow-down-tray', { class: 'w-3.5 h-3.5' })}</button>
                            </div>
                        </div>
                    </div>
                </footer>
             `;
        },
        renderSidebar() {
            if (state.activeProjectId && state.activeProject) return this.renderProjectSidebar();
            return this.renderLibrarySidebar();
        },
        renderTooltipContent(type) {
            let variables = [];
            if (type === 'writing') {
                variables = [
                    { name: 'bookTitle', desc: '프로젝트의 전체 제목' },
                    { name: 'chapterTitle', desc: '현재 챕터(노트)의 제목' },
                    { name: 'manuscript', desc: '현재 챕터의 "원고" 텍스트' },
                    { name: 'notes', desc: '현재 챕터의 "메모" 텍스트' },
                    { name: 'fullToc', desc: '프로젝트의 전체 목차 구조' },
                    { name: 'selected_text', desc: '(컨텍스트 메뉴 전용) 선택된 텍스트' },
                ];
            } else if (type === 'quiz') {
                variables = [
                    { name: 'text', desc: '퀴즈 문제 출제 기반이 되는 원고' },
                    { name: 'questionCount', desc: '퀴즈 생성 개수 설정값' },
                ];
            }

            const itemsHtml = variables.map(v => 
                `<li><code>{{${v.name}}}</code><br>${v.desc}</li>`
            ).join('');
            
            // HTML 속성 값으로 사용될 것이므로, 큰따옴표를 이스케이프 처리합니다.
            return `<ul>${itemsHtml}</ul>`.replace(/"/g, '&quot;');
        },
        renderLibrarySidebar() {
            const {
                type,
                id
            } = state.currentFilter;
            const categoryListHtml = state.categories.map(c => `<li class="nav-item ${type === 'category' && id === c.id ? 'active' : ''}" data-action="filter" data-filter-type="category" data-id="${c.id}"><a>${Heroicons.render('folder', { class: 'icon' })} ${c.name}</a></li>`).join('');
            const tagListHtml = state.tags.map(t => `<li class="nav-item ${type === 'tag' && id === t.name ? 'active' : ''}" data-action="filter" data-filter-type="tag" data-id="${t.name}"><a>${Heroicons.render('tag', { class: 'icon' })} ${t.name} <span class="tag-count">${t.count}</span></a></li>`).join('');
            // 기존 return 문을 아래 코드로 통째로 교체하세요.
return `<div class="sidebar-header"><a href="#" data-action="go-dashboard" class="logo">${Heroicons.render('academic-cap', { style: 'solid' })} 학습 & 저작 v${APP_VERSION}</a></div><div class="sidebar-content"><div class="nav-section"><button class="btn" data-action="new-project" style="width: 100%;">${Heroicons.render('plus')} 새 프로젝트</button></div><nav class="sidebar-nav"><div class="nav-section"><h3 class="nav-section-title">라이브러리</h3><ul class="nav-list" id="library-list"><li class="nav-item ${type === 'dashboard' ? 'active' : ''}" data-action="filter" data-filter-type="dashboard"><a>${Heroicons.render('squares-2x2', { class: 'icon' })} 대시보드</a></li><li class="nav-item ${type === 'all' ? 'active' : ''}" data-action="filter" data-filter-type="all"><a>${Heroicons.render('document-duplicate', { class: 'icon' })} 모든 프로젝트</a></li></ul></div><div class="nav-section"><div class="flex justify-between items-center p-2"><h3 class="nav-section-title mb-0">카테고리</h3><button data-action="toggle-sidebar-section" data-section="categories" title="카테고리 접기/펴기" class="text-slate-400 hover:text-slate-600">${Heroicons.render(state.sidebarCollapseState.categories ? 'chevron-right' : 'chevron-down', { class: 'w-4 h-4' })}</button></div>${!state.sidebarCollapseState.categories ? `<ul class="nav-list" id="category-list">${categoryListHtml}</ul>` : ''}</div><div class="nav-section"><div class="flex justify-between items-center p-2"><h3 class="nav-section-title mb-0">태그</h3><button data-action="toggle-sidebar-section" data-section="tags" title="태그 접기/펴기" class="text-slate-400 hover:text-slate-600">${Heroicons.render(state.sidebarCollapseState.tags ? 'chevron-right' : 'chevron-down', { class: 'w-4 h-4' })}</button></div>${!state.sidebarCollapseState.tags ? `<ul class="nav-list" id="tag-list">${tagListHtml}</ul>` : ''}</div></nav></div><div class="sidebar-footer">${this.renderUserProfile()}</div>`;
        },
        renderProjectSidebar() {
            const project = state.activeProject;

            // ▼▼▼ [추가] 프로젝트 정보를 표시할 HTML 블록을 생성합니다. ▼▼▼
            const projectInfoHtml = `
                <div class="project-info p-4 border-b border-slate-200">
                    <p class="text-xs text-slate-500 break-all">
                        A HISTORY OF BUDDHIST PHILOSOPHY CONTINUITY AND -- DAVID, J KALUPAHANA -- NEW DELHI, 1994 -- MOTILAL BANARSIDASS, -- 9788120811911 -- 022B5C46DA8BC5B5D89AED551BC3E866 -- ANNA'S ARCHIVE 스크립트 목차
                    </p>
                </div>
            `;

            const tocSearch = `<div class="relative p-2"><input type="text" id="toc-search-input" data-action="search-toc" class="w-full pl-8 pr-2 py-1.5 text-sm border rounded-md bg-slate-100" placeholder="목차 검색..." value="${DOMPurify.sanitize(state.tocSearchQuery || '')}"><div class="absolute left-4 top-1/2 -translate-y-1/2 text-slate-400">${Heroicons.render('magnifying-glass', { class: 'w-4 h-4' })}</div></div>`;
             const tocControls = `
        <div class="flex justify-between items-center px-2 pb-2">
            <h3 class="nav-section-title mb-0">${project.name} 목차</h3>
            <div class="flex gap-2">
                <button data-tooltip="전체 펼치기" data-action="toggle-toc-all" data-mode="expand" class="p-1.5 text-slate-500 hover:bg-slate-200 rounded-md">
                    ${Heroicons.render('arrows-pointing-out', { class: 'w-4 h-4' })}
                </button>
                <button data-tooltip="전체 접기" data-action="toggle-toc-all" data-mode="collapse" class="p-1.5 text-slate-500 hover:bg-slate-200 rounded-md">
                    ${Heroicons.render('arrows-pointing-in', { class: 'w-4 h-4' })}
                </button>
            </div>
        </div>`;

            // ▼▼▼ [수정] this.renderToc 호출 부분을 필터링 로직으로 변경 ▼▼▼
            let tocToRender = state.activeProject.toc;
            if (state.tocSearchQuery) {
                const fuse = new Fuse(Utils.getFlatToc(state.activeProject.toc), { keys: ['node.title'], threshold: 0.4 });
                const filteredPaths = new Set(fuse.search(state.tocSearchQuery).map(r => r.item.path));
                
                const filterToc = (node, path = '') => {
                    if (!node.children) return null;
                    const newChildren = node.children.map((child, index) => {
                        const childPath = path ? `${path}.${index}` : `${index}`;
                        // 자식 노드가 검색 결과에 포함되거나, 현재 노드 자체가 검색 결과인 경우
                        if (filteredPaths.has(childPath)) return child;
                        const filteredGrandchildren = filterToc(child, childPath);
                        return filteredGrandchildren ? { ...child, children: filteredGrandchildren } : null;
                    }).filter(Boolean);

                    return newChildren.length > 0 ? newChildren : null;
                };
                const filteredChildren = filterToc(tocToRender);
                tocToRender = { ...tocToRender, children: filteredChildren || [] };
            }
            
             return `<div class="sidebar-header"><button data-action="go-dashboard" class="btn btn-secondary w-full text-sm">${Heroicons.render('arrow-left', { class: 'w-4 h-4 mr-2' })} 라이브러리로 돌아가기</button></div>
                        ${projectInfoHtml}
                        <div class="sidebar-content">
                            ${tocSearch}
                            <h3 class="nav-section-title px-2">${project.name} 목차</h3>
                            ${tocControls}
                            ${this.renderToc(tocToRender)}
                        </div>
                        <div class="sidebar-footer">${this.renderUserProfile()}</div>`;
            },
        renderUserProfile() {
            const { level, xp } = state.userProfile;
            const currentLevelXP = CONFIG.LEVEL_THRESHOLDS[level - 1] || 0;
            const nextLevelXP = CONFIG.LEVEL_THRESHOLDS[level] || xp;
            const xpForLevel = nextLevelXP - currentLevelXP;
            const currentXPInLevel = xp - currentLevelXP;
            const progress = xpForLevel > 0 ? Math.round((currentXPInLevel / xpForLevel) * 100) : 100;
            
            return `<div class="flex items-center space-x-4 w-full">
                        <div class="font-semibold text-sm text-slate-600" data-tooltip="레벨 ${level}">LV.${level}</div>
                        <div class="w-full" data-tooltip="경험치: ${xp.toLocaleString()} / ${nextLevelXP.toLocaleString()}">
                            <div class="h-2 bg-slate-200 rounded-full w-full">
                                <div class="h-full rounded-full xp-bar-inner" style="width: ${progress}%"></div>
                            </div>
                        </div>
                        <button data-action="toggle-theme" data-tooltip="테마 전환" class="p-2 rounded-full hover:bg-slate-200 text-slate-500">
                            ${Heroicons.render(state.theme === 'dark' ? 'sun' : 'moon', { class: 'w-5 h-5' })}
                        </button>
                    </div>`;
        },
        renderMainHeader() {
            const title = this.getHeaderTitle();
            const isProjectListView = state.currentView === 'project_list';
            const workspaceControls = state.currentView === 'workspace' && state.activeProjectId ?
            `<button data-action="manage-history" class="btn btn-secondary btn-sm" title="이력 관리" aria-label="이력 관리">${Heroicons.render('clock', { class: 'w-4 h-4' })}</button>
            <button data-action="manage-toc" class="btn btn-secondary btn-sm" title="목차 관리" aria-label="목차 관리">${Heroicons.render('bars-3-bottom-left', { class: 'w-4 h-4' })}</button>
            <button data-action="open-settings" class="btn btn-secondary btn-sm" title="설정" aria-label="설정">${Heroicons.render('cog-6-tooth', { class: 'w-4 h-4' })}</button>`
            : '';

            let saveStatusIndicator = '';
            if (state.saveStatus === 'saving') {
                saveStatusIndicator = `<div class="flex items-center gap-2 text-sm text-slate-500"><div class="w-4 h-4 border-2 border-slate-400 border-t-transparent rounded-full animate-spin"></div> 저장 중...</div>`;
            } else if (state.saveStatus === 'saved' && state.saveTimestamp) {
                saveStatusIndicator = `<div class="flex items-center gap-2 text-sm text-green-600">${Heroicons.render('check', { class: 'w-4 h-4' })} 마지막 저장: ${state.saveTimestamp.toLocaleTimeString()}</div>`;
            }

            // Render a slightly larger menu icon for better visibility
            const sidebarIcon = Heroicons.render('bars-3', {
                class: 'w-6 h-6'
            });
            return `<header class="main-header">
                <button id="sidebar-toggle" class="mr-4" data-action="toggle-sidebar" aria-label="사이드바 토글">${sidebarIcon}</button>
                <h1 class="header-title">${title}</h1>
                <div class="flex items-center gap-4">
                    <div id="save-status-container">${saveStatusIndicator}</div>
                    <!-- 전역 검색 전 뷰로 돌아가기 버튼 -->
                    ${state.currentView === CONFIG.VIEW_NAMES.GLOBAL_SEARCH ? `<button data-action="exit-global-search" class="p-2 rounded-full hover:bg-slate-200" title="돌아가기">${Heroicons.render('arrow-left', { class: 'w-5 h-5' })}</button>` : ''}
                    <!-- 전역 검색 입력 및 제출 버튼 -->
                    <div class="relative">
                        <input type="text" class="search-input" id="global-search-input" placeholder="전역 검색..." value="${DOMPurify.sanitize(state.globalSearchQuery || '')}">
                        <button data-action="global-search-submit" class="absolute right-3 top-1/2 -translate-y-1/2 text-slate-400" title="검색" aria-label="검색">
                            ${Heroicons.render('magnifying-glass', { class: 'w-4 h-4' })}
                        </button>
                    </div>
                    ${workspaceControls}
                </div>
                ${this.renderProgressBar()}
            </header>`;
        },
        // learning.html 파일의 View 객체 내부에 아래 함수를 새로 추가하세요.
        renderProgressBar() {
            const isProgressBarVisible = state.currentView === 'workspace' && state.workspaceMode === 'view';
            return `
                <div id="view-progress-bar-container" 
                    class="absolute bottom-0 left-0 w-full h-[3px] pointer-events-none" 
                    style="display: ${isProgressBarVisible ? 'block' : 'none'}; transform: translateY(100%);">
                    <div id="view-progress-bar" class="bg-indigo-500 h-full transition-all duration-150 ease-out" style="width: 0%;"></div>
                </div>
            `;
        },
        getHeaderTitle() {
            if (state.currentView === 'workspace' && state.activeProject) return state.activeProject.name;
            // 전역 검색 뷰에서는 제목을 전역 검색으로 표시합니다.
            if (state.currentView === 'global_search') return '전역 검색';
            const {
                type,
                id
            } = state.currentFilter;
            if (type === 'dashboard') return '대시보드';
            if (type === 'all' || state.searchResults) return '모든 프로젝트';
            if (type === 'category') return state.categories.find(c => c.id === id)?.name || '카테고리';
            if (type === 'tag') return `#${id}`;
            return '학습 및 저작 시스템';
        },
        renderCurrentView() {
            switch (state.currentView) {
                case 'dashboard':
                    return this.renderDashboard();
                case 'project_list':
                    return this.renderProjectList();
                case 'workspace':
                    return this.renderWorkspace();
                case 'quiz':
                    return this.renderQuizView();
                case 'quizResult':
                    return this.renderQuizResultView();
                case 'global_search':
                    return this.renderGlobalSearch();
                default:
                    return `<div class="text-center p-8 text-slate-500">뷰를 로드하는 중...</div>`;
            }
        },
        renderDashboard() {
    // 최근 업데이트된 프로젝트 5개를 가져옵니다.
    const recentProjects = [...state.projects]
        .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0))
        .slice(0, 5);

    // 통계 항목을 렌더링하는 헬퍼 함수입니다.
    const statItem = (value, label, filterType, id = null) => `
        <a href="#" class="text-center block hover:bg-slate-50 p-2 rounded-lg" 
           data-action="filter" data-filter-type="${filterType}" ${id ? `data-id="${id}"` : ''}>
            <div class="text-3xl font-bold">${value}</div>
            <div class="text-sm text-slate-500">${label}</div>
        </a>
    `;

    // 대시보드 전체의 HTML 구조를 반환합니다.
    return `
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            
            <div class="p-6 bg-panel rounded-lg shadow-sm">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold">빠른 작업</h3>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <button class="btn" data-action="new-project">
                        ${Heroicons.render('plus')} 새 프로젝트
                    </button>
                    <button class="btn btn-secondary" data-action="new-category">
                        ${Heroicons.render('folder-plus')} 새 카테고리
                    </button>
                </div>
            </div>

            
            <div class="p-6 bg-panel rounded-lg shadow-sm">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold">개요</h3>
                </div>
                <div class="flex justify-around">
                    ${statItem(state.projects.length, '프로젝트', 'all')}
                    ${statItem(state.categories.length, '카테고리', 'category')}
                    ${statItem(state.tags.length, '태그', 'tag')}
                </div>
            </div>

            
            <div class="p-6 bg-panel rounded-lg shadow-sm md:col-span-2 lg:col-span-1">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold">최근 프로젝트</h3>
                </div>
                <ul class="divide-y divide-slate-100">
                    ${recentProjects.map(p => `
                        <li class="py-2 flex justify-between items-center hover:bg-slate-50 rounded-md">
                            <a href="#" data-action="open-project" data-id="${p.id}" class="flex-grow min-w-0">
                                <p class="font-medium truncate">${p.name}</p>
                                <p class="text-xs text-slate-500">${new Date(p.updatedAt || p.createdAt).toLocaleString()}</p>
                            </a>
                            <button data-action="open-project" data-id="${p.id}">
                                ${Heroicons.render('chevron-right', { class: 'w-4 h-4 text-slate-400' })}
                            </button>
                        </li>
                    `).join('') || '<li class="p-4 text-center text-slate-500">최근 프로젝트가 없습니다.</li>'}
                </ul>
            </div>
        </div>
    `;
},
        renderProjectList() {
            let filtered = Controller.getFilteredAndSortedProjects();
            if (filtered.length === 0) {
                // 기존: return `<div class="text-center p-8 text-slate-500">표시할 프로젝트가 없습니다.</div>`;
                // 수정 후:
                return `<div class="flex flex-col items-center justify-center h-full min-h-[60vh] text-center p-4">
                            ${Heroicons.render('document-duplicate', { class: 'h-16 w-16 text-slate-300' })}
                            <h3 class="mt-4 text-xl font-semibold text-slate-800">프로젝트가 없습니다</h3>
                            <p class="mt-1 text-slate-500">새로운 학습 프로젝트를 만들어 시작해보세요.</p>
                            <button class="btn mt-6" data-action="new-project">
                                ${Heroicons.render('plus', { class: 'w-4 h-4 mr-2' })}새 프로젝트 생성
                            </button>
                        </div>`;
            }
            return `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">${filtered.map(p => this.getProjectCardHTML(p)).join('')}</div>`;
        },
        getProjectCardHTML(p) {
            // Delegate rendering to the projectCard component. Keeping a thin wrapper
            // allows backward compatibility while paving the way for component-based UI.
            return this.components.projectCard(p);
        },
        renderWorkspace() {
            if (!state.activeProject) return this.renderSpinner("프로젝트 로딩 중...");
            const allNodes = Utils.getFlatToc(state.activeProject.toc);
            const currentIndex = allNodes.findIndex(c => c.path === state.activeChapterPath);
            const hasPrev = currentIndex > 0;
            const hasNext = currentIndex !== -1 && currentIndex < allNodes.length - 1;
            const navButton = (action, icon, disabled) => `<button data-action="${action}" class="p-2 rounded-full hover:bg-slate-200 disabled:opacity-30 disabled:cursor-not-allowed" ${disabled ? 'disabled' : ''}>${Heroicons.render(icon, { class: 'w-5 h-5 text-slate-600' })}</button>`;

            // [핵심 수정] flex 컨테이너로 전체를 감싸고, action-rail을 밖으로 분리합니다.
            return `<div class="flex gap-4">
                        <div class="workspace-main flex-grow min-w-0">
                            <div class="flex items-center gap-2 mb-4">
                                ${navButton('prev-chapter', 'chevron-left', !hasPrev)}
                                <div class="flex-grow">${this.renderBreadcrumbs()}</div>
                                ${navButton('next-chapter', 'chevron-right', !hasNext)}
                            </div>
                            <div class="bg-panel rounded-lg shadow-sm">
                                <div class="border-b border-slate-200">
                                    <nav class="-mb-px flex space-x-2 sm:space-x-8 px-4 sm:px-6 overflow-x-auto" aria-label="Tabs">
                                        ${this.renderModeTab('write', 'pencil-square', 'AI 글쓰기')}
                                        ${this.renderModeTab('view', 'eye', '보기')}
                                        ${this.renderModeTab('learn', 'academic-cap', '학습')}
                                        ${this.renderModeTab('translate', 'language', '번역')}
                                        ${this.renderModeTab('image', 'photo', '이미지')}
                                    </nav>
                                </div>
                                <div id="workspace-main-content" class="p-4 sm:p-6 min-h-[70vh]">${this.renderWorkspacePanel()}</div>
                            </div>
                        </div>
                        ${this.renderActionRail()}
                    </div>`;
        },

        /**
         * 전역 검색 결과를 렌더링합니다. 검색어에 따라 결과를 리스트로 표시하며,
         * 결과가 없거나 검색어가 없는 경우 적절한 메시지를 보여줍니다.
         * 각 결과는 프로젝트 이름과 챕터 제목, 스니펫으로 구성되며 클릭 시 해당 챕터로 이동합니다.
         * @returns {string}
         */
        renderGlobalSearch() {
            const query = state.globalSearchQuery || '';
            const results = state.globalSearchResults;
            let contentHtml;
            if (!query.trim()) {
                contentHtml = `<div class="text-center p-8 text-slate-500">검색어를 입력하세요.</div>`;
            } else if (!results || results.length === 0) {
                contentHtml = `<div class="text-center p-8 text-slate-500">검색 결과가 없습니다.</div>`;
            } else {
                // 표시해야 할 결과 개수와 전체 결과를 분리합니다.
                const visibleCount = state.globalSearchVisibleCount || 30;
                const totalResults = results.length;
                const visibleResults = results.slice(0, visibleCount);
                contentHtml = `<ul class="divide-y divide-slate-200">
                    ${visibleResults.map(r => {
                        const projectName = DOMPurify.sanitize(r.projectName);
                        const title = DOMPurify.sanitize(r.title || '');
                        // snippet은 <mark> 태그를 허용하여 하이라이트를 유지합니다.
                        const snippet = DOMPurify.sanitize(r.snippet, { ALLOWED_TAGS: ['mark'] });
                        return `<li>
                            <a href="javascript:void(0)" data-action="open-global-search-result" data-project-id="${r.projectId}" data-path="${r.path}" class="block p-4 hover:bg-slate-50">
                                <div class="text-sm font-medium text-indigo-600 truncate">${projectName}${title ? ' » ' + title : ''}</div>
                                <div class="mt-1 text-sm text-slate-600">${snippet}</div>
                            </a>
                        </li>`;
                    }).join('')}
                </ul>`;
                // 더 보여줄 결과가 있다면 '더 찾기' 버튼을 추가합니다.
                if (totalResults > visibleCount) {
                    contentHtml += `<div class="p-4 text-center">
                        <button data-action="global-search-show-more" class="btn btn-secondary btn-sm">더 찾기</button>
                    </div>`;
                }
            }
            return `<div class="p-4">${contentHtml}</div>`;
        },
        renderBreadcrumbs() {
            if (!state.activeChapterPath) {
                return `<div class="bg-breadcrumb rounded-lg p-2.5 h-[44px] flex items-center">
                            <span class="text-sm breadcrumb-text-secondary">노트를 선택하세요.</span>
                        </div>`;
            }

            const breadcrumbs = [];
            let currentPath = '';
            let currentNode = state.activeProject.toc;
            let pathIsValid = true;

            // 경로 유효성 검사를 추가하여 오류 방지
            for (const part of state.activeChapterPath.split('.')) {
                const index = Number(part);
                if (!currentNode || !Array.isArray(currentNode.children) || !currentNode.children[index]) {
                    pathIsValid = false;
                    break; // 경로가 유효하지 않으면 루프 중단
                }
                currentNode = currentNode.children[index];
                currentPath = currentPath ? `${currentPath}.${index}` : `${index}`;
                breadcrumbs.push({
                    title: currentNode.title,
                    path: currentPath
                });
            }

            // 경로가 유효하지 않을 경우, 사라지는 대신 오류 메시지를 표시
            if (!pathIsValid) {
                console.error("Breadcrumb rendering failed: Invalid chapter path", state.activeChapterPath);
                return `<div class="bg-red-100 border border-red-200 text-red-700 rounded-lg p-2.5 h-[44px] flex items-center">
                            ${Heroicons.render('exclamation-triangle', { class: 'w-5 h-5 mr-2' })}
                            <span class="text-sm">오류: 챕터 경로를 찾을 수 없습니다. (목차를 다시 선택해주세요)</span>
                        </div>`;
            }

            const items = breadcrumbs.map((crumb, index) => {
                const isLast = index === breadcrumbs.length - 1;
                // 하드코딩된 클래스 대신 커스텀 클래스 사용
                const linkClass = isLast ? 'breadcrumb-text-primary font-semibold' : 'breadcrumb-text-secondary hover:breadcrumb-text-hover';
                const chevron = !isLast ? Heroicons.render('chevron-right', { class: 'h-4 w-4 breadcrumb-text-secondary mx-1' }) : '';
                return `<li class="flex items-center">
                            <a href="#" data-action="select-chapter" data-path="${crumb.path}" class="text-sm ${linkClass}">
                                ${crumb.title}
                            </a>
                            ${chevron}
                        </li>`;
            }).join('');

            return `<nav class="bg-breadcrumb rounded-lg p-2.5">
                        <ol class="flex items-center flex-wrap">${items}</ol>
                    </nav>`;
        },
        renderImagePanel() {
            if (!state.activeChapterContent) return '';

            const content = state.activeChapterContent;
            const imageUrl = content.imageDataUrl;

            const uploadBoxHtml = `
            <div class="mb-6">
                <label for="image-upload" class="block text-sm font-medium text-slate-700 mb-2">이미지 파일 변경</label>
                <div data-dropzone="image" class="mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-slate-300 border-dashed rounded-md transition-colors hover:border-indigo-400 hover:bg-indigo-50">
                    
                    <div class="space-y-1 text-center">
                        ${Heroicons.render('photo', { class: 'mx-auto h-12 w-12 text-slate-400' })}
                        <div class="flex text-sm text-slate-600">
                            <label for="image-upload" class="relative cursor-pointer bg-white rounded-md font-medium text-indigo-600 hover:text-indigo-500 focus-within:outline-none">
                                <span>파일 선택</span>
                                <input id="image-upload" name="image-upload" type="file" class="sr-only" accept="image/*">
                            </label>
                            <p class="pl-1">또는 파일을 드래그하세요</p>
                        </div>
                        <p class="text-xs text-slate-500">PNG, JPG, GIF 등 이미지 파일 (클립보드 붙여넣기도 가능)</p>
                    </div>
                </div>
            </div>
            `;
            
        const deleteButtonHtml = `
            <div class="mt-4 text-center">
                <button data-action="delete-image" class="btn btn-secondary bg-red-100 text-red-700 hover:bg-red-200">
                    ${Heroicons.render('trash', { class: 'w-4 h-4 mr-2' })}
                    이미지 삭제
                </button>
            </div>
        `;
        
        
        const imagePreviewHtml = imageUrl ? `
            <div>
                <h3 class="text-lg font-semibold text-slate-800 border-b pb-2 mb-4">업로드된 이미지</h3>
                
                <div class="bg-slate-50 p-2 rounded-lg mb-4">
                    <img src="${imageUrl}" alt="업로드된 이미지" class="w-full rounded-md object-contain">
                </div>
                ${deleteButtonHtml}
            </div>
        ` : '';
            return `
            <div class="h-[70vh] overflow-y-auto pr-4">
                ${uploadBoxHtml}
                ${imagePreviewHtml}
            </div>
            `;
        },
        renderToc(toc, level = 0, pathPrefix = '') {
            // ▼▼▼ [개선안 11] 목차가 비어있을 때 '새 챕터 추가' 버튼 렌더링 ▼▼▼
            if (!toc?.children?.length) {
                if (level === 0) {
                    return `<div class="text-center p-4">
                                <p class="text-sm text-slate-500 mb-3">목차가 비어있습니다.</p>
                                <button class="btn btn-secondary btn-sm" data-action="toc-add-root-item">
                                    ${Heroicons.render('plus', { class: 'w-4 h-4 mr-1' })} 첫 챕터 추가
                                </button>
                            </div>`;
                }
                return '';
            }
            const items = toc.children.map((item, index) => {
                const currentPath = pathPrefix ? `${pathPrefix}.${index}` : `${index}`;
                const hasChildren = item.children && item.children.length > 0;
                const isCollapsed = state.tocCollapseState[currentPath];
                const content = state.activeContentsMap.get(`${state.activeProjectId}_${currentPath}`);

                let statusIndicator = '';
                if (content?.status && content.status !== 'empty') {
                    const colorMap = {
                        'prompt-copied': 'bg-blue-400',
                        'manuscript-done': 'bg-yellow-400',
                        'quiz-done': 'bg-green-400'
                    };
                    if (colorMap[content.status]) {
                        statusIndicator = `<span class="w-2 h-2 rounded-full ${colorMap[content.status]} mr-2 flex-shrink-0" title="상태: ${content.status}"></span>`;
                    }
                }

                const collapseIcon = hasChildren ?
                    `<button data-action="toggle-toc-collapse" data-path="${currentPath}" class="p-1 rounded-md hover:bg-slate-200">${Heroicons.render(isCollapsed ? 'chevron-right' : 'chevron-down', { class: 'w-4 h-4 text-slate-500' })}</button>` :
                    ``; // 자식이 없으면 아이콘 없음

                 return `<li class="my-1 toc-item ${state.activeChapterPath === currentPath ? 'active' : ''}">
                    <div class="flex items-center" style="padding-left: ${level * 1}rem;">
                        <div class="w-6 h-8 flex-shrink-0 flex items-center justify-center">
                            ${collapseIcon}
                        </div>
                        <a href="#" data-action="select-chapter" data-path="${currentPath}" class="flex-grow flex items-center min-w-0 h-8 px-2 rounded-md text-sm hover:bg-slate-100 relative">
                            ${statusIndicator}
                            <span class="truncate">${item.title}</span>
                        </a>
                    </div>
                    ${hasChildren && !isCollapsed ? `<ul class="mt-1">${this.renderToc(item, level + 1, currentPath)}</ul>` : ''}
                </li>`;
            }).join('');

            return `<ul class="nav-list">${items}</ul>`;
        },
        renderModeTab: (mode, icon, label) => {
            const isActive = state.workspaceMode === mode;
            const iconClass = `${isActive ? 'text-indigo-500' : 'text-slate-400 group-hover:text-slate-500'} -ml-0.5 mr-2 h-5 w-5`;
            return `<button data-action="switch-mode" data-mode="${mode}" class="${isActive ? 'border-indigo-500 text-indigo-600' : 'border-transparent text-slate-500 hover:text-slate-700 hover:border-slate-300'} group inline-flex items-center py-4 px-1 border-b-2 font-medium text-sm flex-shrink-0">${Heroicons.render(icon, { class: iconClass })}<span>${label}</span></button>`;
        },
        renderWorkspacePanel() {
            if (!state.activeChapterPath) {
                return `<div class="flex flex-col items-center justify-center h-full min-h-[60vh] text-center p-4">${Heroicons.render('document-text', { class: 'h-16 w-16 text-slate-300' })}<h3 class="mt-4 text-xl font-semibold text-slate-800">노트를 선택하세요</h3><p class="mt-1 text-slate-500">좌측 목차에서 작업할 노트를 선택해주세요.</p></div>`;
            }
            if (!state.activeChapterContent) {
                return this.renderSpinner("노트 내용 로딩 중...");
            }
            switch (state.workspaceMode) {
                case 'view':
                    return this.renderViewPanel();
                case 'write':
                    return this.renderWritePanel();
                case 'learn':
                    return this.renderLearnPanel();
                case 'translate':
                    return this.renderTranslatePanel();
                case 'custom':
                    return this.renderCustomButtonPanel();
                    // ▼▼▼ [추가] 이 부분을 추가하세요 ▼▼▼
                case 'image':
                    return this.renderImagePanel();
                default:
                    return `<div>알 수 없는 모드입니다.</div>`;
            }
        },
        renderViewPanel() {
            const content = state.activeChapterContent;
            const hasManuscript = content.manuscript && content.manuscript.trim();
            const hasTranslation = content.translation && content.translation.trim();

            let effectiveMode = state.viewPanelDisplayMode;
            if (effectiveMode === 'auto') {
                effectiveMode = hasTranslation ? 'translation' : 'manuscript';
            }

            const layoutButton = (mode, icon, label) => {
                const isActive = effectiveMode === mode;
                const isDisabled = (mode === 'manuscript' && !hasManuscript) || (mode === 'translation' && !hasTranslation) || (mode === 'both' && (!hasManuscript || !hasTranslation));
                
                return `<button data-action="set-view-panel-mode" data-mode="${mode}" data-tooltip="${label}" 
                                class="layout-toggle-button ${isActive ? 'active' : ''}" ${isDisabled ? 'disabled' : ''}>
                            ${Heroicons.render(icon, { class: 'w-4 h-4' })}
                        </button>`;
            };

            const controls = `
            <div class="flex justify-end items-center mb-4 gap-4">
                <button data-tooltip="${state.isReaderMode ? '리더 모드 종료' : '리더 모드 시작'}" data-action="toggle-reader-mode" class="p-2 text-slate-500 hover:bg-slate-200 rounded-full">
                    ${Heroicons.render(state.isReaderMode ? 'arrows-pointing-in' : 'arrows-pointing-out', { class: 'w-5 h-5' })}
                </button>
                <div class="inline-flex rounded-md shadow-sm">
                    ${layoutButton('manuscript', 'document-text', '원문')}
                    ${layoutButton('translation', 'language', '번역문')}
                    ${layoutButton('both', 'rectangle-group', '모두')}
                </div>
            </div>`;

            const allowedTagsConfig = {
                ALLOWED_TAGS: [
                    'strong', 'b', 'em', 'i', 'p', 'br', 'ul', 'ol', 'li',
                    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'a', 'img', 'code', 'pre', 'blockquote',
                    'table', 'thead', 'tbody', 'tr', 'th', 'td', 'mark', 'sup', 'section', 'hr',
                    'div'
                ],
                ALLOWED_ATTR: [
                    'align','id', 'href', 'role', 'class', 'data-tooltip',
                    'data-action', 'data-footnote-key',
                    'data-source' // [핵심 수정] 이 속성을 허용 목록에 추가합니다.
                ]
            };
            
            // [핵심 수정] 렌더링 시작 시점에서 FootnoteManager를 '단 한 번만' 초기화합니다.
            FootnoteManager.clear();

            // 원문과 번역문에서 각주 정의를 '통합 추출'합니다. 이제 데이터가 덮어씌워지지 않습니다.
            let manuscriptForParsing = hasManuscript ? FootnoteManager.extractAndClean(content.manuscript) : '';
            let translationForParsing = hasTranslation ? FootnoteManager.extractAndClean(content.translation) : '';

            // 정제된 본문을 각각 파싱합니다. (이 과정에서 각주 참조 순서가 기록됩니다)
            const manuscriptHtml = hasManuscript ? Controller.parseMarkdownWithExtensions(manuscriptForParsing) : '';
            const translationHtml = hasTranslation ? Controller.parseMarkdownWithExtensions(translationForParsing) : '';
                
            // 통합된 FootnoteManager 데이터를 기반으로 최종 각주 목록 HTML을 '한 번만' 생성합니다.
            const footnotes = FootnoteManager.footnotes;
            const footnoteOrder = FootnoteManager.getOrder();
            let footnotesHtml = '';
            if (footnoteOrder.length > 0) {
                footnotesHtml += '<hr class="footnote-divider"><section class="footnotes"><ol>';
                footnoteOrder.forEach(name => {
                    const note = FootnoteManager.getNote(name);
                    if (note) {
                        const backRef = `<a href="#fnref:${name}" data-action="footnote-jump" data-footnote-key="${name}" class="footnote-backref" role="doc-backlink">↩</a>`;
                        footnotesHtml += `<li id="fn:${name}"><p class="mr-2 font-mono text-xs text-slate-500">[${name}]:</p><div class="flex-1">${note.html}${backRef}</div></li>`;
                    }
                });
                footnotesHtml += '</ol></section>';
            }

            // 최종 HTML을 조합하고 정화합니다.
            let finalBodyHtml = '';
           if ((effectiveMode === 'manuscript' || effectiveMode === 'both') && hasManuscript) {
                finalBodyHtml += `<h3 class="text-xl font-semibold mb-4 text-slate-800 border-b pb-2">원문 보기</h3><div class="prose prose-custom prose-readable" data-source="manuscript">${manuscriptHtml}</div>`;
            }
            if ((effectiveMode === 'translation' || effectiveMode === 'both') && hasTranslation) {
                finalBodyHtml += `<h3 class="text-xl font-semibold mb-4 ${hasManuscript && effectiveMode === 'both' ? 'mt-8' : ''} text-slate-800 border-b pb-2">번역문 보기</h3><div class="prose prose-custom prose-readable" data-source="translation">${translationHtml}</div>`;
            }
            
            if (!finalBodyHtml.trim()) {
                finalBodyHtml = `<div class="text-center text-slate-500 py-16"><p>표시할 원문 또는 번역문 내용이 없습니다.</p></div>`;
            }

            const fullHtml = finalBodyHtml + footnotesHtml;
            const sanitizedHtml = DOMPurify.sanitize(fullHtml, allowedTagsConfig);

            return `<div>${controls}${sanitizedHtml}</div>`;
        },
        renderWritePanel() {
            const content = state.activeChapterContent;
            return `
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div class="h-[70vh] flex flex-col">
                            <div class="flex justify-between items-center mb-2">
                                <h3 class="text-lg font-semibold text-slate-800">원고 작성</h3>
                                <button data-action="copy-writing-prompt" class="btn btn-secondary btn-sm">
                                    ${Heroicons.render('clipboard-document', { class: 'w-4 h-4 mr-2' })}프롬프트 복사
                                </button>
                            </div>
                            <textarea id="manuscript" data-field="manuscript" class="w-full flex-grow p-4 border border-slate-300 rounded-md shadow-sm" data-preserve-focus="manuscript">${content.manuscript || ''}</textarea>
                        </div>
                        <div class="h-[70vh] flex flex-col">
                            <h3 class="text-lg font-semibold mb-2 text-slate-800">챕터 목표 및 메모</h3>
                            <textarea id="notes" data-field="notes" class="w-full flex-grow p-4 border border-slate-300 rounded-md shadow-sm bg-yellow-50" data-preserve-focus="notes">${content.notes || ''}</textarea>
                        </div>
                    </div>
                `;
        },
        renderLearnPanel() {
            const hasQuestions = state.activeChapterContent?.questions?.length > 0;
            return `<div class="flex flex-col items-center justify-center h-full text-center min-h-[60vh]">${Heroicons.render('light-bulb', { class: 'h-12 w-12 text-slate-400' })}<h4 class="mt-4 text-lg font-semibold text-slate-700">지식을 테스트해보세요</h4><p class="mt-1 text-sm text-slate-500">학습한 내용을 기반으로 퀴즈를 풀어보세요.</p><div class="mt-6 flex flex-col space-y-3 w-full max-w-xs"><button data-action="start-quiz" class="btn w-full justify-center" ${!hasQuestions ? 'disabled' : ''}>퀴즈 시작 (${hasQuestions ? state.activeChapterContent.questions.length : 0}문제)</button><button data-action="manage-quiz" class="btn btn-secondary w-full justify-center">퀴즈 관리</button><button data-action="generate-quiz" class="btn btn-secondary w-full justify-center">${Heroicons.render('sparkles', { class: 'w-5 h-5 mr-2' })}AI로 문제 추가</button></div>${!hasQuestions ? '<p class="mt-2 text-xs text-slate-400">퀴즈를 진행하려면 문제를 먼저 추가해주세요.</p>' : ''}</div>`;
        },
        renderTranslatePanel() {
            const content = state.activeChapterContent;
            const layout = state.workspaceLayout;
            const sourceText = content.manuscript ? marked.parse(content.manuscript) : '<p>번역할 원문이 없습니다.</p>';
            const leftClasses = (layout === 'right') ? 'hidden' : '';
            const rightClasses = (layout === 'left') ? 'hidden' : '';
            const gridClasses = (layout === 'split') ? 'lg:grid-cols-2' : 'lg:grid-cols-1';
            const layoutButton = (mode, icon, label) => {
                const isActive = layout === mode;
                return `<button data-action="set-workspace-layout" data-layout="${mode}" data-tooltip="${label}" 
                                class="layout-toggle-button ${isActive ? 'active' : ''}">
                            ${Heroicons.render(icon, { class: 'w-4 h-4' })}
                        </button>`;
            };
            const controls = `
                    <div class="flex justify-between items-center mb-4">
                        <button data-action="open-split-chapter-modal" class="btn btn-secondary p-2" data-tooltip="번역문 분할">
                            ${Heroicons.render('arrows-right-left', { class: 'w-5 h-5' })}
                        </button>
                        <div class="flex-grow flex justify-center">
                            <div class="inline-flex rounded-md shadow-sm">
                                ${layoutButton('left', 'arrow-left-on-rectangle', '원문만 보기')}
                                ${layoutButton('split', 'squares-2x2', '양쪽 보기')}
                                ${layoutButton('right', 'arrow-right-on-rectangle', '번역문만 보기')}
                            </div>
                        </div>
                        <button data-action="copy-translation-prompt" class="btn btn-secondary p-2" data-tooltip="번역 프롬프트 복사">
                            ${Heroicons.render('clipboard-document', { class: 'w-5 h-5' })}
                        </button>
                    </div>`;

                return `<div>
                            ${controls}
                            <div class="grid grid-cols-1 ${gridClasses} gap-6">
                                <div class="${leftClasses} h-[60vh] flex flex-col">
                                    <h3 class="text-lg font-semibold mb-2 text-slate-800">원문</h3>
                                    <div class="prose prose-custom flex-grow overflow-y-auto p-4 border rounded-md bg-slate-50">${sourceText}</div>
                                </div>
                                <div class="${rightClasses} h-[60vh] flex flex-col">
                                    <h3 class="text-lg font-semibold mb-2 text-slate-800">번역문</h3>
                                    <textarea id="translation" data-field="translation" class="w-full flex-grow p-4 border rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500" data-preserve-focus="translation">${content.translation || ''}</textarea>
                                </div>
                            </div>
                        </div>`;
            },
        renderCustomButtonPanel() {
            const customPrompts = state.activeProject.settings.customPrompts || [];
            if (customPrompts.length === 0) {
                return `<div class="flex flex-col items-center justify-center h-full min-h-[60vh] text-center p-4">
                        ${Heroicons.render('sparkles', { class: 'h-16 w-16 text-slate-300' })}
                        <h3 class="mt-4 text-xl font-semibold text-slate-800">커스텀 버튼이 없습니다</h3>
                        <p class="mt-1 text-slate-500">프로젝트 설정에서 자주 사용하는 커스텀 프롬프트 버튼을 추가해보세요.</p>
                        <button class="btn mt-6" data-action="open-settings">${Heroicons.render('cog-6-tooth', { class: 'w-4 h-4 mr-2' })}설정으로 이동</button>
                    </div>`;
            }
            const buttonsHtml = customPrompts.map((prompt, index) => {
                return `<button class="btn btn-secondary" data-action="copy-custom-prompt" data-index="${index}">
                        ${Heroicons.render('clipboard', { class: 'w-4 h-4 mr-2' })}
                        <span>${DOMPurify.sanitize(prompt.name)}</span>
                    </button>`;
            }).join('');
            return `<div class="p-4">
                    <h3 class="text-xl font-semibold mb-4 text-slate-800 border-b pb-2">커스텀 프롬프트 버튼</h3>
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                        ${buttonsHtml}
                    </div>
                </div>`;
        },
        renderSpinner: (message) => `<div class="flex items-center justify-center h-full"><div class="text-center"><svg class="mx-auto h-12 w-12 text-slate-400 animate-spin" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><h2 class="mt-4 text-lg font-medium text-slate-900">${message}</h2></div></div>`,
        renderContextMenu() {
            // 1. 메뉴를 담을 최상위 컨테이너를 찾습니다.
            const contextMenuContainer = document.getElementById('context-menu-root');
            if (!contextMenuContainer) return; // 컨테이너가 없으면 아무 작업도 하지 않습니다.

            const {
                isOpen,
                x,
                y
            } = state.contextMenu;

            // 2. 메뉴가 닫혀야 하는 상태라면, 컨테이너 내용을 완전히 비우고 함수를 종료합니다.
            if (!isOpen) {
                contextMenuContainer.innerHTML = '';
                return;
            }

            const menuItems = state.activeProject?.settings?.contextMenuItems || [];

            // 3. 메뉴를 열어야 하지만 표시할 아이템이 없다면, 역시 컨테이너를 비우고 종료합니다.
            if (menuItems.length === 0) {
                // ▼▼▼ [수정] 이 부분도 컨테이너를 비워야 합니다. ▼▼▼
                contextMenuContainer.innerHTML = '';
                return;
            }

            const itemsHtml = menuItems.map((item, index) =>
                `<button data-action="execute-context-menu" data-index="${index}" class="block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 hover:text-slate-900">${DOMPurify.sanitize(item.name)}</button>`
            ).join('');

            // 4. 메뉴 HTML을 생성하여 컨테이너에 삽입합니다. (처음에는 숨겨진 상태로)
            contextMenuContainer.innerHTML = `
            <div id="context-menu" class="fixed z-[2500] mb-2 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none context-menu-unselectable"
                style="visibility: hidden; top: ${y}px; left: ${x}px;">
                <div class="py-1" role="menu" aria-orientation="vertical">${itemsHtml}</div>
            </div>`;
            const menuEl = document.getElementById('context-menu');
            if (menuEl) {
                // 이 리스너는 메뉴 클릭 시 텍스트 선택이 해제되는 것을 방지하는 핵심 역할을 합니다.
                menuEl.addEventListener('mousedown', e => {
                    console.log('[Debug] Context menu mousedown detected. Preventing default focus shift.');
                    e.preventDefault();
                });

                // 메뉴 위치 조정 로직은 그대로 유지됩니다.
                const rect = menuEl.getBoundingClientRect();
                let finalX = x;
                let finalY = y;
                if (x + rect.width > window.innerWidth) finalX = window.innerWidth - rect.width - 10;
                if (y + rect.height > window.innerHeight) finalY = window.innerHeight - rect.height - 10;
                menuEl.style.left = `${finalX}px`;
                menuEl.style.top = `${finalY}px`;
                menuEl.style.visibility = 'visible';
            }
        },
        renderToasts() {
            return `<div class="fixed bottom-4 right-4 space-y-3 z-[3000]">${state.toasts.map(toast => {
                let icon = '';
                // 아이콘 색상을 더 선명하게 조정합니다.
                if (toast.type === 'success') icon = Heroicons.render('check-circle', { class: 'h-6 w-6 text-green-500' });
                if (toast.type === 'error') icon = Heroicons.render('exclamation-circle', { class: 'h-6 w-6 text-red-500' });
                if (toast.type === 'info') icon = Heroicons.render('information-circle', { class: 'h-6 w-6 text-blue-500' });
                
                // ▼▼▼ [수정] 하드코딩된 스타일 클래스를 제거하고 너비 문제를 해결합니다. ▼▼▼
                return `
                    <div id="toast-${toast.id}" class="toast-panel max-w-md w-full shadow-lg rounded-lg pointer-events-auto ring-1 ring-black ring-opacity-5 overflow-hidden">
                        <div class="p-4">
                            <div class="flex items-start">
                                <div class="flex-shrink-0">
                                    ${icon}
                                </div>
                                <div class="ml-3 flex-1 pt-0.5">
                                    <p class="toast-text text-sm font-medium">${toast.message}</p>
                                </div>
                                <div class="ml-4 flex-shrink-0 flex">
                                    <button data-action="dismiss-toast" data-id="${toast.id}" class="toast-close-button rounded-md inline-flex">
                                        ${Heroicons.render('x-mark', { class: 'h-5 w-5' })}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('')}</div>`;
        },
        // View 객체 안에 있는 renderQuizView 함수를 아래 코드로 교체하세요.
            // View 객체 안에 있는 renderQuizView 함수를 아래 코드로 교체하세요.
        renderQuizView() {
            const { quizState } = state;
            if (!quizState || !quizState.questions[quizState.currentIndex]) return this.renderSpinner('퀴즈 로딩 중...');

            const q = quizState.questions[quizState.currentIndex];
            const isAnswered = quizState.answers[quizState.currentIndex] !== undefined;

            // 헬퍼: 콘텐츠를 마크다운으로 렌더링하고 정화합니다.
            const renderContent = (text) => text ? DOMPurify.sanitize(marked.parse(text)) : '';

            const renderAnswerComponent = () => {
                const userAnswerData = quizState.answers[quizState.currentIndex];
                switch (q.type) {
                    case CONFIG.QUIZ_TYPE.MULTIPLE_CHOICE:
                        const userAnswerIndex = userAnswerData?.selectedIndex;
                        return `<div class="grid grid-cols-1 sm:grid-cols-2 gap-4 w-full">${
                            q.options.map((opt, index) => {
                                let status = "neutral";
                                if (isAnswered) {
                                    if (index === q.answerIndex) status = 'correct';
                                    else if (index === userAnswerIndex) status = 'incorrect';
                                }
                                return `<button data-action="submit-answer" data-index="${index}" class="quiz-option-button w-full text-left p-4 border rounded-lg transition-colors" data-answer-status="${status}" ${isAnswered ? 'disabled' : ''}>${renderContent(opt)}</button>`;
                            }).join('')
                        }</div>`;
                    default:
                        // [수정] 주관식 폼의 최대 너비를 max-w-md에서 max-w-2xl로 늘렸습니다.
                        return `
                        <form data-action="submit-text-answer" class="w-full max-w-2xl text-center">
                            <textarea id="answer-input" name="answer-input" rows="4" class="w-full text-lg border-2 p-2 bg-transparent border-slate-300 rounded-md focus:outline-none focus:border-indigo-500 transition-colors" placeholder="답안을 입력하세요..." ${isAnswered ? 'disabled' : 'autofocus'}>${userAnswerData?.userAnswer || ''}</textarea>
                            <button type="submit" class="btn mt-8" ${isAnswered ? 'disabled' : ''}>제출하고 정답 확인</button>
                        </form>`;
                }
            };

            const renderFeedback = () => {
                if (!isAnswered) return `<div class="min-h-[148px]"></div>`; // 피드백 영역 높이 확보
                const { isCorrect } = quizState.answers[quizState.currentIndex];
                const feedbackStatus = isCorrect ? 'correct' : 'incorrect';
                const icon = isCorrect ? Heroicons.render('check-circle', { class: 'w-5 h-5' }) : Heroicons.render('x-circle', { class: 'w-5 h-5' });
                const isLastQuestion = quizState.currentIndex + 1 >= quizState.questions.length;
                const nextButtonText = isLastQuestion ? '결과 보기' : '다음 문제';
                const nextButtonIcon = isLastQuestion ? 'flag' : 'arrow-right-circle';
                let correctDisplay = '';
                if (!isCorrect) {
                    correctDisplay = q.type === 'multiple_choice' ? renderContent(q.options[q.answerIndex]) : renderContent(q.answer);
                }

                return `
                <div class="quiz-feedback-panel p-4 rounded-lg mt-8 w-full max-w-3xl text-left" data-answer-status="${feedbackStatus}">
                    <p class="font-bold flex items-center gap-2">${icon} ${isCorrect ? '정답입니다!' : '오답입니다.'}</p>
                    ${!isCorrect ? `<div class="text-sm mt-2"><span class="font-semibold">모범 답안:</span><div class="mt-1">${correctDisplay}</div></div>` : ''}
                    <div class="text-sm mt-2"><span class="font-semibold">해설:</span><div class="mt-1 prose prose-sm max-w-none">${renderContent(q.explanation)}</div></div>
                    <div class="mt-4 flex justify-end">
                        <button data-action="next-question" class="btn flex items-center gap-2">${nextButtonText} ${Heroicons.render(nextButtonIcon, { class: 'w-5 h-5' })}</button>
                    </div>
                </div>`;
            };

            const questionTypeMap = {
                [CONFIG.QUIZ_TYPE.MULTIPLE_CHOICE]: '객관식',
                [CONFIG.QUIZ_TYPE.SHORT_ANSWER]: '단답형',
                [CONFIG.QUIZ_TYPE.SUBJECTIVE]: '서술형',
                [CONFIG.QUIZ_TYPE.CASE_BASED]: '사례형'
            };
            
            // [수정] main 태그에서 text-center 클래스를 제거하고, 문제 컨테이너에서 text-left를 명시합니다.
            // [수정] h2 태그를 div로 바꾸고 폰트 크기를 text-xl md:text-2xl로 조정했습니다.
            return `
            <div class="quiz-container fixed inset-0 flex flex-col z-[1000]">
                <header class="quiz-header shadow-sm p-4 sticky top-0 z-10">
                    <div class="flex items-center justify-between gap-4 max-w-5xl mx-auto">
                        <div class="font-bold text-lg w-24 quiz-text-primary">${quizState.currentIndex + 1} / ${quizState.questions.length}</div>
                        <div class="w-full quiz-progress-bar-bg rounded-full h-4 overflow-hidden">
                            <div class="quiz-progress-bar-fill h-4 rounded-full transition-all duration-300" style="width: ${((quizState.currentIndex) / quizState.questions.length) * 100}%"></div>
                        </div>
                        <button data-action="exit-quiz" class="p-2 rounded-full hover:bg-slate-200" title="퀴즈 나가기">
                            ${Heroicons.render('x-mark', { class: 'quiz-text-secondary' })}
                        </button>
                    </div>
                </header>
                <main class="flex-1 flex flex-col items-center justify-center p-6 overflow-y-auto">
                    <div class="w-full max-w-3xl text-left">
                        <p class="quiz-text-secondary text-sm mb-2">${questionTypeMap[q.type] || '문제'}</p>
                        <div class="text-xl md:text-2xl font-bold leading-tight quiz-text-primary prose max-w-none">${renderContent(q.questionText)}</div>
                    </div>
                    <div class="mt-12 w-full flex justify-center">${renderAnswerComponent()}</div>
                    ${renderFeedback()}
                </main>
            </div>`;
        },
            // View 객체 안에 있는 renderQuizResultView 함수를 아래 코드로 교체하세요.
           // View 객체 안에 있는 renderQuizResultView 함수를 아래 코드로 교체하세요.
renderQuizResultView() {
    const { questions, answers } = state.quizState;
    const totalQuestions = questions.length;
    const correctCount = answers.filter(a => a.isCorrect).length;
    const score = totalQuestions > 0 ? Math.round((correctCount / totalQuestions) * 100) : 0;
    const renderContent = (text) => text ? DOMPurify.sanitize(marked.parse(text)) : '<i>(내용 없음)</i>';

    const filterControls = `
        <div class="flex justify-center gap-4 mb-6">
            <button data-action="set-quiz-result-filter" data-filter="all" class="btn btn-sm ${state.quizResultFilter === 'all' ? '' : 'btn-secondary'}">전체 보기</button>
            <button data-action="set-quiz-result-filter" data-filter="incorrect" class="btn btn-sm ${state.quizResultFilter === 'incorrect' ? '' : 'btn-secondary'}">틀린 문항만 보기</button>
        </div>
    `;

    const summaryHtml = `
    <div class="bg-panel rounded-xl shadow-lg p-6 sm:p-8 text-center mb-8">
        <div class="text-6xl font-bold quiz-result-score">${score}<span class="text-2xl font-medium quiz-text-secondary">점</span></div>
        <p class="mt-2 text-lg font-semibold quiz-text-primary">${totalQuestions}문제 중 ${correctCount}문제 정답</p>
        <div class="mt-6">
            <button data-action="back-to-workspace" class="btn">${Heroicons.render('arrow-left', { class: 'w-4 h-4 mr-2' })} 학습으로 돌아가기</button>
        </div>
    </div>`;
    
    const filteredQuestions = state.quizResultFilter === 'incorrect' ?
        questions.filter((q, index) => !answers[index].isCorrect) :
        questions;

    const questionCardsHtml = filteredQuestions.map((q, index) => {
        const originalIndex = state.quizResultFilter === 'incorrect' ? questions.findIndex(origQ => origQ.id === q.id) : index;
        const userAnswerData = answers[originalIndex];
        const isCorrect = userAnswerData.isCorrect;
        const cardClass = isCorrect ? 'border-l-4 border-green-500' : 'border-l-4 border-red-500';
        let answerFeedbackHtml = '';

        if (q.type === CONFIG.QUIZ_TYPE.MULTIPLE_CHOICE) {
            answerFeedbackHtml = q.options.map((option, optIndex) => {
                const isUserAnswer = optIndex === userAnswerData.selectedIndex;
                const isCorrectAnswer = optIndex === q.answerIndex;
                let status = "neutral";
                if (isUserAnswer && !isCorrect) status = 'incorrect';
                if (isCorrectAnswer) status = 'correct';
                
                let icon = '';
                if (isUserAnswer && !isCorrect) icon = Heroicons.render('x-circle', { class: 'w-5 h-5 mr-2 flex-shrink-0' });
                if (isCorrectAnswer) icon = Heroicons.render('check-circle', { class: 'w-5 h-5 mr-2 flex-shrink-0' });
                return `<div class="flex items-center p-3 mt-2 border rounded-md quiz-option-button" data-answer-status="${status}">${icon}<div>${renderContent(option)}</div></div>`;
            }).join('');
        } else {
             const userAnswerHtml = `<div class="subjective-answer-box"><h4>${Heroicons.render('user', { class: 'w-4 h-4' })}제출한 답안</h4><div class="prose prose-sm max-w-none">${renderContent(userAnswerData.userAnswer || '')}</div></div>`;
             const correctAnswerHtml = `<div class="subjective-answer-box"><h4>${Heroicons.render('check-circle', { class: 'w-4 h-4 text-green-600' })}모범 답안</h4><div class="prose prose-sm max-w-none">${renderContent(q.answer)}</div></div>`;
             answerFeedbackHtml = isCorrect ? correctAnswerHtml : `<div class="subjective-answer-grid">${userAnswerHtml}${correctAnswerHtml}</div>`;
        }
        
        // [수정] 문제 텍스트를 p 태그에서 div로 바꾸고 폰트 크기를 text-xl로 조정했습니다.
        return `<div class="bg-panel rounded-lg shadow p-6 mb-6 text-left ${cardClass}">
                <p class="text-sm font-semibold quiz-text-secondary">문제 ${originalIndex + 1}</p>
                <div class="mt-1 text-xl font-semibold quiz-text-primary prose max-w-none">${renderContent(q.questionText)}</div>
                <div class="mt-4">${answerFeedbackHtml}</div>
                <div class="mt-4 pt-4 border-t border-slate-200">
                    <p class="text-sm font-semibold quiz-text-primary">해설</p>
                    <div class="mt-1 text-sm quiz-text-secondary prose prose-sm max-w-none">${renderContent(q.explanation)}</div>
                </div>
            </div>`;
    }).join('');

    return `<div class="quiz-container fixed inset-0 flex flex-col z-[1000] overflow-y-auto">
        <header class="quiz-header shadow-sm p-4 sticky top-0 z-10">
            <div class="max-w-4xl mx-auto text-center text-2xl font-bold quiz-text-primary">퀴즈 결과</div>
        </header>
        <main class="flex-grow w-full max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            ${summaryHtml}
            <h3 class="text-2xl font-bold quiz-text-primary mb-6 border-b pb-3 border-slate-200">문항별 다시보기</h3>
            ${filterControls}
            ${questionCardsHtml}
        </main>
    </div>`;
},
        };
         const FootnoteManager = {
            footnotes: {},
            footnoteOrder: [],
            
            clear() {
                this.footnotes = {};
                this.footnoteOrder = [];
            },
        
            addDefinition(key, content) {
                const lowerKey = key.toLowerCase();
                if (!this.footnotes[lowerKey]) {
                    const trimmedContent = content.trim().replace(/\n/g, ' ');
                    const inlineHtml = marked.parseInline(trimmedContent);
                    this.footnotes[lowerKey] = {
                        text: trimmedContent,
                        html: inlineHtml
                    };
                }
            },
        
            addReference(key) {
                const lowerKey = key.toLowerCase();
                if (this.footnoteOrder.indexOf(lowerKey) === -1) {
                    this.footnoteOrder.push(lowerKey);
                }
            },
            
            getNote(key) {
                return this.footnotes[key.toLowerCase()];
            },
            
            getOrder() {
                return this.footnoteOrder;
            },
        
            extractAndClean(markdown) {
                // this.clear(); // [핵심 수정] 이 라인을 삭제하거나 주석 처리합니다.
                // [핵심 수정] 마지막 각주를 놓치지 않도록 정규표현식 개선
                // (?=\n\[\^|$) lookahead를 사용하여 다음 각주 또는 파일의 끝(End of String)을 기준으로 삼습니다.
                const footnoteDefRegex = /^\[\^(.+?)\]:\s*([\s\S]*?)(?=\n\[\^|$)/gm;
        
                const cleanedMarkdown = markdown.replace(footnoteDefRegex, (match, name, content) => {
                    this.addDefinition(name, content);
                    return ''; // 원본 텍스트에서 각주 정의 부분 제거
                });
                
                return cleanedMarkdown;
            }
        };

        const Controller = {
            async init() {
                 this.checkVersion();
                if (navigator.storage && navigator.storage.persist) {
                    try {
                        const isPersisted = await navigator.storage.persisted();
                        if (!isPersisted) {
                            const granted = await navigator.storage.persist();
                            if (granted) console.log("영구 저장소 권한이 부여되었습니다.");
                            else console.warn("영구 저장소 권한이 거부되었습니다.");
                        }
                    } catch (error) {
                        console.error("영구 저장소 요청 중 오류 발생:", error);
                    }
                }

                Heroicons.load().catch(console.error);
                SyncManager.init(this.reloadDataAndRender.bind(this));
                const savedTheme = localStorage.getItem('appTheme') || 'light';
                state.theme = savedTheme;
                document.documentElement.classList.toggle('dark', savedTheme === 'dark');

                this.initializeConfig();
                ModalManager.init();
                marked.setOptions({ gfm: true, breaks: true });
                
                const turndownService = new TurndownService();
                turndownService.addRule('highlight', {
                    filter: ['mark'],
                    replacement: function (content) {
                        return '==' + content + '==';
                    }
                });
                this.turndownService = turndownService;

                this.bindGlobalEventListeners();
                
                // URL 해시 변경 이벤트를 감지하도록 리스너를 추가합니다.
                window.addEventListener('hashchange', this.handleURLNavigation.bind(this));

                await DB.init();
                const [projects, categories, userProfile] = await Promise.all([
                    DB.getAll(CONFIG.STORES.PROJECTS),
                    DB.getAll(CONFIG.STORES.CATEGORIES),
                    DB.get(CONFIG.STORES.USER_PROFILE, 'main')
                ]);
                
                state.projects = projects;
                state.categories = categories.sort((a, b) => a.name.localeCompare(b.name));
                state.userProfile = userProfile || { id: 'main', level: 1, xp: 0 };
                if (!userProfile) await DB.put(CONFIG.STORES.USER_PROFILE, state.userProfile);
                this.updateTags();
                this.buildSearchIndex();
                state.isLoading = false;

                // 모든 데이터 로드 후, 현재 URL을 기반으로 초기 화면을 설정하고 렌더링합니다.
                await this.handleURLNavigation();
            },
            async checkVersion() {
                try {
                    // 브라우저 캐시를 무시하고 항상 최신 파일을 가져오기 위해 타임스탬프를 쿼리 파라미터로 추가합니다.
                    const response = await fetch('version.json?cache_bust=' + new Date().getTime());
                    if (!response.ok) return; // 파일을 찾을 수 없으면 조용히 종료합니다.

                    const serverVersionData = await response.json();
                    const serverVersion = serverVersionData.version;

                    console.log(`[Version Check] Current: ${APP_VERSION}, Server: ${serverVersion}`);

                    // 서버 버전이 현재 앱 버전과 다를 경우에만 업데이트 알림을 표시합니다.
                    if (serverVersion && serverVersion !== APP_VERSION) {
                        const wantsUpdate = confirm(
                            `새로운 버전(v${serverVersion})이 있습니다. 업데이트를 위해 페이지를 새로고침 하시겠습니까?\n\n(취소할 경우 일부 기능이 정상 작동하지 않을 수 있습니다.)`
                        );

                        if (wantsUpdate) {
                            // location.reload(true)는 캐시를 무시하고 서버에서 리소스를 강제로 다시 로드합니다.
                            location.reload(true);
                        }
                    }
                } catch (error) {
                    console.error("버전 확인 중 오류 발생:", error);
                }
            },

            // ▼▼▼ [수정] 이 함수 전체를 Controller 객체 내부에 새로 추가하세요 ▼▼▼
            /**
             * [신규] 모든 커스텀 확장 기능이 적용된 격리된 파서 인스턴스를 사용하여 Markdown을 파싱합니다.
             * @param {string} markdownText - 변환할 Markdown 텍스트
             * @returns {string} - 변환된 HTML 문자열
             */
            parseMarkdownWithExtensions(markdownText) {
                if (typeof markdownText !== 'string') return '';

                // 파싱할 때마다 새로운 Marked 인스턴스를 생성하여 상태 공유 문제를 원천적으로 차단합니다.
                const isolatedParser = new marked.Marked();

                const highlightExtension = {
                    name: 'highlight',
                    level: 'inline',
                    start(src) { return src.indexOf('=='); },
                    tokenizer(src) {
                        const rule = /^==(.+?)==/;
                        const match = rule.exec(src);
                        if (match) {
                            return { type: 'highlight', raw: match[0], text: this.lexer.inlineTokens(match[1].trim()) };
                        }
                    },
                    renderer(token) { return `<mark>${this.parser.parseInline(token.text)}</mark>`; },
                };

                const footnoteRefExtension = {
                    name: 'footnoteRef',
                    level: 'inline',
                    start(src) { return src.indexOf('[^'); },
                    tokenizer(src) {
                        const rule = /^\[\^((?:[^\]\\]|\\.)+)\](?!:)/;
                        const match = rule.exec(src);
                        if (match) {
                            FootnoteManager.addReference(match[1]);
                            return { type: 'footnoteRef', raw: match[0], name: match[1] };
                        }
                    },
                    renderer(token) {
                        const name = token.name;
                        const order = FootnoteManager.getOrder();
                        const note = FootnoteManager.getNote(name);
                        const index = order.indexOf(name.toLowerCase()) + 1;
                        const finalIndex = index > 0 ? index : '?';
                        let tooltipContent = note ? (note.text || '').replace(/"/g, '&quot;').replace(/\n/g, ' ') : '각주 내용을 찾을 수 없습니다.';
                        
                        return `<sup id="fnref:${name}" class="footnote-ref"><a href="#fn:${name}" data-action="footnote-jump" data-footnote-key="${name}" data-tooltip="${tooltipContent}">${finalIndex}</a></sup>`;
                    }
                };
                
                isolatedParser.use({ gfm: true, breaks: true, extensions: [highlightExtension, footnoteRefExtension] });

                console.log(`[Debug] Parsing with isolated instance. Input length: ${markdownText.length}`);
                const result = isolatedParser.parse(markdownText);
                return result;
            },
            // ▲▲▲ [수정 완료] ▲▲▲

            updateSaveStatus(status) {
                state.saveStatus = status;
                if (status === 'saved') {
                    state.saveTimestamp = new Date();
                }
                // View의 전체 렌더링 대신, 상태 표시기만 업데이트하도록 요청합니다.
                View.updateSaveStatusIndicator(); 
                this.updateUnloadWarning(); // 저장 중 경고 상태도 함께 업데이트
            },
            // 1. (유지) 브라우저의 기본 컨텍스트 메뉴를 막는 역할은 여전히 매우 중요합니다.
           handleContextMenu(e) {
                const viewPanel = e.target.closest('.prose-readable');
                // 메뉴가 열릴 조건이 아니면 즉시 종료 (기본 메뉴는 그대로 나타남)
                if (state.currentView !== 'workspace' || state.workspaceMode !== 'view' || !viewPanel) {
                    return;
                }

                // [핵심 수정] setTimeout을 제거하고, 텍스트 선택 여부를 즉시 확인합니다.
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                const menuItems = state.activeProject?.settings?.contextMenuItems || [];
                
                // [핵심 수정] 텍스트가 선택되었고, 표시할 메뉴 아이템이 있을 때만 기본 메뉴를 막고 커스텀 메뉴를 엽니다.
                if (selectedText && !selection.isCollapsed && selection.rangeCount > 0 && menuItems.length > 0) {
                    e.preventDefault(); // << 이 줄의 위치가 매우 중요합니다.

                    state.contextMenu = {
                        isOpen: true,
                        x: e.clientX,
                        y: e.clientY,
                        selectedText: selectedText,
                        range: selection.getRangeAt(0)
                    };
                    console.log('[Debug] 텍스트 선택됨. 커스텀 컨텍스트 메뉴를 엽니다.', state.contextMenu);
                    View.render(); // render()가 내부적으로 renderContextMenu()를 호출합니다.
                } else {
                    // 텍스트가 선택되지 않았으면 아무것도 하지 않고 브라우저 기본 메뉴가 나타나도록 둡니다.
                    console.log('[Debug] 선택된 텍스트 없음. 기본 컨텍스트 메뉴를 허용합니다.');
                }
            },
            // [추가] 렌더링 후 폼 요소의 값을 강제로 동기화하는 함수
            isNavigating: false, 
        syncFormElements() {
            if (state.currentView !== 'workspace' || !state.activeChapterContent) {
                return;
            }
            const content = state.activeChapterContent;
            const elementsToSync = {
                'manuscript': content.manuscript || '',
                'notes': content.notes || '',
                'translation': content.translation || ''
            };

            for (const [id, value] of Object.entries(elementsToSync)) {
                const textarea = document.getElementById(id);
                // textarea가 화면에 존재하고, 메모리의 값과 화면의 값이 다를 경우에만 갱신
                if (textarea && textarea.value !== value) {
                    console.log(`[Sync] '${id}' 요소의 값을 동기화합니다.`);
                    textarea.value = value;
                }
            }
        },
        /**
 * [신규] 하이라이트 삭제 버튼을 특정 위치에 표시합니다.
 * @param {HTMLElement} markElement - 클릭된 <mark> 요소
 * @param {MouseEvent} event - 클릭 이벤트 객체
 */
showHighlightDeleteButton(markElement, event) {
    // 임시 ID를 부여하여 어떤 마크를 삭제할지 식별
    const tempId = `mark_${Date.now()}`;
    markElement.dataset.tempId = tempId;

    const root = document.getElementById('highlight-menu-root');
    if (!root) return;
    
    // 페이지 스크롤 위치를 고려하여 버튼의 절대 위치 계산
    const top = event.clientY + window.scrollY - 10;
    const left = event.clientX + window.scrollX;

    root.innerHTML = `
        <button class="highlight-delete-btn"
                style="top: ${top}px; left: ${left}px;"
                data-action="delete-highlight"
                data-target-id="${tempId}"
                title="하이라이트 삭제">
            ${Heroicons.render('x-mark', { class: 'w-4 h-4' })}
        </button>
    `;
},

/**
 * [신규] 표시된 하이라이트 삭제 버튼을 숨깁니다.
 */
hideHighlightDeleteButton() {
    const root = document.getElementById('highlight-menu-root');
    if (root) root.innerHTML = '';
},

/**
 * [신규] 사용자가 하이라이트를 클릭했을 때의 동작을 처리합니다.
 * @param {MouseEvent} event - 클릭 이벤트 객체
 */
handleHighlightClick(event) {
    const target = event.target;
    const clickedMark = target.closest('mark');
    
    // <mark> 태그나 삭제 버튼 자체를 클릭한 것이 아니라면, 기존 버튼을 숨깁니다.
    if (!clickedMark && !target.closest('.highlight-delete-btn')) {
        this.hideHighlightDeleteButton();
        return;
    }

    // <mark> 태그를 클릭했다면, 해당 위치에 삭제 버튼을 표시합니다.
    if (clickedMark) {
        event.stopPropagation(); // 이벤트 버블링을 막아 다른 클릭 핸들러 방해 방지
        this.showHighlightDeleteButton(clickedMark, event);
    }
},
            // [추가] 다른 탭의 변경사항을 반영하기 위한 데이터 새로고침 및 UI 렌더링 함수
        async reloadDataAndRender(payload) {
            console.log('[Controller] 데이터 새로고침 및 UI 렌더링을 시작합니다.', payload);
            
            // 1. 라이브러리 기본 정보(프로젝트, 카테고리 등)를 다시 불러옵니다.
            const [projects, categories, userProfile] = await Promise.all([
                DB.getAll(CONFIG.STORES.PROJECTS),
                DB.getAll(CONFIG.STORES.CATEGORIES),
                DB.get(CONFIG.STORES.USER_PROFILE, 'main')
            ]);

            state.projects = projects;
            state.categories = categories.sort((a, b) => a.name.localeCompare(b.name));
            state.userProfile = userProfile || state.userProfile;
            this.updateTags();
            this.buildSearchIndex();

            // 2. 현재 프로젝트를 보고 있는 경우, 해당 프로젝트의 최신 정보도 갱신합니다.
            if (state.activeProjectId) {
                const updatedProject = await DB.get(CONFIG.STORES.PROJECTS, state.activeProjectId);
                
                // 만약 다른 탭에서 현재 프로젝트가 삭제되었다면, 대시보드로 이동합니다.
                if (!updatedProject) {
                    this.showToast('현재 작업 중인 프로젝트가 다른 탭에서 삭제되었습니다.', 'error');
                    state.activeProjectId = null;
                    state.activeProject = null;
                    state.currentView = 'dashboard';
                } else {
                    // 프로젝트 정보와 콘텐츠 맵을 최신 상태로 업데이트합니다.
                    state.activeProject = updatedProject;
                    
                    const allNodes = Utils.getFlatToc(updatedProject.toc);
                    const contents = await Promise.all(
                        allNodes.map(nodeInfo => DB.get(CONFIG.STORES.CONTENTS, `${state.activeProjectId}_${nodeInfo.node.contentId}`))
                    );
                    
                    state.activeContentsMap.clear();
                    contents.forEach(c => {
                        if (c) state.activeContentsMap.set(c.id, c);
                    });

                    // 현재 열려있는 챕터의 내용도 최신화합니다.
                    if (state.activeChapterPath) {
                        const node = Utils.getNodeByPath(updatedProject.toc, state.activeChapterPath);
                        if (node && node.contentId) {
                            state.activeChapterContent = state.activeContentsMap.get(`${state.activeProjectId}_${node.contentId}`);
                        } else {
                            // 챕터가 삭제된 경우
                            state.activeChapterPath = null;
                            state.activeChapterContent = null;
                        }
                    }
                }
            }

            // 3. 모든 상태 업데이트 후 UI를 다시 렌더링합니다.
            View.render();
            this.syncFormElements(); 
        },
        // Controller 객체 내부에 아래 두 함수를 새로 추가하세요.

            /**
             * [신규 함수] selectionchange 이벤트를 처리하는 핸들러.
             * debounce를 통해 안정적으로 호출됩니다.
             */
            handleSelectionChange() {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                const viewPanel = document.querySelector('#workspace-main-content .prose-readable');
                const menuItems = state.activeProject?.settings?.contextMenuItems || [];

                // 메뉴가 표시되어야 하는 모든 조건을 검사합니다.
                const shouldShowMenu =
                    !selection.isCollapsed &&
                    state.currentView === 'workspace' &&
                    state.workspaceMode === 'view' &&
                    selectedText &&
                    menuItems.length > 0 &&
                    viewPanel &&
                    selection.rangeCount > 0 &&
                    viewPanel.contains(selection.getRangeAt(0).commonAncestorContainer);

                if (shouldShowMenu) {
                    const range = selection.getRangeAt(0);
                    const rect = range.getBoundingClientRect();

                    state.contextMenu = {
                        isOpen: true,
                        x: rect.left + rect.width / 2,
                        y: rect.top,
                        selectedText: selectedText,
                        openedAt: Date.now() // [핵심] 메뉴를 열 때 타임스탬프를 기록합니다.
                    };
                    View.renderContextMenu();
                } else if (state.contextMenu.isOpen) {
                    // 선택이 해제되는 등 메뉴가 닫혀야 할 경우
                    state.contextMenu.isOpen = false;
                    View.renderContextMenu();
                }
            },

            /**
             * [신규 함수] mousedown 이벤트를 처리하여 메뉴를 닫는 핸들러.
             * 유예 시간(Grace Period) 로직이 포함됩니다.
             */
            handleMouseDown(e) {
                // [핵심] 메뉴가 열린 지 200ms가 채 지나지 않았다면, 닫기 로직을 무시합니다.
                if (Date.now() - state.contextMenu.openedAt < 200) {
                    return;
                }

                // 메뉴 바깥을 클릭했을 때만 메뉴를 닫습니다.
                if (state.contextMenu.isOpen && !e.target.closest('#context-menu-root')) {
                    state.contextMenu.isOpen = false;
                    View.renderContextMenu();
                }

                // TOC 컨텍스트 메뉴 닫기 로직 (기존과 동일)
                if (state.tocContextMenu.isOpen && !e.target.closest('#toc-context-menu')) {
                    e.preventDefault();
                    state.tocContextMenu.isOpen = false;
                    View.render();
                }
            },
            updateViewProgressBar() {
                const container = document.querySelector('.main-content');
                const progressBar = document.getElementById('view-progress-bar');
                if (!container || !progressBar) return;

                const scrollableHeight = container.scrollHeight - container.clientHeight;
                const scrollPosition = container.scrollTop;

                let progress = 0;
                if (scrollableHeight > 0) {
                    progress = (scrollPosition / scrollableHeight) * 100;
                }

                // [핵심 수정] transform 대신 width를 직접 업데이트합니다.
                progressBar.style.width = `${progress}%`;
            },
           openTocContextMenu(event, path) {
                // 다중 선택 그룹에 포함되지 않은 항목을 우클릭/롱프레스 한 경우,
                // 기존 선택을 모두 해제하고 해당 항목만 새로 선택합니다.
                if (ModalManager.data.selectedTocPaths && !ModalManager.data.selectedTocPaths.has(path)) {
                    ModalManager.data.selectedTocPaths.clear();
                    ModalManager.data.selectedTocPaths.add(path);
                    ModalManager.data.lastSelectedTocPath = path;
                }

                state.tocContextMenu = {
                    isOpen: true,
                    x: event.clientX,
                    y: event.clientY,
                    path: path,
                };
                View.render();
            },
            handleImagePaste(e) {
                // 이미지 탭이 활성화된 상태가 아니면 아무것도 하지 않음
                if (state.currentView !== 'workspace' || state.workspaceMode !== 'image') {
                    return;
                }

                const items = e.clipboardData.items;
                for (let i = 0; i < items.length; i++) {
                    // 붙여넣은 항목이 이미지 파일일 경우
                    if (items[i].kind === 'file' && items[i].type.startsWith('image/')) {
                        const file = items[i].getAsFile();
                        if (file) {
                            e.preventDefault(); // 기본 붙여넣기 동작 방지
                            Controller.processImageFile(file);
                            break; // 첫 번째 이미지만 처리하고 종료
                        }
                    }
                }
            },
            saveChapterHistory: async (content, type = CONFIG.SNAPSHOT_TYPE.AUTO, message = '챕터 이력이 자동 저장되었습니다.') => {
                if (!content || !content.id) return;
                
                // history 속성이 없으면 초기화
                if (!content.history) content.history = [];

                // 현재 내용을 깊은 복사하여 히스토리에 추가
                const historyItem = {
                    timestamp: new Date().toISOString(),
                    type: type, // 스냅샷 유형 추가
                    content: JSON.parse(JSON.stringify(content))
                };
                content.history.unshift(historyItem); // 최신 버전을 맨 앞에 추가

                // 자동 스냅샷만 개수 제한을 적용
                const autoSnapshots = content.history.filter(h => h.type === CONFIG.SNAPSHOT_TYPE.AUTO);
                if (autoSnapshots.length > CONFIG.HISTORY_MAX_ITEMS) {
                    // 가장 오래된 자동 스냅샷을 찾아서 삭제
                    const oldestAutoSnapshotIndex = content.history.findIndex(h => h.id === autoSnapshots[autoSnapshots.length - 1].id);
                    content.history.splice(oldestAutoSnapshotIndex, 1);
                }
                
                await DB.put(CONFIG.STORES.CONTENTS, content);
                Controller.showToast(message, 'info');
            },

            unsavedChangesHandler(e) {
                e.preventDefault();
                e.returnValue = ''; // Chrome에서 경고창을 띄우기 위해 필요
            },
            ensureAllNodesHaveContentId(node) {
                if (!node) return;
                if (!node.contentId) {
                    console.warn('Missing contentId found in TOC node. Assigning a new one.', node);
                    node.contentId = Utils.generateId('content');
                }
                if (node.children && Array.isArray(node.children)) {
                    // [핵심 수정] 화살표 함수를 사용하여 'this' 컨텍스트를 유지합니다.
                    node.children.forEach(child => this.ensureAllNodesHaveContentId(child));
                }
            },
            showTooltip(target) {
                if (window.innerWidth <= 1024) return; // 모바일에선 비활성화
                const tooltipEl = document.getElementById('app-tooltip');
                const tooltipText = target.dataset.tooltip;
                if (!tooltipEl || !tooltipText) return;

                tooltipEl.innerHTML = tooltipText;

                const targetRect = target.getBoundingClientRect();
                const tooltipRect = tooltipEl.getBoundingClientRect();

                // 기본 위치: 타겟 요소의 왼쪽에 수직 중앙 정렬
                let top = targetRect.top + (targetRect.height / 2) - (tooltipRect.height / 2);
                let left = targetRect.left - tooltipRect.width - 12; // 12px 간격

                // 화면 왼쪽 경계 침범 시: 타겟 오른쪽에 표시
                if (left < 10) {
                    left = targetRect.right + 12;
                }
                // 화면 위쪽 경계 침범 시: 아래로 조정
                if (top < 10) {
                    top = 10;
                }
                // 화면 아래쪽 경계 침범 시: 위로 조정
                if (top + tooltipRect.height > window.innerHeight - 10) {
                    top = window.innerHeight - tooltipRect.height - 10;
                }

                tooltipEl.style.top = `${top}px`;
                tooltipEl.style.left = `${left}px`;
                tooltipEl.classList.add('show');
            },

            hideTooltip() {
                const tooltipEl = document.getElementById('app-tooltip');
                if (tooltipEl) {
                    tooltipEl.classList.remove('show');
                }
            },
            updateUnloadWarning() {
                if (state.saveStatus === 'saving') {
                    window.addEventListener('beforeunload', this.unsavedChangesHandler);
                } else {
                    window.removeEventListener('beforeunload', this.unsavedChangesHandler);
                }
            },
            getCombinedActions() {
                if (!state.activeProject) return [];

                // 1. 프로젝트 설정에 저장된 커스텀 프롬프트 목록을 가져옵니다. 이것이 유일한 기준이 됩니다.
                const customPrompts = state.activeProject.settings.customPrompts || [];

                // 2. '수동 스냅샷'과 같이 설정에서 관리되지 않는 시스템 고유 액션을 정의합니다.
                const systemActionsGroup = {
                    title: '시스템',
                    actions: [{
                        id: 'manual-snapshot',
                        name: '수동 스냅샷',
                        icon: 'camera',
                        template: '수동 스냅샷을 생성합니다.'
                    }]
                };

                // 3. 사용자가 설정한 프롬프트들을 '사용자 정의' 그룹으로 묶습니다.
                const userPromptsGroup = {
                    title: '사용자 정의 프롬프트',
                    actions: customPrompts
                };

                // 4. 내용이 있는 그룹만 필터링하여 반환합니다. 
                //    이제 하드코딩된 기본 그룹이 없으므로 중복이 발생하지 않습니다.
                return [userPromptsGroup, systemActionsGroup].filter(g => g.actions.length > 0);
            },
            async processAndCopyPrompt(template, actionTitle) {
                if (!template) {
                    this.showToast('프롬프트 템플릿이 비어있습니다.', 'error');
                    return;
                }

                // 1. 시스템이 자동으로 채울 수 있는 모든 변수 목록 정의
                const systemVariables = [
                    'bookTitle', 'projectGenre', 'projectAgeGroup', 'projectAudience', 
                    'references', 'partTitle', 'partDescription', 'chapterTitle', 
                    'chapterDescription', 'fullToc', 'partToc', 'projectStyleExample', 
                    'manuscript', 'translation', 'notes', 'selected_text'
                ];

                // 2. 템플릿에서 모든 {{...}} 변수를 추출
                const allVarsInTemplate = [...template.matchAll(/{{\s*([^}]+?)\s*}}/g)].map(match => match[1]);
                const uniqueVars = [...new Set(allVarsInTemplate)];

                // 3. 사용자가 직접 입력해야 하는 변수 필터링
                const userVariables = uniqueVars.filter(v => !systemVariables.includes(v));

                // 4. 모든 시스템 변수의 현재 값을 가져옵니다.
                const systemValues = this.getSystemVariableValues();

                // 5. 사용자 입력이 필요한 변수가 있다면 모달을 엽니다.
                if (userVariables.length > 0) {
                    ModalManager.open('promptVariables', {
                        title: actionTitle,
                        variables: userVariables,
                        template: template,
                        systemValues: systemValues // 시스템 값들을 모달 데이터로 전달
                    });
                } else {
                    // 6. 필요한 변수가 없다면 즉시 프롬프트를 생성하고 복사합니다.
                    let finalPrompt = template;
                    for (const [key, value] of Object.entries(systemValues)) {
                        const regex = new RegExp(`{{\\s*${key}\\s*}}`, 'g');
                        finalPrompt = finalPrompt.replace(regex, value || '');
                    }
                    this.copyToClipboard(finalPrompt);
                }
            },

            // ▼▼▼ [추가] 시스템 변수의 현재 값을 객체로 반환하는 헬퍼 함수입니다. ▼▼▼
            getSystemVariableValues() {
                if (!state.activeProject) return {};
                
                const { settings, toc } = state.activeProject;
                const chapterNode = state.activeChapterPath ? Utils.getNodeByPath(toc, state.activeChapterPath) : null;
                const pathParts = state.activeChapterPath ? state.activeChapterPath.split('.').map(Number) : [];
                const partNode = toc.children?.[pathParts[0]];
                
                return {
                    'selected_text': state.contextMenu.selectedText || '',
                    'bookTitle': toc.title || '',
                    'projectGenre': settings.writingGenre || '',
                    'projectAgeGroup': settings.writingAgeGroup || '',
                    'projectAudience': settings.writingAudience || '',
                    'references': settings.writingReferences || '',
                    'partTitle': partNode?.title || '',
                    'partDescription': partNode?.description || '',
                    'chapterTitle': chapterNode?.title || '',
                    'chapterDescription': state.activeChapterContent?.notes || chapterNode?.description || '',
                    'fullToc': Utils.generateTocText(toc, 0, '', state.activeChapterPath),
                    'partToc': partNode ? Utils.generateTocText(partNode, 0, '', pathParts.slice(1).join('.')) : '',
                    'projectStyleExample': settings.writingStyle || '',
                    'manuscript': state.activeChapterContent?.manuscript || '',
                    'translation': state.activeChapterContent?.translation || '',
                    'notes': state.activeChapterContent?.notes || '',
                };
            },
            

            // ▼▼▼ [추가] 시스템 변수의 현재 값을 객체로 반환하는 헬퍼 함수입니다. ▼▼▼
            getSystemVariableValues() {
                if (!state.activeProject) return {};
                
                const { settings, toc } = state.activeProject;
                const chapterNode = state.activeChapterPath ? Utils.getNodeByPath(toc, state.activeChapterPath) : null;
                const pathParts = state.activeChapterPath ? state.activeChapterPath.split('.').map(Number) : [];
                const partNode = toc.children?.[pathParts[0]];
                
                return {
                    'selected_text': state.contextMenu.selectedText || '',
                    'bookTitle': toc.title || '',
                    'projectGenre': settings.writingGenre || '',
                    'projectAgeGroup': settings.writingAgeGroup || '',
                    'projectAudience': settings.writingAudience || '',
                    'references': settings.writingReferences || '',
                    'partTitle': partNode?.title || '',
                    'partDescription': partNode?.description || '',
                    'chapterTitle': chapterNode?.title || '',
                    'chapterDescription': state.activeChapterContent?.notes || chapterNode?.description || '',
                    'fullToc': Utils.generateTocText(toc, 0, '', state.activeChapterPath),
                    'partToc': partNode ? Utils.generateTocText(partNode, 0, '', pathParts.slice(1).join('.')) : '',
                    'projectStyleExample': settings.writingStyle || '',
                    'manuscript': state.activeChapterContent?.manuscript || '',
                    'translation': state.activeChapterContent?.translation || '',
                    'notes': state.activeChapterContent?.notes || '',
                };
            },
            
            async handleURLNavigation() {
                // 이미 다른 네비게이션이 처리 중이면 중복 실행을 방지합니다.
                if (this.isNavigating) return;
                this.isNavigating = true;

                try {
                    const hash = window.location.hash.slice(1);
                    this.saveScrollPosition();

                    const projectMatch = hash.match(/^\/projects\/([a-zA-Z0-9_]+)/);
                    const chapterMatch = hash.match(/^\/projects\/([a-zA-Z0-9_]+)\/chapters\/(.+)/);

                    let viewChanged = false;

                    if (chapterMatch) {
                        const [, projectId, chapterPath] = chapterMatch;
                        if (state.activeProjectId !== projectId) {
                            await this.openProject(projectId, false); // 렌더링은 마지막에 한번만
                        }
                        if (state.activeChapterPath !== chapterPath) {
                            await this.selectChapter(chapterPath, false); // 렌더링은 마지막에 한번만
                        }
                        viewChanged = true;
                    } else if (projectMatch) {
                        const [, projectId] = projectMatch;
                        if (state.activeProjectId !== projectId) {
                            await this.openProject(projectId, false); // 렌더링은 마지막에 한번만
                            // 프로젝트만 열렸을 경우, 마지막 챕터나 첫 챕터로 이동
                            const project = state.activeProject;
                            if (project) {
                                const allNodes = Utils.getFlatToc(project.toc);
                                const pathToSelect = project.lastChapterPath || (allNodes[0]?.path || null);
                                if (pathToSelect) {
                                    await this.selectChapter(pathToSelect, false);
                                }
                            }
                        }
                        viewChanged = true;
                    } else {
                        // 대시보드로 가는 경우, 상태를 직접 변경합니다.
                        if (state.currentView !== 'dashboard') {
                            state.currentView = 'dashboard';
                            state.activeProjectId = null;
                            state.activeProject = null;
                            state.activeChapterPath = null;
                            state.activeChapterContent = null;
                            state.currentFilter = { type: 'dashboard', id: null };
                            viewChanged = true;
                        }
                    }

                    // 모든 상태 변경이 끝난 후, 마지막에 UI를 한 번만 렌더링합니다.
                    View.render();

                } catch (error) {
                    console.error("URL 네비게이션 처리 중 오류 발생:", error);
                    this.showToast('페이지 이동 중 오류가 발생했습니다.', 'error');
                } finally {
                    // 처리가 끝나면 플래그를 해제합니다.
                    this.isNavigating = false;
                }
            },

            updateURLFromState() {
                let newHash = '#/';
                if (state.activeProjectId) {
                    newHash = `#/projects/${state.activeProjectId}`;
                    if (state.activeChapterPath) {
                        newHash += `/chapters/${state.activeChapterPath}`;
                    }
                }
                
                // 현재 URL과 새로운 URL이 다를 경우에만 변경하여 불필요한 히스토리 생성을 방지합니다.
                if (window.location.hash !== newHash) {
                    // pushState 대신 location.hash를 사용하여 히스토리를 관리합니다.
                    window.location.hash = newHash;
                }
            },

            toggleActionRail() {
                state.isActionRailOpen = !state.isActionRailOpen;
                View.render();
            },
            handleImageDragOver(e) {
                e.preventDefault();
                e.stopPropagation();
                // 드래그 중일 때 시각적 피드백을 줍니다 (예: 배경색 변경)
                e.currentTarget.classList.add('bg-indigo-50', 'border-indigo-400');
            },

            handleImageDragLeave(e) {
                e.preventDefault();
                e.stopPropagation();
                // 드래그가 영역을 벗어나면 시각적 피드백을 제거합니다.
                e.currentTarget.classList.remove('bg-indigo-50', 'border-indigo-400');
            },

            handleImageDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                e.currentTarget.classList.remove('bg-indigo-50', 'border-indigo-400');

                const files = e.dataTransfer.files;
                if (files && files.length > 0) {
                    // 드롭된 첫 번째 파일을 처리 함수로 넘깁니다.
                    Controller.processImageFile(files[0]);
                }
            },
            bindGlobalEventListeners() {
                const handleAction = e => {
                    this.handleHighlightClick(e);
                    const trigger = e.target.closest('[data-action]');
                    if (!trigger || trigger.matches('form[data-action]')) return;
                    const action = trigger.dataset.action;
                    const handler = this.ACTION_HANDLERS[action];
                    if (handler) {
                        e.preventDefault();
                        handler(trigger, e);
                    }
                };
                document.body.addEventListener('click', handleAction.bind(this));
                document.body.addEventListener('contextmenu', this.handleContextMenu.bind(this));

                document.body.addEventListener('touchend', handleAction.bind(this));


                document.body.addEventListener('submit', e => {
                    const form = e.target.closest('form[data-action]');
                    if (!form) return;
                    e.preventDefault();
                    const action = form.dataset.action;
                    const handler = this.ACTION_HANDLERS[action];
                    if (handler) handler(form, e);
                });

                document.body.addEventListener('change', e => {
                    const trigger = e.target;
                    if (trigger.id === 'image-upload') {
                        this.ACTION_HANDLERS['handle-image-upload'](trigger);
                        return;
                    }
                    if (trigger.matches('input[type="file"]')) {
                        this.handleFileSelection(trigger);
                        return
                    }
                    if (trigger.hasAttribute('data-action') && !trigger.matches('form[data-action]')) {
                        const handler = this.ACTION_HANDLERS[trigger.dataset.action];
                        if (handler) handler(trigger, e);
                    }
                });

                document.body.addEventListener('input', Utils.debounce(async e => {
                    if (e.target.matches('#search-input')) {
                        // 프로젝트 검색 기능은 제거되었지만, 기존 코드를 유지하기 위해 단순히 상태만 업데이트합니다.
                        state.searchQuery = e.target.value;
                    } else if (e.target.matches('#global-search-input')) {
                        // 전역 검색 입력값만 업데이트합니다. 실제 검색은 엔터키 입력이나 검색 버튼 클릭 시 수행됩니다.
                        state.globalSearchQuery = e.target.value;
                    } else if (e.target.matches('[data-action="toc-edit-title"]')) {
                        this.handleTocTitleEdit(e.target);
                    } else if (e.target.matches('#manuscript, #notes, #translation, [data-setting-key], [data-custom-prompt-key]')) {
                        await this.handleContentChange(e);
                    } else if (e.target.matches('#setting-tags-input')) {
                        this.handleTagInput(e.target);
                    }
                }, 500));
                document.addEventListener('keydown', e => {
                    // 전역 검색 입력에서 Enter키를 누르면 검색을 실행합니다.
                    if (e.target.matches('#global-search-input') && e.key === 'Enter') {
                        e.preventDefault();
                        // 현재 입력값으로 검색을 실행합니다.
                        this.handleGlobalSearch(e.target.value);
                        return;
                    }
                    if (e.key === 'Escape' && ModalManager.isOpen) {
                        console.log('[디버그] 모달 닫힘: "ESC 키" 누름');
                        ModalManager.close();
                    }
                });
                // ▼▼▼ 새로운 코드 ▼▼▼
                document.body.addEventListener('mouseenter', e => {
                    const target = e.target.closest('[data-tooltip]');
                    if (target) Controller.showTooltip(target);
                }, true); // 캡처링 단계에서 이벤트를 감지하여 안정성 확보

                document.body.addEventListener('mouseleave', e => {
                    const target = e.target.closest('[data-tooltip]');
                    if (target) Controller.hideTooltip();
                }, true);
                document.addEventListener('katex-loaded', () => {
                    state.isKaTeXLoaded = true;
                    this.applyPostRenderEffects();
                });
                document.addEventListener('keydown', e => {
                    const isInputActive = ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName);
                    if (!isInputActive && state.currentView === 'workspace') {
                    if (e.key === 'ArrowLeft') { // 이전 챕터
                        e.preventDefault();
                        this.navigateChapter(-1);
                    } else if (e.key === 'ArrowRight') { // 다음 챕터
                        e.preventDefault();
                        this.navigateChapter(1);
                    }
                }
            });
                
                // Controller.bindGlobalEventListeners 함수 내부에 추가
                document.addEventListener('selectionchange', Utils.debounce(() => {
                    const selection = window.getSelection();
                    if (!selection || selection.rangeCount === 0) return;

                    const viewPanel = document.querySelector('#workspace-main-content .prose-readable');
                    // 메뉴가 표시되어야 하는 모든 조건을 검사합니다.
                    const shouldShowMenu = 
                        !selection.isCollapsed &&
                        state.currentView === 'workspace' &&
                        state.workspaceMode === 'view' &&
                        viewPanel &&
                        viewPanel.contains(selection.getRangeAt(0).commonAncestorContainer);

                    if (shouldShowMenu) {
                        const range = selection.getRangeAt(0);
                        const rect = range.getBoundingClientRect();
                        
                        // 뷰포트 상단이나 하단에 너무 가깝게 붙어있으면 메뉴를 숨깁니다.
                        if (rect.top < 20 || rect.bottom > window.innerHeight - 20) {
                            if (state.contextMenu.isOpen) {
                                state.contextMenu.isOpen = false;
                                View.render();
                            }
                        } else {
                            // 메뉴의 위치를 뷰포트 기준 좌표로 업데이트합니다.
                            state.contextMenu = {
                                isOpen: true,
                                // pageX, pageY 대신 rect 좌표를 사용합니다.
                                x: rect.left + rect.width / 2,
                                y: rect.top, // 메뉴가 텍스트 바로 위에 위치하도록 top 좌표 사용
                                selectedText: selection.toString().trim()
                            };
                            View.render();
                        }
                    } else if (state.contextMenu.isOpen) {
                        // 메뉴가 표시될 조건이 아니면 메뉴를 닫습니다.
                        state.contextMenu.isOpen = false;
                        View.render();
                    }
                }, 100)); // 50ms 디바운스로 스크롤 중 과도한 렌더링 방지
                // ▲▲▲ [수정 완료] ▲▲▲                document.addEventListener('paste', e => this.handleImagePaste(e));
                    const contentView = document.getElementById('content-view');
                    if (contentView) {
                        contentView.addEventListener('contextmenu', (e) => this.handleContextMenu(e), false);
                    }
                    
                    // 2. 메뉴 닫기: 문서 전체의 'mousedown' 이벤트를 감지합니다.
                    //    사용자가 메뉴 바깥의 아무 곳이나 클릭(터치)하면 메뉴가 닫힙니다.
                    //    캡처링 단계(true)에서 실행하여 다른 이벤트보다 먼저 안정적으로 처리합니다.
                document.body.addEventListener('mousedown', this.handleMouseDown.bind(this), true);

                document.body.addEventListener('contextmenu', (e => {
                    const targetItem = e.target.closest('.modal-container #toc-editor-list .toc-item');
                    if (targetItem) {
                        e.preventDefault();
                        this.openTocContextMenu(e, targetItem.dataset.path);
                    }
                }).bind(this));

                document.body.addEventListener('touchstart', (e => {
                    const targetItem = e.target.closest('.modal-container #toc-editor-list .toc-item');
                    if (targetItem) {
                        this.touchStartX = e.touches[0].clientX;
                        this.touchStartY = e.touches[0].clientY;
                        this.touchTimer = setTimeout(() => {
                            this.openTocContextMenu(e.touches[0], targetItem.dataset.path);
                            this.touchTimer = null;
                        }, 500);
                    }
                }).bind(this));

                document.body.addEventListener('touchmove', (e => {
                    if (this.touchTimer) {
                        const moveX = Math.abs(this.touchStartX - e.touches[0].clientX);
                        const moveY = Math.abs(this.touchStartY - e.touches[0].clientY);
                        if (moveX > 10 || moveY > 10) {
                            clearTimeout(this.touchTimer);
                            this.touchTimer = null;
                        }
                    }
                }).bind(this));

                document.body.addEventListener('touchend', (e => {
                    if (this.touchTimer) {
                        clearTimeout(this.touchTimer);
                        this.touchTimer = null;
                    }
                }).bind(this));
            },

            
            bindDynamicEventListeners() {
                if (ModalManager.type === 'manageToc') {
                    const list = document.getElementById('toc-editor-list');
                    if (list) {
                        list.addEventListener('dragstart', this.handleTocDragStart);
                        list.addEventListener('dragover', this.handleTocDragOver);
                        list.addEventListener('dragleave', this.handleTocDragLeave);
                        list.addEventListener('drop', this.handleTocDrop);
                    }
                }
                if (ModalManager.type === 'settings') {
                    const tagInput = document.getElementById('setting-tags-input');
                    if (tagInput) {
                        tagInput.addEventListener('keydown', this.handleTagInputKeydown);
                    }

                    // ✅ START: Enter 키 오작동 방지 코드 추가
                    const settingsForm = document.querySelector('form[data-action="save-settings"]');
                    if (settingsForm) {
                        settingsForm.addEventListener('keydown', (e) => {
                            // 폼 내부의 텍스트 입력 필드에서 Enter 키를 누를 때
                            if (e.key === 'Enter' && e.target.tagName === 'INPUT' && e.target.type === 'text') {
                                // 기본 동작인 폼 제출을 무조건 막습니다.
                                e.preventDefault();

                                // 만약 '새 항목 추가' 관련 이름 입력 필드에서 Enter를 눌렀다면,
                                // '목록에 추가' 버튼을 대신 클릭해주는 편리한 기능을 추가합니다.
                                if (e.target.id === 'new-prompt-name' || e.target.id === 'new-contextMenu-name') {
                                    const addButton = e.target.closest('.p-4.border').querySelector('button[data-action^="add-custom-"]');
                                    if (addButton) {
                                        addButton.click();
                                    }
                                }
                            }
                        });
                    }
                    // ✅ END: Enter 키 오작동 방지 코드 추가
                }
                if (state.currentView === 'workspace' && state.workspaceMode === 'image') {
                    const dropzone = document.querySelector('[data-dropzone="image"]');
                    if (dropzone) {
                        dropzone.addEventListener('dragover', this.handleImageDragOver);
                        dropzone.addEventListener('dragleave', this.handleImageDragLeave);
                        dropzone.addEventListener('drop', this.handleImageDrop);
                    }
                }
            },
            initializeConfig() {
                CONFIG.DEFAULT_ACTIONS = [
                   { id: 'default-fact-check',
        name: "✔️ 자료 검증",
        icon: 'check-badge',
        template: `
<prompt id="default-fact-check">
    <metaPrompt>
        <purpose>
            문서 내용 중 사실 관계가 틀리거나 확인이 필요한 부분을 찾아내고, 정확한 정보와 근거를 제시받는다.
        </purpose>
        <promptDesignFramework>
            <objectiveDefinition id="1">
                <finalDeliverable id="1.1">
                    {{검증_목표}}에 대한 사실 관계 오류 지적 및 정확한 정보와 근거가 포함된 검증 보고서
                </finalDeliverable>
                <coreTask id="1.2">
                    검증, 분석, 지적, 교정
                </coreTask>
                <successCriteria id="1.3">
                    1. 지적된 오류가 원문의 내용과 일치하는가?
                    2. 제시된 교정 정보가 사실에 부합하고 신뢰할 수 있는가?
                    3. 객관적이고 중립적인 어조를 유지하는가?
                </successCriteria>
            </objectiveDefinition>
            <personaAssignment id="2">
                <expertPersona id="2.1">
                    당신은 최고 수준의 사실 확인 전문가이자 교정 편집자입니다. 당신은 주어진 문서에서 사실적 오류, 논리적 모순, 오해의 소지가 있는 부분을 정확하게 찾아내고, 공신력 있는 출처를 기반으로 정확한 정보를 제시합니다. 모든 지적은 명확하고 간결해야 합니다.
                </expertPersona>
                <audience id="2.2">
                    작품의 신뢰성을 높이려는 작가 또는 편집자
                </audience>
                <toneAndStyle id="2.3">
                    어조: 전문적, 객관적 / 스타일: 간결한 보고서 형식
                </toneAndStyle>
            </personaAssignment>
            <contextAndFormat id="3">
                <essentialContext id="3.1">
                    <![CDATA[
                    - 검증 대상 텍스트: {{manuscript}}
                    - 검증할 목표: {{검증_목표}}
                    ]]>
                </essentialContext>
                <outputFormat id="3.2">
                    <![CDATA[
                    ### 사실 검증 결과
                    
                    - **검증 목표**: {{검증_목표}}
                    - **지적 사항**: (가능한 모든 오류 지적. 원문 내용 인용 후 정확한 정보 제시)
                    - **수정 제안**: (수정할 부분들을 특정하여, 그 부분의 수정문을 코드블럭에 넣어서 그대로 붙여넣을 수 있도록 해준다.)
                    ]]>
                </outputFormat>
            </contextAndFormat>
        </promptDesignFramework>
    </metaPrompt>
</prompt>
`
    },
    {
        id: 'default-tone-unify',
        name: "🎨 문체 통일",
        icon: 'sliders',
        template: `
<prompt id="default-tone-unify">
    <metaPrompt>
        <purpose>
            문서의 전체 문체를 일관성 있게 다듬고, 특정 스타일 가이드라인에 맞춘다.
        </purpose>
        <promptDesignFramework>
            <objectiveDefinition id="1">
                <finalDeliverable id="1.1">
                    {{새로운_문체}}가 적용된 문서
                </finalDeliverable>
                <coreTask id="1.2">
                    교정, 수정, 문체 통일
                </coreTask>
                <successCriteria id="1.3">
                    1. 수정된 문체와 {{새로운_문체}}의 특징이 일치하는가?
                    2. 원문의 의미와 내용이 훼손되지 않고 자연스럽게 연결되는가?
                    3. 문장과 문단 간의 흐름이 매끄러운가?
                </successCriteria>
            </objectiveDefinition>
            <personaAssignment id="2">
                <expertPersona id="2.1">
                    당신은 언어의 뉘앙스를 완벽하게 이해하는 전문 편집자입니다. 당신은 주어진 텍스트를 분석하여 문체의 불일치성을 찾아내고, 특정 스타일 가이드({{새로운_문체}})에 맞춰 전체 문서를 매끄럽게 재구성합니다.
                </expertPersona>
                <audience id="2.2">
                    출판 또는 배포 전 최종 검토를 원하는 작가 또는 편집자
                </audience>
                <toneAndStyle id="2.3">
                    어조: {{새로운_문체}}에 따라 유연하게 변경
                    스타일: {{새로운_문체}}에 따라 유연하게 변경
                </toneAndStyle>
            </personaAssignment>
            <contextAndFormat id="3">
                <essentialContext id="3.1">
                    <![CDATA[
                    - 수정 대상 문서: {{manuscript}}
                    - 참고할 프로젝트 스타일: {{projectStyleExample}}
                    - 사용자가 지정한 새로운 문체: {{새로운_문체}}
                    - 만약 새로운 문체가 지정되지 않았다면, 프로젝트 기본 스타일을 따르시오.
                    ]]>
                </essentialContext>
                <outputFormat id="3.2">
                    <![CDATA[
                    수정된 전체 문서를 출력한다.
                    ]]>
                </outputFormat>
            </contextAndFormat>
        </promptDesignFramework>
    </metaPrompt>
</prompt>
`
    },
                    {
                        id: 'default-info-add',
                        name: "🧩 정보 추가",
                        icon: 'plus-circle',
                        template: `<prompt id="default-info-add">
    <metaPrompt>
        <purpose>
            문서의 맥락을 해치지 않으면서 독자의 이해를 돕는 관련 배경 지식이나 심층 정보를 추가한다.
        </purpose>
        <promptDesignFramework>
            <objectiveDefinition id="1">
                <finalDeliverable id="1.1">
                    정보가 추가되어 더 풍부해진 문서
                </finalDeliverable>
                <coreTask id="1.2">
                    정보 통합, 내용 확장, 배경지식 추가
                </coreTask>
                <successCriteria id="1.3">
                    1. 추가된 정보가 기존 맥락과 자연스럽게 연결되는가?
                    2. 추가된 정보가 독자의 이해를 실제로 돕는가?
                    3. 내용에 불필요한 부분이 추가되지 않고 원래의 의도가 유지되는가?
                </successCriteria>
            </objectiveDefinition>
            <personaAssignment id="2">
                <expertPersona id="2.1">
                    당신은 주어진 주제에 대해 깊은 지식을 가진 학자이자 작가입니다. 당신은 텍스트의 흐름을 방해하지 않으면서, 독자들이 궁금해할 만한 유용한 배경 정보나 심화 내용을 통합하여 문서의 완성도를 높입니다.
                </expertPersona>
                <audience id="2.2">
                    특정 주제에 대해 더 깊이 알고 싶은 독자
                </audience>
                <toneAndStyle id="2.3">
                    어조: 전문적, 정보 제공적 / 스타일: 기존 텍스트의 문체에 맞게 통합
                </toneAndStyle>
            </personaAssignment>
            <contextAndFormat id="3">
                <essentialContext id="3.1">
                    <![CDATA[
                    - 수정 대상 문서: {{manuscript}}
                    - 추가할 정보: {{추가할_내용}}
                    ]]>
                </essentialContext>
                <outputFormat id="3.2">
                    <![CDATA[
                    추가할 내용을 기존 문서에 자연스럽게 통합하여 최종 결과물을 반환한다.
                    ]]>
                </outputFormat>
            </contextAndFormat>
        </promptDesignFramework>
    </metaPrompt>
</prompt>
                        `
                    },
                    {
                        id: 'default-summarize',
                        name: "📜 핵심 요약",
                        icon: 'document-text',
                        template: `당신은 핵심을 꿰뚫는 전문 분석가입니다. 다음 텍스트('{{manuscript}}')를 읽고, 가장 중요한 핵심 내용을 3~5개의 불렛 포인트로 요약해주세요. 각 요점은 간결하면서도 전체 맥락을 이해할 수 있도록 명확해야 합니다.`
                    },
                    {
                        id: 'default-simplify',
                        name: "💡 알기 쉽게",
                        icon: 'academic-cap',
                        template: `
                        <prompt id="default-simplify">
    <metaPrompt>
        <purpose>
            전문적인 내용을 일반인이 이해하기 쉬운 언어와 형식으로 바꾼다.
        </purpose>
        <promptDesignFramework>
            <objectiveDefinition id="1">
                <finalDeliverable id="1.1">
                    '해당 글에 대한 지식을 갈망하는 독자'를 위한 쉬운 설명 자료
                </finalDeliverable>
                <coreTask id="1.2">
                    재구성, 설명, 단순화, 비유
                </coreTask>
                <successCriteria id="1.3">
                    1. 원문의 복잡한 개념이 쉬운 언어로 명확히 전달되는가?
                    2. 비유나 예시가 독자의 이해를 효과적으로 돕는가?
                    3. 원문의 핵심적인 정보가 왜곡되지 않았는가?
                </successCriteria>
            </objectiveDefinition>
            <personaAssignment id="2">
                <expertPersona id="2.1">
                    당신은 복잡한 개념을 가장 쉽게 설명하는 데 탁월한 능력을 가진 전문 교육자입니다. 당신은 독자의 지식 수준을 파악하고, 그에 맞는 비유, 예시, 그리고 단순한 언어를 사용하여 내용을 전달합니다.
                </expertPersona>
                <audience id="2.2">
                    해당 분야에 대한 배경 지식이 없는 일반 독자 또는 {{대상_독자}}
                </audience>
                <toneAndStyle id="2.3">
                    어조: 친절하고 이해를 돕는 / 스타일: 일상적인 대화체, 비유와 예시 포함
                </toneAndStyle>
            </personaAssignment>
            <contextAndFormat id="3">
                <essentialContext id="3.1">
                    <![CDATA[
                    - 단순화할 원본 텍스트: {{manuscript}}
                    - 대상 독자: 해당 글에 대한 지식을 갈망하는 독자
                    ]]>
                </essentialContext>
                <outputFormat id="3.2">
                    <![CDATA[
                    원본 텍스트를 대상 독자의 관점에서 재구성한 결과물을 반환한다.
                    ]]>
                </outputFormat>
            </contextAndFormat>
        </promptDesignFramework>
    </metaPrompt>
</prompt>
                        `
                    },
                    {
                        id: 'default-keywords',
                        name: "🏷️ 키워드 추출",
                        icon: 'tag',
                        template: `당신은 데이터 분석가입니다. 다음 텍스트('{{manuscript}}')의 핵심 주제를 가장 잘 나타내는 키워드를 5~10개 추출해주세요. 결과는 쉼표로 구분된 목록 형식으로만 제공해야 합니다. (예: 키워드1, 키워드2, 키워드3)`
                    }
                ];

                // ▼▼▼ [수정 2] 기본 '컨텍스트 메뉴' 항목 목록을 별도로 정의합니다. ▼▼▼
                CONFIG.DEFAULT_CONTEXT_MENU_ITEMS = [
                    {
                        id: 'default-highlight',
                        name: "🎨 하이라이트",
                        action: 'context-highlight' // 프롬프트 대신 직접 실행할 액션 지정
                    },
                    {
                        id: 'default-add-footnote',
                        name: "📑 각주 추가",
                        action: 'context-add-footnote' // 프롬프트 대신 직접 실행할 액션 지정
                    },
                    {
                        id: 'default-explain-sentence',
                        name: "문장 해설 요청",
                        template: `다음 문장이 잘 이해가 가지 않습니다. 아래 자료 등을 참조하여 해설해 주세요.\n\n# 문장\n{{selected_text}}\n\n# 자료\n{{manuscript}}\n\n{{translation}}`
                    },
                    
                ];

                CONFIG.DEFAULT_PROJECT_SETTINGS = {
                    writingGenre: "전문 분석 보고서",
                    writingAudience: "해당 분야를 배우기 갈망하는 사람",
                    writingAgeGroup: "성인",
                    writingStyle: "천천히 천천히 심혈을 기울여 작성한, 최대한의 정보를 학술적 정확성과 함께 담아낸 객관적이고 명료하며, 논리적인 문체",
                    writingReferences: "핵심 참고자료 (세계관, 인물, 용어 등)를 여기에 입력하세요.",
                    writingPrompt: `Have a break and then...
<?xml version="1.0" encoding="UTF-8"?>
<metaPrompt>
    <purpose>
        주어진 모든 맥락 정보를 종합적으로 분석하여, 특정 장(Chapter)에 해당하는 전문가 수준의 원고 초안을 천천히 심혈을 기울여서 차근차근 생성하는 것. 최대한 길고 자세하며, 주어진 목표를 완벽하게 달성해야 한다.
    </purpose>
    <promptDesignFramework>
        <objectiveDefinition id="1" title="목표 정의: 과업의 제1원칙">
            <finalDeliverable id="1.1" description="프롬프트를 통해 얻고자 하는 최종 결과물">
                '{{chapterTitle}}' 장에 대한 완성도 높은 원고 초안을, 체계적인 소제목을 포함하여 최대한 길게 생성한다. 이 원고는 별도의 서문이나 요약 없이, 즉시 본문에 삽입할 수 있는 마크다운(Markdown) 형식이어야 한다.
            </finalDeliverable>
            <coreTask id="1.2" description="LLM이 수행해야 할 핵심적인 동사">
                제시된 모든 맥락과 제약 조건을 엄격히 준수하여, '{{chapterTitle}}' 장의 원고를 **집필하라**.
            </coreTask>
            <successCriteria id="1.3" description="결과물이 '성공'이라고 판단할 객관적인 기준">
                1. 생성된 원고가 '{{chapterDescription}}'에 명시된 목표와 내용을 충실히 반영하는가?
                2. 원고가 전체 목차('{{fullToc}}')의 흐름 속에서 현재 장의 역할을 정확히 수행하는가?
                3. 프로젝트 설정('{{projectGenre}}', '{{projectAudience}}', '{{projectStyleExample}}')에 부합하는 문체와 어조를 일관되게 유지하는가?
                4. 'references'에 제공된 설정(인물, 배경, 용어 등)을 정확하게 활용하였는가?
                5. 결과물이 서문, 요약, 반복 등 불필요한 내용 없이 오직 원고 본문만으로 구성되었는가?
                6. 생성된 원고가 허용된 최대 토큰 길이를 활용하여 최대한 상세하게 작성되었는가?
            </successCriteria>
        </objectiveDefinition>
        <personaAssignment id="2" title="역할 부여: 최적의 인지 모델 설계">
            <expertPersona id="2.1" description="과업을 가장 잘 수행할 전문가의 상세한 묘사">
                당신은 **'{{projectGenre}}' 장르의 베테랑 작가**이자, 해당 분야의 깊이 있는 지식을 갖춘 전문가다. 당신의 임무는 단순한 텍스트 생성이 아니라, 작품 전체의 유기적인 흐름과 깊이를 더하는 한 부분을 완성하는 것이다. 당신은 프로젝트의 총괄 편집자로서, 모든 세부 설정과 이야기의 큰 그림을 완벽하게 이해하고 있다.
            </expertPersona>
            <audience id="2.2" description="결과물을 소비할 대상과 그들의 지식 수준">
                이 글의 핵심 독자는 **'{{projectAudience}}'**이며, 대상 연령층은 **'{{projectAgeGroup}}'**이다. 이들의 지적 호기심과 기대 수준을 고려하여 전문적이면서도 이해하기 쉽게 집필해야 한다.
            </audience>
            <toneAndStyle id="2.3" description="결과물의 어조와 스타일">
                글의 전체적인 톤앤매너와 문체는 다음 예시를 따른다: **'{{projectStyleExample}}'**. 이를 바탕으로 일관성 있는 작풍을 유지하라.
            </toneAndStyle>
        </personaAssignment>
        <contextAndFormat id="3" title="맥락 제공 및 형식 지정">
            <essentialContext id="3.1" description="과업 수행에 필요한 모든 배경 정보, 데이터, 이전 대화 내용"><![CDATA[
### 프로젝트 전체 개요
- **책 전체 제목**: {{bookTitle}}
- **장르 및 대상**: {{projectGenre}}, {{projectAgeGroup}} {{projectAudience}}
- **핵심 참고자료 (세계관, 인물, 용어 등)**:
{{references}}

### 집필할 장(Chapter)의 위치와 목표
- **현재 파트(Part)**: {{partTitle}} ({{partDescription}})
- **집필 대상 장(Chapter)**: **{{chapterTitle}}**
- **이번 장의 핵심 목표**: {{chapterDescription}}

### 전체 목차 구조 (현재 위치 표시: ▶)
{{fullToc}}

### 현재 파트의 목차 구조 (현재 위치 표시: ▶)
{{partToc}}
            ]]></essentialContext>
            <outputFormat id="3.2" description="결과물이 출력되어야 할 정확한 형식 또는 템플릿"><![CDATA[
## 최종 출력물 형식 (매우 중요)
- **오직 원고 본문만 출력한다.**
- **원고 내용에 적절한 소제목 목차를 포함하고, 목차의 최상위 제목은 '##'으로 시작해야 한다.**
- Markdown 문법을 사용하여 문단을 나누고, 필요시 강조 등을 표현한다.
- "결과물:", "원고:", "다음은 요청하신 원고입니다." 와 같은 서두를 절대로 사용하지 마라.
- 프롬프트의 내용을 요약하거나 되풀이하지 마라.
            ]]></outputFormat>
        </contextAndFormat>
        <reasoningDesign id="4" title="추론 과정 설계: 생각의 경로 구축">
            <reasoningFramework id="4.1" description="과업 복잡성에 따른 추론 방식 선택">
                <option type="DirectResponse" description="단순 정보 요청 시 사용">
                    <task>위의 모든 정보를 바탕으로, '{{chapterTitle}}' 장의 원고를 즉시 집필하라.</task>
                </option>
            </reasoningFramework>
        </reasoningDesign>
        <constraints id="5" title="제약 조건 설정: 탐색 공간 제어">
            <mustInclude id="5.1" description="결과물에 반드시 포함되어야 할 키워드, 개념, 데이터 포인트">
                - 원고 내용은 '{{chapterDescription}}'의 목표를 직접적으로 달성해야 한다.
                - 'references'의 설정과 충돌이 없어야 한다.
            </mustInclude>
            <mustAvoid id="5.2" description="반드시 피해야 할 주제, 표현, 단어, 편향, 가정">
                - 집필 과업에 대한 자기 평가나 소감, 요약, 변명, 추가 설명을 포함하지 마라.
                - 작가(AI)가 독자에게 직접 말을 거는 듯한 '메타적 서술'을 피하라. (예: "이제부터 ~에 대해 알아보겠습니다.")
                - 전체 이야기의 결말을 암시하거나 단정 짓는 서술을 피하라. 현재 장의 역할에만 집중하라.
            </mustAvoid>
            <selfCorrectionCommand id="5.3" description="생성될 프롬프트 마지막에 포함될 최종 검증 명령"><![CDATA[
모든 지시사항을 완수한 후, 최종 답변을 제출하기 전에 잠시 멈추고 스스로 '레드팀'의 역할을 수행하라. 내가 제시한 모든 요구사항(역할, 형식, 내용, 제약 조건 등)이 100% 충족되었는지, 논리적 비약이나 설정 충돌은 없는지, 더 나은 대안은 없는지 최소 세 번 이상 교차 검증하고, 그 결과를 반영하여 최종적으로 완벽하고 군더더기 없는 원고 초안만 출력하라.
            ]]></selfCorrectionCommand>
            <supplementaryDirectives title="Author's Internal Checklist">
                <directive id="A" title="독자의 그림자: 끊임없는 질문에 답하기">
                    <description>
                        글을 쓰는 내내, 당신의 어깨너머로 회의적이지만 지적인 독자가 함께 읽고 있다고 상상하라. 그 독자는 매 문단이 끝날 때마다 다음과 같이 질문할 것이다: "그래서 이게 왜 중요한데(So What)?", "이 주장의 근거는 무엇이지?", "더 쉬운 설명은 없나?" 당신의 글은 이러한 독자의 잠재적 질문을 미리 예측하고, 그에 대한 답을 본문 안에 자연스럽게 녹여내야 한다. 독자의 의문이 싹트기 전에 해소시켜라.
                    </description>
                </directive>
                <directive id="B" title="정보적 투자수익률(ROI) 원칙: 독자의 노력을 보상하기">
                    <description>
                        독자가 한 문장을 읽는 데 사용하는 인지적 노력은 '투자'다. 당신은 그 투자에 대해 최대한의 '수익(지적 깨달음, 감정적 동요, 실용적 가치)'으로 보상할 의무가 있다. 모든 문장이 정보적 가치를 지니는지, 불필요한 미사여구나 군더더기는 없는지 끊임없이 점검하라. 문장이 길어진다면, 그 길이만큼의 가치를 담고 있는지 증명해야 한다.
                    </description>
                </directive>
                <directive id="C" title="논리적 연결의 미학: 문단과 문단을 엮는 힘">
                    <description>
                        문단을 독립된 정보의 섬으로 취급하지 마라. 뛰어난 글은 각 문단이 서로 맞물려 돌아가는 정교한 기계와 같다. 한 문단의 마지막 문장은 다음 문단의 첫 문장을 자연스럽게 호출하는 '갈고리' 역할을 해야 한다. 논리의 흐름이 끊기지 않고, 독자가 물 흐르듯 다음 내용으로 넘어갈 수 있도록 문단 사이의 논리적 인장력을 최대화하라.
                    </description>
                </directive>
                <directive id="D" title="구성의 교향곡: 요소들의 조화로운 배치">
                    <description>
                        하나의 장(Chapter)은 단일한 음색의 연주가 아닌, 다양한 악기가 조화를 이루는 교향곡이어야 한다. '이론 제시', '사례 분석', '서사적 묘사', '데이터 인용', '성찰적 질문' 등 다양한 구성 요소를 단조롭지 않게 배치하라. 예를 들어, 무거운 이론을 제시했다면 곧바로 흥미로운 일화를 통해 독자의 이해를 돕고 환기시키는 지혜가 필요하다.
                    </description>
                </directive>
                <directive id="E" title="지적 정직성의 프레임: 경계와 복잡성의 인정">
                    <description>
                        당신의 주장이 적용되는 범위와 한계를 명확히 하라. 모든 것을 설명할 수 있는 것처럼 과장하거나, 복잡한 문제를 단순하게 양분하지 마라. 특히 비문학 분야에서는 반대 의견이나 대안적 해석을 공정하게 소개하고, 왜 당신의 관점이 더 설득력 있는지 논증하라. 이러한 지적 정직성은 글의 신뢰도를 극적으로 높인다. 소설의 경우, 이는 세상을 선과 악으로만 나누지 않는 입체적인 세계관 구축으로 이어진다.
                    </description>
                </directive>
            </supplementaryDirectives>
        </constraints>
    </promptDesignFramework>
</metaPrompt>`,
                    translationPrompt: `Have a break and then...
<?xml version="2.0" encoding="UTF-8"?>
<metaPrompt>
    <purpose>
        천천히 심혈을 기울여, 'essentialContext'에 제공된 원문을 분석한다. 원문의 톤앤매너와 핵심 정보를 완벽하게 보존하면서, 가장 유려하고 자연스러운 문어체 한국어로 번역한다. 최종 결과물은 즉시 출판 가능한 수준의 가독성, 학문적 정확성, 의미 전달의 명확성을 갖춰야 한다.
    </purpose>
    <promptDesignFramework>
        <objectiveDefinition id="1" title="목표 정의: 과업의 제1원칙">
            <finalDeliverable id="1.1" description="프롬프트를 통해 얻고자 하는 최종 결과물">
                사용자가 제공한 원문을 전문가 수준으로 번역하고 다듬어, 즉시 출판하여 베스트셀러가 될 수 있는 상태의 완벽한 한국어 문어체 원고.
            </finalDeliverable>
            <coreTask id="1.2" description="LLM이 수행해야 할 핵심적인 동사">
                **번역(Translate), 교정(Refine), 그리고 형식화(Format)하라.** 단순한 단어 대체를 넘어, 전문 편집자로서 원문의 의미와 뉘앙스를 한국어 독자에게 최적화된 콘텐츠로 재창조하라.
            </coreTask>
            <successCriteria id="1.3" description="결과물이 '성공'이라고 판단할 객관적인 기준">
                - 번역문은 원문의 핵심 의미, 세부 뉘앙스, 그리고 저자의 의도를 100% 보존한다.
                - 한국어 문장은 문법적으로 완벽하며, 원문의 어조와 스타일을 유지하면서도 자연스럽고 유려하다.
                - 모든 문장이 누락 없이 번역되었으며, 일관된 문체를 유지한다.
                - 제목, 소제목, 문단 나누기 등 원문의 논리적 구조를 정확히 반영하여 가독성을 극대화한다.
                - '[여기에 입력]'과 같은 플레이스홀더 텍스트가 최종 결과물에 남아있지 않다.
            </successCriteria>
        </objectiveDefinition>
        <personaAssignment id="2" title="역할 부여: 최적의 인지 모델 설계">
            <expertPersona id="2.1" description="과업을 가장 잘 수행할 전문가의 상세한 묘사">
                당신은 **'20년 경력의 마스터 번역가 겸 콘텐츠 전략가'**다. 국제회의 통역사이자 여러 베스트셀러 기술 서적을 번역한 경험을 바탕으로, 단순한 언어 변환을 넘어 문화적 맥락과 미묘한 뉘앙스까지 포착한다. 당신은 독자의 마음을 움직이는 글을 만들어내는 전문가이며, 디지털 콘텐츠의 가독성까지 고려하여 번역 결과를 구조화한다.
            </expertPersona>
            <audience id="2.2" description="결과물을 소비할 대상과 그들의 지식 수준">
                제공된 원문의 내용, 어휘, 스타일을 분석하여 잠재 독자층(예: 기술 전문가, 일반 대중, 학생 등)을 추론하고, 그들의 지식 수준과 관심사에 맞춰 가장 이해하기 쉬운 어휘와 문장 구조를 선택해야 한다.
            </audience>
            <toneAndStyle id="2.3" description="결과물의 어조와 스타일 및 정신적 도구">
                - **톤앤매너 복제:** 원문의 어조(예: 학술적, 유머러스함, 진지함, 대중적)를 정확히 분석하고, 그 느낌을 한국어 표현으로 완벽하게 재현해야 한다. 직역으로 어색해지는 관용구나 문화적 표현은 한국 독자가 즉시 이해할 수 있는 자연스러운 표현으로 의역한다.
                - **문어체 사용:** 베스트셀러처럼 잘 읽히는 문어체를 사용하여, 원본의 모든 내용과 정보를 포함하면서도 술술 읽혀야만 한다.
                - **정신적 도구 (Mental Model):** '독자의 입장에서 생각하기'. 문장을 완성하기 전에, 잠재 독자의 관점에서 그 문장을 소리 내어 읽어본다고 상상하라. '이 문장은 명확한가? 매력적인가? 이전 내용과 자연스럽게 연결되는가?'를 끊임없이 자문하며 결과물을 다듬어라.
            </toneAndStyle>
        </personaAssignment>
        <contextAndFormat id="3" title="맥락 제공 및 형식 지정">
            <essentialContext id="3.1" description="과업 수행에 필요한 모든 배경 정보, 데이터, 이전 대화 내용"><![CDATA[
{{text}}
            ]]></essentialContext>
            <outputFormat id="3.2" description="결과물이 출력되어야 할 정확한 형식 또는 템플릿"><![CDATA[
입력된 원문의 형식에 맞춰 가장 적절하고 가독성 높은 형식으로 출력한다.
            ]]></outputFormat>
        </contextAndFormat>
        <reasoningDesign id="4" title="추론 과정 설계: 생각의 경로 구축">
            <reasoningFramework id="4.1" description="과업 복잡성에 따른 추론 방식 선택">
                <option type="ProblemDecomposition" description="복잡한 프로젝트 수행 시 사용">
                    <instruction>
                        아래의 최종 목표를 달성하기 위해, 다음의 하위 작업들을 명시된 순서대로 반드시 수행하라. 각 단계의 결과는 다음 단계의 입력으로 사용된다.
                    </instruction>
                    <subTasks>
                        <task id="1">**1단계: 원문 심층 분석 (Analyze):** 제공된 원문을 최소 3회 이상 정독하여 핵심 메시지, 논리 구조, 저자의 어조와 문체, 그리고 숨은 의도를 완벽하게 파악한다.</task>
                        <task id="2">**2단계: 초벌 번역 및 뉘앙스 포착 (Translate & Capture):** 원문의 의미를 정확하게 전달하는 데 초점을 맞춰 초벌 번역을 수행한다. 특히 기술 용어, 관용 표현, 문화적 배경이 담긴 뉘앙스를 놓치지 않도록 주의한다.</task>
                        <task id="3">**3단계: 윤문 및 유려함 확보 (Refine & Polish):** 초벌 번역 결과물을 한국어 독자의 시각에서 어색함이 없도록 다듬는다. 딱딱한 번역투 문장을 자연스러운 한국어 문장으로 재구성하고, 더 적절한 어휘를 선택하여 글 전체의 유려함을 극대화한다.</task>
                        <task id="4">**4단계: 콘텐츠 구조화 및 형식화 (Structure & Format):** 완성된 내용을 가독성을 높이기 위해 본문을 논리적인 문단과 소제목으로 나누고, 원문의 구조를 충실히 따른다.</task>
                    </subTasks>
                </option>
            </reasoningFramework>
            <fewShotExamples id="4.2" description="1~3개의 고품질 입/출력 예시로 결과물 패턴 학습">
                <example id="1">
                    <input><![CDATA[
Title: The Unseen Power of Micro-interactions

Micro-interactions are the small, often unnoticed animations and design elements that make a user interface feel alive. Think of the "like" button animation on Twitter, or the subtle bounce when you pull to refresh a feed. While seemingly minor, these details are critical. They provide feedback, guide users, and add a touch of personality to a digital product, transforming a functional tool into an enjoyable experience. Good micro-interactions are almost invisible, doing their job without shouting for attention.
                    ]]></input>
                    <output><![CDATA[]]></output>
                </example>
            </fewShotExamples>
        </constraints>
        <constraints id="5" title="제약 조건 설정: 탐색 공간 제어">
            <mustInclude id="5.1" description="결과물에 반드시 포함되어야 할 키워드, 개념, 데이터 포인트">
            - 최종 결과물은 완벽한 한국어 번역문이어야 한다.
            - 원문에 포함된 모든 정보는 번역문에 반드시 포함되어야 한다.
            
            - **각주(Footnote) 처리 규칙:**
            - 원문에는 [^key] 형식의 '참조'와 [^key]: 내용 형식의 '정의'가 포함될 수 있다.
            - **참조 구문 보존:** 본문에 있는 [^key] 구문과 그 안의 'key'는 절대로 번역하거나 변경하지 말고 원본 그대로 유지해야 한다.
            - **정의 내용 번역:** [^key]: 뒷부분에 있는 '내용' 부분은 반드시 한국어로 번역해야 한다.
            - **예시:**
                - **원문:** This is an important concept[^concept1]. See the study[^ref2].
                [^concept1]: A key idea discussed throughout the chapter.
                [^ref2]: Smith et al. (2023).
                - **올바른 번역:** 이것은 중요한 개념입니다[^concept1]. 해당 연구를 참고하세요[^ref2].
                [^concept1]: 이 장 전반에 걸쳐 논의되는 핵심 아이디어입니다.
                [^ref2]: Smith 외. (2023).
            </mustInclude>
            <mustAvoid id="5.2" description="반드시 피해야 할 주제, 표현, 단어, 편향, 가정">
                - 단어 대 단어 식의 기계적인 직역.
                - 원문의 정보를 누락하거나, 원문에 없는 내용을 임의로 추가하는 행위.
                - 한국어 독자가 읽기에 어색하거나 부자연스러운 번역투 문장.
                - 최종 결과물에 '여기를 채우세요'와 같은 미완성된 플레이스홀더를 남기는 것.
            </mustAvoid>
            <selfCorrectionCommand id="5.3" description="생성될 프롬프트 마지막에 포함될 최종 검증 명령"><![CDATA[
모든 지시사항을 완수한 후, 최종 답변을 제출하기 전에 잠시 멈추고 스스로 '레드팀'의 역할을 수행하라. 내가 제시한 모든 요구사항(역할, 형식, 내용, 제약 조건 등)이 100% 충족되었는지, 논리적 비약이나 모순은 없는지, 더 나은 대안은 없는지 최소 세 번 이상 교차 검증하고, 그 결과를 반영하여 최종적으로 완벽하고 군더더기 없는 결과물만 출력하라.
            ]]></selfCorrectionCommand>
        </constraints>
    </promptDesignFramework>
</metaPrompt>`,
                    quizQuestionCount: 5,
                    quizTaskDescription: `You are an expert educator and instructional designer. Your task is to create a comprehensive and in-depth learning quiz based on the provided text. The quiz must thoroughly test the user's understanding of all key concepts, facts, and nuances within the text.`,
                    quizOutputFormatInstruction: `Respond ONLY with a valid JSON array of question objects inside a <json_response> tag. Do not include any other text or explanations outside this tag.`,
                    quizPromptTemplate: `Have a break and then...
<?xml version="1.0" encoding="UTF-8"?>
<metaPrompt>
    <purpose>
        {{taskDescription}}
    </purpose>
    <promptDesignFramework>
        <objectiveDefinition id="1" title="목표 정의: 과업의 제1원칙">
            <finalDeliverable id="1.1" description="프롬프트를 통해 얻고자 하는 최종 결과물">
                엄격한 JSON 형식 스키마를 준수하는, {{questionCount}}개의 질문 객체로 구성된 유효한 JSON 배열. 각 질문은 교육적으로 가치가 높고, 명확한 정답과 상세한 해설을 포함해야 한다.
            </finalDeliverable>
            <coreTask id="1.2" description="LLM이 수행해야 할 핵심적인 동사">
                제시된 텍스트를 분석하고, 이를 바탕으로 학습자의 고차원적 사고 능력을 평가하는 심층 퀴즈를 **설계하고 생성하라(Design and Generate)**.
            </coreTask>
            <successCriteria id="1.3" description="결과물이 '성공'이라고 판단할 객관적인 기준">
                1. 정확히 {{questionCount}}개의 질문이 생성되었는가?
                2. 'multiple_choice', 'short_answer', 'subjective', 'case_based' 등 다양한 유형의 질문이 혼합되었는가?
                3. 각 질문이 원본 텍스트의 핵심 개념, 사실, 뉘앙스를 효과적으로 평가하는가?
                4. 모든 질문의 정답이 정확하고, 해설이 명확하며 교육적인가?
                5. 최종 결과물이 지정된 JSON 형식과 스키마를 100% 준수하며, 오류 없이 파싱되는가?
                6. 질문의 언어가 한국어로 명확하고 자연스럽게 작성되었는가?
                7. 질문이 단순 사실 확인을 넘어, **추론, 분석, 비판, 적용** 능력을 종합적으로 평가하는가?
            </successCriteria>
        </objectiveDefinition>
        <personaAssignment id="2" title="역할 부여: 최적의 인지 모델 설계">
            <expertPersona id="2.1" description="과업을 가장 잘 수행할 전문가의 상세한 묘사">
                당신은 **'인지과학 및 교육 평가에 정통한 교육과정 설계 전문가'**이다. 당신은 피상적인 지식과 깊이 있는 이해를 구분하는 데 탁월하며, 학습자가 정보를 단순히 기억하는 것을 넘어 내재화하고 응용할 수 있는지 측정하는 정교한 질문을 설계하는 데 매우 능숙하다. 당신의 임무는 학습자가 자신의 이해 수준을 정확히 진단하고 더 깊은 탐구로 나아가도록 자극하는 지적인 도구를 만드는 것이다.
            </expertPersona>
            <audience id="2.2" description="결과물을 소비할 대상과 그들의 지식 수준">
                이 퀴즈의 사용자는 제공된 텍스트를 방금 학습한 지적인 성인이다. 이들은 내용을 기억하고 있지만, 자신이 정말로 핵심을 꿰뚫고 있는지, 그리고 배운 지식을 다른 상황에 적용할 수 있는지 확인하고 싶어 한다.
            </audience>
            <toneAndStyle id="2.3" description="결과물의 어조와 스타일">
                - **어조**: 지적이고 전문적이며, 신뢰감을 주는 어조를 사용한다.
                - **스타일**: 질문은 명확하고 간결하며, 학습자의 깊이 있는 사고를 자극하도록 구성한다. 해설은 정답의 근거를 넘어, 관련된 개념까지 확장하여 설명함으로써 추가 학습을 유도한다.
            </toneAndStyle>
        </personaAssignment>
        <contextAndFormat id="3" title="맥락 제공 및 형식 지정">
            <essentialContext id="3.1" description="과업 수행에 필요한 모든 배경 정보"><![CDATA[
- **퀴즈 문항 수**: {{questionCount}}
- **퀴즈 출제 언어**: 한국어
- **퀴즈 출제 기반 원본 텍스트**:
{{text}}
            ]]></essentialContext>
            <outputFormat id="3.2" description="결과물이 출력되어야 할 정확한 형식 또는 템플릿"><![CDATA[
{{outputFormatInstruction}}

### JSON 객체 스키마:
- **questionText**: [String] 질문 내용.
- **type**: [String] 질문 유형 ('multiple_choice', 'short_answer', 'subjective', 'case_based' 중 하나).
- **options**: [Array of Strings] 'multiple_choice' 유형일 경우 4개의 선택지 배열. 다른 유형은 null.
- **answer**: [String] 정답. 'multiple_choice'는 정답 선택지의 텍스트, 'short_answer'는 간결한 정답 용어, 'subjective' 및 'case_based'는 상세한 모범 답안.
- **explanation**: [String] 정답이 왜 정답인지에 대한 명확하고 상세한 해설. 가능한 경우 원본 텍스트를 참조하여 설명.
            ]]></outputFormat>
        </contextAndFormat>
        <reasoningDesign id="4" title="추론 과정 설계: 생각의 경로 구축">
            <reasoningFramework id="4.1" description="과업 복잡성에 따른 추론 방식 선택">
                <option type="ProblemDecomposition" description="복잡한 프로젝트 수행 시 사용">
                    <instruction>아래의 최종 목표를 달성하기 위해, 다음의 하위 작업들을 명시된 순서대로 반드시 수행하라.</instruction>
                    <subTasks>
                        <task id="1">**1단계: 원본 텍스트 심층 분석:** 제공된 텍스트를 정독하여 핵심 주장, 논리적 구조, 주요 개념 간의 관계, 그리고 저자가 암묵적으로 전제하는 가정을 파악한다.</task>
                        <task id="2">**2단계: 심층적 이해를 측정하는 문항 설계:** 분석된 핵심 내용을 바탕으로, 학습자의 '진정한 이해'를 측정하는 고차원적 문항 {{questionCount}}개를 설계한다. 단순 정보 회상을 넘어, 다음과 같은 인지 능력을 평가하는 데 집중하라:
- **개념 연결:** 텍스트 내의 서로 다른 두 가지 핵심 개념을 제시하고, 그 둘의 관계(예: 원인-결과, 대조, 포함 관계)를 설명하도록 요구하는 질문.
- **논증 분석:** 저자의 핵심 주장을 자신의 언어로 요약하고, 그 주장을 뒷받침하는 근거를 본문에서 찾아내도록 하는 질문.
- **비판적 사고:** 본문의 특정 관점에 대해 동의하거나 반박하고, 그 이유를 논리적으로 서술하도록 요구하는 질문. (예: '저자의 주장에 나타날 수 있는 잠재적 한계점은 무엇인가?')
- **적용 및 유추:** 본문에서 배운 추상적인 원리를 구체적인 가상 시나리오나 새로운 사례에 적용하여 해결책을 제시하도록 하는 질문.
- **가정 탐색:** 저자가 명시적으로 언급하지 않았지만, 논리 전개의 바탕이 되는 숨겨진 가정을 찾아내도록 유도하는 질문.
</task>
                        <task id="3">**3단계: 정답 및 해설 작성:** 각 문항에 대한 명확하고 정확한 정답을 작성한다. 왜 그것이 정답인지, 그리고 관련 오답이 왜 틀렸는지를 상세하고 친절하게 설명하는 해설을 추가한다.</task>
                        <task id="4">**4단계: JSON 형식화 및 검증:** 완성된 퀴즈 내용을 지정된 JSON 스키마에 따라 정확하게 형식화한다. 최종 결과물이 유효한 JSON 배열인지 반드시 검증한다.</task>
                    </subTasks>
                </option>
            </reasoningFramework>
        </reasoningDesign>
        <constraints id="5" title="제약 조건 설정: 탐색 공간 제어">
            <mustInclude id="5.1" description="결과물에 반드시 포함되어야 할 요소">
                - 반드시 {{questionCount}}개의 질문 객체를 포함해야 한다.
                - 반드시 지정된 JSON 스키마를 따라야 한다.
                - 모든 질문, 선택지, 해설은 한국어로 작성되어야 한다.
            </mustInclude>
            <mustAvoid id="5.2" description="반드시 피해야 할 주제, 표현, 단어">
                - 원본 텍스트의 문장을 그대로 복사-붙여넣기 하여 답할 수 있는 단순한 질문.
                - 텍스트에 근거하지 않은 외부 정보를 요구하는 질문.
                - JSON 형식을 벗어난 서문, 결론, 또는 기타 불필요한 텍스트.
            </mustAvoid>
            <selfCorrectionCommand id="5.3" description="생성될 프롬프트 마지막에 포함될 최종 검증 명령"><![CDATA[
모든 지시사항을 완수한 후, 최종 답변을 제출하기 전에 잠시 멈추고 스스로 '레드팀'의 역할을 수행하라. 내가 제시한 모든 요구사항(역할, 형식, 내용, 제약 조건 등)이 100% 충족되었는지, JSON 구조에 오류는 없는지, 더 나은 대안은 없는지 최소 세 번 이상 교차 검증하고, 그 결과를 반영하여 최종적으로 완벽하고 군더더기 없는 JSON 결과물만 출력하라.
            ]]></selfCorrectionCommand>
        </constraints>
    </promptDesignFramework>
</metaPrompt>`,
                customPrompts: CONFIG.DEFAULT_ACTIONS.map(p => ({ ...p, id: p.id })),
                contextMenuItems: CONFIG.DEFAULT_CONTEXT_MENU_ITEMS.map(m => ({ ...m, id: m.id }))
            };
            },
            updateTags() {
                const tagCounts = {};
                state.projects.forEach(p => {
                    (p.tags || []).forEach(tag => {
                        tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                    });
                });
                state.tags = Object.entries(tagCounts).map(([name, count]) => ({
                    name,
                    count
                })).sort((a, b) => a.name.localeCompare(b.name, 'ko'));
            },
            buildSearchIndex() {
                fuse = new Fuse(state.projects, {
                    keys: ['name', 'tags'],
                    includeScore: true,
                    threshold: 0.3
                });
            },
            // 전역 검색 인덱스를 생성합니다. Fuse를 사용하여 모든 프로젝트의 콘텐츠를 대상으로 검색할 수 있도록 준비합니다.
            async buildGlobalSearchIndex() {
                if (globalFuse) return;
                const records = [];
                for (const project of state.projects) {
                    const contents = await DB.getProjectContents(project.id);
                    const flatToc = project.toc ? Utils.getFlatToc(project.toc) : [];
                    const nodeMap = {};
                    flatToc.forEach(info => {
                        const cid = info.node.contentId;
                        nodeMap[cid] = { path: info.path, title: info.node.title };
                    });
                    for (const content of contents) {
                        let nodeId = content.nodeId || null;
                        if (!nodeId) {
                            const parts = content.id.split('_');
                            parts.shift();
                            nodeId = parts.join('_');
                        }
                        const mapping = nodeMap[nodeId] || {};
                        const combinedText = [
                            content.manuscript || '',
                            content.translation || '',
                            content.notes || ''
                        ].join(' ');
                        if (!combinedText.trim()) continue;
                        records.push({
                            projectId: project.id,
                            projectName: project.name,
                            path: mapping.path || null,
                            title: mapping.title || '',
                            text: combinedText,
                            contentId: content.id
                        });
                    }
                }
                globalFuse = new Fuse(records, {
                    keys: ['text'],
                    includeScore: true,
                    threshold: 0.3
                });
            },
            /**
             * 주어진 텍스트에서 검색어의 첫 번째 발생 주변을 추출하여 스니펫을 생성합니다.
             * @param {string} text - 원본 텍스트
             * @param {string} query - 사용자 검색어
             * @param {number} radius - 검색어 전후 추출할 문자 수
             * @returns {string} - HTML 마크업을 포함한 스니펫
             */
            getSnippet(text, query, radius = 50) {
                const normalized = (text || '').replace(/\s+/g, ' ');
                const lowerText = normalized.toLowerCase();
                const terms = query.toLowerCase().split(/\s+/).filter(Boolean);
                let idx = -1;
                for (const term of terms) {
                    const i = lowerText.indexOf(term);
                    if (i >= 0 && (idx === -1 || i < idx)) {
                        idx = i;
                    }
                }
                if (idx < 0) idx = 0;
                const start = Math.max(0, idx - radius);
                const end = Math.min(normalized.length, idx + (terms[0] ? terms[0].length : 0) + radius);
                let snippet = normalized.slice(start, end).trim();
                terms.forEach(term => {
                    if (term) {
                        const regex = new RegExp(term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                        snippet = snippet.replace(regex, match => `<mark>${match}</mark>`);
                    }
                });
                const prefix = start > 0 ? '…' : '';
                const suffix = end < normalized.length ? '…' : '';
                return prefix + snippet + suffix;
            },

            /**
             * 한글 조사(은/는/이/가/을/를/와/과/도/의)를 제거하여 검색어를 정규화합니다.
             * 주로 명사 뒤에 붙는 조사를 단순히 삭제하여 어간만 남기기 때문에 간단한 검색 품질 개선에 도움이 됩니다.
             * @param {string} text - 원본 문자열
             * @returns {string} - 정규화된 문자열
             */
            normalizeKorean(text) {
                // 각 단어의 끝에 붙는 조사만 제거합니다. 공백과 구두점 경계에서만 수행하도록 \b 사용.
                return (text || '').replace(/\b([가-힣]+)([은는이가을를와과도의])\b/g, '$1');
            },
            /**
             * 전역 검색을 수행하고 결과를 상태에 저장합니다.
             * @param {string} query - 검색어
             */
            async handleGlobalSearch(query) {
                // 전역 검색어를 저장하지만 즉시 검색을 실행하지는 않습니다. 검색 실행 시 이전 뷰를 기억합니다.
                const trimmed = query.trim();
                state.globalSearchQuery = query;

                // 이전 뷰를 저장하여 종료 시 돌아갈 수 있도록 합니다.
                if (state.currentView !== CONFIG.VIEW_NAMES.GLOBAL_SEARCH) {
                    state.previousView = state.currentView;
                }

                // 빈 검색어일 경우 결과를 초기화하고 전역 검색 뷰로 전환만 합니다.
                if (trimmed === '') {
                    state.globalSearchResults = null;
                    state.globalSearchVisibleCount = 30;
                    state.currentView = CONFIG.VIEW_NAMES.GLOBAL_SEARCH;
                    View.render();
                    return;
                }
                await this.buildGlobalSearchIndex();
                // 한글 조사를 제거한 검색어를 함께 사용하여 검색 품질을 높입니다.
                const normalized = this.normalizeKorean(trimmed);
                const queries = Array.from(new Set([trimmed, normalized]));
                const searchOptions = { limit: 200 };
                const aggregated = [];
                for (const q of queries) {
                    try {
                        aggregated.push(...globalFuse.search(q, searchOptions));
                    } catch (err) {
                        aggregated.push(...globalFuse.search(q));
                    }
                }
                // 중복된 contentId를 제거하면서 원래의 순서를 유지합니다.
                const seen = new Set();
                const uniqueResults = [];
                for (const res of aggregated) {
                    const cid = res.item.contentId;
                    if (!seen.has(cid)) {
                        seen.add(cid);
                        uniqueResults.push(res);
                    }
                }
                const processed = uniqueResults.map(res => {
                    const rec = res.item;
                    const snippet = this.getSnippet(rec.text, trimmed);
                    // 경로가 없을 경우, 프로젝트의 toc를 탐색하여 해당 contentId에 대한 경로를 찾습니다.
                    let path = rec.path;
                    if (!path) {
                        const project = state.projects.find(p => p.id === rec.projectId);
                        if (project && project.toc) {
                            const allNodes = Utils.getFlatToc(project.toc);
                            const match = allNodes.find(item => item.node.contentId === rec.contentId);
                            if (match) path = match.path;
                        }
                    }
                    return {
                        projectId: rec.projectId,
                        projectName: rec.projectName,
                        path: path,
                        title: rec.title || '',
                        snippet: snippet
                    };
                });
                state.globalSearchResults = processed;
                state.globalSearchVisibleCount = 30;
                // 전역 검색 뷰로 전환합니다. 이전 프로젝트 검색 상태를 지웁니다.
                state.currentView = CONFIG.VIEW_NAMES.GLOBAL_SEARCH;
                state.searchQuery = '';
                state.searchResults = null;
                View.render();
            },
            handleSearch(query) {
                // Use the global setState helper to update multiple pieces of state consistently.
                const trimmedQuery = query.trim();
                const searchResults = trimmedQuery === '' ? null : fuse.search(query).map(result => result.item);
                setState({
                    searchQuery: query,
                    searchResults,
                    currentView: CONFIG.VIEW_NAMES.PROJECT_LIST,
                    currentFilter: { type: 'all', id: null }
                });
                // searchInput.value is automatically updated via re-render
            },
            handleNavFilter(target) {
                if (!target) return;
                const type = target.dataset.filterType;
                const id = target.dataset.id || null;
                if (type === 'category' && state.categories.length === 0) return;
                if (type === 'tag' && state.tags.length === 0) return;
                // Reset search results and update current filter and view using setState.
                const newView = (type === 'dashboard') ? CONFIG.VIEW_NAMES.DASHBOARD : CONFIG.VIEW_NAMES.PROJECT_LIST;
                const searchInput = document.getElementById('search-input');
                if (searchInput) searchInput.value = '';
                // Expand sidebar groups when no specific id is provided.
                if (type === 'category' && !id) {
                    state.sidebarCollapseState.categories = false;
                } else if (type === 'tag' && !id) {
                    state.sidebarCollapseState.tags = false;
                }
                setState({
                    currentFilter: { type, id },
                    searchResults: null,
                    currentView: newView
                });
                if (window.innerWidth <= 1024) this.closeSidebar();
            },
            getFilteredAndSortedProjects() {
                let filtered = state.searchResults ? state.searchResults : state.projects;
                if (!state.searchResults) {
                    const {
                        type,
                        id
                    } = state.currentFilter;
                    if (type === 'category' && id) filtered = filtered.filter(p => p.categoryId === id);
                    else if (type === 'tag' && id) filtered = filtered.filter(p => p.tags?.includes(id));
                }
                const [field, direction] = state.currentSortOrder.split('_');
                return [...filtered].sort((a, b) => {
                    let valA = a[field] || 0;
                    let valB = b[field] || 0;
                    if (field === 'name') return direction === 'asc' ? valA.localeCompare(valB, 'ko') : valB.localeCompare(valA, 'ko');
                    valA = new Date(valA).getTime() || 0;
                    valB = new Date(valB).getTime() || 0;
                    return direction === 'asc' ? valA - valB : valB - valA;
                });
            },
            // learning.html 파일의 Controller 객체 내부에서
// 기존 openProject 함수를 아래 코드로 통째로 교체하세요.

            async openProject(id, shouldRender = true) {
                state.isLoading = true;
                if (shouldRender) {
                    View.render();
                }

                try {
                    const project = await DB.get(CONFIG.STORES.PROJECTS, id);
                    if (!project) throw new Error("프로젝트를 찾을 수 없습니다.");

                    // [핵심 수정] 단순 덮어쓰기 대신 지능형 병합 로직을 사용합니다.
const savedSettings = project.settings || {};
project.settings = { ...CONFIG.DEFAULT_PROJECT_SETTINGS, ...savedSettings }; // 기본 설정은 덮어씁니다.
// 커스텀 목록은 지능적으로 병합합니다.
project.settings.customPrompts = Utils.mergeCustomItems(savedSettings.customPrompts, CONFIG.DEFAULT_PROJECT_SETTINGS.customPrompts);
project.settings.contextMenuItems = Utils.mergeCustomItems(savedSettings.contextMenuItems, CONFIG.DEFAULT_PROJECT_SETTINGS.contextMenuItems);

                    // 1. 마이그레이션 필요 여부 확인
                    let needsMigration = false;
                    const checkNeedsMigration = (node) => {
                        if (!node) return;
                        if (!node.contentId) needsMigration = true;
                        if (node.children) node.children.forEach(checkNeedsMigration);
                    };
                    if (project.toc) checkNeedsMigration(project.toc);

                    // 2. 마이그레이션 실행
                    if (needsMigration) {
                        this.showToast('이전 버전 프로젝트를 업데이트합니다...', 'info');
                        const migrationPromises = [];
                        
                        const migrateNode = (node, path) => {
                            if (!node) return;
                            if (!node.contentId) {
                                node.contentId = Utils.generateId('content');
                                const oldContentId = `${id}_${path}`;
                                const newContentId = `${id}_${node.contentId}`;

                                const migrationTask = async () => {
                                    const oldContent = await DB.get(CONFIG.STORES.CONTENTS, oldContentId);
                                    if (oldContent) {
                                        await DB.delete(CONFIG.STORES.CONTENTS, oldContentId);
                                        oldContent.id = newContentId;
                                        await DB.put(CONFIG.STORES.CONTENTS, oldContent);
                                    } else {
                                    const nodeId = node.contentId;
                                    const newEmptyContent = {
                                        id: newContentId,
                                        projectId: id,
                                        nodeId: nodeId,
                                        manuscript: '',
                                        translation: '',
                                        notes: '',
                                        imageDataUrl: null,
                                        questions: [],
                                        historyMetadata: { snapshotCount: 0, lastSnapshotAt: null },
                                        status: 'empty'
                                    };
                                        await DB.put(CONFIG.STORES.CONTENTS, newEmptyContent);
                                    }
                                };
                                migrationPromises.push(migrationTask());
                            }
                            if (node.children) {
                                node.children.forEach((child, index) => migrateNode(child, `${path ? path + '.' : ''}${index}`));
                            }
                        };

                        if (project.toc && project.toc.children) {
                            project.toc.children.forEach((child, index) => migrateNode(child, `${index}`));
                        }
                        
                        await Promise.all(migrationPromises);
                        await DB.put(CONFIG.STORES.PROJECTS, project);
                        this.showToast('프로젝트 업데이트가 완료되었습니다.', 'success');
                    }

                    // 3. 콘텐츠 로드
                    const allNodes = Utils.getFlatToc(project.toc);
                    const contents = await Promise.all(
                        allNodes.map(nodeInfo => DB.get(CONFIG.STORES.CONTENTS, `${id}_${nodeInfo.node.contentId}`))
                    );

                    state.activeContentsMap = new Map();
                    contents.forEach((c, index) => {
                        const nodeInfo = allNodes[index];
                        const contentId = `${id}_${nodeInfo.node.contentId}`;
                        if (c) {
                            state.activeContentsMap.set(c.id, c);
                        } else {
                            console.warn(`콘텐츠를 찾을 수 없어 새로 생성합니다: ${contentId}`);
                            // Extract the nodeId (contentId part) from the composite id
                            const nodeId = nodeInfo.node.contentId || contentId.split('_').slice(1).join('_');
                            const newContent = {
                                id: contentId,
                                projectId: id,
                                nodeId: nodeId,
                                manuscript: '',
                                translation: '',
                                notes: '',
                                imageDataUrl: null,
                                questions: [],
                                historyMetadata: { snapshotCount: 0, lastSnapshotAt: null },
                                status: 'empty'
                            };
                            state.activeContentsMap.set(contentId, newContent);
                            DB.put(CONFIG.STORES.CONTENTS, newContent);
                        }
                    });
                    
                    state.activeProjectId = id;
                    state.activeProject = project;
                    state.currentView = 'workspace';
                    document.title = `${project.name} | 통합 학습 및 저작 시스템 v3.17`;
                    // 마지막 챕터나 첫 챕터를 선택하는 로직은 URL 네비게이션 함수에서 처리하도록 합니다.
                    // 이 함수는 순수하게 프로젝트를 여는 책임만 가집니다.

                } catch (error) {
                    console.error("프로젝트 열기 실패:", error);
                    this.showToast(`프로젝트를 여는 중 오류 발생: ${error.message}`, 'error');
                    // 오류 발생 시 대시보드로 안전하게 이동
                    state.currentView = 'dashboard';
                    state.activeProjectId = null;
                } finally {
                    // 브라우저 탭의 제목을 프로젝트 이름으로 업데이트합니다.
                    state.isLoading = false;
                    // shouldRender가 true일 때만 렌더링하도록 조건 추가
                    if (shouldRender) {
                        View.render();
                    }
                }
            },
            async selectChapter(path, shouldRender = true) {
                this.saveScrollPosition();
                
                state.activeChapterPath = path;
                if (state.activeProject && state.activeProject.lastChapterPath !== path) {
                    state.activeProject.lastChapterPath = path;
                    state.activeProject.updatedAt = new Date().toISOString();
                    await DB.put(CONFIG.STORES.PROJECTS, state.activeProject);
                }

                const node = Utils.getNodeByPath(state.activeProject.toc, path);
                if (node && node.contentId) {
                    state.activeChapterContent = state.activeContentsMap.get(`${state.activeProjectId}_${node.contentId}`);
                } else {
                    state.activeChapterContent = null;
                }

                state.quizState = null;
                state.viewPanelDisplayMode = 'auto';

                if (shouldRender) {
                    View.render();
                    setTimeout(() => this.syncFormElements(), 0);
                }
                const translationTextarea = document.getElementById('translation');
                if (translationTextarea) {
                    translationTextarea.value = state.activeChapterContent?.translation || '';
                }
                const mainScrollContainer = document.querySelector('.main-content');
                if (mainScrollContainer) {
                    mainScrollContainer.scrollTop = 0;
                }

                setTimeout(() => {
                    const activeTocItem = document.querySelector(`.sidebar .toc-item.active`);
                    if (activeTocItem) {
                        activeTocItem.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center'
                        });
                    }
                }, 100);

                if (state.isMobileSidebarOpen) this.closeSidebar();

                // [추가] 함수 실행이 끝난 후, 현재 상태를 URL에 반영합니다.
                this.updateURLFromState();
            },
            async handleContentChange(event) {
                const { field } = event.target.dataset;
                const value = event.target.value;

                if (state.activeChapterContent && field) {
                    // 기존: state.saveStatus = 'saving'; View.render();
                    this.updateSaveStatus('saving'); // 수정

                    const content = state.activeChapterContent;
                    content[field] = value;
                    if (field === 'manuscript' && value.trim() && (content.status === 'empty' || content.status === 'prompt-copied')) {
                        content.status = 'manuscript-done';
                    }
                    await DB.put(CONFIG.STORES.CONTENTS, content);
                    
                    // 기존: state.saveStatus = 'saved'; ... View.render();
                    this.updateSaveStatus('saved'); // 수정

                    setTimeout(() => {
                        // 기존: state.saveStatus = 'idle'; View.render();
                        this.updateSaveStatus('idle'); // 수정
                    }, 2000);
                    this.saveChapterHistory(content);
                } 
                // 설정 모달 관련 로직은 그대로 유지
                else if (ModalManager.isOpen && ModalManager.type === 'settings' && event.target.dataset.settingKey) {
                    ModalManager.data[event.target.dataset.settingKey] = value;
                }
            },
            showToast(message, type = 'info', duration = 3000) {
                const id = Utils.generateId('toast');
                state.toasts.push({
                    id,
                    message,
                    type
                });
                View.render();
                setTimeout(() => Controller.dismissToast(id), duration);
            },
            dismissToast(id) {
                const toastEl = document.getElementById(`toast-${id}`);
                if (toastEl) {
                    toastEl.style.transition = 'opacity 0.5s ease';
                    toastEl.style.opacity = 0;
                    setTimeout(() => {
                        state.toasts = state.toasts.filter(t => t.id !== id);
                        View.render();
                    }, 500);
                } else {
                    state.toasts = state.toasts.filter(t => t.id !== id);
                }
            },
            applyPostRenderEffects() {
                const tocLinks = document.querySelectorAll('.sidebar .toc-item a');
                tocLinks.forEach(link => {
                    const textSpan = link.querySelector('span.truncate');
                    if (!textSpan) return;

                    const path = link.dataset.path;
                    const node = Utils.getNodeByPath(state.activeProject.toc, path);
                    const content = node ? state.activeContentsMap.get(`${state.activeProjectId}_${node.contentId}`) : null;
                    
                    const isTruncated = textSpan.scrollWidth > textSpan.clientWidth;

                    // 1. 콘텐츠 정보가 없으면 툴팁을 아예 표시하지 않음
                    if (!content) {
                        link.removeAttribute('data-tooltip');
                        return;
                    }
                    
                    // 2. 콘텐츠 정보를 바탕으로 통계 데이터 생성
                    const manuscriptCount = content.manuscript?.length || 0;
                    const translationCount = content.translation?.length || 0;
                    const hasImage = !!content.imageDataUrl;
                    const hasQuizzes = content.questions && content.questions.length > 0;

                    // 3. 텍스트가 잘렸거나, 추가 정보가 하나라도 있을 경우에만 툴팁을 생성
                    if (isTruncated || manuscriptCount > 0 || translationCount > 0 || hasImage || hasQuizzes) {
                        const fullTitle = DOMPurify.sanitize(textSpan.textContent);
                        
                        // 4. 아이콘과 함께 표시될 상세 정보 HTML 생성
                        const detailsHtml = `
                            <hr class='border-slate-500 my-1 opacity-50'>
                            <div class='grid grid-cols-2 gap-x-2 mt-1.5 font-normal text-xs'>
                                <div class='flex items-center' title="원고 글자수">
                                    ${Heroicons.render('document-text', { class: 'w-3.5 h-3.5 mr-1 flex-shrink-0' })}
                                    <span>${Utils.formatCount(manuscriptCount)}자</span>
                                </div>
                                <div class='flex items-center' title="번역문 글자수">
                                    ${Heroicons.render('language', { class: 'w-3.5 h-3.5 mr-1 flex-shrink-0' })}
                                    <span>${Utils.formatCount(translationCount)}자</span>
                                </div>
                                <div class='flex items-center' title="이미지">
                                    ${Heroicons.render(hasImage ? 'check-circle' : 'x-circle', { class: `w-3.5 h-3.5 mr-1 flex-shrink-0 ${hasImage ? 'text-green-400' : 'text-slate-500'}` })}
                                    <span>이미지</span>
                                </div>
                                <div class='flex items-center' title="퀴즈">
                                    ${Heroicons.render(hasQuizzes ? 'check-circle' : 'x-circle', { class: `w-3.5 h-3.5 mr-1 flex-shrink-0 ${hasQuizzes ? 'text-green-400' : 'text-slate-500'}` })}
                                    <span>퀴즈</span>
                                </div>
                            </div>
                        `;
                        
                        // 5. 최종 툴팁 HTML을 data-tooltip 속성에 할당
                        const tooltipContent = `<div class='text-left'><div class='font-semibold mb-1'>${fullTitle}</div>${detailsHtml}</div>`;
                        link.setAttribute('data-tooltip', tooltipContent);

                    } else {
                        // 텍스트가 잘리지도 않았고, 추가 정보도 없으면 툴팁을 제거
                        link.removeAttribute('data-tooltip');
                    }
                });
                 const mainContentEl = document.querySelector('.main-content');
                if (mainContentEl) {
                    mainContentEl.addEventListener('scroll', () => {
                        // 컨텍스트 메뉴가 열려있으면 닫습니다.
                        if (state.contextMenu.isOpen) {
                            state.contextMenu.isOpen = false;
                            View.renderContextMenu();
                        }
                        // 진행률 표시줄을 업데이트합니다.
                        this.updateViewProgressBar();
                    }, { passive: true });
                }
                if (state.currentView === 'workspace' && state.workspaceMode === 'view' && state.isKaTeXLoaded && window.renderMathInElement) {
                    const viewPanel = document.querySelector('.prose.prose-readable');
                    if (viewPanel) {
                        try {
                            renderMathInElement(viewPanel, {
                                delimiters: [{
                                    left: '$',
                                    right: '$',
                                    display: true
                                }, {
                                    left: '\\(',
                                    right: '\\)',
                                    display: false
                                }, {
                                    left: '\\[',
                                    right: '\\]',
                                    display: true
                                }]
                            });
                        } catch (e) {
                            console.error("KaTeX rendering failed:", e);
                        }
                    }
                }
                if (state.activeChapterPath) {
                    const keyPrefix = `${state.activeProjectId}_${state.activeChapterPath}`;

                    // 현재 모드에 맞는 메인 패널 스크롤 위치 복원
                    const mainContentPanel = document.getElementById('workspace-main-content');
                    const savedMainScroll = state.scrollPositions[`${keyPrefix}_${state.workspaceMode}`];
                    if (mainContentPanel && savedMainScroll !== undefined) {
                        mainContentPanel.scrollTop = savedMainScroll;
                    }

                    // 기존 텍스트 영역 스크롤 위치 복원 로직은 유지
                    const elementsToRestore = ['manuscript', 'notes', 'translation'];
                    elementsToRestore.forEach(id => {
                        const el = document.getElementById(id);
                        const savedPosition = state.scrollPositions[`${keyPrefix}_${id}`];
                        if (el && savedPosition !== undefined) {
                            el.scrollTop = savedPosition;
                        }
                    });
                }
            },
            async submitNewProject(form) {
                const activeTab = ModalManager.data.activeTab || 'blank';
                try {
                    let projectData, contentsData;
                    if (['jsonText', 'tocJson'].includes(activeTab)) {
                        const textarea = form.querySelector('textarea');
                        try {
                            JSON.parse(textarea.value);
                            ModalManager.data.error = '';
                        } catch (e) {
                            ModalManager.data.error = `JSON 형식이 올바르지 않습니다: ${e.message}`;
                            ModalManager.render();
                            return;
                        }
                    }
                    ModalManager.data.isLoading = true;
                    ModalManager.data.loadingMessage = '프로젝트 생성 중...';
                    ModalManager.render();
                    if (activeTab === 'blank') {
                        const projectName = form.querySelector('#blank-project-name').value.trim();
                        const categoryId = form.querySelector('#blank-project-category').value;
                        if (!projectName) throw new Error("프로젝트 이름을 입력해주세요.");
                        ({
                            project: projectData,
                            contents: contentsData
                        } = this.processBlankProject(projectName, categoryId));
                    } else if (activeTab === 'zip') {
                        ModalManager.data.loadingMessage = 'ZIP 파일 분석 중...';
                        ModalManager.render();
                        const fileInput = form.querySelector('#zip-upload');
                        if (!fileInput.files[0]) throw new Error("ZIP 파일을 선택해주세요.");
                        ({
                            project: projectData,
                            contents: contentsData
                        } = await this.processZipFile(fileInput.files[0]));
                    } else if (activeTab === 'jsonFile') {
                        const fileInput = form.querySelector('#json-upload');
                        if (!fileInput.files[0]) throw new Error("JSON 파일을 선택해주세요.");
                        if (fileInput.files[0].type.includes('zip') || fileInput.files[0].name.toLowerCase().endsWith('.zip')) {
                            throw new Error("ZIP 파일은 'ZIP' 탭에서 업로드해야 합니다.");
                        }
                        ({
                            project: projectData,
                            contents: contentsData
                        } = this.processJsonData(JSON.parse(await fileInput.files[0].text())));
                    } else if (activeTab === 'jsonText') {
                        const jsonTextInput = form.querySelector('#json-text-input');
                        ({
                            project: projectData,
                            contents: contentsData
                        } = this.processJsonData(JSON.parse(jsonTextInput.value)));
                    } else if (activeTab === 'tocJson') {
                        const tocJsonInput = form.querySelector('#toc-json-input');
                        ({
                            project: projectData,
                            contents: contentsData
                        } = this.processTocJson(JSON.parse(tocJsonInput.value)));
                    } else {
                        throw new Error("알 수 없는 생성 방식입니다.");
                    }

                    ModalManager.data.loadingMessage = '데이터베이스에 저장 중...';
                    ModalManager.render();
                    await DB.put(CONFIG.STORES.PROJECTS, projectData);
                    if (contentsData && contentsData.length > 0) {
                        await Promise.all(contentsData.map(c => DB.put(CONFIG.STORES.CONTENTS, c)));
                    }

                    state.projects.unshift(projectData);
                    this.updateTags();
                    this.buildSearchIndex();
                    this.showToast(`'${projectData.name}' 프로젝트가 생성되었습니다.`, 'success');
                    ModalManager.close();
                } catch (error) {
                    console.error("Project creation failed:", error);
                    this.showToast(`프로젝트 생성 실패: ${error.message}`, 'error');
                    ModalManager.data.isLoading = false;
                } finally {
                    state.isLoading = false;
                    View.render();
                }
            },
            processBlankProject(name, categoryId) {
                const projectId = Utils.generateId('proj');
                const project = {
                    id: projectId,
                    name,
                    categoryId: categoryId || null,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    toc: {
                        title: name,
                        children: []
                    },
                    settings: JSON.parse(JSON.stringify(CONFIG.DEFAULT_PROJECT_SETTINGS))

                };
                return {
                    project,
                    contents: []
                };
            },
            handleFileSelection(input) {
                const label = document.getElementById(input.dataset.targetLabel);
                if (label) {
                    const fileName = input.files[0] ? input.files[0].name : '선택된 파일 없음';
                    label.textContent = fileName;
                    label.title = fileName;
                }
            },
            async processZipFile(file) {
                const turndownService = new TurndownService();
                const zip = await JSZip.loadAsync(file);
                const allEntries = [];

                zip.forEach((relPath, entry) => {
                    const normPath = relPath.replace(/\/$/, '').replace(/\\/g, '/');
                    if (normPath && !normPath.startsWith('__MACOSX')) {
                        allEntries.push({
                            path: normPath,
                            isDir: entry.dir,
                            entry
                        });
                    }
                });

                allEntries.sort((a, b) => Utils.naturalSort(a.path, b.path));
                const projectToc = Utils.createTocNode(Utils.formatTitle(file.name)); // 수정

                const pathMap = new Map();

                for (const {
                        path
                    }
                    of allEntries) {
                    let currentNode = projectToc;
                    let currentPath = '';
                    path.split('/').forEach((part) => {
                    currentPath = currentPath ? `${currentPath}/${part}` : part;
                    let childNode = pathMap.get(currentPath);
                    if (!childNode) {
                        childNode = Utils.createTocNode(Utils.formatTitle(part)); // 수정
                        childNode.originalPath = path; // 기존 로직 유지를 위해 originalPath 추가
                        currentNode.children.push(childNode);
                        pathMap.set(currentPath, childNode);
                    }
                    currentNode = childNode;
                });
                }

                Utils.normalizeTocNode(projectToc);
                const projectId = Utils.generateId('proj');
                const project = {
                    id: projectId,
                    name: projectToc.title,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    toc: projectToc,
                    settings: {
                        ...CONFIG.DEFAULT_PROJECT_SETTINGS
                    }
                };

                const contents = (await Promise.all(Utils.getAllNodePaths(projectToc).map(async ({
                    path,
                    node
                }) => {
                    const fileEntry = allEntries.find(f => f.path === node.originalPath)?.entry;
                    let manuscript = '';
                    if (fileEntry && !fileEntry.dir) {
                        if (/\.html?$/i.test(fileEntry.name)) {
                            const rawHtml = await fileEntry.async('string');
                            const bodyMatch = rawHtml.match(/<body[^>]*>([\s\S]*)<\/body>/i);
                            manuscript = turndownService.turndown(DOMPurify.sanitize(bodyMatch ? bodyMatch[1] : ''));
                        } else {
                            manuscript = await fileEntry.async('string');
                        }
                    }
                    return {
                        id: `${projectId}_${node.contentId}`, // Use the node's contentId to build the composite key
                        projectId: projectId,
                        nodeId: node.contentId,
                        manuscript,
                        translation: '',
                        notes: '',
                        imageDataUrl: null,
                        questions: [],
                        historyMetadata: { snapshotCount: 0, lastSnapshotAt: null },
                        status: manuscript.trim() ? 'manuscript-done' : 'empty'
                    };
                }))).filter(Boolean);

                return {
                    project,
                    contents
                };
            },
            processJsonData(data) {
                if (data.type !== CONFIG.EXPORT_TYPE_ID) throw new Error("유효하지 않은 프로젝트 파일 형식입니다.");
                const newId = Utils.generateId('proj');
                const newProject = {
                    ...data.project,
                    id: newId,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString()
                };
                const savedSettingsFromJson = newProject.settings || {};
                newProject.settings = { ...CONFIG.DEFAULT_PROJECT_SETTINGS, ...savedSettingsFromJson };
                newProject.settings.customPrompts = Utils.mergeCustomItems(savedSettingsFromJson.customPrompts, CONFIG.DEFAULT_PROJECT_SETTINGS.customPrompts);
                newProject.settings.contextMenuItems = Utils.mergeCustomItems(savedSettingsFromJson.contextMenuItems, CONFIG.DEFAULT_PROJECT_SETTINGS.contextMenuItems);

                
                // ▼▼▼ [수정] JSON 데이터에 contentId가 없을 경우를 대비한 마이그레이션 로직 추가 ▼▼▼
                const addContentIdIfNeeded = (node) => {
                    if (!node.contentId) {
                        node.contentId = Utils.generateId('content');
                    }
                    if (node.children) {
                        node.children.forEach(addContentIdIfNeeded);
                    }
                };
                addContentIdIfNeeded(newProject.toc);
                Utils.normalizeTocNode(newProject.toc);
                // ▲▲▲ [수정 완료] ▲▲▲

                // We'll generate a list of all nodes and map original contents by their
                // exported `path` value, which is actually the node's contentId. The
                // current Utils.getAllNodePaths() returns numeric index paths (e.g. "0",
                // "1.2"), so using that to look up the imported content will fail. We
                // instead match on the node's contentId directly.
                const allNodes = Utils.getAllNodePaths(newProject.toc);
                // Build a lookup map keyed by the contentId (stored in `path` property in
                // exported JSON) to the original content object.
                const contentMap = new Map(
                    (data.contents || []).map(c => [c.path, c])
                );

                const newContents = allNodes.map(nodeInfo => {
                    // The exported JSON stores the original content's `contentId` in the
                    // `path` field. Use the node's contentId to find the corresponding
                    // imported content.
                    const originalContent = contentMap.get(nodeInfo.node.contentId) || {};
                    const { path: _ignoredPath, ...rest } = originalContent;
                    // Always associate the content with the new project via projectId.
                    // Any existing projectId from the import is ignored.  Use empty
                    // defaults and override them with imported fields via the spread.
                    return {
                        id: `${newId}_${nodeInfo.node.contentId}`,
                        projectId: newId,
                        nodeId: nodeInfo.node.contentId,
                        manuscript: '',
                        translation: '',
                        notes: '',
                        imageDataUrl: null,
                        questions: [],
                        historyMetadata: { snapshotCount: 0, lastSnapshotAt: null },
                        status: 'empty',
                        ...rest,
                    };
                });

                return { project: newProject, contents: newContents };
            },
            processTocJson(tocData) {
                if (!tocData.title || !Array.isArray(tocData.children)) {
                    throw new Error("유효하지 않은 목차 JSON 형식입니다. 최상위 객체에 'title'과 'children' 속성이 필요합니다.");
                }
                const projectId = Utils.generateId('proj');
                const finalToc = JSON.parse(JSON.stringify(tocData)); // 원본 데이터 수정을 방지하기 위해 깊은 복사

                // [핵심 수정] 모든 노드를 순회하며 고유 contentId를 할당하는 재귀 함수
                const assignContentIds = (node) => {
                    if (!node.contentId) { // 기존에 ID가 없을 경우에만 새로 할당
                        node.contentId = Utils.generateId('content');
                    }
                    if (node.children && node.children.length > 0) {
                        node.children.forEach(assignContentIds);
                    }
                };

                assignContentIds(finalToc); // TOC 전체에 contentId 할당
                Utils.normalizeTocNode(finalToc);

                const project = {
                    id: projectId,
                    name: finalToc.title,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    toc: finalToc,
                    settings: { ...CONFIG.DEFAULT_PROJECT_SETTINGS }
                };

                // [핵심 수정] path 기반이 아닌, 각 노드의 contentId를 기반으로 콘텐츠 객체 생성
                const contents = Utils.getFlatToc(finalToc).map(({ node }) => ({
                    id: `${projectId}_${node.contentId}`,
                    projectId: projectId,
                    nodeId: node.contentId,
                    manuscript: '',
                    translation: '',
                    notes: node.description || '',
                    imageDataUrl: null,
                    questions: [],
                    historyMetadata: { snapshotCount: 0, lastSnapshotAt: null },
                    status: 'empty'
                }));
                
                return { project, contents };
            },
            copyToClipboard(text, id = null) { // [수정] id를 인자로 받도록 변경
                const textArea = document.createElement("textarea");
                textArea.value = text;
                textArea.style.position = "fixed";
                textArea.style.top = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    const successful = document.execCommand('copy');
                    if (successful) {
                        this.showToast('클립보드에 복사되었습니다.', 'success');
                        // [수정] id가 있을 경우, 복사 확인 애니메이션 상태를 업데이트합니다.
                        if (id) {
                            if (!state.copiedStatus) state.copiedStatus = {};
                            state.copiedStatus[id] = true;
                            View.render();
                            setTimeout(() => {
                                state.copiedStatus[id] = false;
                                View.render();
                            }, 1500);
                        }
                    } else {
                        throw new Error('Copy command failed');
                    }
                } catch (err) {
                    console.error("Clipboard copy failed:", err);
                    this.showToast('클립보드 복사에 실패했습니다.', 'error');
                }
                document.body.removeChild(textArea);
            },
        copyPromptForCurrentChapter() {
                if (!state.activeProject) return;
                const template = state.activeProject.settings.writingPrompt || CONFIG.DEFAULT_PROJECT_SETTINGS.writingPrompt;
                // ▼▼▼ [수정] 변수 처리 로직을 중앙 함수에 위임 ▼▼▼
                this.processAndCopyPrompt(template, 'AI 글쓰기 프롬프트 실행');
                // ▲▲▲ [수정 완료] ▲▲▲
            },
            copyTranslationPrompt() {
                if (!state.activeChapterContent?.manuscript) return this.showToast('번역할 내용이 없습니다.', 'error');
                let prompt = state.activeProject.settings.translationPrompt || CONFIG.DEFAULT_PROJECT_SETTINGS.translationPrompt;
                prompt = prompt.replace('{{text}}', state.activeChapterContent.manuscript);
                this.copyToClipboard(prompt, `copy-translation-prompt-${state.activeChapterPath}`);
            },

            getNextFootnoteNumber(manuscriptText) {
                if (!manuscriptText) return 1;
                // 정규식: 문서 전체에서 "[^숫자]:" 형태의 모든 각주 정의를 찾음
                const regex = /\[\^(\d+)\]:/g;
                let match;
                let maxNumber = 0;

                // exec()를 반복 호출하여 모든 일치 항목을 순회
                while ((match = regex.exec(manuscriptText)) !== null) {
                    const currentNumber = parseInt(match[1], 10);
                    if (currentNumber > maxNumber) {
                        maxNumber = currentNumber;
                    }
                }
                return maxNumber + 1;
            },

            buildQuizPrompt() {
                const turndownService = new TurndownService();
                if (!state.activeChapterContent?.manuscript) return null;

                const sourceHtml = marked.parse(state.activeChapterContent.manuscript);
                const sourceText = turndownService.turndown(sourceHtml);
                if (!sourceText.trim()) return null;

                const settings = state.activeProject.settings;
                let template = settings.quizPromptTemplate || CONFIG.DEFAULT_PROJECT_SETTINGS.quizPromptTemplate;
                
                // [수정] 모든 변수를 담는 객체를 생성합니다.
                const replacements = {
                    '{{taskDescription}}': settings.quizTaskDescription,
                    '{{outputFormatInstruction}}': settings.quizOutputFormatInstruction,
                    '{{questionCount}}': settings.quizQuestionCount,
                    '{{text}}': sourceText.substring(0, 15000) // 텍스트는 용량 제한을 둡니다.
                };

                // [수정] for...of 루프와 전역 정규식을 사용하여 모든 변수를 치환합니다.
                for (const [key, value] of Object.entries(replacements)) {
                    // key에서 '{{'와 '}}'를 제거하고 공백을 제거하여 순수 변수 이름만 추출합니다.
                    const varName = key.slice(2, -2).trim();
                    // 공백을 허용하고( \s* ), 전역(g)으로 검색하는 정규식을 동적으로 생성합니다.
                    const regex = new RegExp(`{{\\s*${varName}\\s*}}`, 'g');
                    // 템플릿 내의 모든 일치 항목을 찾아 값으로 교체합니다.
                    template = template.replace(regex, value || '');
                }

                return template;
            },
            async generateQuiz() {
            let apiKey = localStorage.getItem('googleApiKey');
            if (!apiKey) {
                ModalManager.open('apiKey');
                return;
            }
            const prompt = this.buildQuizPrompt();
            if (!prompt) {
                this.showToast('퀴즈를 생성할 학습 내용이 없습니다.', 'error');
                return;
            }
            this.showToast('AI가 문제를 생성하고 있습니다...', 'info');
            const spinnerEl = document.querySelector('[data-action="generate-quiz"]');
            if (spinnerEl) spinnerEl.innerHTML = `<div class="w-5 h-5 border-2 border-slate-500 border-t-transparent rounded-full animate-spin"></div>`;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                if (!response.ok) throw new Error(`API 요청 실패: ${response.statusText}`);
                const result = await response.json();
                const responseText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!responseText) throw new Error("AI로부터 빈 응답을 받았습니다.");

                const jsonMatch = responseText.match(/<json_response>([\s\S]*?)<\/json_response>/);
                const jsonText = jsonMatch ? jsonMatch[1].trim() : responseText.match(/\[[\s\S]*\]/)?.[0] || responseText.trim();

                const questions = JSON.parse(jsonText);
                
                // [수정] AI로부터 받은 각 질문에 고유 ID를 부여합니다.
                questions.forEach(q => { if (!q.id) q.id = Utils.generateId('quiz'); });

                const content = state.activeChapterContent;
                content.questions = [...(content.questions || []), ...questions];
                content.status = 'quiz-done';
                await DB.put(CONFIG.STORES.CONTENTS, content);
                this.showToast(`${questions.length}개의 문제가 추가되었습니다.`, 'success');
                View.render();
            } catch (error) {
                console.error("Quiz generation failed:", error);
                this.showToast(`문제 생성 실패: ${error.message}`, 'error');
            } finally {
                if (spinnerEl) spinnerEl.innerHTML = `${Heroicons.render('sparkles', { class: 'w-5 h-5 mr-2' })}AI로 문제 추가`;
            }
        },
            startQuiz() {
                const questions = state.activeChapterContent.questions;
                if (!questions?.length) return;
                const processed = JSON.parse(JSON.stringify(questions)).map(q => {
                    if (q.type === CONFIG.QUIZ_TYPE.MULTIPLE_CHOICE) q.answerIndex = q.options.findIndex(opt => opt === q.answer);
                    return q;
                });
                state.quizState = {
                    questions: [...processed].sort(() => Math.random() - 0.5),
                    currentIndex: 0,
                    answers: []
                };
                state.currentView = 'quiz';
                View.render();
            },
            async finishQuiz() {
                const correctAnswers = state.quizState.answers.filter(a => a.isCorrect).length;
                const xpGained = correctAnswers * 100;
                if (xpGained > 0) {
                    const newXp = state.userProfile.xp + xpGained;
                    let newLevel = state.userProfile.level;
                    while (CONFIG.LEVEL_THRESHOLDS[newLevel] !== undefined && newXp >= CONFIG.LEVEL_THRESHOLDS[newLevel]) {
                        newLevel++;
                    }
                    if (newLevel > state.userProfile.level) {
                        this.showToast(`레벨 업! LV.${newLevel} 달성!`, 'success');
                    }
                    state.userProfile.xp = newXp;
                    state.userProfile.level = newLevel;
                    await DB.put(CONFIG.STORES.USER_PROFILE, state.userProfile);
                }
                state.currentView = 'quizResult';
                this.showToast(`퀴즈 완료! +${xpGained} XP`, 'success');
                View.render();
            },
            handleTocTitleEdit(input) {
                const node = Utils.getNodeByPath(ModalManager.data.editableToc, input.dataset.path);
                if (node) {
                    // ▼▼▼ [디버깅 코드 추가] ▼▼▼
                    console.log(`--- [2. 제목 수정 감지] ---
Path: ${input.dataset.path}
기존 제목: "${node.title}"
새 제목: "${input.value}"`);
                    // ▲▲▲ [디버깅 코드 추가] ▲▲▲
                    node.title = input.value;
                }
            },
            // learning.html 파일의 Controller 객체 내부

            // learning.html 파일의 Controller 객체 내부

            // learning.html 파일의 Controller 객체 내부

            async saveToc() {
                // [핵심 수정] 모달이 닫히기 전에, 수정된 목차 데이터를 안전한 지역 변수에 먼저 깊은 복사합니다.
                // 이것이 경쟁 조건 버그를 해결하는 가장 중요한 부분입니다.
                const tocToSave = JSON.parse(JSON.stringify(ModalManager.data.editableToc));

                state.isLoading = true;
                ModalManager.close(); // 이제 안전하게 모달을 닫을 수 있습니다.
                View.render(); // 로딩 상태를 즉시 UI에 반영
                
                try {
                    const projectId = state.activeProjectId;
                    const originalToc = state.activeProject.toc;

                    // 새로 추가되거나 삭제된 노드를 추적하기 위해 contentId 집합을 사용합니다.
                    const getIds = (node) => {
                        if (!node || !node.contentId) return new Set();
                        let ids = new Set([node.contentId]);
                        if (node.children) {
                            node.children.forEach(child => getIds(child).forEach(id => ids.add(id)));
                        }
                        return ids;
                    };

                    const oldContentIds = getIds(originalToc);
                    const newContentIds = getIds(tocToSave);

                    const deletedContentIds = [...oldContentIds].filter(id => !newContentIds.has(id));
                    const addedContentIds = [...newContentIds].filter(id => !oldContentIds.has(id));

                    // DB 작업을 위한 프로미스 배열
                    const promises = [];

                    // 새로 추가된 콘텐츠 생성
                    for (const contentId of addedContentIds) {
                        const newContent = {
                            id: `${projectId}_${contentId}`,
                            projectId: projectId,
                            nodeId: contentId,
                            manuscript: '',
                            translation: '',
                            notes: '',
                            imageDataUrl: null,
                            questions: [],
                            historyMetadata: { snapshotCount: 0, lastSnapshotAt: null },
                            status: 'empty',
                        };
                        promises.push(DB.put(CONFIG.STORES.CONTENTS, newContent));
                        state.activeContentsMap.set(newContent.id, newContent);
                    }

                    // 삭제된 콘텐츠 제거
                    for (const contentId of deletedContentIds) {
                        const fullContentId = `${projectId}_${contentId}`;
                        promises.push(DB.delete(CONFIG.STORES.CONTENTS, fullContentId));
                        state.activeContentsMap.delete(fullContentId);
                    }

                    // 현재 열려있던 챕터가 삭제되었는지 확인
                    const activeNode = state.activeChapterPath ? Utils.getNodeByPath(originalToc, state.activeChapterPath) : null;
                    if (activeNode && deletedContentIds.includes(activeNode.contentId)) {
                        state.activeChapterPath = null;
                        state.activeChapterContent = null;
                    }
                    
                    // 프로젝트의 목차를 새 버전으로 업데이트
                    state.activeProject.toc = tocToSave;
                    state.activeProject.updatedAt = new Date().toISOString();
                    promises.push(DB.put(CONFIG.STORES.PROJECTS, state.activeProject));
                    
                    await Promise.all(promises);
                    this.showToast('목차가 성공적으로 업데이트되었습니다.', 'success');

                } catch (error) {
                    console.error("Failed to save TOC:", error);
                    this.showToast(`목차 저장 실패: ${error.message}`, 'error');
                } finally {
                    state.isLoading = false;
                    // 최종 상태를 반영하여 다시 렌더링
                    View.render();
                }
            },
            buildSplitChapterPrompt(sourceType) { // 'manuscript' 또는 'translation'
                const sourceText = state.activeChapterContent[sourceType];
                const sourceLabel = sourceType === 'manuscript' ? '원문' : '번역문';

                if (!sourceText?.trim()) {
                    this.showToast(`분할할 ${sourceLabel}이 없습니다.`, 'error');
                    return null;
                }
                const paragraphs = sourceText.split(/\n\s*\n/).map(p => p.trim()).filter(Boolean);
                if (paragraphs.length < 2) {
                    this.showToast(`${sourceLabel}의 내용이 분할하기에 충분하지 않습니다.`, 'error');
                    return null;
                }

                const totalParagraphs = paragraphs.length;
                const totalCharacters = sourceText.replace(/\s/g, '').length;
                const avgCharactersPerParagraph = Math.round(totalCharacters / totalParagraphs);

                const numberedContent = paragraphs.map((p, i) => `[Paragraph ${i + 1}] ${p}`).join('\n\n');

                const prompt = `<Prime_Directive>Analyze the provided text, which is broken into numbered paragraphs, and identify logical division points to create sub-chapters.
                <Statistics>
                    <total_paragraphs>${totalParagraphs}</total_paragraphs>
                    <total_characters>${totalCharacters}</total_characters>
                    <avg_characters_per_paragraph>${avgCharactersPerParagraph}</avg_characters_per_paragraph>
                </Statistics>
                </Prime_Directive><purpose>
                    **1. First, count the total number of paragraphs in the provided text and state it clearly.**
                    **2. Analyze the ENTIRE provided text from beginning to end to understand its structure and flow.**
                    **3. Divide the content into an appropriate number of sub-chapters. Each sub-chapter's content should be approximately 20KB in size (around 6800 Korean characters). The number of chapters should be determined by this size constraint, not a fixed number.**
                    4. Each sub-chapter should represent a distinct sub-topic or section of the main text.
                    5. The sub-chapters MUST collectively cover the entire document's content. The start points of the sub-chapters should be distributed throughout the text.
                    6. Your output MUST be a valid JSON array of objects following the specified schema. Do not add any explanation or commentary outside the JSON markup.
                </purpose><Output_Specification><Format>JSON Array</Format><Schema>[ { "sub_chapter_title": "A descriptive title for the first sub-topic.", "start_paragraph": 1 }, { "sub_chapter_title": "Title for the second sub-topic.", "start_paragraph": ... } ]</Schema><interaction_language>Korean</interaction_language></Output_Specification><data content="formatted_content">--- START OF DATA ---${numberedContent}--- END OF DATA ---</data>`;

                return prompt.trim();
            },
            async handleSplitChapterSubmit(form) {
                const jsonContent = new FormData(form).get('jsonContent');
                if (!jsonContent) return;

                const sourceType = ModalManager.data.sourceToSplit || 'manuscript';
                const sourceLabel = sourceType === 'manuscript' ? '원문' : '번역문';

                state.isLoading = true;
                ModalManager.close();
                View.render();
                try {
                    const subChaptersData = JSON.parse(jsonContent.trim().match(/\[[\s\S]*\]/)?.[0] || '[]');
                    if (!Array.isArray(subChaptersData) || !subChaptersData.every(i => i.sub_chapter_title && i.start_paragraph)) throw new Error('Invalid JSON format.');

                    const sourceText = state.activeChapterContent[sourceType];
                    const paragraphs = sourceText.split(/\n{2,}/).map(p => p.trim()).filter(Boolean);

                    const projectId = state.activeProjectId;
                    const parentPath = state.activeChapterPath;
                    const parentNode = Utils.getNodeByPath(state.activeProject.toc, parentPath);
                    const initialChildCount = parentNode.children.length;
                    const creationPromises = [];
                    subChaptersData.sort((a, b) => a.start_paragraph - b.start_paragraph);

                    for (let i = 0; i < subChaptersData.length; i++) {
                        const start = subChaptersData[i].start_paragraph - 1;
                        const end = (i < subChaptersData.length - 1) ? subChaptersData[i + 1].start_paragraph - 1 : paragraphs.length;
                        const content = paragraphs.slice(start, end).join('\n\n');
                        // Create a new TOC node with its own contentId via helper
                        const newChildNode = Utils.createTocNode(subChaptersData[i].sub_chapter_title);
                        parentNode.children.push(newChildNode);
                        const newChildPath = `${parentPath}.${initialChildCount + i}`;

                        // Build the new content record based on the node's contentId
                        const newContent = {
                            id: `${projectId}_${newChildNode.contentId}`,
                            projectId: projectId,
                            nodeId: newChildNode.contentId,
                            manuscript: '',
                            translation: '',
                            notes: `Original content from '${parentNode.title}'.`,
                            imageDataUrl: null,
                            questions: [],
                            historyMetadata: { snapshotCount: 0, lastSnapshotAt: null },
                            status: 'manuscript-done'
                        };
                        // Place the split content into the correct field
                        newContent[sourceType] = content;

                        state.activeContentsMap.set(newContent.id, newContent);
                        creationPromises.push(DB.put(CONFIG.STORES.CONTENTS, newContent));
                    }

                    state.activeChapterContent[sourceType] = `[${sourceLabel}이(가) ${subChaptersData.length}개의 하위 노트로 분할되었습니다.]`;
                    creationPromises.push(DB.put(CONFIG.STORES.CONTENTS, state.activeChapterContent));

                    state.activeProject.updatedAt = new Date().toISOString();
                    creationPromises.push(DB.put(CONFIG.STORES.PROJECTS, state.activeProject));

                    await Promise.all(creationPromises);
                    this.showToast(`${sourceLabel} 분할 및 하위 챕터 생성이 완료되었습니다.`, 'success');
                } catch (error) {
                    console.error("Chapter split failed:", error);
                    this.showToast(`챕터 분할 실패: ${error.message}`, 'error');
                } finally {
                    state.isLoading = false;
                    View.render();
                }
            },
            navigateChapter(direction) {
                if (!state.activeProject || !state.activeChapterPath) return;
                const allNodes = Utils.getFlatToc(state.activeProject.toc);
                const currentIndex = allNodes.findIndex(node => node.path === state.activeChapterPath);
                if (currentIndex === -1) return;
                const nextIndex = currentIndex + direction;
                if (nextIndex >= 0 && nextIndex < allNodes.length) {
                    const nextChapterPath = allNodes[nextIndex].path;
                    this.selectChapter(nextChapterPath);
                }
            },
            toggleSidebar() {
                if (window.innerWidth <= 1024) {
                    setState({ isMobileSidebarOpen: !state.isMobileSidebarOpen });
                } else {
                    setState({ isSidebarOpen: !state.isSidebarOpen });
                }
            },
            closeSidebar() {
                if (state.isMobileSidebarOpen) {
                    setState({ isMobileSidebarOpen: false });
                }
            },

            /**
             * Centralized error handling helper. Use this function to log errors and show a user-facing message.
             * This encourages consistent error reporting across the app. You can call this from any catch block.
             * @param {Error} error - The error object caught from a try/catch.
             * @param {string} userMessage - A message to display to the user via toast.
             */
            handleError(error, userMessage) {
                if (error) {
                    console.error(error);
                }
                if (typeof userMessage === 'string' && userMessage.trim()) {
                    this.showToast(userMessage, 'error');
                }
            },
            handleTocDragStart(e) {
                const item = e.target.closest('.toc-drag-item');
                if (item) {
                    ModalManager.data.draggedPath = item.dataset.path;
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', item.dataset.path);
                }
            },
            handleTocDragOver(e) {
                e.preventDefault();
                const targetItem = e.target.closest('.toc-drag-item');
                document.querySelectorAll('.toc-drop-indicator-before, .toc-drop-indicator-after, .toc-drop-indicator-inside').forEach(el => el.classList.remove('toc-drop-indicator-before', 'toc-drop-indicator-after', 'toc-drop-indicator-inside'));
                if (targetItem) {
                    const rect = targetItem.getBoundingClientRect();
                    const dropZoneHeight = rect.height / 3;
                    if (e.clientY < rect.top + dropZoneHeight) {
                        targetItem.classList.add('toc-drop-indicator-before');
                        ModalManager.data.dropTarget = {
                            path: targetItem.dataset.path,
                            position: 'before'
                        };
                    } else if (e.clientY > rect.bottom - dropZoneHeight) {
                        targetItem.classList.add('toc-drop-indicator-after');
                        ModalManager.data.dropTarget = {
                            path: targetItem.dataset.path,
                            position: 'after'
                        };
                    } else {
                        targetItem.classList.add('toc-drop-indicator-inside');
                        ModalManager.data.dropTarget = {
                            path: targetItem.dataset.path,
                            position: 'inside'
                        };
                    }
                }
            },
            handleTocDragLeave(e) {
                document.querySelectorAll('.toc-drop-indicator-before, .toc-drop-indicator-after, .toc-drop-indicator-inside').forEach(el => el.classList.remove('toc-drop-indicator-before', 'toc-drop-indicator-after', 'toc-drop-indicator-inside'));
            },
            handleTocDrop(e) {
                e.preventDefault();
                document.querySelectorAll('.toc-drop-indicator-before, .toc-drop-indicator-after, .toc-drop-indicator-inside').forEach(el => el.classList.remove('toc-drop-indicator-before', 'toc-drop-indicator-after', 'toc-drop-indicator-inside'));
                const draggedPath = ModalManager.data.draggedPath;
                const dropTarget = ModalManager.data.dropTarget;
                if (!draggedPath || !dropTarget || dropTarget.path === draggedPath || dropTarget.path.startsWith(draggedPath + '.')) return;
                const toc = ModalManager.data.editableToc;
                const {
                    parent: draggedParent,
                    index: draggedIndex
                } = Utils.getParentNodeAndIndexByPath(toc, draggedPath);
                if (!draggedParent) return;
                const [draggedNode] = draggedParent.children.splice(draggedIndex, 1);
                if (!draggedNode) {
                    console.error("Drag-and-drop failed: Could not retrieve the node to be moved.");
                    this.showToast('목차 이동에 실패했습니다. 페이지를 새로고침 후 다시 시도해주세요.', 'error');
                    ModalManager.render(); // 이동 실패 시 목차를 원상 복구하기 위해 다시 렌더링
                    return; 
                }
                if (dropTarget.position === 'inside') {
                    const newParentNode = Utils.getNodeByPath(toc, dropTarget.path);
                    if (newParentNode) {
                        if (!newParentNode.children) newParentNode.children = [];
                        newParentNode.children.push(draggedNode);
                    }
                } else {
                    const {
                        parent: targetParent,
                        index: targetIndex
                    } = Utils.getParentNodeAndIndexByPath(toc, dropTarget.path);
                    if (!targetParent) return;
                    const insertIndex = dropTarget.position === 'before' ? targetIndex : targetIndex + 1;
                    targetParent.children.splice(insertIndex, 0, draggedNode);
                }
                ModalManager.data.draggedPath = null;
                ModalManager.data.dropTarget = null;
                ModalManager.render();
            },
            handleTagInput(input) {
                const value = input.value.toLowerCase();
                const suggestionsContainer = document.getElementById('tag-suggestions');
                if (!value) {
                    suggestionsContainer.classList.add('hidden');
                    return;
                }
                const existingTags = ModalManager.data.projectTags || [];
                const availableTags = state.tags.map(t => t.name).filter(t => !existingTags.includes(t));
                const filtered = availableTags.filter(tag => tag.toLowerCase().includes(value));
                if (filtered.length > 0) {
                    suggestionsContainer.innerHTML = filtered.map(tag => `<div class="p-2 hover:bg-slate-100 cursor-pointer" data-action="select-tag-suggestion" data-tag="${tag}">${tag}</div>`).join('');
                    suggestionsContainer.classList.remove('hidden');
                } else {
                    suggestionsContainer.classList.add('hidden');
                }
            },
            handleTagInputKeydown(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const tag = e.target.value.trim();
                    if (tag) {
                        Controller.addTagToProject(tag);
                        e.target.value = '';
                        document.getElementById('tag-suggestions').classList.add('hidden');
                    }
                }
            },
            addTagToProject(tag) {
                if (!ModalManager.data.projectTags) {
                    ModalManager.data.projectTags = [];
                }
                if (!ModalManager.data.projectTags.includes(tag)) {
                    ModalManager.data.projectTags.push(tag);
                    ModalManager.render();
                }
            },
            saveScrollPosition() {
                if (!state.activeChapterPath) return;
                const keyPrefix = `${state.activeProjectId}_${state.activeChapterPath}`;

                // [수정] 현재 활성화된 메인 패널의 스크롤 위치도 저장합니다.
                const mainContentPanel = document.getElementById('workspace-main-content');
                if (mainContentPanel) {
                    state.scrollPositions[`${keyPrefix}_${state.workspaceMode}`] = mainContentPanel.scrollTop;
                }

                // 기존의 텍스트 영역 스크롤 위치 저장은 유지합니다.
                const elementsToSave = ['manuscript', 'notes', 'translation'];
                elementsToSave.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        state.scrollPositions[`${keyPrefix}_${id}`] = el.scrollTop;
                    }
                });
            },
            // ▼▼▼ [추가] 1단계: 이미지 파일 처리 로직을 공통 함수로 분리 ▼▼▼
            async processImageFile(file) {
                if (!file || !file.type.startsWith('image/')) {
                    this.showToast('이미지 파일만 업로드할 수 있습니다.', 'error');
                    return;
                }

                const reader = new FileReader();

                reader.onload = async (e) => {
                    const imageDataUrl = e.target.result;
                    state.activeChapterContent.imageDataUrl = imageDataUrl;
                    await DB.put(CONFIG.STORES.CONTENTS, state.activeChapterContent);
                    this.showToast('이미지가 성공적으로 저장되었습니다.', 'success');
                    View.render();
                };

                reader.onerror = () => {
                    this.showToast('파일을 읽는 데 실패했습니다.', 'error');
                };

                reader.readAsDataURL(file);
            },


            ACTION_HANDLERS: {
                'toggle-sidebar': () => Controller.toggleSidebar(),
                'close-sidebar': () => Controller.closeSidebar(),
                'go-dashboard': () => {
                    window.location.hash = '#/';
                },
                'delete-image': async () => {
                    // 현재 챕터에 이미지 데이터가 있는지 확인합니다.
                    if (state.activeChapterContent?.imageDataUrl) {
                        // 1. 상태 객체에서 이미지 데이터를 null로 변경합니다.
                        state.activeChapterContent.imageDataUrl = null;

                        // 2. 변경된 내용을 데이터베이스에 비동기적으로 저장합니다.
                        await DB.put(CONFIG.STORES.CONTENTS, state.activeChapterContent);

                        // 3. 사용자에게 성공 메시지를 보여줍니다.
                        Controller.showToast('이미지가 삭제되었습니다.', 'success');

                        // 4. 화면을 다시 그려서 이미지 미리보기를 없애고 업로드 UI를 보여줍니다.
                        View.render();
                    }
                },
                'prev-chapter': () => Controller.navigateChapter(-1),
                'next-chapter': () => Controller.navigateChapter(1),
                'filter': (el) => Controller.handleNavFilter(el),
                'new-category': async () => {
                    // Request a new category name via a custom modal prompt rather than using the native browser prompt.
                    const name = await ModalManager.showInputPrompt({
                        title: '새 카테고리 추가',
                        message: '추가할 카테고리의 이름을 입력하세요.',
                        placeholder: '카테고리 이름',
                        confirmText: '추가'
                    });
                    if (name) {
                        const newCategory = {
                            id: Utils.generateId('cat'),
                            name
                        };
                        await DB.put(CONFIG.STORES.CATEGORIES, newCategory);
                        state.categories.push(newCategory);
                        state.categories.sort((a, b) => a.name.localeCompare(b.name));
                        View.render();
                    }
                },
                'footnote-jump': (el, e) => {
                    e.preventDefault();
                    const key = el.dataset.footnoteKey;
                    if (!key) return;

                    const targetElement = document.getElementById(`fn:${key}`);

                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        targetElement.style.transition = 'background-color 0.5s ease';
                        targetElement.style.backgroundColor = 'var(--bg-hover)';
                        setTimeout(() => {
                            targetElement.style.backgroundColor = '';
                        }, 1500);
                    }
                },
                'search-toc': (el) => { // 1번
                    state.tocSearchQuery = el.value;
                    View.render();
                },
                'toggle-reader-mode': () => { // 4번
                    state.isReaderMode = !state.isReaderMode;
                    View.render();
                },
                'toggle-theme': () => { // 9번
                    state.theme = state.theme === 'light' ? 'dark' : 'light';
                    localStorage.setItem('appTheme', state.theme);
                    document.documentElement.classList.toggle('dark', state.theme === 'dark');
                    View.render(); // 버튼 아이콘을 업데이트하기 위해 렌더링
                },
                'handle-image-upload': (input) => {
                    const file = input.files[0];
                    if (file) {
                        Controller.processImageFile(file);
                    }
                },
                // Controller.ACTION_HANDLERS 객체 내부
                 // [수정] 이름 변경 로직을 분리하고, 다중/범위 선택 기능을 강화합니다.
                'toc-editor-click': (el, e) => {
                    const path = el.dataset.path;
                    const { shiftKey, ctrlKey, metaKey } = e;
                    const tocData = ModalManager.data;
                    const flatToc = Utils.getFlatToc(tocData.editableToc);

                    // 이름 변경을 위한 더블클릭 감지
                    if (e.detail === 2) { // e.detail은 클릭 횟수를 나타냅니다.
                        Controller.ACTION_HANDLERS['toc-context-rename'](el);
                        return;
                    }
                    
                    // Shift 키를 이용한 범위 선택
                    if (shiftKey && tocData.lastSelectedTocPath) {
                        const lastIdx = flatToc.findIndex(item => item.path === tocData.lastSelectedTocPath);
                        const currentIdx = flatToc.findIndex(item => item.path === path);
                        if (lastIdx !== -1 && currentIdx !== -1) {
                            const start = Math.min(lastIdx, currentIdx);
                            const end = Math.max(lastIdx, currentIdx);
                            if (!ctrlKey && !metaKey) tocData.selectedTocPaths.clear();
                            for (let i = start; i <= end; i++) {
                                tocData.selectedTocPaths.add(flatToc[i].path);
                            }
                        }
                    // Ctrl/Cmd 키를 이용한 다중 선택
                    } else if (ctrlKey || metaKey) {
                        tocData.selectedTocPaths.has(path) ? tocData.selectedTocPaths.delete(path) : tocData.selectedTocPaths.add(path);
                    // 일반 단일 선택
                    } else {
                        tocData.selectedTocPaths.clear();
                        tocData.selectedTocPaths.add(path);
                    }
                    
                    tocData.lastSelectedTocPath = path;
                    ModalManager.render();
                },

                // [신규] 이름 변경 핸들러: input 필드를 편집 가능하게 만듭니다.
                'toc-context-rename': (el) => {
                    const path = el.dataset.path || ModalManager.data.selectedTocPaths.values().next().value;
                    if (!path) return;
                    
                    const input = document.querySelector(`.modal-container input[data-path="${path}"]`);
                    if (input) {
                        input.readOnly = false;
                        input.focus();
                        input.select();
                        
                        const handleRenameEnd = () => {
                            input.readOnly = true;
                            const node = Utils.getNodeByPath(ModalManager.data.editableToc, path);
                            if(node) node.title = input.value;
                            input.removeEventListener('blur', handleRenameEnd);
                            input.removeEventListener('keydown', handleKeydown);
                            ModalManager.render();
                        };
                        const handleKeydown = (e) => {
                            if (e.key === 'Enter') handleRenameEnd();
                            if (e.key === 'Escape') {
                                input.value = Utils.getNodeByPath(ModalManager.data.editableToc, path).title;
                                handleRenameEnd();
                            }
                        };
                        input.addEventListener('blur', handleRenameEnd);
                        input.addEventListener('keydown', handleKeydown);
                    }
                },

                // 전역 검색 결과 클릭 시 해당 프로젝트와 챕터로 이동합니다.
                'open-global-search-result': (el, event) => {
                    if (event) event.preventDefault();
                    const projectId = el.dataset.projectId;
                    const path = el.dataset.path;
                    if (!projectId || !path) return;
                    // 해시 변경을 통해 URL 네비게이션을 트리거합니다.
                    window.location.hash = `#/projects/${projectId}/chapters/${path}`;
                    // 검색 결과 클릭 후 전역 검색 상태를 초기화하여 스무스한 전환을 돕습니다.
                    state.globalSearchQuery = '';
                    state.globalSearchResults = null;
                    state.globalSearchVisibleCount = 30;
                },

                // 전역 검색 결과를 추가로 더 보여주는 버튼의 핸들러입니다.
                'global-search-show-more': () => {
                    // 30개씩 추가로 로드합니다.
                    const increment = 30;
                    const current = state.globalSearchVisibleCount || 30;
                    state.globalSearchVisibleCount = current + increment;
                    View.render();
                },

                // 전역 검색 결과 페이지에서 이전 뷰로 돌아갑니다.
                'exit-global-search': () => {
                    // 검색 상태를 초기화하고 이전 뷰로 전환합니다.
                    state.globalSearchQuery = '';
                    state.globalSearchResults = null;
                    state.globalSearchVisibleCount = 30;
                    // 돌아갈 뷰가 없으면 기본적으로 대시보드로 갑니다.
                    state.currentView = state.previousView || CONFIG.VIEW_NAMES.DASHBOARD;
                    View.render();
                },

                // 검색 버튼 클릭 시 전역 검색을 수행합니다.
                'global-search-submit': (el) => {
                    const input = document.getElementById('global-search-input');
                    if (input) {
                        Controller.handleGlobalSearch(input.value);
                    }
                },
                'delete-highlight': async (el) => {
                    const targetId = el.dataset.targetId;
                    const markToDelete = document.querySelector(`mark[data-temp-id="${targetId}"]`);

                    if (!markToDelete) return;

                    const sourcePanel = markToDelete.closest('[data-source]');
                    if (!sourcePanel) return;

                    const dataSourceKey = sourcePanel.dataset.source;

                    // <mark> 태그를 제거(unwrap)합니다.
                    const parent = markToDelete.parentNode;
                    while (markToDelete.firstChild) {
                        parent.insertBefore(markToDelete.firstChild, markToDelete);
                    }
                    parent.removeChild(markToDelete);
                    parent.normalize();

                    // 변경사항을 저장합니다.
                    const updatedHtml = sourcePanel.innerHTML;
                    const newMarkdown = Controller.turndownService.turndown(updatedHtml);
                    state.activeChapterContent[dataSourceKey] = newMarkdown;
                    await DB.put(CONFIG.STORES.CONTENTS, state.activeChapterContent);
                    
                    Controller.hideHighlightDeleteButton(); // 삭제 버튼 숨기기
                    Controller.showToast('하이라이트가 삭제되었습니다.', 'info');
                    
                    // 화면을 다시 렌더링하여 변경사항을 완전히 반영합니다.
                    View.render();
                },
                // [신규] 다중 삭제 핸들러: 선택된 모든 항목을 한 번에 삭제합니다.
                'toc-context-delete': () => {
                    const selectedPaths = ModalManager.data.selectedTocPaths;
                    if (selectedPaths.size === 0) return;

                    ModalManager.open('confirm', {
                        title: `${selectedPaths.size}개 항목 삭제`,
                        message: `선택한 ${selectedPaths.size}개의 항목과 모든 하위 항목을 영구적으로 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.`,
                        confirmText: '삭제',
                        onConfirm: () => {
                            const toc = ModalManager.data.editableToc;
                            // 깊은 순서대로 정렬하여 하위 노드부터 안전하게 삭제
                            const sortedPaths = [...selectedPaths].sort((a, b) => b.length - a.length);

                            sortedPaths.forEach(path => {
                                const { parent, index } = Utils.getParentNodeAndIndexByPath(toc, path);
                                if (parent && parent.children && parent.children[index]) {
                                    // 다른 선택 항목의 하위 항목이 아닌 경우에만 삭제
                                    const isSubpath = sortedPaths.some(p => path.startsWith(p + '.') && p !== path);
                                    if (!isSubpath) {
                                        parent.children.splice(index, 1);
                                    }
                                }
                            });
                            selectedPaths.clear();
                            ModalManager.render();
                        }
                    });
                },
                'new-project': () => ModalManager.open('newProject', {
                    activeTab: 'blank'
                }),
                'open-project': (el) => {
                    window.location.hash = `#/projects/${el.dataset.id}`;
                },
                'delete-project-confirm': (el) => {
    const project = state.projects.find(p => p.id === el.dataset.id);
    if (!project) return;
    ModalManager.open('confirm', {
        title: '프로젝트 삭제 확인',
        message: `'${project.name}' 프로젝트와 모든 관련 데이터를 영구적으로 삭제하시겠습니까?`,
        confirmText: '삭제',
        onConfirm: async () => {
            await DB.deleteProjectAndContents(project.id);
            state.projects = state.projects.filter(p => p.id !== project.id);
            Controller.updateTags();
            Controller.buildSearchIndex();
            Controller.showToast('프로젝트가 삭제되었습니다.', 'success');
            
            // ▼▼▼ 수정된 부분 ▼▼▼
            // 조건 없이 항상 View.render()를 호출하여 현재 뷰를 새로고침합니다.
            View.render();
            // ▲▲▲ 수정된 부분 ▲▲▲
        }
    });
},
                'close-modal': () => ModalManager.close(),
                'close-modal-overlay': (el, e) => {
                    if (e.target === el) ModalManager.close();
                },
                'confirm-action': () => {
                    const onConfirm = ModalManager.data.onConfirm;
                    if (typeof onConfirm === 'function') onConfirm();
                    ModalManager.close();
                },
                'switch-mode': (el) => {
                    Controller.saveScrollPosition();
                    state.workspaceMode = el.dataset.mode;
                    View.render();
                },
                // ▼▼▼ [신규 핸들러 1] "초기화" 입력 감지 ▼▼▼
                'handle-reset-confirmation-input': (el) => {
                    const resetButton = document.getElementById('reset-settings-btn');
                    if (resetButton) {
                        // 입력값이 "초기화"와 정확히 일치할 때만 버튼 활성화
                        resetButton.disabled = el.value !== '초기화';
                    }
                },

                // ▼▼▼ [신규 핸들러 2] 초기화 실행 (이중 확인) ▼▼▼
                'confirm-reset-settings': () => {
                    ModalManager.open('confirm', {
                        title: '최종 확인',
                        message: '정말로 현재 프로젝트의 모든 설정을 기본값으로 되돌리시겠습니까? 저장된 프롬프트와 메뉴 등이 모두 사라집니다.',
                        confirmText: '네, 초기화합니다',
                        onConfirm: async () => {
                            try {
                                const project = state.activeProject;
                                if (!project) throw new Error('활성 프로젝트가 없습니다.');

                                // ================== ▼▼▼ [로직 수정 시작] ▼▼▼ ==================
                                // 중앙 설정 객체를 깊은 복사하여 프로젝트 설정을 덮어씁니다.
                                project.settings = JSON.parse(JSON.stringify(CONFIG.DEFAULT_PROJECT_SETTINGS));
                                project.updatedAt = new Date().toISOString();
                                // ================== ▲▲▲ [로직 수정 완료] ▲▲▲ ==================

                                const projectInList = state.projects.find(p => p.id === project.id);
                                if (projectInList) {
                                    projectInList.settings = project.settings;
                                    projectInList.updatedAt = project.updatedAt;
                                }

                                await DB.put(CONFIG.STORES.PROJECTS, project);
                                
                                ModalManager.close();
                                Controller.showToast('프로젝트 설정이 기본값으로 초기화되었습니다.', 'success');

                                Controller.ACTION_HANDLERS['open-settings']();

                            } catch (error) {
                                console.error("설정 초기화 실패:", error);
                                Controller.showToast(`오류 발생: ${error.message}`, 'error');
                            }
                        }
                    });
                },
                'select-chapter': (el) => {
                    const projectId = state.activeProjectId;
                    const chapterPath = el.dataset.path;
                    window.location.hash = `#/projects/${projectId}/chapters/${chapterPath}`;
                },
                'toggle-toc-collapse': (el) => {
                    const path = el.dataset.path;
                    state.tocCollapseState[path] = !state.tocCollapseState[path];
                    View.render();
                },
                'submit-new-project': (form) => Controller.submitNewProject(form),
                'switch-modal-tab': (el) => {
                    ModalManager.data.activeTab = el.dataset.tab;
                    ModalManager.render();
                },
                'open-settings': () => {
                    if (!state.activeProject) {
                        Controller.showToast('활성화된 프로젝트가 없어 설정을 열 수 없습니다.', 'error');
                        return;
                    }
                    const s = JSON.parse(JSON.stringify(state.activeProject.settings || {}));
                    ModalManager.open('settings', {
                        activeTab: 'general',
                        name: state.activeProject.name,
                        categoryId: state.activeProject.categoryId,
                        projectTags: [...(state.activeProject.tags || [])],
                        ...CONFIG.DEFAULT_PROJECT_SETTINGS,
                        ...s,
                        customPrompts: s.customPrompts || CONFIG.DEFAULT_PROJECT_SETTINGS.customPrompts,
                        contextMenuItems: s.contextMenuItems || CONFIG.DEFAULT_PROJECT_SETTINGS.contextMenuItems,
                    });
                },
                'switch-settings-tab': (el) => {
                    ModalManager.data.activeTab = el.dataset.tab;
                    ModalManager.render();
                },
                'manage-history': () => {
                    if (!state.activeChapterContent) {
                        return Controller.showToast('이력을 관리할 챕터를 먼저 선택하세요.', 'error');
                    }
                    ModalManager.open('manageHistory', {
                        history: state.activeChapterContent.history || [],
                        activeContent: state.activeChapterContent
                    });
                },
                'revert-history': async (el) => {
                    const index = parseInt(el.dataset.index, 10);
                    const content = state.activeChapterContent;
                    if (!content || !content.history || !content.history[index]) return;

                    ModalManager.open('confirm', {
                        title: '버전 되돌리기',
                        message: `선택한 버전으로 챕터 내용을 되돌리시겠습니까? 현재 내용은 이력으로 저장됩니다.`,
                        confirmText: '되돌리기',
                        onConfirm: async () => {
                            // 현재 상태를 히스토리로 추가
                            Controller.saveChapterHistory(content);

                            // 선택한 이력 내용으로 현재 콘텐츠를 덮어쓰기
                            const revertedContent = content.history[index].content;
                            Object.assign(content, revertedContent);
                            content.updatedAt = new Date().toISOString(); // 업데이트 시간 갱신

                            // DB에 저장
                            await DB.put(CONFIG.STORES.CONTENTS, content);
                            state.activeContentsMap.set(content.id, content);

                            // UI 갱신
                            ModalManager.close();
                            Controller.showToast('성공적으로 챕터 내용을 되돌렸습니다.', 'success');
                            View.render();
                        }
                    });
                },
                // ▼▼▼ [추가] 이력 비교 기능 핸들러 (UI 없이 콘솔에 출력) ▼▼▼
                'compare-history': (el) => {
                    const index = parseInt(el.dataset.index, 10);
                    const history = state.activeChapterContent.history || [];
                    if (index < 0 || index >= history.length) return;

                    const currentContent = history[0].content; // 현재 버전은 항상 첫 번째
                    const prevContent = history[index].content;

                    const diff = {
                        manuscript: `[--- 이전 ---]\n${prevContent.manuscript}\n\n[--- 현재 ---]\n${currentContent.manuscript}`,
                        notes: `[--- 이전 ---]\n${prevContent.notes}\n\n[--- 현재 ---]\n${currentContent.notes}`,
                        translation: `[--- 이전 ---]\n${prevContent.translation}\n\n[--- 현재 ---]\n${currentContent.translation}`
                    };

                    console.log("--- 챕터 이력 비교 (Diff) ---");
                    console.log("원고 변경 이력:", diff.manuscript);
                    console.log("메모 변경 이력:", diff.notes);
                    console.log("번역문 변경 이력:", diff.translation);

                    Controller.showToast('변경 이력이 콘솔에 출력되었습니다.', 'info');
                },
                'open-prompt-variables': (el) => {
                    const type = el.dataset.type;
                    let title = '';
                    let variables = [];

                    if (type === 'writing') {
                        title = '글쓰기 템플릿 변수';
                        variables = [
                            { name: 'bookTitle', desc: '프로젝트의 전체 제목입니다.' },
                            { name: 'chapterTitle', desc: '현재 작업 중인 챕터(노트)의 제목입니다.' },
                            { name: 'manuscript', desc: '현재 챕터의 "원고" 텍스트 전체입니다.' },
                            { name: 'notes', desc: '현재 챕터의 "메모" 텍스트 전체입니다.' },
                            { name: 'fullToc', desc: '프로젝트의 전체 목차 구조 텍스트입니다.' },
                            { name: 'projectGenre', desc: '프로젝트 설정에 입력된 장르입니다.' },
                            { name: 'projectAudience', desc: '프로젝트 설정에 입력된 목표 독자입니다.' },
                            { name: 'projectStyleExample', desc: '프로젝트 설정에 입력된 스타일 예시입니다.' },
                        ];
                    } else if (type === 'quiz') {
                        title = '퀴즈 템플릿 변수';
                        variables = [
                            { name: 'text', desc: '퀴즈 문제를 출제할 기반이 되는 현재 챕터의 "원고" 텍스트입니다.' },
                            { name: 'questionCount', desc: '프로젝트 설정에 입력된 퀴즈 생성 개수입니다.' },
                            { name: 'taskDescription', desc: '퀴즈 프롬프트 설정의 "과업 설명" 텍스트입니다.' },
                            { name: 'outputFormatInstruction', desc: '퀴즈 프롬프트 설정의 "출력 형식" 텍스트입니다.' },
                        ];
                    }

                    ModalManager.open('promptVariables', { title, variables });
                },

                'sort-projects': (select) => {
                    state.currentSortOrder = select.value;
                    View.render();
                },
                'retry-question': () => {
                    if (state.quizState) {
                        // 현재 문제의 답변 상태를 '답변 안 함'(undefined)으로 되돌립니다.
                        state.quizState.answers[state.quizState.currentIndex] = undefined;
                        View.render(); // UI를 다시 렌더링하여 문제를 다시 풀 수 있게 합니다.
                    }
                },
                'save-settings': async (form) => {
                    const data = ModalManager.data;
                    const name = data.name || state.activeProject.name;
                    const categoryId = data.categoryId;
                    const projectTags = data.projectTags || [];

                    const settingsToSave = {};
                    form.querySelectorAll('[data-setting-key]').forEach(input => {
                        const key = input.dataset.settingKey;
                        settingsToSave[key] = input.type === 'number' ? Number(input.value) : input.value;
                    });

                    // 1. 현재 활성화된 프로젝트 객체의 정보를 업데이트합니다.
                    Object.assign(state.activeProject.settings, settingsToSave);
                    state.activeProject.name = name;
                    state.activeProject.toc.title = name;
                    state.activeProject.categoryId = categoryId;
                    state.activeProject.tags = projectTags;
                    state.activeProject.settings.customPrompts = (data.customPrompts || []).filter(p => p.name && p.template);
                    state.activeProject.settings.contextMenuItems = (data.contextMenuItems || []).filter(p => p.name && p.template);
                    state.activeProject.updatedAt = new Date().toISOString();

                    // ▼▼▼ [핵심 수정] 아래 코드를 추가하여 전체 프로젝트 목록도 함께 업데이트합니다. ▼▼▼
                    const projectInList = state.projects.find(p => p.id === state.activeProject.id);
                    if (projectInList) {
                        projectInList.name = state.activeProject.name;
                        projectInList.categoryId = state.activeProject.categoryId;
                        projectInList.tags = state.activeProject.tags;
                        projectInList.updatedAt = state.activeProject.updatedAt;
                        projectInList.settings = state.activeProject.settings;
                    }
                    // ▲▲▲ [수정 완료] ▲▲▲

                    // 2. 데이터베이스에 변경된 프로젝트 정보를 저장합니다.
                    await DB.put(CONFIG.STORES.PROJECTS, state.activeProject);

                    // 3. 태그 목록과 검색 인덱스를 갱신합니다.
                    Controller.updateTags();
                    Controller.buildSearchIndex(); // 변경된 이름으로 검색이 가능하도록 인덱스를 다시 만듭니다.
                    Controller.showToast('설정이 성공적으로 저장되었습니다.', 'success');

                    // 4. 모달을 닫고 화면을 새로고침합니다.
                    ModalManager.close();
                    View.render();
                },
                'add-custom-prompt': () => {
                    const nameInput = document.getElementById('new-prompt-name');
                    const templateInput = document.getElementById('new-prompt-template');
                    const name = nameInput.value.trim();
                    const template = templateInput.value.trim();
                    if (!name || !template) return Controller.showToast('이름과 템플릿을 모두 입력해야 합니다.', 'error');
                    if (!ModalManager.data.customPrompts) ModalManager.data.customPrompts = [];
                    ModalManager.data.customPrompts.push({
                        id: Utils.generateId('cp'),
                        name,
                        template
                    });
                    nameInput.value = '';
                    templateInput.value = '';
                    ModalManager.render();
                },
                'handle-image-upload': (input) => {
                    const file = input.files[0];
                    if (!file || !file.type.startsWith('image/')) {
                        Controller.showToast('이미지 파일을 선택해주세요.', 'error');
                        return;
                    }

                    const reader = new FileReader();

                    // 파일 읽기가 성공했을 때 실행될 로직
                    reader.onload = async (e) => {
                        const imageDataUrl = e.target.result; // 이미지를 Base64 데이터 URL로 변환

                        // 현재 챕터의 콘텐츠 객체에 이미지 데이터를 저장
                        state.activeChapterContent.imageDataUrl = imageDataUrl;

                        // 변경된 내용을 데이터베이스에 저장
                        await DB.put(CONFIG.STORES.CONTENTS, state.activeChapterContent);

                        Controller.showToast('이미지가 성공적으로 저장되었습니다.', 'success');

                        // 화면을 다시 그려서 업로드된 이미지를 표시
                        View.render();
                    };

                    // 파일 읽기에 실패했을 때
                    reader.onerror = () => {
                        Controller.showToast('파일을 읽는 데 실패했습니다.', 'error');
                    };

                    // 파일 읽기 시작
                    reader.readAsDataURL(file);
                },
                'export-project': (el) => {
                    // 버튼의 data-id 속성 또는 현재 활성화된 프로젝트의 ID를 가져옵니다.
                    const projectId = el.dataset.id || state.activeProjectId;
                    if (projectId) {
                        // 기존에 존재하던 내보내기 함수를 호출합니다.
                        Controller.exportProject(projectId);
                    } else {
                        Controller.showToast('내보낼 프로젝트를 식별할 수 없습니다.', 'error');
                    }
                },
                'remove-custom-prompt': (el) => {
                    const idToRemove = el.dataset.id;
                    ModalManager.data.customPrompts = ModalManager.data.customPrompts.filter(p => p.id !== idToRemove);
                    ModalManager.render();
                },
                'add-custom-context-menu': () => {
                    const nameInput = document.getElementById('new-contextMenu-name');
                    const templateInput = document.getElementById('new-contextMenu-template');
                    const name = nameInput.value.trim();
                    const template = templateInput.value.trim();
                    if (!name || !template) return Controller.showToast('이름과 템플릿을 모두 입력해야 합니다.', 'error');
                    if (!ModalManager.data.contextMenuItems) ModalManager.data.contextMenuItems = [];
                    ModalManager.data.contextMenuItems.push({
                        id: Utils.generateId('cmi'),
                        name,
                        template
                    });
                    nameInput.value = '';
                    templateInput.value = '';
                    ModalManager.render();
                },
                'remove-custom-context-menu': (el) => {
                    const idToRemove = el.dataset.id;
                    ModalManager.data.contextMenuItems = ModalManager.data.contextMenuItems.filter(p => p.id !== idToRemove);
                    ModalManager.render();
                },
                 // ▼▼▼ [수정] 'copy-custom-prompt' 핸들러를 새 헬퍼 함수를 호출하도록 변경합니다. ▼▼▼
                'copy-custom-prompt': (el) => {
                    const index = parseInt(el.dataset.index, 10);
                    const actionGroups = Controller.getCombinedActions();
                    const flatActions = actionGroups.flatMap(group => group.actions);
                    const actionToRun = flatActions[index];
                    if (actionToRun) {
                        Controller.processAndCopyPrompt(actionToRun.template, `실행: ${actionToRun.name}`);
                    }
                },
                'context-highlight': async () => {
                    const selection = window.getSelection();
                    if (!selection.rangeCount || selection.isCollapsed) return;

                    const userRange = selection.getRangeAt(0);
                    const sourcePanel = userRange.commonAncestorContainer.nodeType === Node.ELEMENT_NODE
                        ? userRange.commonAncestorContainer.closest('[data-source]')
                        : userRange.commonAncestorContainer.parentElement.closest('[data-source]');

                    if (!sourcePanel) {
                        Controller.showToast('하이라이트는 원문 또는 번역문 영역에서만 가능합니다.', 'error');
                        return;
                    }
                    const dataSourceKey = sourcePanel.dataset.source;

                    // 1. 병합될 최종 범위를 담을 새 Range 객체를 생성하고, 사용자의 선택으로 초기화합니다.
                    const mergedRange = userRange.cloneRange();
                    const marksToRemove = [];

                    // 2. 현재 패널 내의 모든 기존 <mark> 태그를 찾습니다.
                    const existingMarks = sourcePanel.querySelectorAll('mark');
                    existingMarks.forEach(mark => {
                        // 3. 사용자의 선택 영역과 기존 하이라이트가 겹치는지 확인합니다.
                        if (userRange.intersectsNode(mark)) {
                            // 4. 겹치는 경우, 병합될 범위(mergedRange)를 확장합니다.
                            const markRange = document.createRange();
                            markRange.selectNode(mark);
                            
                            if (markRange.compareBoundaryPoints(Range.START_TO_START, mergedRange) < 0) {
                                mergedRange.setStartBefore(mark);
                            }
                            if (markRange.compareBoundaryPoints(Range.END_TO_END, mergedRange) > 0) {
                                mergedRange.setEndAfter(mark);
                            }
                            // 5. 나중에 제거하기 위해 겹치는 마크를 목록에 추가합니다.
                            marksToRemove.push(mark);
                        }
                    });

                    // 6. 겹쳤던 기존 하이라이트들을 먼저 제거(unwrap)합니다.
                    marksToRemove.forEach(mark => {
                        const parent = mark.parentNode;
                        while (mark.firstChild) {
                            parent.insertBefore(mark.firstChild, mark);
                        }
                        parent.removeChild(mark);
                        parent.normalize(); // 인접한 텍스트 노드를 합쳐줍니다.
                    });
                    
                    // 7. 최종적으로 병합된 범위에 새로운 <mark> 태그를 적용합니다.
                    const newMark = document.createElement('mark');
                    try {
                        mergedRange.surroundContents(newMark);
                    } catch (e) {
                        // 범위가 복잡한 DOM 구조를 가질 경우 대체 방식 사용
                        newMark.appendChild(mergedRange.extractContents());
                        mergedRange.insertNode(newMark);
                    }

                    // 8. 변경된 내용을 저장합니다.
                    const updatedHtml = sourcePanel.innerHTML;
                    const newMarkdown = Controller.turndownService.turndown(updatedHtml);
                    state.activeChapterContent[dataSourceKey] = newMarkdown;
                    await DB.put(CONFIG.STORES.CONTENTS, state.activeChapterContent);

                    Controller.showToast('하이라이트가 적용되었습니다.', 'success');
                    selection.removeAllRanges();
                    // 메뉴 닫기 및 렌더링은 상위 핸들러에서 처리합니다.
                },

                // learning.html: 5937번째 줄 근처
                // 기존 'context-add-footnote' 함수를 아래 코드로 전체 교체합니다.

                'context-add-footnote': () => {
                    // 선택된 텍스트가 있는지 확인 후, 각주 추가 전용 모달을 엽니다.
                    if (!state.contextMenu.selectedText) return;
                    ModalManager.open('addFootnote');
                },
                'submit-add-footnote': async (form) => {
                    const formData = new FormData(form);
                    const footnoteKey = formData.get('footnote-key-input').trim();
                    const footnoteContent = formData.get('footnote-content-input').trim();

                    if (!footnoteContent) {
                        Controller.showToast('각주 내용을 입력해주세요.', 'error');
                        return;
                    }
                    
                    const { selectedText } = state.contextMenu;
                    let { manuscript } = state.activeChapterContent;
                    if (!selectedText || !manuscript) return;

                    let finalKey;
                    if (!footnoteKey) {
                        finalKey = Controller.getNextFootnoteNumber(manuscript);
                    } else {
                        finalKey = footnoteKey.replace(/\s/g, '_');
                    }

                    // 1. 선택 텍스트 뒤에 참조 추가
                    const newTextWithRef = `${selectedText}[^${finalKey}]`;
                    manuscript = manuscript.replace(selectedText, newTextWithRef);

                    // 2. 문서 맨 끝에 '사용자가 입력한 내용'으로 각주 정의 추가
                    const footnoteDefinition = `\n\n[^${finalKey}]: ${footnoteContent}`;
                    manuscript += footnoteDefinition;
                    
                    // 상태 업데이트 및 저장
                    state.activeChapterContent.manuscript = manuscript;
                    await DB.put(CONFIG.STORES.CONTENTS, state.activeChapterContent);
                    Controller.showToast('각주가 성공적으로 추가되었습니다.', 'success');
                    
                    // 모달 닫고 UI 갱신
                    ModalManager.close();
                    View.render();
                },
                'execute-context-menu': (el) => {
                    const index = parseInt(el.dataset.index, 10);
                    const allContextMenuItems = state.activeProject?.settings?.contextMenuItems || [];
                    const menuItem = allContextMenuItems[index];

                    console.log(`[Debug] Context menu item clicked: "${menuItem?.name || 'Unknown'}"`);

                    if (!menuItem) {
                        console.error('[Debug] 메뉴 아이템을 찾을 수 없습니다. Index:', index);
                        return;
                    }

                    if (menuItem.action && typeof Controller.ACTION_HANDLERS[menuItem.action] === 'function') {
                        Controller.ACTION_HANDLERS[menuItem.action]();
                    } else if (menuItem.template) {
                        // 프롬프트 복사 시점에도 window에서 직접 선택 영역 텍스트를 가져옵니다.
                        const selectedText = window.getSelection().toString().trim();
                        state.contextMenu.selectedText = selectedText;
                        Controller.processAndCopyPrompt(menuItem.template, `실행: ${menuItem.name}`);
                    } else {
                        Controller.showToast('이 메뉴 항목을 실행할 수 없습니다.', 'error');
                    }

                    // [중요] 어떤 액션이 실행되든, 마지막에 항상 메뉴를 닫고 UI를 갱신합니다.
                    console.log('[Debug] 액션 실행 완료. 컨텍스트 메뉴를 닫습니다.');
                    state.contextMenu.isOpen = false;
                    View.render();
                },
                'submit-prompt-variables': (form) => {
                    const { template, systemValues } = ModalManager.data;
                    const formData = new FormData(form);
                    const userValues = Object.fromEntries(formData.entries());

                    let finalPrompt = template;

                    // 1. 시스템 변수를 먼저 치환합니다.
                    for (const [key, value] of Object.entries(systemValues)) {
                        const regex = new RegExp(`{{\\s*${key}\\s*}}`, 'g');
                        finalPrompt = finalPrompt.replace(regex, value || '');
                    }

                    // 2. 사용자가 입력한 변수를 치환합니다.
                    for (const [key, value] of Object.entries(userValues)) {
                        const regex = new RegExp(`{{\\s*${key}\\s*}}`, 'g');
                        finalPrompt = finalPrompt.replace(regex, value || '');
                    }

                    Controller.copyToClipboard(finalPrompt);
                    ModalManager.close();
                },
                
                // Controller.ACTION_HANDLERS 객체 내부...

                'copy-writing-prompt': (el) => { // [수정] 존재하지 않는 함수 대신 올바른 함수를 호출합니다.
                    Controller.copyPromptForCurrentChapter();
                },
                'copy-translation-prompt': () => { // [수정] 올바른 함수를 호출하도록 명확히 합니다.
                    Controller.copyTranslationPrompt();
                },
                'manage-quiz': () => ModalManager.open('manageQuiz'),
                'generate-quiz': () => Controller.generateQuiz(),
                'submit-api-key': (form) => {
                    const key = form.querySelector('#api-key-input').value;
                    if (key) {
                        localStorage.setItem('googleApiKey', key);
                        ModalManager.close();
                    }
                },
                'copy-quiz-prompt': () => {
                    const prompt = Controller.buildQuizPrompt();
                    if (prompt) Controller.copyToClipboard(prompt);
                    else Controller.showToast('퀴즈 생성을 위한 내용이 부족합니다.', 'error');
                },
                'add-questions-from-json': async (form) => {
                    const jsonContent = new FormData(form).get('jsonContent');
                    try {
                        const questions = JSON.parse(jsonContent.trim().match(/\[[\s\S]*\]/)?.[0] || '[]');
                        
                        // [수정] 각 질문에 고유 ID를 부여합니다.
                        questions.forEach(q => { if (!q.id) q.id = Utils.generateId('quiz'); });

                        const content = state.activeChapterContent;
                        content.questions = [...(content.questions || []), ...questions];
                        content.status = 'quiz-done';
                        await DB.put(CONFIG.STORES.CONTENTS, content);
                        state.activeContentsMap.set(content.id, content);
                        Controller.showToast(`${questions.length}개의 문제가 추가되었습니다.`, 'success');
                        ModalManager.render();
                    } catch (e) {
                        Controller.showToast(`유효하지 않은 JSON입니다: ${e.message}`, 'error');
                    }
                },
                'delete-quiz-question': async (el) => {
                    // [수정] 인덱스 대신 ID를 사용하여 삭제할 질문을 찾습니다.
                    const idToDelete = el.dataset.id;
                    state.activeChapterContent.questions = state.activeChapterContent.questions.filter(q => q.id !== idToDelete);
                    
                    await DB.put(CONFIG.STORES.CONTENTS, state.activeChapterContent);
                    state.activeContentsMap.set(state.activeChapterContent.id, state.activeChapterContent);
                    ModalManager.render();
                },
                'edit-quiz-question': (el) => {
                    // [수정] 인덱스 대신 ID를 기준으로 수정할 항목을 지정합니다.
                    const id = el.dataset.id;
                    ModalManager.data.editingQuestionId = id; // editingQuestionIndex -> editingQuestionId
                    ModalManager.render();
                },
                'cancel-edit-quiz': () => {
                    // [수정] 수정 상태 ID를 초기화합니다.
                    ModalManager.data.editingQuestionId = null;
                    ModalManager.render();
                },
                'save-quiz-question': async (form) => {
                    // [수정] data-question-id 속성에서 ID를 가져옵니다.
                    const id = form.closest('[data-question-id]').dataset.questionId;
                    const questions = state.activeChapterContent.questions;
                    
                    // [수정] 인덱스가 아닌 ID로 질문 객체를 찾습니다.
                    const questionToUpdate = questions.find(q => q.id === id);

                    if (!questionToUpdate) return;
                    
                    questionToUpdate.questionText = form.elements.questionText.value;
                    questionToUpdate.explanation = form.elements.explanation.value;

                    if (questionToUpdate.type === 'multiple_choice') {
                        const optionsContainer = form.querySelector('#options-container');
                        const newOptions = Array.from(optionsContainer.querySelectorAll('input[type="text"]')).map(input => input.value);
                        questionToUpdate.options = newOptions;
                        
                        const checkedRadio = optionsContainer.querySelector('input[type="radio"]:checked');
                        // [수정] 옵션 텍스트로 정답을 저장합니다.
                        questionToUpdate.answer = checkedRadio ? newOptions[parseInt(checkedRadio.dataset.optionIndex, 10)] : newOptions[0];
                    } else {
                        questionToUpdate.answer = form.elements.answer.value;
                    }

                    await DB.put(CONFIG.STORES.CONTENTS, state.activeChapterContent);
                    state.activeContentsMap.set(state.activeChapterContent.id, state.activeChapterContent);
                    
                    // [수정] 수정 상태 ID를 초기화합니다.
                    ModalManager.data.editingQuestionId = null;
                    Controller.showToast('퀴즈가 성공적으로 수정되었습니다.', 'success');
                    ModalManager.render();
                },
                'start-quiz': () => Controller.startQuiz(),
                'exit-quiz': () => ModalManager.open('confirm', {
                    title: '퀴즈 나가기',
                    message: '퀴즈를 중단하시겠습니까?',
                    confirmText: '나가기',
                    onConfirm: () => {
                        state.quizState = null;
                        state.currentView = 'workspace';
                        View.render();
                    }
                }),
                'submit-answer': (el) => {
                    const q = state.quizState.questions[state.quizState.currentIndex];
                    const selectedIndex = parseInt(el.dataset.index, 10);
                    state.quizState.answers[state.quizState.currentIndex] = {
                        selectedIndex,
                        isCorrect: selectedIndex === q.answerIndex
                    };
                    View.render();
                },
                'submit-text-answer': (form) => {
                    const userAnswer = new FormData(form).get('answer-input') || '';
                    const q = state.quizState.questions[state.quizState.currentIndex];
                    state.quizState.answers[state.quizState.currentIndex] = {
                        userAnswer,
                        isCorrect: userAnswer.trim().toLowerCase() === q.answer.trim().toLowerCase()
                    };
                    View.render();
                },
                'next-question': () => {
                    if (state.quizState.currentIndex < state.quizState.questions.length - 1) {
                        state.quizState.currentIndex++;
                    } else {
                        Controller.finishQuiz();
                    }
                    View.render();
                },
                'back-to-workspace': () => {
                    state.quizState = null;
                    state.currentView = 'workspace';
                    View.render();
                },
                'manage-toc': () => {
                    // ▼▼▼ [디버깅 코드 추가] ▼▼▼
                    const tocCopy = JSON.parse(JSON.stringify(state.activeProject.toc));
                    console.log("--- [1. 목차 관리 시작] ---");
                    console.log("모달을 위해 복사된 초기 TOC 데이터:", tocCopy);
                    // ▲▲▲ [디버깅 코드 추가] ▲▲▲

                    ModalManager.open('manageToc', {
                        editableToc: tocCopy, // 복사된 데이터를 모달로 전달
                        selectedTocPaths: new Set(),
                        lastSelectedTocPath: null
                    });
                },
                 'toc-add-child': (el) => {
                    const parentNode = Utils.getNodeByPath(ModalManager.data.editableToc, el.dataset.path);
                    if (parentNode) {
                        if (!parentNode.children) parentNode.children = [];
                        // createTocNode 유틸리티를 사용하여 ID가 포함된 노드를 생성합니다.
                        const newNode = Utils.createTocNode("새 하위 항목");
                        parentNode.children.push(newNode);
                        ModalManager.render();
                    }
                },

                // ▼▼▼ [수정] 불필요한 DB 조작을 제거하고 모달 내에서만 동작하도록 로직 단순화 ▼▼▼
                // 루트 수준의 목차 항목을 추가합니다. 모달 안팎에서 모두 동작하도록 수정되었습니다.
                'toc-add-root-item': async () => {
                    // 모달 내에서 작업하는 경우: 기존 로직을 유지합니다.
                    if (ModalManager.data && ModalManager.data.editableToc) {
                        const toc = ModalManager.data.editableToc;
                        if (toc) {
                            // createTocNode 유틸리티를 사용하여 ID가 포함된 노드를 생성합니다.
                            const newNode = Utils.createTocNode("새 최상위 항목");
                            toc.children.push(newNode);
                            ModalManager.render();
                        }
                        return;
                    }
                    // 모달이 열려 있지 않은 경우(예: 워크스페이스에서 '첫 챕터 추가' 버튼을 클릭한 경우)
                    // 현재 활성 프로젝트에 직접 새로운 루트 챕터를 추가합니다.
                    const projectId = state.activeProjectId;
                    const project = state.activeProject;
                    if (!projectId || !project) return;
                    // 루트 toc가 없으면 초기화합니다.
                    if (!project.toc) {
                        project.toc = { title: '', children: [] };
                    } else if (!Array.isArray(project.toc.children)) {
                        project.toc.children = [];
                    }
                    // 새 노드 생성
                    const newNode = Utils.createTocNode('새 챕터');
                    project.toc.children.push(newNode);
                    // state.projects 배열 내의 해당 프로젝트 객체도 toc 변경을 반영합니다.
                    const projIndex = state.projects.findIndex(p => p.id === projectId);
                    if (projIndex >= 0) {
                        // 중첩 객체를 유지하기 위해 기존 객체를 그대로 수정
                        state.projects[projIndex].toc = project.toc;
                    }
                    // 새로운 콘텐츠 객체 생성
                    const contentId = newNode.contentId;
                    const newContent = {
                        id: `${projectId}_${contentId}`,
                        projectId: projectId,
                        nodeId: contentId,
                        manuscript: '',
                        translation: '',
                        notes: '',
                        imageDataUrl: null,
                        questions: [],
                        historyMetadata: { snapshotCount: 0, lastSnapshotAt: null },
                        status: 'empty'
                    };
                    // DB에 새 콘텐츠 저장 및 state 갱신
                    try {
                        await DB.put(CONFIG.STORES.CONTENTS, newContent);
                    } catch (err) {
                        console.error('새 콘텐츠 저장 중 오류:', err);
                    }
                    state.activeContentsMap.set(newContent.id, newContent);
                    // 프로젝트의 toc 업데이트를 DB에 저장
                    try {
                        await DB.put(CONFIG.STORES.PROJECTS, project);
                    } catch (err) {
                        console.error('프로젝트 toc 업데이트 중 오류:', err);
                    }
                    // UI 새로 고침
                    View.render();
                },
                'toc-delete': (el) => {
                    const {
                        parent,
                        index
                    } = Utils.getParentNodeAndIndexByPath(ModalManager.data.editableToc, el.dataset.path);
                    if (parent?.children) {
                        parent.children.splice(index, 1);
                        ModalManager.render();
                    }
                },
                'save-toc': () => Controller.saveToc(),
                'open-split-chapter-modal': () => {
                    const defaultSource = state.activeChapterContent.translation?.trim() ? 'translation' : 'manuscript';
                    const prompt = Controller.buildSplitChapterPrompt(defaultSource);
                    if (prompt) {
                        Controller.copyToClipboard(prompt);
                        ModalManager.open('splitChapter', {
                            sourceToSplit: defaultSource
                        });
                    }
                },
                'regenerate-split-prompt': (el, e) => {
                    if (e.target.tagName === 'INPUT') {
                        const newSource = e.target.value;
                        ModalManager.data.sourceToSplit = newSource;
                        const prompt = Controller.buildSplitChapterPrompt(newSource);
                        if (prompt) {
                            Controller.copyToClipboard(prompt);
                        }
                        ModalManager.render();
                    }
                },
                'submit-split-chapter': (form) => Controller.handleSplitChapterSubmit(form),
                'dismiss-toast': (el) => Controller.dismissToast(el.dataset.id),
                'remove-tag': (el) => {
                    const tagToRemove = el.dataset.tag;
                    ModalManager.data.projectTags = ModalManager.data.projectTags.filter(t => t !== tagToRemove);
                    ModalManager.render();
                },
                'select-tag-suggestion': (el) => {
                    Controller.addTagToProject(el.dataset.tag);
                    document.getElementById('setting-tags-input').value = '';
                    document.getElementById('tag-suggestions').classList.add('hidden');
                },
                'toggle-sidebar-section': (el) => {
                    const section = el.dataset.section;
                    state.sidebarCollapseState[section] = !state.sidebarCollapseState[section];
                    View.render();
                },
                'toggle-toc-all': (el) => {
                    const mode = el.dataset.mode;
                    const allPaths = Utils.getFlatToc(state.activeProject.toc).map(item => item.path);
                    if (mode === 'collapse') {
                        allPaths.forEach(path => state.tocCollapseState[path] = true);
                    } else {
                        state.tocCollapseState = {};
                    }
                    View.render();
                },
                'set-workspace-layout': (el) => {
                    state.workspaceLayout = el.dataset.layout;
                    View.render();
                },
                'set-view-panel-mode': (el) => {
                    state.viewPanelDisplayMode = el.dataset.mode;
                    View.render();
                },
                'set-quiz-result-filter': (el) => {
                    state.quizResultFilter = el.dataset.filter;
                    View.render();
                },
                'toggle-action-rail': () => Controller.toggleActionRail(),
                'manual-snapshot': async () => {
                    if (!state.activeChapterContent) {
                        Controller.showToast('스냅샷을 만들 챕터가 없습니다.', 'error');
                        return;
                    }
                    // Ask the user for a snapshot name using a custom modal prompt.
                    const name = await ModalManager.showInputPrompt({
                        title: '스냅샷 생성',
                        message: '새 스냅샷의 이름을 입력하세요.',
                        placeholder: '스냅샷 이름',
                        confirmText: '생성'
                    });
                    if (name) {
                        Controller.saveChapterHistory(state.activeChapterContent, CONFIG.SNAPSHOT_TYPE.MANUAL, `스냅샷 '${name}'이(가) 생성되었습니다.`);
                    }
                },
                'handle-reset-confirmation-input': (el) => {
                const resetButton = document.getElementById('reset-settings-btn');
                if (resetButton) {
                    // 입력값이 "초기화"와 정확히 일치할 때만 버튼 활성화
                    resetButton.disabled = el.value !== '초기화';
                }
            },

            'confirm-reset-settings': () => {
                ModalManager.open('confirm', {
                    title: '최종 확인',
                    message: '정말로 현재 프로젝트의 모든 설정을 기본값으로 되돌리시겠습니까? 저장된 프롬프트와 메뉴 등이 모두 사라집니다.',
                    confirmText: '네, 초기화합니다',
                    onConfirm: async () => {
                        try {
                            const project = state.activeProject;
                            if (!project) throw new Error('활성 프로젝트가 없습니다.');

                            // 기본 설정을 깊은 복사하여 새 객체로 만듭니다.
                            project.settings = JSON.parse(JSON.stringify(CONFIG.DEFAULT_PROJECT_SETTINGS));
                            project.updatedAt = new Date().toISOString();
                            project.updatedAt = new Date().toISOString();

                            const projectInList = state.projects.find(p => p.id === project.id);
                            if (projectInList) {
                                projectInList.settings = project.settings;
                                projectInList.updatedAt = project.updatedAt;
                            }

                            await DB.put(CONFIG.STORES.PROJECTS, project);
                            
                            ModalManager.close(); // 확인 모달 닫기
                            Controller.showToast('프로젝트 설정이 기본값으로 초기화되었습니다.', 'success');

                            // 설정 모달을 다시 열어 초기화된 상태를 보여줍니다.
                            // 이렇게 하면 사용자가 변경사항을 즉시 확인할 수 있습니다.
                            Controller.ACTION_HANDLERS['open-settings']();

                        } catch (error) {
                            console.error("설정 초기화 실패:", error);
                            Controller.showToast(`오류 발생: ${error.message}`, 'error');
                        }
                    }
                });
            },
            },
            async exportProject(projectId) {
                try {
                    this.showToast('프로젝트 데이터 준비 중...', 'info');

                    const project = await DB.get(CONFIG.STORES.PROJECTS, projectId);
                    if (!project) {
                        throw new Error("프로젝트를 찾을 수 없습니다.");
                    }

                    const contents = await DB.getProjectContents(projectId);

                    const portableContents = contents.map(content => {
                        const path = content.id.replace(`${projectId}_`, '');
                        const newContent = {
                            ...content,
                            path
                        };
                        delete newContent.id;
                        return newContent;
                    });

                    const exportData = {
                        type: CONFIG.EXPORT_TYPE_ID,
                        project: project,
                        contents: portableContents
                    };

                    const jsonString = JSON.stringify(exportData, null, 2);
                    const blob = new Blob([jsonString], {
                        type: 'application/json'
                    });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    const safeFileName = project.name.replace(/[\/\\?%*:|"<>]/g, '-') || 'project';
                    a.download = `${safeFileName}.json`;

                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    URL.revokeObjectURL(url);
                    this.showToast('프로젝트 내보내기가 완료되었습니다.', 'success');

                } catch (error) {
                    console.error("Export failed:", error);
                    this.showToast(`프로젝트 내보내기 실패: ${error.message}`, 'error');
                }
            },
        };

        // Register the view to react to state changes. Whenever setState is called,
        // View.render() will be invoked automatically.
        addStateListener(() => View.render());
        Controller.init();
    </script>
 
<!-- FOCUS-PRESERVER PATCH START -->
<script>
(function(){
  if (window.__FOCUS_PRESERVER_PATCH__) return;
  window.__FOCUS_PRESERVER_PATCH__ = true;

  function isTextInput(el){
    return el && (el.tagName === 'TEXTAREA' || (el.tagName === 'INPUT' && /^(text|search|password|email|url|tel|number)$/i.test(el.type)));
  }
  const FocusPreserver = {
    capture(){
      const el = document.activeElement instanceof Element ? document.activeElement : null;
      if (!el) return { el:null, id:null };
      let selStart, selEnd;
      if (isTextInput(el)){
        try { selStart = el.selectionStart; selEnd = el.selectionEnd; } catch(e){}
      }
      const id = el.id || el.getAttribute('data-preserve-focus') || null;
      return { el, id, selStart, selEnd };
    },
    restore(id, selStart, selEnd){
      if (!id) return;
      var esc = (window.CSS && CSS.escape) ? CSS.escape : function(s){ return String(s).replace(/[^a-zA-Z0-9_-]/g,'\\$&'); };
      const next = document.getElementById(id) || document.querySelector('[data-preserve-focus="'+esc(id)+'"]');
      if (!next) return;
      if (typeof next.focus === 'function'){
        try { next.focus({ preventScroll:true }); } catch(e){ try{ next.focus(); }catch(_){} }
        if (isTextInput(next)){
          try {
            const s = typeof selStart === 'number' ? selStart : next.value.length;
            const e = typeof selEnd === 'number' ? selEnd : s;
            next.setSelectionRange(s,e);
          } catch(e){}
        }
      }
    }
  };

  function chain(fnA, fnB){
    return function(){
      var a = fnA && fnA.apply(this, arguments);
      var b = fnB && fnB.apply(this, arguments);
      if (a === false || b === false) return false;
      return true;
    };
  }

  window.safeMorphdom = function safeMorphdom(targetEl, nextHtmlOrEl, options){
    options = options || {};
    const cap = FocusPreserver.capture();

    var nextEl = nextHtmlOrEl;
    if (typeof nextHtmlOrEl === 'string'){
      var d = document.createElement('div');
      d.innerHTML = nextHtmlOrEl;
      nextEl = d.firstElementChild || d;
    }

    var userOnBefore = options.onBeforeElUpdated;
    var userOnUpdated = options.onElUpdated;

    var merged = Object.assign({}, options, {
      onBeforeElUpdated: chain(function(fromEl, toEl){
        if (cap.el && fromEl === cap.el) return false;
        return true;
      }, userOnBefore),
      onElUpdated: chain(function(el){}, userOnUpdated)
    });

    if (typeof window.morphdom !== 'function'){
      console.error('safeMorphdom: morphdom not found on window');
    } else {
      window.morphdom(targetEl, nextEl, merged);
    }

    FocusPreserver.restore(cap.id, cap.selStart, cap.selEnd);
  };
})();
</script>
<!-- FOCUS-PRESERVER PATCH END -->
</body>
 </html>
