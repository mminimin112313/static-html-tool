<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í´ë” ìŠ¤ìºë„ˆ ë° TXT ë‚´ë³´ë‚´ê¸°</title>
    <!-- Tailwind CSS CDN ë¡œë“œ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter í°íŠ¸ ë¡œë“œ */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ ìŠ¤íƒ€ì¼ */
        #drop-zone.drag-over {
            border-color: #3b82f6; /* blue-500 */
            background-color: #eff6ff; /* blue-50 */
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-2xl">
        <h1 class="text-2xl font-bold text-center text-gray-800 mb-4">í´ë” ìŠ¤ìº” ë° TXT ìƒì„±ê¸°</h1>
        <p class="text-center text-gray-600 mb-6">ì•„ë˜ ì˜ì—­ì— í´ë”ë¥¼ ë“œë˜ê·¸ ì•¤ ë“œë¡­í•˜ì„¸ìš”. í´ë” êµ¬ì¡°ì™€ ëª¨ë“  íŒŒì¼ ë‚´ìš©ì´ í¬í•¨ëœ <code>.txt</code> íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤.</p>

        <!-- ë“œë¡­ ì˜ì—­ -->
        <div id="drop-zone" class="border-4 border-dashed border-gray-300 rounded-lg p-16 text-center transition-all duration-300">
            <p id="drop-message" class="text-gray-500">ì´ê³³ì— í´ë”ë¥¼ ë“œë˜ê·¸í•˜ì„¸ìš”</p>
        </div>

        <!-- ë¡œë”© ìŠ¤í”¼ë„ˆ (ì´ˆê¸° ìˆ¨ê¹€) -->
        <div id="spinner" class="hidden my-6 flex justify-center items-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
            <p class="ml-3 text-gray-700">í´ë”ë¥¼ ìŠ¤ìº”í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì ì‹œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”...</p>
        </div>

        <!-- ê²°ê³¼ ë¡œê·¸ (íŒŒì¼ êµ¬ì¡°) -->
        <div class="mt-6">
            <h2 class="text-lg font-semibold text-gray-700 mb-2">ìŠ¤ìº”ëœ íŒŒì¼ êµ¬ì¡°:</h2>
            <pre id="log-area" class="bg-gray-900 text-white font-mono text-sm p-4 rounded-lg overflow-auto max-h-72 w-full hidden"></pre>
        </div>

        <!-- í˜¸í™˜ì„± ê²½ê³  -->
        <p class="text-sm text-center text-red-600 mt-6">
            <strong>ì°¸ê³ :</strong> ì´ ê¸°ëŠ¥ì€ Chrome, Edge ë“± Chromium ê¸°ë°˜ ë¸Œë¼ìš°ì €ì—ì„œë§Œ ì •ìƒ ì‘ë™í•©ë‹ˆë‹¤.
        </p>
    </div>

    <script>
        const dropZone = document.getElementById('drop-zone');
        const dropMessage = document.getElementById('drop-message');
        const logArea = document.getElementById('log-area');
        const spinner = document.getElementById('spinner');

        // ë“œë˜ê·¸ ì´ë²¤íŠ¸ ì²˜ë¦¬ (ë³€ê²½ ì—†ìŒ)
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        // ë“œë˜ê·¸ ì´ë²¤íŠ¸ ì²˜ë¦¬ (ë³€ê²½ ì—†ìŒ)
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
        });

        // ë“œë¡­ ì´ë²¤íŠ¸ ì²˜ë¦¬ (í•µì‹¬ ë¡œì§)
        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            logArea.classList.add('hidden');
            logArea.textContent = '';
            spinner.classList.remove('hidden');
            dropMessage.textContent = "í´ë”ë¥¼ ë“œë˜ê·¸í•˜ì„¸ìš”";

            try {
                const items = e.dataTransfer.items;
                if (!items || items.length === 0) {
                    throw new Error('ë“œë¡­ëœ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.');
                }

                const item = items[0].webkitGetAsEntry();
                if (!item || !item.isDirectory) {
                    throw new Error('í´ë”ê°€ ì•„ë‹Œ íŒŒì¼ì´ ë“œë¡­ë˜ì—ˆìŠµë‹ˆë‹¤. í´ë”ë¥¼ ë“œë¡­í•´ì£¼ì„¸ìš”.');
                }

                const rootEntry = item;
                let rootPath = rootEntry.name + '/';
                let rootTree = 'ğŸ“ ' + rootEntry.name + '\n';

                // ì¬ê·€ì ìœ¼ë¡œ í´ë” ìŠ¤ìº”
                // processFolderê°€ ì´ì œ {fileTree: string, fileContents: string[]} ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
                const { fileTree, fileContents } = await processFolder(rootEntry, rootPath, '  ');
                
                rootTree += fileTree;
                
                // 1. íŒŒì¼ êµ¬ì¡°ë¥¼ í™”ë©´ì— í‘œì‹œ
                logArea.textContent = rootTree;
                logArea.classList.remove('hidden');

                // 2. ìµœì¢… TXT íŒŒì¼ ìƒì„± (Blob íŒŒíŠ¸ ë°°ì—´ ì‚¬ìš©)
                //    í•˜ë‚˜ì˜ ê±°ëŒ€í•œ ë¬¸ìì—´ ëŒ€ì‹ , ë¬¸ìì—´ ì¡°ê°ë“¤ì˜ 'ë°°ì—´'ì„ ë§Œë“­ë‹ˆë‹¤.
                const blobParts = [
                    `--- FILE STRUCTURE ---\n\n${rootTree}\n\n--- FILE CONTENTS ---\n\n`
                ];

                // fileContentsëŠ” ì´ì œ ë¬¸ìì—´ ë°°ì—´ì´ë¯€ë¡œ concatìœ¼ë¡œ ë³‘í•©í•©ë‹ˆë‹¤.
                const combinedBlobParts = blobParts.concat(fileContents); // <-- ë³€ê²½ë¨

                // 3. íŒŒì¼ ë‹¤ìš´ë¡œë“œ (Blob íŒŒíŠ¸ ë°°ì—´ì„ ì „ë‹¬)
                downloadAsText(combinedBlobParts, rootEntry.name + "_export.txt"); // <-- ë³€ê²½ë¨

            } catch (err) {
                console.error(err);
                logArea.textContent = `ì˜¤ë¥˜ ë°œìƒ: ${err.message}`;
                logArea.classList.remove('hidden');
            } finally {
                spinner.classList.add('hidden');
            }
        });

        /**
         * ë””ë ‰í„°ë¦¬ ì—”íŠ¸ë¦¬ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
         * @param {FileSystemDirectoryEntry} directoryEntry - ìŠ¤ìº”í•  ë””ë ‰í„°ë¦¬ ì—”íŠ¸ë¦¬
         * @param {string} pathPrefix - í˜„ì¬ íŒŒì¼ ê²½ë¡œ (ì˜ˆ: "MyProject/src/")
         * @param {string} indent - ë“¤ì—¬ì“°ê¸° ë¬¸ì (ì˜ˆ: "  ")
         * @returns {Promise<{fileTree: string, fileContents: string[]}>} // <-- ë°˜í™˜ íƒ€ì… ë³€ê²½ë¨ (string[])
         */
        async function processFolder(directoryEntry, pathPrefix, indent) {
            let fileTree = '';
            let fileContents = []; // <-- ë³€ê²½ë¨: ë¬¸ìì—´ì´ ì•„ë‹Œ 'ë°°ì—´'ë¡œ ì‹œì‘

            const entries = await readDirectoryEntries(directoryEntry);
            
            entries.sort((a, b) => {
                if (a.isDirectory && !b.isDirectory) return -1;
                if (!a.isDirectory && b.isDirectory) return 1;
                return a.name.localeCompare(b.name);
            });

            for (const entry of entries) {
                if (entry.isDirectory) {
                    fileTree += `${indent}ğŸ“ ${entry.name}\n`;
                    const { fileTree: subTree, fileContents: subContents } = await processFolder(
                        entry,
                        pathPrefix + entry.name + '/',
                        indent + '  '
                    );
                    fileTree += subTree;
                    fileContents = fileContents.concat(subContents); // <-- ë³€ê²½ë¨: ë°°ì—´ ë³‘í•©
                } else if (entry.isFile) {
                    fileTree += `${indent}ğŸ“„ ${entry.name}\n`;
                    fileContents.push(await processFile(entry, pathPrefix + entry.name)); // <-- ë³€ê²½ë¨: ë°°ì—´ì— push
                }
            }

            return { fileTree, fileContents };
        }

        /**
         * íŒŒì¼ ì—”íŠ¸ë¦¬ë¥¼ ì²˜ë¦¬í•˜ì—¬ XML íƒœê·¸ë¡œ ê°ì‹¼ ë¬¸ìì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
         * (ì´ í•¨ìˆ˜ëŠ” ë³€ê²½í•  í•„ìš” ì—†ìŒ)
         * @param {FileSystemFileEntry} fileEntry - ì½ì„ íŒŒì¼ ì—”íŠ¸ë¦¬
         * @param {string} path - íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ
         * @returns {Promise<string>}
         */
        async function processFile(fileEntry, path) {
            const file = await new Promise((resolve, reject) => fileEntry.file(resolve, reject));
            let content = '';

            const isTextBased = file.type.startsWith('text/') || 
                                /\.(txt|js|css|html|xml|json|md|py|java|c|cpp|cs|go|rs|sh)$/i.test(file.name) ||
                                !file.type; 

            if (isTextBased && file.size < 5 * 1024 * 1024) { 
                try {
                    content = await file.text();
                } catch (e) {
                    content = `[Error reading file as text: ${e.message}]`;
                }
            } else if (file.size >= 5 * 1024 * 1024) {
                 content = `[File too large (${(file.size / (1024*1024)).toFixed(2)} MB). Content not included.]`;
            } else {
                content = `[Binary file: ${file.type}, size: ${file.size} bytes. Content not included.]`;
            }

            return `<file path="${path}">\n<![CDATA[\n${content}\n]]>\n</file>\n\n`;
        }

        /**
         * ë””ë ‰í„°ë¦¬ì˜ ëª¨ë“  ì—”íŠ¸ë¦¬ë¥¼ ì½ì–´ì˜¤ëŠ” ë˜í¼ í•¨ìˆ˜ (ë³€ê²½ ì—†ìŒ)
         * @param {FileSystemDirectoryEntry} directoryEntry
         * @returns {Promise<FileSystemEntry[]>}
         */
        function readDirectoryEntries(directoryEntry) {
            return new Promise((resolve, reject) => {
                const reader = directoryEntry.createReader();
                let allEntries = [];

                function readBatch() {
                    reader.readEntries(
                        (entries) => {
                            if (entries.length > 0) {
                                allEntries = allEntries.concat(entries);
                                readBatch();
                            } else {
                                resolve(allEntries);
                            }
                        },
                        (err) => reject(err)
                    );
                }
                
                readBatch();
            });
        }

        /**
         * í…ìŠ¤íŠ¸ë¥¼ .txt íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.
         * @param {string[]} blobParts - <-- ë³€ê²½ë¨: ë‹¨ì¼ í…ìŠ¤íŠ¸ê°€ ì•„ë‹Œ Blob íŒŒíŠ¸ 'ë°°ì—´'ì„ ë°›ìŒ
         * @param {string} filename - íŒŒì¼ ì´ë¦„
         */
        function downloadAsText(blobParts, filename) { // <-- ë³€ê²½ë¨: ë§¤ê°œë³€ìˆ˜ ì´ë¦„ ë³€ê²½ (text -> blobParts)
            // Blob ìƒì„±ìì— ë¬¸ìì—´ ë°°ì—´(blobParts)ì„ ë°”ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤.
            const blob = new Blob(blobParts, { type: 'text/plain;charset=utf-8' }); // <-- ë³€ê²½ë¨
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            
            document.body.appendChild(a);
            a.click();
            
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

    </script>
</body>

</html>
