<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>í´ë” ìŠ¤ìºë„ˆ ë° TXT ë‚´ë³´ë‚´ê¸°</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Inter í°íŠ¸ ë¡œë“œ */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
    body {
      font-family: 'Inter', sans-serif;
    }
    /* ë“œë˜ê·¸ ì˜¤ë²„ ì‹œ ìŠ¤íƒ€ì¼ */
    #drop-zone.drag-over {
      border-color: #3b82f6; /* blue-500 */
      background-color: #eff6ff; /* blue-50 */
    }
  </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">
  <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-2xl mx-4">
    <h1 class="text-2xl font-bold text-center text-gray-800 mb-4">í´ë” ìŠ¤ìº” ë° TXT ìƒì„±ê¸°</h1>
    <p class="text-center text-gray-600 mb-6">ì•„ë˜ ì˜ì—­ì— í´ë”ë¥¼ ë“œë˜ê·¸ ì•¤ ë“œë¡­í•˜ì„¸ìš”. í´ë” êµ¬ì¡°ì™€ ëª¨ë“  íŒŒì¼ ë‚´ìš©ì´ í¬í•¨ëœ <code>.txt</code> íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤.</p>

    <div class="mb-6">
      <label for="ignore-patterns" class="block text-sm font-medium text-gray-700 mb-2">ë¬´ì‹œí•  íŒŒì¼/í´ë” (ì‰¼í‘œë¡œ êµ¬ë¶„)</label>
      <input type="text" id="ignore-patterns" 
             class="w-full p-2 border border-gray-300 rounded-md text-sm focus:ring-blue-500 focus:border-blue-500" 
             value=".git, .venv, .vite, node_modules, .idea, .vscode, __pycache__, dist, build, .DS_Store, package-lock.json, yarn.lock"
             placeholder="ì œì™¸í•  íŒŒì¼ì´ë‚˜ í´ë”ëª…ì„ ì‰¼í‘œ(,)ë¡œ êµ¬ë¶„í•˜ì—¬ ì…ë ¥í•˜ì„¸ìš”">
    </div>

    <div id="drop-zone" class="border-4 border-dashed border-gray-300 rounded-lg p-16 text-center transition-all duration-300">
      <p id="drop-message" class="text-gray-500">ì´ê³³ì— í´ë”ë¥¼ ë“œë˜ê·¸í•˜ì„¸ìš”</p>
    </div>

    <div id="spinner" class="hidden my-6 flex justify-center items-center">
      <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
      <p class="ml-3 text-gray-700">í´ë”ë¥¼ ìŠ¤ìº”í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì ì‹œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”...</p>
    </div>

    <div class="mt-6">
      <h2 class="text-lg font-semibold text-gray-700 mb-2">ìŠ¤ìº”ëœ íŒŒì¼ êµ¬ì¡°:</h2>
      <pre id="log-area" class="bg-gray-900 text-white font-mono text-sm p-4 rounded-lg overflow-auto max-h-72 w-full hidden"></pre>
    </div>

    <p class="text-sm text-center text-red-600 mt-6">
      <strong>ì°¸ê³ :</strong> ì´ ê¸°ëŠ¥ì€ Chrome, Edge ë“± Chromium ê¸°ë°˜ ë¸Œë¼ìš°ì €ì—ì„œë§Œ ì •ìƒ ì‘ë™í•©ë‹ˆë‹¤.
    </p>
  </div>

  <script>
    const dropZone = document.getElementById('drop-zone');
    const dropMessage = document.getElementById('drop-message');
    const logArea = document.getElementById('log-area');
    const spinner = document.getElementById('spinner');
    const ignoreInput = document.getElementById('ignore-patterns');

    // ë“œë˜ê·¸ ì´ë²¤íŠ¸ ì²˜ë¦¬
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault(); // ê¸°ë³¸ ë™ì‘ ë°©ì§€
      dropZone.classList.add('drag-over');
    });

    dropZone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropZone.classList.remove('drag-over');
    });

    // ë“œë¡­ ì´ë²¤íŠ¸ ì²˜ë¦¬ (í•µì‹¬ ë¡œì§)
    dropZone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropZone.classList.remove('drag-over');
      logArea.classList.add('hidden');
      logArea.textContent = '';
      spinner.classList.remove('hidden');
      dropMessage.textContent = "í´ë”ë¥¼ ë“œë˜ê·¸í•˜ì„¸ìš”";

      try {
        const items = e.dataTransfer.items;
        if (!items || items.length === 0) {
          throw new Error('ë“œë¡­ëœ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.');
        }

        const item = items[0].webkitGetAsEntry();
        if (!item || !item.isDirectory) {
          throw new Error('í´ë”ê°€ ì•„ë‹Œ íŒŒì¼ì´ ë“œë¡­ë˜ì—ˆìŠµë‹ˆë‹¤. í´ë”ë¥¼ ë“œë¡­í•´ì£¼ì„¸ìš”.');
        }

        // í´ë” ì²˜ë¦¬ ì‹œì‘
        const rootEntry = item;
        let rootPath = rootEntry.name + '/';
        let rootTree = 'ğŸ“ ' + rootEntry.name + '\n';

        // ì„¤ì •ëœ ì œì™¸ ëª©ë¡ íŒŒì‹± (ì‰¼í‘œë¡œ êµ¬ë¶„ -> ë°°ì—´ ë³€í™˜ -> ê³µë°± ì œê±°)
        const ignoreList = ignoreInput.value.split(',').map(s => s.trim()).filter(s => s.length > 0);

        // ì¬ê·€ì ìœ¼ë¡œ í´ë” ìŠ¤ìº”
        // processFolderê°€ ì´ì œ {fileTree: string, fileContents: string[]} ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
        const { fileTree, fileContents } = await processFolder(rootEntry, rootPath, ' ', ignoreList);
       
        rootTree += fileTree;
       
        // 1. íŒŒì¼ êµ¬ì¡°ë¥¼ í™”ë©´ì— í‘œì‹œ
        logArea.textContent = rootTree;
        logArea.classList.remove('hidden');

        // 2. ìµœì¢… TXT íŒŒì¼ ìƒì„± (Blob íŒŒíŠ¸ ë°°ì—´ ì‚¬ìš©)
        const blobParts = [
          `--- FILE STRUCTURE ---\n\n${rootTree}\n\n--- FILE CONTENTS ---\n\n`
        ];

        const combinedBlobParts = blobParts.concat(fileContents);

        // 3. íŒŒì¼ ë‹¤ìš´ë¡œë“œ
        downloadAsText(combinedBlobParts, rootEntry.name + "_export.txt");

      } catch (err) {
        console.error(err);
        logArea.textContent = `ì˜¤ë¥˜ ë°œìƒ: ${err.message}`;
        logArea.classList.remove('hidden');
      } finally {
        spinner.classList.add('hidden'); // ìŠ¤í”¼ë„ˆ ìˆ¨ê¸°ê¸°
      }
    });

    /**
    * ë””ë ‰í„°ë¦¬ ì—”íŠ¸ë¦¬ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    * @param {FileSystemDirectoryEntry} directoryEntry - ìŠ¤ìº”í•  ë””ë ‰í„°ë¦¬ ì—”íŠ¸ë¦¬
    * @param {string} pathPrefix - í˜„ì¬ íŒŒì¼ ê²½ë¡œ
    * @param {string} indent - ë“¤ì—¬ì“°ê¸° ë¬¸ì
    * @param {string[]} ignoreList - ì œì™¸í•  íŒŒì¼/í´ë” ì´ë¦„ ëª©ë¡
    * @returns {Promise<{fileTree: string, fileContents: string[]}>}
    */
    async function processFolder(directoryEntry, pathPrefix, indent, ignoreList) {
      let fileTree = '';
      let fileContents = []; 

      const entries = await readDirectoryEntries(directoryEntry);
     
      // ì¼ê´€ëœ ìˆœì„œë¥¼ ìœ„í•´ ì •ë ¬ (í´ë” ìš°ì„ , ê·¸ ë‹¤ìŒ ì´ë¦„ìˆœ)
      entries.sort((a, b) => {
        if (a.isDirectory && !b.isDirectory) return -1;
        if (!a.isDirectory && b.isDirectory) return 1;
        return a.name.localeCompare(b.name);
      });

      for (const entry of entries) {
        // ì œì™¸ ëª©ë¡ì— í¬í•¨ëœ ì´ë¦„ì´ë©´ ê±´ë„ˆëœ€ (ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ê²½ìš°)
        if (ignoreList.includes(entry.name)) {
            continue;
        }

        if (entry.isDirectory) {
          fileTree += `${indent}ğŸ“ ${entry.name}\n`;
          const { fileTree: subTree, fileContents: subContents } = await processFolder(
            entry,
            pathPrefix + entry.name + '/',
            indent + ' ',
            ignoreList
          );
          fileTree += subTree;
          fileContents = fileContents.concat(subContents); 
        } else if (entry.isFile) {
          fileTree += `${indent}ğŸ“„ ${entry.name}\n`;
          fileContents.push(await processFile(entry, pathPrefix + entry.name)); 
        }
      }

      return { fileTree, fileContents };
    }

    /**
    * íŒŒì¼ ì—”íŠ¸ë¦¬ë¥¼ ì²˜ë¦¬í•˜ì—¬ XML íƒœê·¸ë¡œ ê°ì‹¼ ë¬¸ìì—´ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    * @param {FileSystemFileEntry} fileEntry - ì½ì„ íŒŒì¼ ì—”íŠ¸ë¦¬
    * @param {string} path - íŒŒì¼ì˜ ì „ì²´ ê²½ë¡œ
    * @returns {Promise<string>}
    */
    async function processFile(fileEntry, path) {
      const file = await new Promise((resolve, reject) => fileEntry.file(resolve, reject));
      let content = '';

      // í…ìŠ¤íŠ¸ ê¸°ë°˜ íŒŒì¼ì¸ì§€ ê°„ë‹¨íˆ í™•ì¸
      const isTextBased = file.type.startsWith('text/') ||
                /\.(txt|js|css|html|xml|json|md|py|java|c|cpp|cs|go|rs|sh)$/i.test(file.name) ||
                !file.type; // MIME íƒ€ì…ì´ ì—†ëŠ” ê²½ìš° ì¼ë‹¨ í…ìŠ¤íŠ¸ë¡œ ì‹œë„

      if (isTextBased && file.size < 5 * 1024 * 1024) { // 5MB ë¯¸ë§Œ í…ìŠ¤íŠ¸ íŒŒì¼ë§Œ ì½ê¸°
        try {
          content = await file.text();
        } catch (e) {
          content = `[Error reading file as text: ${e.message}]`;
        }
      } else if (file.size >= 5 * 1024 * 1024) {
        content = `[File too large (${(file.size / (1024*1024)).toFixed(2)} MB). Content not included.]`;
      } else {
        content = `[Binary file: ${file.type}, size: ${file.size} bytes. Content not included.]`;
      }

      // XML íƒœê·¸ë¡œ ê°ì‹¸ê¸°. CDATAë¥¼ ì‚¬ìš©í•˜ì—¬ íŠ¹ìˆ˜ ë¬¸ìê°€ ìˆì–´ë„ ë¬¸ì œ ì—†ë„ë¡ í•¨.
      return `<file path="${path}">\n<![CDATA[\n${content}\n]]>\n</file>\n\n`;
    }

    /**
    * ë””ë ‰í„°ë¦¬ì˜ ëª¨ë“  ì—”íŠ¸ë¦¬ë¥¼ ì½ì–´ì˜¤ëŠ” ë˜í¼ í•¨ìˆ˜
    * @param {FileSystemDirectoryEntry} directoryEntry
    * @returns {Promise<FileSystemEntry[]>}
    */
    function readDirectoryEntries(directoryEntry) {
      return new Promise((resolve, reject) => {
        const reader = directoryEntry.createReader();
        let allEntries = [];

        function readBatch() {
          reader.readEntries(
            (entries) => {
              if (entries.length > 0) {
                allEntries = allEntries.concat(entries);
                readBatch(); 
              } else {
                resolve(allEntries); 
              }
            },
            (err) => reject(err)
          );
        }
       
        readBatch();
      });
    }

    /**
    * í…ìŠ¤íŠ¸ë¥¼ .txt íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œí•©ë‹ˆë‹¤.
    * @param {string[]} blobParts
    * @param {string} filename
    */
    function downloadAsText(blobParts, filename) {
      const blob = new Blob(blobParts, { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
     
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
     
      document.body.appendChild(a);
      a.click(); 
     
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

  </script>
</body>
</html>
